// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "forge-std/console.sol";

import "src/PuttyV2.sol";
import "../shared/Fixture.t.sol";

/**
 * @title ExploitTest - PoC for ETH Locked in Contract Vulnerability
 * @notice This test demonstrates that ETH sent to fillOrder() and exercise() functions
 *         gets permanently locked in the contract when non-ETH code paths are taken.
 *
 * VULNERABILITY DESCRIPTION:
 * Both fillOrder() and exercise() are marked as payable to support ETH payments in certain
 * scenarios (e.g., when WETH is the base asset). However, these functions have multiple code
 * paths, and not all of them require or use msg.value. When ETH is sent along with calls that
 * take non-ETH code paths, the ETH becomes permanently locked in the contract with no way to
 * retrieve it.
 *
 * AFFECTED CODE PATHS:
 * 1. fillOrder() - Line 324: When filling a long order (order.isLong == true), premium is
 *    transferred from maker to taker via ERC20, but any msg.value sent is ignored and locked.
 *
 * 2. fillOrder() - Line 338: When baseAsset is not WETH during short order filling, the
 *    premium is transferred via ERC20, but any msg.value sent is ignored and locked.
 *
 * 3. exercise() - Line 436: When exercising a call option with non-WETH baseAsset, the
 *    strike is transferred via ERC20, but any msg.value sent is ignored and locked.
 *
 * IMPACT:
 * Users who accidentally send ETH when calling these functions on non-ETH code paths will
 * permanently lose their ETH. The contract has no withdrawal mechanism for accidentally
 * sent ETH, making this a critical user fund loss vulnerability.
 */
contract ExploitTest is Fixture {
    address[] internal whitelist;
    address[] internal floorTokens;
    PuttyV2.ERC20Asset[] internal erc20Assets;
    PuttyV2.ERC721Asset[] internal erc721Assets;
    uint256[] internal floorAssetTokenIds;

    function setUp() public {
        // Setup: Give test contract and babe plenty of WETH and LINK tokens
        deal(address(weth), address(this), 100 ether);
        deal(address(weth), babe, 100 ether);
        deal(address(link), address(this), 100 ether);
        deal(address(link), babe, 100 ether);

        // Setup: Give test contract and babe native ETH
        vm.deal(address(this), 100 ether);
        vm.deal(babe, 100 ether);

        // Approve PuttyV2 to spend tokens
        weth.approve(address(p), type(uint256).max);
        link.approve(address(p), type(uint256).max);

        vm.prank(babe);
        weth.approve(address(p), type(uint256).max);

        vm.prank(babe);
        link.approve(address(p), type(uint256).max);
    }

    receive() external payable {}

    /**
     * @notice EXPLOIT #1: ETH locked when filling a LONG order
     *
     * ATTACK SCENARIO:
     * When filling a long order, the premium is transferred from the maker to the taker
     * using ERC20.safeTransferFrom() (line 324). The function is payable but doesn't use
     * msg.value in this code path. Any ETH sent gets permanently locked.
     *
     * STEPS:
     * 1. Create a long call order with WETH as base asset
     * 2. Fill the order while sending ETH (msg.value > 0)
     * 3. Verify ETH is locked in the contract with no way to retrieve it
     */
    function testExploit_EthLockedWhenFillingLongOrder() public {
        // STEP 1: Create a long call order
        PuttyV2.Order memory longOrder = PuttyV2.Order({
            maker: babe,
            isCall: true,
            isLong: true,  // This is a LONG order - premium flows from maker to taker
            baseAsset: address(weth),
            strike: 10 ether,
            premium: 1 ether,
            duration: 10 days,
            expiration: block.timestamp + 30 days,
            nonce: 1,
            whitelist: whitelist,
            floorTokens: floorTokens,
            erc20Assets: erc20Assets,
            erc721Assets: erc721Assets
        });

        bytes memory signature = signOrder(babePrivateKey, longOrder);

        // Record initial balances
        uint256 contractBalanceBefore = address(p).balance;
        uint256 attackerBalanceBefore = address(this).balance;

        // STEP 2: Fill the long order while accidentally sending 5 ETH
        // The premium transfer happens via ERC20 (line 324), so this ETH should not be needed
        uint256 ethSentByMistake = 5 ether;

        p.fillOrder{value: ethSentByMistake}(longOrder, signature, floorAssetTokenIds);

        // STEP 3: VERIFY VULNERABILITY - ETH is now locked in the contract
        uint256 contractBalanceAfter = address(p).balance;
        uint256 attackerBalanceAfter = address(this).balance;

        // The contract received the ETH
        assertEq(contractBalanceAfter - contractBalanceBefore, ethSentByMistake,
            "Contract should have received the ETH");

        // The attacker lost the ETH
        assertEq(attackerBalanceBefore - attackerBalanceAfter, ethSentByMistake,
            "Attacker should have lost the ETH");

        // CRITICAL: There is no function in PuttyV2 to withdraw this locked ETH
        // The ETH is permanently stuck in the contract
        console.log("ETH locked in contract:", contractBalanceAfter);
        console.log("This ETH is permanently lost - no withdrawal mechanism exists!");
    }

    /**
     * @notice EXPLOIT #2: ETH locked when filling SHORT order with non-WETH base asset
     *
     * ATTACK SCENARIO:
     * When filling a short order with a non-WETH base asset (e.g., LINK), the premium
     * is transferred via ERC20.safeTransferFrom() (line 338). The function is payable
     * but doesn't use msg.value in this code path. Any ETH sent gets permanently locked.
     *
     * STEPS:
     * 1. Create a short call order with LINK (not WETH) as base asset
     * 2. Fill the order while sending ETH (msg.value > 0)
     * 3. Verify ETH is locked in the contract
     */
    function testExploit_EthLockedWhenFillingShortOrderWithNonWethAsset() public {
        // STEP 1: Create a short call order with LINK as base asset (not WETH)
        PuttyV2.Order memory shortOrder = PuttyV2.Order({
            maker: babe,
            isCall: true,
            isLong: false,  // This is a SHORT order - premium flows from taker to maker
            baseAsset: address(link),  // Using LINK, not WETH - this is key!
            strike: 10 ether,
            premium: 1 ether,
            duration: 10 days,
            expiration: block.timestamp + 30 days,
            nonce: 2,
            whitelist: whitelist,
            floorTokens: floorTokens,
            erc20Assets: erc20Assets,
            erc721Assets: erc721Assets
        });

        bytes memory signature = signOrder(babePrivateKey, shortOrder);

        // Record initial balances
        uint256 contractBalanceBefore = address(p).balance;
        uint256 attackerBalanceBefore = address(this).balance;

        // STEP 2: Fill the short order while accidentally sending 3 ETH
        // Since baseAsset is LINK (not WETH), the else branch at line 338 executes
        // The premium is transferred via ERC20, so this ETH is not used
        uint256 ethSentByMistake = 3 ether;

        p.fillOrder{value: ethSentByMistake}(shortOrder, signature, floorAssetTokenIds);

        // STEP 3: VERIFY VULNERABILITY - ETH is now locked in the contract
        uint256 contractBalanceAfter = address(p).balance;
        uint256 attackerBalanceAfter = address(this).balance;

        // The contract received the ETH
        assertEq(contractBalanceAfter - contractBalanceBefore, ethSentByMistake,
            "Contract should have received the ETH");

        // The attacker lost the ETH
        assertEq(attackerBalanceBefore - attackerBalanceAfter, ethSentByMistake,
            "Attacker should have lost the ETH");

        console.log("ETH locked in contract:", contractBalanceAfter);
        console.log("This ETH is permanently lost - no withdrawal mechanism exists!");
    }

    /**
     * @notice EXPLOIT #3: ETH locked when exercising call option with non-WETH base asset
     *
     * ATTACK SCENARIO:
     * When exercising a call option with a non-WETH base asset, the strike is transferred
     * via ERC20.safeTransferFrom() (line 436). The function is payable but doesn't use
     * msg.value in this code path. Any ETH sent gets permanently locked.
     *
     * STEPS:
     * 1. Create and fill a long call order with LINK as base asset
     * 2. Exercise the call option while sending ETH (msg.value > 0)
     * 3. Verify ETH is locked in the contract
     */
    function testExploit_EthLockedWhenExercisingCallWithNonWethAsset() public {
        // STEP 1: Setup - Create a long call order with LINK as base asset
        // The maker will be this contract so we can exercise it
        PuttyV2.Order memory longCallOrder = PuttyV2.Order({
            maker: address(this),  // This contract is the maker (will own the long position)
            isCall: true,
            isLong: true,
            baseAsset: address(link),  // Using LINK, not WETH
            strike: 10 ether,
            premium: 1 ether,
            duration: 10 days,
            expiration: block.timestamp + 30 days,
            nonce: 3,
            whitelist: whitelist,
            floorTokens: floorTokens,
            erc20Assets: erc20Assets,
            erc721Assets: erc721Assets
        });

        // Sign the order with a private key we control
        // We'll use babe to fill the order as the taker
        uint256 thisContractPrivateKey = 0x1234567890;
        address thisContractSigner = vm.addr(thisContractPrivateKey);

        // Update the maker to be the signer address
        longCallOrder.maker = thisContractSigner;

        // Give the signer some tokens
        deal(address(link), thisContractSigner, 100 ether);
        vm.prank(thisContractSigner);
        link.approve(address(p), type(uint256).max);

        bytes memory signature = signOrder(thisContractPrivateKey, longCallOrder);

        // Fill the order as babe (taker gets short position, maker gets long position)
        vm.prank(babe);
        p.fillOrder(longCallOrder, signature, floorAssetTokenIds);

        // Now thisContractSigner owns the long position and can exercise it
        // Give the signer some ETH
        vm.deal(thisContractSigner, 100 ether);

        // Record initial balances before exercise
        uint256 contractBalanceBefore = address(p).balance;
        uint256 signerBalanceBefore = thisContractSigner.balance;

        // STEP 2: Exercise the call option while accidentally sending 7 ETH
        // Since baseAsset is LINK (not WETH), the else branch at line 436 executes
        // The strike is transferred via ERC20, so this ETH is not used
        uint256 ethSentByMistake = 7 ether;

        vm.prank(thisContractSigner);
        p.exercise{value: ethSentByMistake}(longCallOrder, floorAssetTokenIds);

        // STEP 3: VERIFY VULNERABILITY - ETH is now locked in the contract
        uint256 contractBalanceAfter = address(p).balance;
        uint256 signerBalanceAfter = thisContractSigner.balance;

        // The contract received the ETH
        assertEq(contractBalanceAfter - contractBalanceBefore, ethSentByMistake,
            "Contract should have received the ETH");

        // The signer lost the ETH (balance decreased by the amount sent)
        assertEq(signerBalanceBefore - signerBalanceAfter, ethSentByMistake,
            "User should have lost the ETH");

        console.log("ETH locked in contract:", contractBalanceAfter);
        console.log("This ETH is permanently lost - no withdrawal mechanism exists!");
    }

    /**
     * @notice COMBINED EXPLOIT: Multiple users lose ETH over time
     *
     * This test demonstrates the cumulative impact of the vulnerability where multiple
     * users accidentally send ETH to the contract, and it all gets permanently locked.
     */
    function testExploit_CumulativeEthLoss() public {
        uint256 initialContractBalance = address(p).balance;

        // User 1: Fills a long order with 2 ETH accidentally sent
        PuttyV2.Order memory order1 = PuttyV2.Order({
            maker: babe,
            isCall: true,
            isLong: true,
            baseAsset: address(weth),
            strike: 5 ether,
            premium: 0.5 ether,
            duration: 5 days,
            expiration: block.timestamp + 30 days,
            nonce: 10,
            whitelist: whitelist,
            floorTokens: floorTokens,
            erc20Assets: erc20Assets,
            erc721Assets: erc721Assets
        });
        bytes memory sig1 = signOrder(babePrivateKey, order1);
        p.fillOrder{value: 2 ether}(order1, sig1, floorAssetTokenIds);

        // User 2: Fills a short order with non-WETH asset, 3 ETH accidentally sent
        PuttyV2.Order memory order2 = PuttyV2.Order({
            maker: babe,
            isCall: false,
            isLong: false,
            baseAsset: address(link),
            strike: 8 ether,
            premium: 0.8 ether,
            duration: 7 days,
            expiration: block.timestamp + 30 days,
            nonce: 11,
            whitelist: whitelist,
            floorTokens: floorTokens,
            erc20Assets: erc20Assets,
            erc721Assets: erc721Assets
        });
        bytes memory sig2 = signOrder(babePrivateKey, order2);
        p.fillOrder{value: 3 ether}(order2, sig2, floorAssetTokenIds);

        // Verify total locked ETH
        uint256 finalContractBalance = address(p).balance;
        uint256 totalLockedEth = finalContractBalance - initialContractBalance;

        assertEq(totalLockedEth, 5 ether, "Total of 5 ETH should be locked");

        console.log("Total ETH permanently locked from multiple users:", totalLockedEth);
        console.log("CRITICAL: No mechanism exists to recover this ETH!");
    }
}
