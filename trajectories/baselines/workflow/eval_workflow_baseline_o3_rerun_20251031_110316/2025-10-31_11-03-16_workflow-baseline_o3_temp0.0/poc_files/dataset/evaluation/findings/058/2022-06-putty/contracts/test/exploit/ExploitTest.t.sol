// SPDX-License-Identifier: MIT
pragma solidity 0.8.13;

/*
    Foundry PoC that proves users can permanently lock ETH in PuttyV2 by
    sending msg.value along a code-path that never consumes it.

    High-level idea for the test
    ----------------------------
    1.  The maker (an EOA controlled by a private key in the test) creates a
        SHORT CALL order that uses a non-WETH ERC-20 (mock USDC) as baseAsset.
        – order.isLong = false
        – order.isCall = true
        The order therefore takes the “short call” branch in `fillOrder`.
    2.  The taker calls `fillOrder` **with 1 ether attached** even though the
        selected branch never calls `IWETH.deposit{value:…}` (because
        baseAsset != WETH).
    3.  After the call   - the PuttyV2 contract’s ETH balance increased by
        exactly 1 ether.  
        - the taker received nothing extra.  
        - no function allows anyone to withdraw this ETH.
    4.  The test asserts these facts – proving ETH is black-holed.
*/

import "forge-std/Test.sol";
import "src/PuttyV2.sol";
import "solmate/tokens/WETH.sol";
import "solmate/tokens/ERC20.sol";

contract MockERC20 is ERC20 {
    constructor(string memory n, string memory s, uint8 d) ERC20(n, s, d) {}
    function mint(address to, uint256 amount) external { _mint(to, amount); }
}

contract LockedEtherExploitTest is Test {
    using stdStorage for StdStorage;

    /* ------------------------------------------------------------- */
    /*                          Test actors                           */
    /* ------------------------------------------------------------- */

    uint256 private constant MAKER_PK = 0xBEEF;       // deterministic key
    address private           maker   = vm.addr(MAKER_PK);
    address private           taker   = address(this); // the test contract

    /* ------------------------------------------------------------- */
    /*                     Contracts under test                      */
    /* ------------------------------------------------------------- */

    WETH  private weth;
    MockERC20 private usdc;
    PuttyV2 private putty;

    /* ------------------------------------------------------------- */
    /*                              Setup                            */
    /* ------------------------------------------------------------- */

    function setUp() public {
        // give both maker and taker some ETH so we can pay gas / msg.value
        vm.deal(maker,  10 ether);
        vm.deal(taker,  10 ether);

        // deploy mocks
        weth = new WETH();
        usdc = new MockERC20("USDC", "USDC", 6);

        // mint plenty of USDC to maker so the order can succeed
        usdc.mint(maker, 1_000_000e6);

        // deploy PuttyV2 – fee = 0 for simplicity
        putty = new PuttyV2("ipfs://baseURI/", 0, address(weth));

        // maker approves PuttyV2 to pull USDC premium / assets when necessary
        vm.prank(maker);
        usdc.approve(address(putty), type(uint256).max);
    }

    /* ------------------------------------------------------------- */
    /*                        The actual exploit                     */
    /* ------------------------------------------------------------- */

    function test_LockEther_via_fillOrder_nonWETH() public {
        /* -------------------- craft malicious order -------------------- */
        PuttyV2.Order memory order;

        order.maker      = maker;
        order.isCall     = true;          // SHORT  CALL
        order.isLong     = false;         //  ^^^   ^^^  (maker is short, taker will be long)
        order.baseAsset  = address(usdc); // NOT WETH  -> msg.value will be ignored
        order.strike     = 0;
        order.premium    = 0;             // keep premium 0 to avoid token transfers
        order.duration   = 1 days;
        order.expiration = block.timestamp + 2 days;
        order.nonce      = 0;

        // empty dynamic fields
        order.whitelist      = new address[](0);
        order.floorTokens    = new address[](0);
        order.erc20Assets    = new PuttyV2.ERC20Asset[](0);
        order.erc721Assets   = new PuttyV2.ERC721Asset[](0);

        /* ------------------------ sign the order ----------------------- */
        bytes32 orderHash = putty.hashOrder(order);

        (uint8 v, bytes32 r, bytes32 s) = vm.sign(MAKER_PK, orderHash);
        bytes memory signature = abi.encodePacked(r, s, v); // (r || s || v)

        /* ----------------------- execute fillOrder --------------------- */
        uint256 ethToLock = 1 ether;
        uint256 takerEthBefore = taker.balance;

        // taker (msg.sender) fills the order **while sending ETH**
        putty.fillOrder{value: ethToLock}(order, signature, new uint256[](0));

        /* --------------------- post-conditions check ------------------- */

        // 1. ETH left the taker’s address
        assertEq(taker.balance, takerEthBefore - ethToLock, "Taker should have lost exactly 1 ether");

        // 2. ETH is now stuck inside PuttyV2
        assertEq(address(putty).balance, ethToLock, "ETH permanently locked in PuttyV2");

        // 3. There is no way for anyone (incl. owner) to withdraw native ETH.
        //    For completeness we prove that the owner cannot pull it out by
        //    attempting to call `setFee`, the only payable owner function.
        //    (We expect the call to succeed but *not* transfer ETH out.)

        vm.prank(putty.owner());
        putty.setFee(0); // succeeds – but ETH still stays inside

        assertEq(address(putty).balance, ethToLock, "ETH still locked after owner action");
    }
}