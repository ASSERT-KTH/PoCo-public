// SPDX-License-Identifier: MIT
pragma solidity 0.8.23;

import "forge-std/Test.sol";

import {State} from "@src/SizeStorage.sol";
import {CapsLibrary} from "@src/libraries/CapsLibrary.sol";

/* ----------------------------------------------------------------
 * Very-lightweight ERC-20 mock
 * ----------------------------------------------------------------
 * Only the pieces that are required for the PoC are implemented:
 *  - totalSupply()
 *  - balanceOf()
 *  - mint() / burn() helpers for the test
 * No transfer-logic is needed for this demonstration.
 * -------------------------------------------------------------- */
contract ERC20Mock {
    string public constant name     = "Mock";
    string public constant symbol   = "MOCK";
    uint8  public constant decimals = 6;

    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;

    function mint(address to, uint256 amount) external {
        balanceOf[to] += amount;
        totalSupply   += amount;
    }

    function burn(address from, uint256 amount) external {
        balanceOf[from] -= amount;
        totalSupply     -= amount;
    }
}

/* ----------------------------------------------------------------
 * Exploit test
 * ----------------------------------------------------------------
 * Demonstrates that the post-multicall invariant implemented in
 * CapsLibrary is wrong: a legitimate deposit+repay batch reverts.
 * -------------------------------------------------------------- */
contract MulticallInvariantPoC is Test {
    using CapsLibrary for State;

    State internal state;

    ERC20Mock internal borrowAToken; // future-value claim
    ERC20Mock internal debtToken;    // present-value claim

    /* ---------------------------------------------------------- */
    function setUp() public {
        borrowAToken = new ERC20Mock();
        debtToken    = new ERC20Mock();

        // Set a borrow-aToken cap of 1 000 000 units (6 decimals)
        state.riskConfig.borrowATokenCap = 1_000_000e6;
    }

    /* ----------------------------------------------------------
     * The test follows the exact numbers given in the report.
     *
     * 1) borrowAToken supply is driven to 990 000  (10 000 below cap)
     * 2) A borrower has an outstanding debt:
     *        principal (debtToken)        = 80 000
     *        future value (borrowAToken)  = 100 000
     * 3) Inside a single multicall tx the borrower executes:
     *        deposit(100 000)  →  repay()
     *
     *    After the batch finishes, the library checks:
     *
     *        borrowSupplyIncrease  = +100 000
     *        debtSupplyDecrease    =  -80 000
     *
     *    100 000 > 80 000  ⇒  the check REVERTS, blocking repayment.
     * ---------------------------------------------------------- */
    function test_DepositPlusRepay_Reverts() public {
        /* --- Arrange initial on-chain state ------------------- */
        borrowAToken.mint(address(this), 990_000e6);  // almost at cap
        debtToken.mint(address(this),    80_000e6);   // principal

        uint256 borrowSupplyBefore = borrowAToken.totalSupply();
        uint256 debtSupplyBefore   = debtToken.totalSupply();

        assertEq(borrowSupplyBefore, 990_000e6, "sanity");
        assertEq(state.riskConfig.borrowATokenCap, 1_000_000e6, "cap");

        /* --- Simulate deposit(+100 000) & repay(-80 000) ------ */
        borrowAToken.mint(address(this), 100_000e6);  // what deposit() does
        debtToken.burn(address(this),    80_000e6);   // what repay() does

        uint256 borrowSupplyAfter = borrowAToken.totalSupply();
        uint256 debtSupplyAfter   = debtToken.totalSupply();

        /* --- The library MUST revert, proving the bug ---------- */
        vm.expectRevert();
        CapsLibrary.validateBorrowATokenIncreaseLteDebtTokenDecrease(
            state,
            borrowSupplyBefore,
            debtSupplyBefore,
            borrowSupplyAfter,
            debtSupplyAfter
        );
    }
}