// SPDX-License-Identifier: MIT
pragma solidity 0.8.25;

import {Test, console} from "forge-std/Test.sol";
import {PhiNFT1155} from "../../src/art/PhiNFT1155.sol";
import {IPhiFactory} from "../../src/interfaces/IPhiFactory.sol";
import {IPhiRewards} from "../../src/interfaces/IPhiRewards.sol";
import {ERC1155Upgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol";

// Mock PhiFactory contract for testing
contract MockPhiFactory {
    address public protocolFeeDestination;
    address public phiRewardsAddress;
    mapping(uint256 artId => ArtData) public artData;
    mapping(address contractAddr => string) public contractURIs;
    mapping(uint256 artId => string) public tokenURIs;

    struct ArtData {
        address artist;
        address receiver;
        uint256 mintFee;
        bool soulBounded;
    }

    uint256 public artCreateFee = 0.01 ether;

    constructor() {
        protocolFeeDestination = address(0xdead);
        phiRewardsAddress = address(0xbeef);
    }

    function setArtData(uint256 artId, address artist, address receiver, uint256 mintFee, bool soulBounded) external {
        artData[artId] = ArtData(artist, receiver, mintFee, soulBounded);
    }

    function setTokenURI(uint256 artId, string memory uri) external {
        tokenURIs[artId] = uri;
    }

    function setContractURI(address contractAddr, string memory uri) external {
        contractURIs[contractAddr] = uri;
    }

    function getTokenURI(uint256 artId) external view returns (string memory) {
        return tokenURIs[artId];
    }

    function contractURI(address contractAddr) external view returns (string memory) {
        return contractURIs[contractAddr];
    }
}

// Mock PhiRewards contract for testing
contract MockPhiRewards {
    function handleRewardsAndGetValueSent(
        uint256,
        uint256,
        uint256,
        uint256,
        bytes memory,
        bool
    ) external payable {
        // Just accept the ETH and do nothing for testing
    }
}

contract PhiNFT1155PauseTest is Test {
    PhiNFT1155 public phiNFT;
    MockPhiFactory public mockFactory;
    MockPhiRewards public mockRewards;
    
    address public owner = address(0x1);
    address public alice = address(0x2);
    address public bob = address(0x3);
    
    uint256 public constant ART_ID = 1;
    uint256 public constant CRED_ID = 100;
    uint256 public constant CRED_CHAIN_ID = 1;
    uint256 public constant MINT_QUANTITY = 10;

    function setUp() public {
        // Deploy mock contracts
        vm.startPrank(owner);
        mockFactory = new MockPhiFactory();
        mockRewards = new MockPhiRewards();
        
        // Set up art data in factory
        mockFactory.setArtData(
            ART_ID,
            owner, // artist
            owner, // receiver
            0.001 ether, // mint fee
            false // not soul bounded
        );
        
        // Set token URI
        mockFactory.setTokenURI(ART_ID, "https://example.com/token/1");
        
        // Deploy PhiNFT1155
        phiNFT = new PhiNFT1155();
        
        // Initialize the contract
        phiNFT.initialize(
            CRED_CHAIN_ID,
            CRED_ID,
            "test",
            address(mockFactory.protocolFeeDestination())
        );
        
        // Create art from factory
        uint256 tokenId = phiNFT.createArtFromFactory{value: 0.01 ether}(ART_ID);
        
        // Mint some tokens to alice
        vm.deal(address(mockFactory), 1 ether);
        vm.startPrank(address(mockFactory));
        phiNFT.claimFromFactory{value: 0.001 ether}(
            ART_ID,
            alice,
            address(0),
            address(0),
            MINT_QUANTITY,
            bytes32(0),
            "https://example.com/image"
        );
        vm.stopPrank();
        
        vm.stopPrank();
    }

    function test_PauseMechanismBypass_TransferWhenPaused() public {
        // Verify initial state - contract is not paused
        assertFalse(phiNFT.paused(), "Contract should not be paused initially");
        
        // Verify alice has tokens
        assertEq(phiNFT.balanceOf(alice, 1), MINT_QUANTITY, "Alice should have tokens");
        
        // Owner pauses the contract
        vm.prank(owner);
        phiNFT.pause();
        
        // Verify contract is paused
        assertTrue(phiNFT.paused(), "Contract should be paused");
        
        // VULNERABILITY: Despite being paused, alice can still transfer tokens
        vm.startPrank(alice);
        
        // This transfer should fail if pause worked correctly, but it will succeed
        phiNFT.safeTransferFrom(alice, bob, 1, 5, "");
        
        vm.stopPrank();
        
        // Verify the transfer succeeded (vulnerability demonstrated)
        assertEq(phiNFT.balanceOf(alice, 1), MINT_QUANTITY - 5, "Alice should have 5 tokens left");
        assertEq(phiNFT.balanceOf(bob, 1), 5, "Bob should have received 5 tokens");
        
        console.log("VULNERABILITY CONFIRMED: Transfer succeeded despite contract being paused!");
    }

    function test_PauseMechanismBypass_BatchTransferWhenPaused() public {
        // Owner pauses the contract
        vm.prank(owner);
        phiNFT.pause();
        
        // Verify contract is paused
        assertTrue(phiNFT.paused(), "Contract should be paused");
        
        // VULNERABILITY: Despite being paused, alice can still batch transfer tokens
        vm.startPrank(alice);
        
        uint256[] memory tokenIds = new uint256[](1);
        tokenIds[0] = 1;
        uint256[] memory amounts = new uint256[](1);
        amounts[0] = 3;
        
        // This batch transfer should fail if pause worked correctly, but it will succeed
        phiNFT.safeBatchTransferFrom(alice, bob, tokenIds, amounts, "");
        
        vm.stopPrank();
        
        // Verify the batch transfer succeeded (vulnerability demonstrated)
        assertEq(phiNFT.balanceOf(alice, 1), MINT_QUANTITY - 3, "Alice should have 7 tokens left");
        assertEq(phiNFT.balanceOf(bob, 1), 3, "Bob should have received 3 tokens");
        
        console.log("VULNERABILITY CONFIRMED: Batch transfer succeeded despite contract being paused!");
    }

    function test_PauseMechanismWorksForMinting() public {
        // Owner pauses the contract
        vm.prank(owner);
        phiNFT.pause();
        
        // Verify contract is paused
        assertTrue(phiNFT.paused(), "Contract should be paused");
        
        // Minting should fail when paused (this works correctly)
        vm.startPrank(address(mockFactory));
        vm.expectRevert(); // Should revert due to whenNotPaused modifier
        phiNFT.claimFromFactory{value: 0.001 ether}(
            ART_ID,
            bob,
            address(0),
            address(0),
            1,
            bytes32(0),
            "https://example.com/image2"
        );
        vm.stopPrank();
        
        console.log("Minting correctly fails when paused");
    }

    function test_PauseMechanismWorksForArtCreation() public {
        // Owner pauses the contract
        vm.prank(owner);
        phiNFT.pause();
        
        // Verify contract is paused
        assertTrue(phiNFT.paused(), "Contract should be paused");
        
        // Art creation should fail when paused (this works correctly)
        vm.startPrank(address(mockFactory));
        vm.expectRevert(); // Should revert due to whenNotPaused modifier
        phiNFT.createArtFromFactory{value: 0.01 ether}(2);
        vm.stopPrank();
        
        console.log("Art creation correctly fails when paused");
    }
}