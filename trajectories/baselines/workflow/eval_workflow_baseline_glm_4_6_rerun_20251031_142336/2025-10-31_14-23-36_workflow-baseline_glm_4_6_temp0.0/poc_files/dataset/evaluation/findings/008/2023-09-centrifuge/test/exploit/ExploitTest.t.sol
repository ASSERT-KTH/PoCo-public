// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.21;

import {Test, console} from "forge-std/Test.sol";
import {LiquidityPool} from "../src/LiquidityPool.sol";
import {Auth} from "../src/util/Auth.sol";
import {MathLib} from "../src/util/MathLib.sol";
import {IERC20} from "../src/interfaces/IERC20.sol";
import {IERC4626} from "../src/interfaces/IERC4626.sol";

// Mock contracts for testing
contract MockERC20 is IERC20 {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    constructor(string memory _name, string memory _symbol, uint8 _decimals) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
    }

    function transfer(address to, uint256 value) external returns (bool) {
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        return true;
    }

    function approve(address spender, uint256 value) external returns (bool) {
        allowance[msg.sender][spender] = value;
        return true;
    }

    function transferFrom(address from, address to, uint256 value) external returns (bool) {
        allowance[from][msg.sender] -= value;
        balanceOf[from] -= value;
        balanceOf[to] += value;
        return true;
    }

    function mint(address to, uint256 value) external {
        balanceOf[to] += value;
        totalSupply += value;
    }

    function burn(address from, uint256 value) external {
        balanceOf[from] -= value;
        totalSupply -= value;
    }
}

contract MockTrancheToken is MockERC20 {
    bytes32 public constant PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 deadline)");
    bytes32 public DOMAIN_SEPARATOR;
    mapping(address => uint256) public nonces;

    constructor() MockERC20("Tranche Token", "TRANCHE", 18) {
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
                keccak256(bytes(name)),
                keccak256(bytes("1")),
                block.chainid,
                address(this)
            )
        );
    }

    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {
        require(block.timestamp <= deadline, "PERMIT_DEADLINE_EXPIRED");
        bytes32 digest = keccak256(
            abi.encodePacked(
                "\x19\x01",
                DOMAIN_SEPARATOR,
                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))
            )
        );
        address recoveredAddress = ecrecover(digest, v, r, s);
        require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNATURE");
        allowance[owner][spender] = value;
    }

    function checkTransferRestriction(address, address, uint256) external pure returns (bool) {
        return true;
    }
}

contract MockInvestmentManager {
    struct Order {
        uint128 maxDeposit;
        uint128 maxMint;
        uint128 maxWithdraw;
        uint128 maxRedeem;
    }

    mapping(address => mapping(address => Order)) public orderbook;
    mapping(address => uint256) public escrowShares;
    address public liquidityPool;
    uint256 public constant PRICE_PRECISION = 1e18;

    function setLiquidityPool(address _liquidityPool) external {
        liquidityPool = _liquidityPool;
    }

    function requestDeposit(uint256 assets, address owner) external {
        orderbook[owner][msg.sender].maxDeposit += uint128(assets);
        // Simulate minting shares to escrow at current price
        uint256 shares = (assets * PRICE_PRECISION) / getCurrentPrice();
        escrowShares[msg.sender] += shares;
    }

    function processDeposit(address user, uint256 assets) external returns (uint256 shares) {
        require(assets <= orderbook[user][msg.sender].maxDeposit, "amount-exceeds-deposit-limits");
        
        uint256 depositPrice = calculateDepositPrice(user, msg.sender);
        require(depositPrice != 0, "deposit-token-price-0");
        
        // Calculate shares with potential rounding error
        shares = (assets * PRICE_PRECISION) / depositPrice;
        
        // Transfer from escrow
        require(escrowShares[msg.sender] >= shares, "insufficient-escrow-shares");
        escrowShares[msg.sender] -= shares;
        
        // Update order
        orderbook[user][msg.sender].maxDeposit -= uint128(assets);
    }

    function calculateDepositPrice(address user, address _liquidityPool) public view returns (uint256) {
        // Simulate average price calculation that can have rounding errors
        // This is where the vulnerability manifests
        uint128 totalAssets = orderbook[user][_liquidityPool].maxDeposit;
        if (totalAssets == 0) return 0;
        
        // Simulate different prices for different portions
        // In reality, this would be calculated from actual executed orders
        uint256 price1 = 1000 * PRICE_PRECISION / 1000; // Price 1.0
        uint256 price2 = 1100 * PRICE_PRECISION / 1000; // Price 1.1
        
        // Calculate weighted average with rounding
        uint256 halfAssets = totalAssets / 2;
        uint256 weightedPrice = (halfAssets * price1 + (totalAssets - halfAssets) * price2) / totalAssets;
        
        return weightedPrice;
    }

    function getCurrentPrice() internal view returns (uint256) {
        return 1050 * PRICE_PRECISION / 1000; // Current price 1.05
    }

    function maxDeposit(address receiver, address) external view returns (uint256) {
        return orderbook[receiver][msg.sender].maxDeposit;
    }

    function totalAssets(uint256, address) external pure returns (uint256) {
        return 0;
    }

    function convertToShares(uint256 assets, address) external pure returns (uint256) {
        return assets;
    }

    function convertToAssets(uint256 shares, address) external pure returns (uint256) {
        return shares;
    }

    function previewDeposit(address, address, uint256 assets) external pure returns (uint256) {
        return assets;
    }

    function processMint(address, uint256) external pure returns (uint256) {
        return 0;
    }

    function maxMint(address, address) external pure returns (uint256) {
        return 0;
    }

    function previewMint(address, address, uint256) external pure returns (uint256) {
        return 0;
    }

    function maxWithdraw(address, address) external pure returns (uint256) {
        return 0;
    }

    function previewWithdraw(address, address, uint256) external pure returns (uint256) {
        return 0;
    }

    function processWithdraw(uint256, address, address) external pure returns (uint256) {
        return 0;
    }

    function maxRedeem(address, address) external pure returns (uint256) {
        return 0;
    }

    function previewRedeem(address, address, uint256) external pure returns (uint256) {
        return 0;
    }

    function processRedeem(uint256, address, address) external pure returns (uint256) {
        return 0;
    }

    function requestRedeem(uint256, address) external pure {}

    function collectDeposit(address) external pure {}

    function collectRedeem(address) external pure {}

    function decreaseDepositRequest(uint256, address) external pure {}

    function decreaseRedeemRequest(uint256, address) external pure {}
}

contract LiquidityPoolTest is Test {
    LiquidityPool public liquidityPool;
    MockERC20 public asset;
    MockTrancheToken public share;
    MockInvestmentManager public investmentManager;
    
    address public owner = address(0x1);
    address public investor1 = address(0x2);
    address public investor2 = address(0x3);

    function setUp() public {
        // Deploy mock contracts
        asset = new MockERC20("USDC", "USDC", 6);
        share = new MockTrancheToken();
        investmentManager = new MockInvestmentManager();
        
        // Set up investment manager
        investmentManager.setLiquidityPool(address(investmentManager));
        
        // Deploy LiquidityPool
        liquidityPool = new LiquidityPool(
            1, // poolId
            bytes16(0x1), // trancheId
            address(asset),
            address(share),
            address(investmentManager)
        );
        
        // Mint initial tokens for testing
        asset.mint(investor1, 1000e6);
        asset.mint(investor2, 1000e6);
        
        // Approve LiquidityPool to spend assets
        vm.prank(investor1);
        asset.approve(address(investmentManager), 1000e6);
        vm.prank(investor2);
        asset.approve(address(investmentManager), 1000e6);
        
        // Mint initial shares to escrow
        share.mint(address(investmentManager), 2000e18);
    }

    function testRoundingErrorVulnerability() public {
        // Step 1: Investor1 makes multiple deposit requests at different "epochs"
        // Simulating price changes between epochs
        
        // First deposit request at price 1.0
        vm.prank(investor1);
        investmentManager.requestDeposit(500e6, investor1);
        
        // Simulate time passing and price change
        vm.warp(block.timestamp + 1 days);
        
        // Second deposit request at price 1.1
        vm.prank(investor1);
        investmentManager.requestDeposit(500e6, investor1);
        
        // Step 2: Investor2 also makes deposit requests
        vm.prank(investor2);
        investmentManager.requestDeposit(300e6, investor2);
        
        vm.warp(block.timestamp + 1 days);
        
        vm.prank(investor2);
        investmentManager.requestDeposit(300e6, investor2);
        
        // Step 3: Check initial state
        uint256 investor1MaxDeposit = liquidityPool.maxDeposit(investor1);
        uint256 investor2MaxDeposit = liquidityPool.maxDeposit(investor2);
        
        console.log("Investor1 maxDeposit:", investor1MaxDeposit);
        console.log("Investor2 maxDeposit:", investor2MaxDeposit);
        console.log("Escrow shares before claims:", investmentManager.escrowShares(address(investmentManager)));
        
        // Step 4: Investor1 claims their full deposit
        // Due to rounding error in calculateDepositPrice, they might receive more shares
        uint256 sharesReceived1 = liquidityPool.deposit(investor1MaxDeposit, investor1);
        
        console.log("Shares received by Investor1:", sharesReceived1);
        console.log("Escrow shares after Investor1 claim:", investmentManager.escrowShares(address(investmentManager)));
        
        // Step 5: Investor2 tries to claim their full deposit
        // This might fail due to insufficient shares in escrow
        try liquidityPool.deposit(investor2MaxDeposit, investor2) returns (uint256 sharesReceived2) {
            console.log("Shares received by Investor2:", sharesReceived2);
            console.log("ERROR: Vulnerability not triggered - Investor2 was able to claim full amount");
        } catch Error(string memory reason) {
            console.log("Vulnerability confirmed! Investor2 claim failed with:", reason);
            
            // Try claiming partial amount
            uint256 partialAmount = investor2MaxDeposit / 2;
            try liquidityPool.deposit(partialAmount, investor2) returns (uint256 sharesReceived2) {
                console.log("Partial claim successful - Investor2 received:", sharesReceived2, "shares for", partialAmount, "assets");
            } catch {
                console.log("Even partial claim failed - severe share shortage");
            }
        }
        
        // Step 6: Verify the rounding error
        uint256 expectedSharesForInvestor1 = (investor1MaxDeposit * 1e18) / 1050000000000000000; // At price 1.05
        uint256 expectedSharesForInvestor2 = (investor2MaxDeposit * 1e18) / 1050000000000000000; // At price 1.05
        
        console.log("Expected shares for Investor1 (at 1.05):", expectedSharesForInvestor1);
        console.log("Expected shares for Investor2 (at 1.05):", expectedSharesForInvestor2);
        console.log("Total expected shares:", expectedSharesForInvestor1 + expectedSharesForInvestor2);
        console.log("Actual shares minted to escrow:", 2000e18);
        
        // The vulnerability is confirmed if:
        // 1. Investor1 received more shares than expected
        // 2. Investor2 cannot claim their full amount
        // 3. The discrepancy is due to rounding in average price calculation
    }
}