// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import {Test, console} from "forge-std/Test.sol";
import {ERC20} from "solmate/tokens/ERC20.sol";
import {ERC721} from "solmate/tokens/ERC721.sol";
import {PrivatePool} from "../src/PrivatePool.sol";
import {Factory} from "../src/Factory.sol";
import {IRoyaltyRegistry} from "royalty-registry-solidity/IRoyaltyRegistry.sol";
import {IStolenNftOracle} from "../src/interfaces/IStolenNftOracle.sol";

contract MockERC20 is ERC20 {
    constructor(string memory name, string memory symbol, uint8 decimals) ERC20(name, symbol, decimals) {}
    
    function mint(address to, uint256 amount) public {
        _mint(to, amount);
    }
}

contract MockRoyaltyNFT is ERC721 {
    uint256 public tokenIdCounter;
    mapping(uint256 => uint256) public royaltyFees;
    mapping(uint256 => address) public royaltyRecipients;
    
    constructor() ERC721("MockNFT", "MNFT") {}
    
    function mint(address to, uint256 tokenId) public {
        _mint(to, tokenId);
        tokenIdCounter++;
    }
    
    function setRoyalty(uint256 tokenId, uint256 fee, address recipient) public {
        royaltyFees[tokenId] = fee;
        royaltyRecipients[tokenId] = recipient;
    }
    
    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {
        return (royaltyRecipients[tokenId], royaltyFees[tokenId]);
    }
    
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == 0x2a55205a || super.supportsInterface(interfaceId); // ERC2981 interface
    }
}

contract MockRoyaltyRegistry is IRoyaltyRegistry {
    mapping(address => address) public royaltyLookup;
    
    function setRoyaltyLookup(address nft, address lookup) external {
        royaltyLookup[nft] = lookup;
    }
    
    function getRoyaltyLookupAddress(address nft) external view override returns (address) {
        return royaltyLookup[nft];
    }
}

contract MockStolenNftOracle is IStolenNftOracle {
    function validateTokensAreNotStolen(
        address,
        uint256[] calldata,
        Message[] calldata
    ) external pure override {
        // Always pass for testing
    }
}

contract RoyaltyVulnerabilityTest is Test {
    PrivatePool pool;
    MockERC20 baseToken;
    MockRoyaltyNFT nft;
    Factory factory;
    MockRoyaltyRegistry royaltyRegistry;
    MockStolenNftOracle stolenNftOracle;
    
    address owner = address(0x1);
    address trader = address(0x2);
    
    uint256 constant NFT_ID = 1;
    uint256 constant ROYALTY_FEE = 10 ether; // 10 WETH royalty fee
    uint256 constant POOL_ETH_BALANCE = 100 ether;
    uint256 constant VIRTUAL_BASE_RESERVES = 50 ether;
    uint256 constant VIRTUAL_NFT_RESERVES = 1 ether;

    function setUp() public {
        // Deploy mock contracts
        baseToken = new MockERC20("WETH", "WETH", 18);
        nft = new MockRoyaltyNFT();
        royaltyRegistry = new MockRoyaltyRegistry();
        stolenNftOracle = new MockStolenNftOracle();
        
        // Set up royalty registry to use the NFT itself for royalty info
        royaltyRegistry.setRoyaltyLookup(address(nft), address(nft));
        
        // Deploy factory
        factory = new Factory(address(0), address(royaltyRegistry), address(stolenNftOracle));
        
        // Create pool
        address poolAddress = factory.createPool();
        pool = PrivatePool(payable(poolAddress));
        
        // Setup NFT with royalty that returns zero address as recipient
        nft.mint(owner, NFT_ID);
        nft.setRoyalty(NFT_ID, ROYALTY_FEE, address(0)); // Zero address recipient
        
        // Initialize pool with royalty payments enabled
        vm.prank(owner);
        pool.initialize(
            address(baseToken),
            address(nft),
            uint128(VIRTUAL_BASE_RESERVES),
            uint128(VIRTUAL_NFT_RESERVES),
            0, // changeFee
            0, // feeRate
            bytes32(0), // merkleRoot
            false, // useStolenNftOracle
            true // payRoyalties - CRITICAL: Enable royalty payments
        );
        
        // Fund pool with base tokens
        baseToken.mint(address(pool), POOL_ETH_BALANCE);
        
        // Transfer NFT to pool
        vm.prank(owner);
        nft.safeTransferFrom(owner, address(pool), NFT_ID);
        
        // Approve pool to spend trader's tokens
        vm.prank(trader);
        baseToken.mint(trader, 100 ether);
        vm.prank(trader);
        baseToken.approve(address(pool), type(uint256).max);
    }

    function testRoyaltyFeeTrappedWhenRecipientIsZeroAddress() public {
        // Record initial balances
        uint256 initialTraderBalance = baseToken.balanceOf(trader);
        uint256 initialPoolBalance = baseToken.balanceOf(address(pool));
        
        // Calculate expected buy cost without royalty
        uint256[] memory tokenIds = new uint256[](1);
        tokenIds[0] = NFT_ID;
        uint256[] memory tokenWeights = new uint256[](1);
        tokenWeights[0] = 1 ether;
        PrivatePool.MerkleMultiProof memory proof;
        
        (uint256 netInputAmount,,) = pool.buyQuote(1 ether);
        
        // Execute buy - trader pays royalty even though recipient is zero address
        vm.prank(trader);
        (uint256 actualNetInput,,) = pool.buy(tokenIds, tokenWeights, proof);
        
        // Verify vulnerability: trader paid more than expected due to royalty
        assertGt(actualNetInput, netInputAmount, "Trader should pay royalty fee");
        assertEq(actualNetInput, netInputAmount + ROYALTY_FEE, "Royalty fee should be added");
        
        // Verify royalty fee is trapped in pool (not distributed to zero address)
        assertEq(
            baseToken.balanceOf(address(pool)),
            initialPoolBalance + actualNetInput,
            "Pool should retain the royalty fee"
        );
        
        // Verify trader lost the royalty amount
        assertEq(
            baseToken.balanceOf(trader),
            initialTraderBalance - actualNetInput,
            "Trader should lose the royalty amount"
        );
        
        // Verify NFT was transferred to trader
        assertEq(nft.ownerOf(NFT_ID), trader, "NFT should be transferred to trader");
    }

    function testRoyaltyFeeTrappedInSellFlow() public {
        // First, transfer NFT to trader for selling test
        vm.prank(owner);
        nft.safeTransferFrom(address(pool), trader, NFT_ID);
        
        // Approve pool to transfer NFT
        vm.prank(trader);
        nft.setApprovalForAll(address(pool), true);
        
        // Record initial balances
        uint256 initialTraderBalance = baseToken.balanceOf(trader);
        uint256 initialPoolBalance = baseToken.balanceOf(address(pool));
        
        // Calculate expected sell amount without royalty
        uint256[] memory tokenIds = new uint256[](1);
        tokenIds[0] = NFT_ID;
        uint256[] memory tokenWeights = new uint256[](1);
        tokenWeights[0] = 1 ether;
        PrivatePool.MerkleMultiProof memory proof;
        IStolenNftOracle.Message[] memory stolenNftProofs;
        
        (uint256 netOutputAmount,,) = pool.sellQuote(1 ether);
        
        // Execute sell - trader receives less due to royalty deduction
        vm.prank(trader);
        (uint256 actualNetOutput,,) = pool.sell(tokenIds, tokenWeights, proof, stolenNftProofs);
        
        // Verify vulnerability: trader received less than expected due to royalty
        assertLt(actualNetOutput, netOutputAmount, "Trader should receive less due to royalty");
        assertEq(actualNetOutput, netOutputAmount - ROYALTY_FEE, "Royalty fee should be deducted");
        
        // Verify royalty fee is trapped in pool (not distributed to zero address)
        assertEq(
            baseToken.balanceOf(address(pool)),
            initialPoolBalance - actualNetOutput,
            "Pool should retain the royalty fee"
        );
        
        // Verify trader lost the royalty amount
        assertEq(
            baseToken.balanceOf(trader),
            initialTraderBalance + actualNetOutput,
            "Trader should receive less due to royalty deduction"
        );
        
        // Verify NFT is now owned by pool
        assertEq(nft.ownerOf(NFT_ID), address(pool), "NFT should be transferred to pool");
    }

    function testRoyaltyFeeNotCollectedWhenPayRoyaltiesIsFalse() public {
        // Disable royalty payments
        vm.prank(owner);
        pool.setPayRoyalties(false);
        
        // Record initial balances
        uint256 initialTraderBalance = baseToken.balanceOf(trader);
        
        // Execute buy without royalty collection
        uint256[] memory tokenIds = new uint256[](1);
        tokenIds[0] = NFT_ID;
        uint256[] memory tokenWeights = new uint256[](1);
        tokenWeights[0] = 1 ether;
        PrivatePool.MerkleMultiProof memory proof;
        
        (uint256 netInputAmount,,) = pool.buyQuote(1 ether);
        
        vm.prank(trader);
        (uint256 actualNetInput,,) = pool.buy(tokenIds, tokenWeights, proof);
        
        // Verify no royalty was collected when payRoyalties is false
        assertEq(actualNetInput, netInputAmount, "No royalty should be collected when disabled");
        assertEq(
            baseToken.balanceOf(trader),
            initialTraderBalance - netInputAmount,
            "Trader should pay exact amount without royalty"
        );
    }
}