// SPDX-License-Identifier: MIT
pragma solidity 0.8.13;

import "forge-std/Test.sol";
import "../src/PuttyV2.sol";
import "solmate/tokens/ERC20.sol";
import "solmate/tokens/WETH.sol";
import "solmate/tokens/ERC721.sol";

// Mock ERC20 for testing
contract MockERC20 is ERC20 {
    constructor(string memory name, string memory symbol, uint256 initialSupply) ERC20(name, symbol, 18) {
        _mint(msg.sender, initialSupply);
    }
    
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

// Mock ERC721 for testing
contract MockERC721 is ERC721 {
    constructor(string memory name, string memory symbol) ERC721(name, symbol) {}
    
    function mint(address to, uint256 tokenId) external {
        _mint(to, tokenId);
    }
    
    function tokenURI(uint256) public view virtual override returns (string memory) {
        return "";
    }
}

contract PuttyV2VulnerabilityTest is Test {
    PuttyV2 public putty;
    WETH public weth;
    MockERC20 public baseAsset;
    MockERC721 public nftAsset;
    
    address public maker = address(0x1);
    address public taker = address(0x2);
    
    uint256 private constant STRIKE = 1 ether;
    uint256 private constant PREMIUM = 0.1 ether;
    uint256 private constant DURATION = 30 days;
    
    // Private key for maker (derived from address 0x1)
    uint256 private constant makerPrivateKey = 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80;
    
    function setUp() public {
        // Deploy WETH
        weth = new WETH();
        
        // Deploy mock tokens
        baseAsset = new MockERC20("Base Asset", "BASE", 1000 ether);
        nftAsset = new MockERC721("NFT Asset", "NFT");
        
        // Deploy PuttyV2
        putty = new PuttyV2("https://api.putty.finance/", 10, address(weth));
        
        // Fund accounts
        vm.deal(maker, 100 ether);
        vm.deal(taker, 100 ether);
        
        // Mint baseAsset tokens
        baseAsset.mint(maker, 100 ether);
        baseAsset.mint(taker, 100 ether);
        
        // Mint NFT
        nftAsset.mint(maker, 1);
        nftAsset.mint(taker, 2);
        
        // Approve tokens
        vm.startPrank(maker);
        baseAsset.approve(address(putty), type(uint256).max);
        nftAsset.setApprovalForAll(address(putty), true);
        vm.stopPrank();
        
        vm.startPrank(taker);
        baseAsset.approve(address(putty), type(uint256).max);
        nftAsset.setApprovalForAll(address(putty), true);
        vm.stopPrank();
    }
    
    function testFillOrderWithNonWETHBaseAssetLocksEther() public {
        // Create order with non-WETH base asset
        PuttyV2.Order memory order = _createOrder(false, true); // isCall=false, isLong=true (long put)
        
        // Sign the order
        bytes32 orderHash = putty.hashOrder(order);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(makerPrivateKey, orderHash);
        bytes memory signature = abi.encodePacked(r, s, v);
        
        // Record initial contract balance
        uint256 initialContractBalance = address(putty).balance;
        
        // Fill order with Ether (should not be needed for non-WETH base asset)
        vm.startPrank(taker);
        vm.deal(taker, 10 ether);
        
        // This will lock 1 ether in the contract forever
        putty.fillOrder{value: 1 ether}(order, signature, new uint256[](0));
        vm.stopPrank();
        
        // Verify Ether is locked in contract
        uint256 finalContractBalance = address(putty).balance;
        assertEq(finalContractBalance, initialContractBalance + 1 ether, "Ether should be locked in contract");
        
        // The Ether cannot be recovered - it's permanently stuck
        assertTrue(finalContractBalance > 0, "Contract now holds stuck Ether");
    }
    
    function testExerciseWithNonWETHBaseAssetLocksEther() public {
        // First fill a long call order
        PuttyV2.Order memory order = _createOrder(true, true); // isCall=true, isLong=true (long call)
        
        // Sign the order
        bytes32 orderHash = putty.hashOrder(order);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(makerPrivateKey, orderHash);
        bytes memory signature = abi.encodePacked(r, s, v);
        
        // Fill order normally
        vm.startPrank(taker);
        uint256 positionId = putty.fillOrder(order, signature, new uint256[](0));
        vm.stopPrank();
        
        // Record initial contract balance
        uint256 initialContractBalance = address(putty).balance;
        
        // Exercise with Ether (should not be needed for non-WETH base asset)
        vm.startPrank(taker);
        vm.deal(taker, 10 ether);
        
        // This will lock 1 ether in the contract forever
        putty.exercise{value: 1 ether}(order, new uint256[](0));
        vm.stopPrank();
        
        // Verify Ether is locked in contract
        uint256 finalContractBalance = address(putty).balance;
        assertEq(finalContractBalance, initialContractBalance + 1 ether, "Ether should be locked in contract");
        
        // The Ether cannot be recovered - it's permanently stuck
        assertTrue(finalContractBalance > 0, "Contract now holds stuck Ether");
    }
    
    function testFillOrderShortPositionWithNonWETHBaseAssetLocksEther() public {
        // Create short order with non-WETH base asset
        PuttyV2.Order memory order = _createOrder(false, false); // isCall=false, isLong=false (short put)
        
        // Sign the order
        bytes32 orderHash = putty.hashOrder(order);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(makerPrivateKey, orderHash);
        bytes memory signature = abi.encodePacked(r, s, v);
        
        // Record initial contract balance
        uint256 initialContractBalance = address(putty).balance;
        
        // Fill order with Ether (should not be needed for non-WETH base asset)
        vm.startPrank(taker);
        vm.deal(taker, 10 ether);
        
        // This will lock 1 ether in the contract forever
        putty.fillOrder{value: 1 ether}(order, signature, new uint256[](0));
        vm.stopPrank();
        
        // Verify Ether is locked in contract
        uint256 finalContractBalance = address(putty).balance;
        assertEq(finalContractBalance, initialContractBalance + 1 ether, "Ether should be locked in contract");
    }
    
    // Helper function to create orders
    function _createOrder(bool isCall, bool isLong) internal view returns (PuttyV2.Order memory) {
        PuttyV2.ERC20Asset[] memory erc20Assets = new PuttyV2.ERC20Asset[](1);
        erc20Assets[0] = PuttyV2.ERC20Asset({
            token: address(baseAsset),
            tokenAmount: 1 ether
        });
        
        PuttyV2.ERC721Asset[] memory erc721Assets = new PuttyV2.ERC721Asset[](1);
        erc721Assets[0] = PuttyV2.ERC721Asset({
            token: address(nftAsset),
            tokenId: isLong ? 2 : 1
        });
        
        return PuttyV2.Order({
            maker: maker,
            isCall: isCall,
            isLong: isLong,
            baseAsset: address(baseAsset), // Non-WETH base asset
            strike: STRIKE,
            premium: PREMIUM,
            duration: DURATION,
            expiration: block.timestamp + 1 days,
            nonce: 0,
            whitelist: new address[](0),
            floorTokens: new address[](0),
            erc20Assets: erc20Assets,
            erc721Assets: erc721Assets
        });
    }
}