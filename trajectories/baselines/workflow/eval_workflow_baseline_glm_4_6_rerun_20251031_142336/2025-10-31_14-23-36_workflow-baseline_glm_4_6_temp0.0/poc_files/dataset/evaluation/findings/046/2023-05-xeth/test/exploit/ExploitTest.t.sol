// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import "forge-std/Test.sol";
import "../src/CVXStaker.sol";
import "../src/interfaces/ICVXBooster.sol";
import "../src/interfaces/IBaseRewardPool.sol";
import "../src/interfaces/ICurvePool.sol";

// Mock ERC20 that reverts on zero transfers to demonstrate the vulnerability
contract RevertOnZeroERC20 {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    constructor(string memory _name, string memory _symbol, uint8 _decimals) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
    }

    function mint(address to, uint256 amount) external {
        totalSupply += amount;
        balanceOf[to] += amount;
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        if (amount == 0) revert("Zero transfer not allowed");
        _transfer(msg.sender, to, amount);
        return true;
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        if (amount == 0) revert("Zero transfer not allowed");
        uint256 current = allowance[from][msg.sender];
        if (current < amount) revert("Insufficient allowance");
        allowance[from][msg.sender] = current - amount;
        _transfer(from, to, amount);
        return true;
    }

    function _transfer(address from, address to, uint256 amount) internal {
        uint256 fromBalance = balanceOf[from];
        if (fromBalance < amount) revert("Insufficient balance");
        balanceOf[from] = fromBalance - amount;
        balanceOf[to] += amount;
    }
}

// Mock CVX Booster contract
contract MockCVXBooster is ICVXBooster {
    struct PoolInfo {
        address lptoken;
        address token;
        address gauge;
        address crvRewards;
        address stash;
        bool shutdown;
    }

    mapping(uint256 => PoolInfo) public poolInfo;

    function setPoolInfo(uint256 _pid, address _lptoken, address _token, bool _shutdown) external {
        poolInfo[_pid] = PoolInfo({
            lptoken: _lptoken,
            token: _token,
            gauge: address(0),
            crvRewards: address(0),
            stash: address(0),
            shutdown: _shutdown
        });
    }

    function deposit(uint256 _pid, uint256 _amount, bool _stake) external override {
        // Mock implementation - just transfer tokens to this contract
        IERC20(poolInfo[_pid].lptoken).transferFrom(msg.sender, address(this), _amount);
    }
}

// Mock Base Reward Pool contract
contract MockBaseRewardPool is IBaseRewardPool {
    mapping(address => uint256) public balances;
    mapping(address => uint256) public earned;
    address public rewardToken;

    constructor(address _rewardToken) {
        rewardToken = _rewardToken;
    }

    function setBalance(address account, uint256 amount) external {
        balances[account] = amount;
    }

    function setEarned(address account, uint256 amount) external {
        earned[account] = amount;
    }

    function balanceOf(address account) external view override returns (uint256) {
        return balances[account];
    }

    function earned(address account) external view override returns (uint256) {
        return earned[account];
    }

    function withdrawAndUnwrap(uint256 amount, bool claim) external override {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        balances[msg.sender] -= amount;
    }

    function withdrawAllAndUnwrap(bool claim) external override {
        balances[msg.sender] = 0;
    }

    function getReward(address account, bool claimExtras) external override {
        // Transfer reward tokens to the account
        uint256 amount = earned[account];
        if (amount > 0) {
            IERC20(rewardToken).transfer(account, amount);
            earned[account] = 0;
        }
    }
}

contract CVXStakerExploit is Test {
    CVXStaker public cvxStaker;
    MockCVXBooster public booster;
    MockBaseRewardPool public rewardPool;
    RevertOnZeroERC20 public clpToken;
    RevertOnZeroERC20 public rewardToken1;
    RevertOnZeroERC20 public rewardToken2;
    RevertOnZeroERC20 public rewardToken3;

    address public owner = address(0x1);
    address public operator = address(0x2);
    address public rewardsRecipient = address(0x3);

    function setUp() public {
        // Start prank as owner
        vm.startPrank(owner);

        // Deploy mock contracts
        clpToken = new RevertOnZeroERC20("CLP Token", "CLP", 18);
        booster = new MockCVXBooster();
        rewardToken1 = new RevertOnZeroERC20("Reward Token 1", "RWD1", 18);
        rewardToken2 = new RevertOnZeroERC20("Reward Token 2", "RWD2", 18);
        rewardToken3 = new RevertOnZeroERC20("Reward Token 3", "RWD3", 18);
        
        // Deploy reward pool with rewardToken1 as the main reward token
        rewardPool = new MockBaseRewardPool(address(rewardToken1));

        // Set up reward tokens array - includes tokens that revert on zero transfers
        address[] memory rewardTokens = new address[](3);
        rewardTokens[0] = address(rewardToken1);
        rewardTokens[1] = address(rewardToken2);
        rewardTokens[2] = address(rewardToken3);

        // Deploy CVXStaker
        cvxStaker = new CVXStaker(
            operator,
            clpToken,
            booster,
            rewardTokens
        );

        // Set up pool info
        booster.setPoolInfo(1, address(clpToken), address(clpToken), false);
        cvxStaker.setCvxPoolInfo(1, address(clpToken), address(rewardPool));

        // Set rewards recipient
        cvxStaker.setRewardsRecipient(rewardsRecipient);

        // Mint some CLP tokens to the staker contract
        clpToken.mint(address(cvxStaker), 1000 ether);

        // Set up reward pool balance
        rewardPool.setBalance(address(cvxStaker), 500 ether);

        vm.stopPrank();
    }

    function test_Vulnerability_ZeroTransferRevert() public {
        // Set up rewards: rewardToken1 has balance, rewardToken2 has zero balance
        vm.startPrank(owner);
        
        // Mint rewards directly to CVXStaker contract (simulating claimed rewards)
        rewardToken1.mint(address(cvxStaker), 100 ether);
        // rewardToken2 has zero balance (not minted)
        rewardToken3.mint(address(cvxStaker), 50 ether);
        
        // Set earned amounts in reward pool
        rewardPool.setEarned(address(cvxStaker), 100 ether);
        
        vm.stopPrank();

        // Claim rewards - this should fail due to zero transfer on rewardToken2
        vm.expectRevert("Zero transfer not allowed");
        cvxStaker.getReward(false);
    }

    function test_Vulnerability_DoS_Impact() public {
        // Demonstrate the DoS impact - no rewards can be claimed
        vm.startPrank(owner);
        
        // Mint rewards to CVXStaker contract
        rewardToken1.mint(address(cvxStaker), 100 ether);
        // rewardToken2 has zero balance (not minted)
        rewardToken3.mint(address(cvxStaker), 50 ether);
        
        rewardPool.setEarned(address(cvxStaker), 100 ether);
        
        vm.stopPrank();

        // Check initial state
        uint256 initialBalance1 = rewardToken1.balanceOf(rewardsRecipient);
        uint256 initialBalance2 = rewardToken2.balanceOf(rewardsRecipient);
        uint256 initialBalance3 = rewardToken3.balanceOf(rewardsRecipient);
        
        assertEq(initialBalance1, 0, "Initial rewardToken1 balance should be 0");
        assertEq(initialBalance2, 0, "Initial rewardToken2 balance should be 0");
        assertEq(initialBalance3, 0, "Initial rewardToken3 balance should be 0");

        // Try to claim rewards - should fail
        vm.expectRevert("Zero transfer not allowed");
        cvxStaker.getReward(false);

        // Verify no rewards were transferred due to DoS
        assertEq(rewardToken1.balanceOf(rewardsRecipient), 0, "Recipient should receive no rewardToken1");
        assertEq(rewardToken2.balanceOf(rewardsRecipient), 0, "Recipient should receive no rewardToken2");
        assertEq(rewardToken3.balanceOf(rewardsRecipient), 0, "Recipient should receive no rewardToken3");
        
        // Rewards remain stuck in the contract
        assertEq(rewardToken1.balanceOf(address(cvxStaker)), 100 ether, "rewardToken1 stuck in contract");
        assertEq(rewardToken3.balanceOf(address(cvxStaker)), 50 ether, "rewardToken3 stuck in contract");
    }

    function test_Vulnerability_Workaround_WithBalance() public {
        // Show that it works when all tokens have non-zero balance
        vm.startPrank(owner);
        
        // Mint rewards to CVXStaker contract - all with non-zero balance
        rewardToken1.mint(address(cvxStaker), 100 ether);
        rewardToken2.mint(address(cvxStaker), 1 ether); // Non-zero balance
        rewardToken3.mint(address(cvxStaker), 50 ether);
        
        rewardPool.setEarned(address(cvxStaker), 100 ether);
        
        vm.stopPrank();

        // Claim rewards - this should succeed
        cvxStaker.getReward(false);

        // Verify rewards were transferred
        assertEq(rewardToken1.balanceOf(rewardsRecipient), 100 ether, "Recipient should receive rewardToken1");
        assertEq(rewardToken2.balanceOf(rewardsRecipient), 1 ether, "Recipient should receive rewardToken2");
        assertEq(rewardToken3.balanceOf(rewardsRecipient), 50 ether, "Recipient should receive rewardToken3");
        
        // Verify no rewards remain in contract
        assertEq(rewardToken1.balanceOf(address(cvxStaker)), 0, "No rewardToken1 should remain");
        assertEq(rewardToken2.balanceOf(address(cvxStaker)), 0, "No rewardToken2 should remain");
        assertEq(rewardToken3.balanceOf(address(cvxStaker)), 0, "No rewardToken3 should remain");
    }

    function test_Vulnerability_Permanent_DoS() public {
        // Demonstrate that the DoS can be permanent since rewardTokens array is immutable
        vm.startPrank(owner);
        
        // Mint rewards to CVXStaker contract
        rewardToken1.mint(address(cvxStaker), 100 ether);
        // rewardToken2 has zero balance and will always cause revert
        rewardToken3.mint(address(cvxStaker), 50 ether);
        
        vm.stopPrank();

        // Multiple attempts to claim rewards all fail
        for(uint i = 0; i < 3; i++) {
            vm.expectRevert("Zero transfer not allowed");
            cvxStaker.getReward(false);
        }

        // Even after time passes, rewards remain stuck
        vm.warp(block.timestamp + 365 days);
        vm.expectRevert("Zero transfer not allowed");
        cvxStaker.getReward(false);

        // Verify rewards are permanently stuck
        assertEq(rewardToken1.balanceOf(address(cvxStaker)), 100 ether, "rewardToken1 permanently stuck");
        assertEq(rewardToken3.balanceOf(address(cvxStaker)), 50 ether, "rewardToken3 permanently stuck");
    }
}