// SPDX-License-Identifier: MIT
pragma solidity 0.8.21;

import {Test, console} from "forge-std/Test.sol";
import {LRTDepositPool} from "../../src/LRTDepositPool.sol";
import {LRTConfig} from "../../src/LRTConfig.sol";
import {LRTConstants} from "../../src/utils/LRTConstants.sol";
import {UtilLib} from "../../src/utils/UtilLib.sol";
import {IRSETH} from "../../src/interfaces/IRSETH.sol";
import {ILRTOracle} from "../../src/interfaces/ILRTOracle.sol";
import {INodeDelegator} from "../../src/interfaces/INodeDelegator.sol";
import {ILRTDepositPool} from "../../src/interfaces/ILRTDepositPool.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

// Mock contracts for testing
contract MockERC20 is IERC20 {
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    mapping(address => uint256) public override balanceOf;
    mapping(address => mapping(address => uint256)) public override allowance;
    
    uint256 public override totalSupply;
    
    constructor(string memory _name, string memory _symbol) {
        name = _name;
        symbol = _symbol;
    }
    
    function mint(address to, uint256 amount) external {
        balanceOf[to] += amount;
        totalSupply += amount;
    }
    
    function burn(address from, uint256 amount) external {
        balanceOf[from] -= amount;
        totalSupply -= amount;
    }
    
    function transfer(address to, uint256 amount) external override returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        return true;
    }
    
    function transferFrom(address from, address to, uint256 amount) external override returns (bool) {
        allowance[from][msg.sender] -= amount;
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        return true;
    }
    
    function approve(address spender, uint256 amount) external override returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }
}

contract MockRSETH is IRSETH {
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    mapping(address => uint256) public override balanceOf;
    mapping(address => mapping(address => uint256)) public override allowance;
    
    uint256 public override totalSupply;
    
    constructor(string memory _name, string memory _symbol) {
        name = _name;
        symbol = _symbol;
    }
    
    function mint(address to, uint256 amount) external override {
        balanceOf[to] += amount;
        totalSupply += amount;
    }
    
    function burn(address from, uint256 amount) external override {
        balanceOf[from] -= amount;
        totalSupply -= amount;
    }
    
    function transfer(address to, uint256 amount) external override returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        return true;
    }
    
    function transferFrom(address from, address to, uint256 amount) external override returns (bool) {
        allowance[from][msg.sender] -= amount;
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        return true;
    }
    
    function approve(address spender, uint256 amount) external override returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }
}

contract MockLRTOracle is ILRTOracle {
    mapping(address => uint256) public assetPrices;
    uint256 public rsETHPrice;
    
    function setAssetPrice(address asset, uint256 price) external {
        assetPrices[asset] = price;
    }
    
    function setRSETHPrice(uint256 price) external {
        rsETHPrice = price;
    }
    
    function getAssetPrice(address asset) external view override returns (uint256) {
        return assetPrices[asset];
    }
    
    function getRSETHPrice() external view override returns (uint256) {
        return rsETHPrice;
    }
}

contract MockNodeDelegator is INodeDelegator {
    mapping(address => uint256) public assetBalances;
    
    function setAssetBalance(address asset, uint256 balance) external {
        assetBalances[asset] = balance;
    }
    
    function getAssetBalance(address asset) external view override returns (uint256) {
        return assetBalances[asset];
    }
}

contract LRTDepositPoolExploit is Test {
    LRTDepositPool public depositPool;
    LRTConfig public lrtConfig;
    MockERC20 public asset;
    MockRSETH public rsETH;
    MockLRTOracle public oracle;
    MockNodeDelegator public nodeDelegator;
    
    address public admin = address(0x1);
    address public manager = address(0x2);
    address public user = address(0x3);
    
    uint256 public constant INITIAL_ASSET_PRICE = 1e18; // 1 ETH = 1 asset
    uint256 public constant INITIAL_RS_ETH_PRICE = 1e18; // 1 rsETH = 1 ETH
    uint256 public constant INITIAL_ASSET_AMOUNT = 10e18; // 10 assets in protocol
    uint256 public constant INITIAL_RS_ETH_SUPPLY = 10e18; // 10 rsETH supply
    uint256 public constant USER_DEPOSIT_AMOUNT = 30e18; // User deposits 30 assets

    function setUp() public {
        // Deploy contracts
        lrtConfig = new LRTConfig();
        asset = new MockERC20("Asset", "ASSET");
        rsETH = new MockRSETH("rsETH", "RSETH");
        oracle = new MockLRTOracle();
        nodeDelegator = new MockNodeDelegator();
        depositPool = new LRTDepositPool();
        
        // Initialize LRTConfig
        vm.startPrank(admin);
        lrtConfig.initialize(admin);
        lrtConfig.setContract(LRTConstants.LRT_ORACLE, address(oracle));
        lrtConfig.setContract(LRTConstants.RSETH, address(rsETH));
        lrtConfig.setContract(LRTConstants.LRT_DEPOSIT_POOL, address(depositPool));
        
        // Set asset as supported and set deposit limit
        lrtConfig.addSupportedAsset(address(asset));
        lrtConfig.setDepositLimitByAsset(address(asset), 1000e18);
        
        // Initialize deposit pool
        depositPool.initialize(address(lrtConfig));
        
        // Add node delegator to queue
        address[] memory ndcs = new address[](1);
        ndcs[0] = address(nodeDelegator);
        depositPool.addNodeDelegatorContractToQueue(ndcs);
        
        // Set up roles
        lrtConfig.grantRole(LRTConstants.LRT_MANAGER_ROLE, manager);
        vm.stopPrank();
        
        // Set up initial state
        _setupInitialState();
    }
    
    function _setupInitialState() internal {
        // Mint initial assets to deposit pool
        asset.mint(address(depositPool), INITIAL_ASSET_AMOUNT);
        
        // Mint initial rsETH supply
        rsETH.mint(admin, INITIAL_RS_ETH_SUPPLY);
        
        // Set up oracle prices
        oracle.setAssetPrice(address(asset), INITIAL_ASSET_PRICE);
        oracle.setRSETHPrice(INITIAL_RS_ETH_PRICE);
        
        // Give user some assets to deposit
        asset.mint(user, USER_DEPOSIT_AMOUNT);
        vm.startPrank(user);
        asset.approve(address(depositPool), USER_DEPOSIT_AMOUNT);
        vm.stopPrank();
    }
    
    function testVulnerability_DepositBeforeCalculation() public {
        console.log("=== VULNERABILITY DEMONSTRATION ===");
        console.log("Initial state:");
        console.log("Total assets in protocol:", depositPool.getTotalAssetDeposits(address(asset)) / 1e18);
        console.log("rsETH supply:", rsETH.totalSupply() / 1e18);
        console.log("rsETH price:", oracle.getRSETHPrice() / 1e18);
        console.log("Asset price:", oracle.getAssetPrice(address(asset)) / 1e18);
        
        // Calculate expected rsETH amount (what user SHOULD get)
        uint256 expectedRsETH = (USER_DEPOSIT_AMOUNT * INITIAL_ASSET_PRICE) / INITIAL_RS_ETH_PRICE;
        console.log("\nExpected rsETH to receive:", expectedRsETH / 1e18);
        
        // User deposits assets
        vm.startPrank(user);
        uint256 userBalanceBefore = rsETH.balanceOf(user);
        
        // This will exploit the vulnerability
        depositPool.depositAsset(address(asset), USER_DEPOSIT_AMOUNT);
        
        uint256 userBalanceAfter = rsETH.balanceOf(user);
        uint256 actualRsETHReceived = userBalanceAfter - userBalanceBefore;
        vm.stopPrank();
        
        console.log("Actual rsETH received:", actualRsETHReceived / 1e18);
        console.log("Loss percentage:", ((expectedRsETH - actualRsETHReceived) * 100) / expectedRsETH, "%");
        
        // Verify the vulnerability
        assertTrue(actualRsETHReceived < expectedRsETH, "User received less rsETH than expected");
        
        // Calculate what the user actually got based on the flawed calculation
        uint256 totalAssetsAfterDeposit = INITIAL_ASSET_AMOUNT + USER_DEPOSIT_AMOUNT;
        uint256 inflatedRsETHPrice = (totalAssetsAfterDeposit * INITIAL_ASSET_PRICE) / INITIAL_RS_ETH_SUPPLY;
        uint256 expectedFlawedCalculation = (USER_DEPOSIT_AMOUNT * INITIAL_ASSET_PRICE) / inflatedRsETHPrice;
        
        console.log("\nFlawed calculation result:", expectedFlawedCalculation / 1e18);
        assertEq(actualRsETHReceived, expectedFlawedCalculation, "Matches the flawed calculation");
    }
    
    function testCorrectOrder_FixedVersion() public {
        console.log("\n=== CORRECT ORDER DEMONSTRATION ===");
        
        // Simulate correct order: calculate first, then transfer
        uint256 totalAssetsBefore = depositPool.getTotalAssetDeposits(address(asset));
        uint256 rsETHPriceBefore = oracle.getRSETHPrice();
        
        // Calculate rsETH amount BEFORE transfer
        uint256 correctRsETHAmount = (USER_DEPOSIT_AMOUNT * oracle.getAssetPrice(address(asset))) / rsETHPriceBefore;
        
        console.log("Total assets before deposit:", totalAssetsBefore / 1e18);
        console.log("rsETH price before deposit:", rsETHPriceBefore / 1e18);
        console.log("Correct rsETH amount:", correctRsETHAmount / 1e18);
        
        // Now transfer assets
        vm.startPrank(user);
        asset.transferFrom(user, address(depositPool), USER_DEPOSIT_AMOUNT);
        vm.stopPrank();
        
        // Mint the calculated amount
        rsETH.mint(user, correctRsETHAmount);
        
        console.log("User received:", correctRsETHAmount / 1e18, "rsETH");
        console.log("This is the correct amount!");
    }
    
    function testEdgeCase_LargeDeposit() public {
        console.log("\n=== EDGE CASE: LARGE DEPOSIT ===");
        
        // Reset to smaller initial state
        vm.startPrank(admin);
        asset.burn(address(depositPool), INITIAL_ASSET_AMOUNT);
        rsETH.burn(admin, INITIAL_RS_ETH_SUPPLY);
        asset.mint(address(depositPool), 1e18); // Only 1 asset initially
        rsETH.mint(admin, 1e18); // Only 1 rsETH initially
        vm.stopPrank();
        
        uint256 largeDeposit = 100e18;
        asset.mint(user, largeDeposit);
        vm.startPrank(user);
        asset.approve(address(depositPool), largeDeposit);
        
        uint256 expectedRsETH = largeDeposit; // Should get 100 rsETH
        console.log("Expected rsETH for 100 asset deposit:", expectedRsETH / 1e18);
        
        depositPool.depositAsset(address(asset), largeDeposit);
        
        uint256 actualReceived = rsETH.balanceOf(user);
        console.log("Actually received:", actualReceived / 1e18);
        console.log("Loss:", ((expectedRsETH - actualReceived) * 100) / expectedRsETH, "%");
        
        assertTrue(actualReceived < expectedRsETH, "Vulnerability confirmed with large deposit");
        vm.stopPrank();
    }
}