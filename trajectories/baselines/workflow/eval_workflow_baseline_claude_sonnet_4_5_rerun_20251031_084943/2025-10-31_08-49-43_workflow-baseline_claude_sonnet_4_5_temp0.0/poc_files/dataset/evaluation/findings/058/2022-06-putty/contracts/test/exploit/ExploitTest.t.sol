// SPDX-License-Identifier: MIT
pragma solidity 0.8.13;

import "forge-std/Test.sol";
import "../../src/PuttyV2.sol";
import "solmate/tokens/ERC20.sol";
import "solmate/tokens/ERC721.sol";

/**
 * @title EtherLockExploitTest
 * @notice Demonstrates the vulnerability where Ether sent to payable functions
 *         gets permanently locked when non-ETH code paths are executed.
 * 
 * Vulnerability: fillOrder() and exercise() are payable but have code paths
 * that don't consume msg.value, causing Ether to be trapped in the contract.
 */
contract EtherLockExploitTest is Test {
    PuttyV2 public putty;
    MockWETH public weth;
    MockERC20 public usdc;
    MockERC721 public nft;
    
    address public maker;
    address public taker;
    uint256 public makerPrivateKey;
    uint256 public takerPrivateKey;
    
    function setUp() public {
        // Setup test accounts
        makerPrivateKey = 0xA11CE;
        takerPrivateKey = 0xB0B;
        maker = vm.addr(makerPrivateKey);
        taker = vm.addr(takerPrivateKey);
        
        // Deploy mock tokens
        weth = new MockWETH();
        usdc = new MockERC20("USDC", "USDC", 6);
        nft = new MockERC721("TestNFT", "TNFT");
        
        // Deploy PuttyV2
        putty = new PuttyV2("https://putty.finance/", 0, address(weth));
        
        // Fund accounts
        vm.deal(maker, 100 ether);
        vm.deal(taker, 100 ether);
        usdc.mint(maker, 1000000e6);
        usdc.mint(taker, 1000000e6);
        nft.mint(maker, 1);
        nft.mint(taker, 2);
    }
    
    /**
     * @notice Exploit 1: Ether locked when filling a long order
     * @dev When filling a long order, premium is transferred from maker to taker
     *      via ERC20.safeTransferFrom. Any msg.value sent is ignored and locked.
     */
    function testExploit_EtherLockedOnLongOrderFill() public {
        // Record initial contract balance
        uint256 initialContractBalance = address(putty).balance;
        
        // Create a long call order with USDC as base asset
        PuttyV2.Order memory order = PuttyV2.Order({
            maker: maker,
            isCall: true,
            isLong: true,
            baseAsset: address(usdc),
            strike: 100e6,
            premium: 10e6,
            duration: 1 days,
            expiration: block.timestamp + 1 days,
            nonce: 0,
            whitelist: new address[](0),
            floorTokens: new address[](0),
            erc20Assets: new PuttyV2.ERC20Asset[](0),
            erc721Assets: new PuttyV2.ERC721Asset[](0)
        });
        
        // Maker approves premium transfer
        vm.prank(maker);
        usdc.approve(address(putty), order.premium);
        
        // Sign the order
        bytes32 orderHash = putty.hashOrder(order);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(makerPrivateKey, orderHash);
        bytes memory signature = abi.encodePacked(r, s, v);
        
        // Taker accidentally sends 1 ETH when filling the long order
        // This ETH should not be accepted since the premium is paid in USDC
        uint256 etherSent = 1 ether;
        vm.prank(taker);
        putty.fillOrder{value: etherSent}(order, signature, new uint256[](0));
        
        // VULNERABILITY DEMONSTRATED: Ether is now locked in the contract
        uint256 finalContractBalance = address(putty).balance;
        assertEq(finalContractBalance - initialContractBalance, etherSent, "Ether was not locked");
        
        // Verify there's no way to recover the locked Ether
        // The contract has no withdraw function for trapped ETH
        console.log("Ether locked in contract:", etherSent);
        console.log("Contract balance:", address(putty).balance);
    }
    
    /**
     * @notice Exploit 2: Ether locked when filling short order with non-WETH base asset
     * @dev When filling a short order with non-WETH base asset, premium is transferred
     *      via ERC20. Any msg.value sent is ignored and locked.
     */
    function testExploit_EtherLockedOnShortOrderFillNonWETH() public {
        uint256 initialContractBalance = address(putty).balance;
        
        // Create a short put order with USDC as base asset
        PuttyV2.Order memory order = PuttyV2.Order({
            maker: maker,
            isCall: false,
            isLong: false,
            baseAsset: address(usdc),
            strike: 100e6,
            premium: 10e6,
            duration: 1 days,
            expiration: block.timestamp + 1 days,
            nonce: 1,
            whitelist: new address[](0),
            floorTokens: new address[](0),
            erc20Assets: new PuttyV2.ERC20Asset[](0),
            erc721Assets: new PuttyV2.ERC721Asset[](0)
        });
        
        // Maker approves strike transfer
        vm.prank(maker);
        usdc.approve(address(putty), order.strike);
        
        // Taker approves premium transfer
        vm.prank(taker);
        usdc.approve(address(putty), order.premium);
        
        // Sign the order
        bytes32 orderHash = putty.hashOrder(order);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(makerPrivateKey, orderHash);
        bytes memory signature = abi.encodePacked(r, s, v);
        
        // Taker sends ETH when filling, but base asset is USDC
        uint256 etherSent = 0.5 ether;
        vm.prank(taker);
        putty.fillOrder{value: etherSent}(order, signature, new uint256[](0));
        
        // VULNERABILITY: ETH is locked
        uint256 finalContractBalance = address(putty).balance;
        assertEq(finalContractBalance - initialContractBalance, etherSent, "Ether was not locked");
        
        console.log("Ether locked from short order fill:", etherSent);
    }
    
    /**
     * @notice Exploit 3: Ether locked when exercising call option with non-WETH base asset
     * @dev When exercising a call option with non-WETH base asset, strike is paid
     *      via ERC20. Any msg.value sent is ignored and locked.
     */
    function testExploit_EtherLockedOnCallExerciseNonWETH() public {
        // Setup: Fill a long call order first
        PuttyV2.ERC721Asset[] memory erc721Assets = new PuttyV2.ERC721Asset[](1);
        erc721Assets[0] = PuttyV2.ERC721Asset({token: address(nft), tokenId: 1});
        
        PuttyV2.Order memory order = PuttyV2.Order({
            maker: maker,
            isCall: true,
            isLong: true,
            baseAsset: address(usdc),
            strike: 100e6,
            premium: 10e6,
            duration: 1 days,
            expiration: block.timestamp + 1 days,
            nonce: 2,
            whitelist: new address[](0),
            floorTokens: new address[](0),
            erc20Assets: new PuttyV2.ERC20Asset[](0),
            erc721Assets: erc721Assets
        });
        
        // Maker approves premium and NFT
        vm.startPrank(maker);
        usdc.approve(address(putty), order.premium);
        nft.approve(address(putty), 1);
        vm.stopPrank();
        
        // Taker approves strike
        vm.prank(taker);
        usdc.approve(address(putty), order.strike);
        
        // Sign and fill order
        bytes32 orderHash = putty.hashOrder(order);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(makerPrivateKey, orderHash);
        bytes memory signature = abi.encodePacked(r, s, v);
        
        vm.prank(taker);
        putty.fillOrder(order, signature, new uint256[](0));
        
        // Record balance before exercise
        uint256 initialContractBalance = address(putty).balance;
        
        // Maker exercises the long call position, accidentally sending ETH
        uint256 etherSent = 2 ether;
        vm.prank(maker);
        putty.exercise{value: etherSent}(order, new uint256[](0));
        
        // VULNERABILITY: ETH is locked during exercise
        uint256 finalContractBalance = address(putty).balance;
        assertEq(finalContractBalance - initialContractBalance, etherSent, "Ether was not locked");
        
        console.log("Ether locked during call exercise:", etherSent);
        console.log("Total contract balance:", address(putty).balance);
    }
}

// Mock WETH contract
contract MockWETH is ERC20 {
    constructor() ERC20("Wrapped Ether", "WETH", 18) {}
    
    function deposit() public payable {
        _mint(msg.sender, msg.value);
    }
    
    function withdraw(uint256 amount) public {
        _burn(msg.sender, amount);
        payable(msg.sender).transfer(amount);
    }
    
    receive() external payable {
        deposit();
    }
}

// Mock ERC20 contract
contract MockERC20 is ERC20 {
    constructor(string memory name, string memory symbol, uint8 decimals) ERC20(name, symbol, decimals) {}
    
    function mint(address to, uint256 amount) public {
        _mint(to, amount);
    }
}

// Mock ERC721 contract
contract MockERC721 is ERC721 {
    constructor(string memory name, string memory symbol) ERC721(name, symbol) {}
    
    function mint(address to, uint256 tokenId) public {
        _mint(to, tokenId);
    }
    
    function tokenURI(uint256) public pure override returns (string memory) {
        return "https://example.com/token";
    }
}
