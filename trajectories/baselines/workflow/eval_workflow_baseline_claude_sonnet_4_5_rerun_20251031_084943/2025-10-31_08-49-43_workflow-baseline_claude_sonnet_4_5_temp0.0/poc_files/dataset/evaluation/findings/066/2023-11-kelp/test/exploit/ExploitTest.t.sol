// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.21;

import "forge-std/Test.sol";
import "forge-std/console.sol";

/**
 * @title Exploit Test for Incorrect rsETH Minting Vulnerability
 * @notice This PoC demonstrates how the premature balance update in depositAsset() 
 *         causes users to receive significantly fewer rsETH tokens than they should.
 * 
 * VULNERABILITY EXPLANATION:
 * The depositAsset() function transfers assets BEFORE calculating the rsETH mint amount.
 * This causes the price calculation to include the deposited assets, inflating the rsETH price
 * and resulting in fewer tokens minted to the user.
 * 
 * ATTACK FLOW:
 * 1. Protocol has existing deposits (totalEthLocked = 10 ETH, rsETHSupply = 10 rsETH)
 * 2. User deposits 30 ETH worth of assets
 * 3. Contract transfers assets first (balance increases to 40 ETH)
 * 4. Contract calculates rsETH price using inflated balance (40 ETH / 10 rsETH = 4 ETH per rsETH)
 * 5. User receives only 7.5 rsETH instead of expected 30 rsETH (75% loss)
 */

// Mock ERC20 token for testing
contract MockERC20 {
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    uint256 public totalSupply;
    
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    
    constructor(string memory _name, string memory _symbol) {
        name = _name;
        symbol = _symbol;
    }
    
    function mint(address to, uint256 amount) external virtual {
        totalSupply += amount;
        balanceOf[to] += amount;
        emit Transfer(address(0), to, amount);
    }
    
    function transfer(address to, uint256 amount) external returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        emit Transfer(msg.sender, to, amount);
        return true;
    }
    
    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
    
    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        if (allowance[from][msg.sender] != type(uint256).max) {
            allowance[from][msg.sender] -= amount;
        }
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        emit Transfer(from, to, amount);
        return true;
    }
}

// Mock rsETH token that can be minted
contract MockRSETH is MockERC20 {
    constructor() MockERC20("rsETH", "rsETH") {}
    
    function mint(address to, uint256 amount) external override {
        totalSupply += amount;
        balanceOf[to] += amount;
        emit Transfer(address(0), to, amount);
    }
}

// Mock LRTOracle for price calculations
contract MockLRTOracle {
    address public depositPool;
    address public asset;
    uint256 public assetPrice;
    
    constructor(address _asset, uint256 _assetPrice) {
        asset = _asset;
        assetPrice = _assetPrice;
    }
    
    function setDepositPool(address _depositPool) external {
        depositPool = _depositPool;
    }
    
    function getAssetPrice(address _asset) external view returns (uint256) {
        require(_asset == asset, "Unsupported asset");
        return assetPrice;
    }
    
    function getRSETHPrice() external view returns (uint256) {
        // Get total ETH locked from deposit pool
        uint256 totalEthLocked = MockDepositPool(depositPool).getTotalAssetDeposits(asset);
        uint256 rsETHSupply = MockRSETH(MockDepositPool(depositPool).rsETH()).totalSupply();
        
        if (rsETHSupply == 0) {
            return 1e18;
        }
        
        // rsEthPrice = totalEthLocked / rsETHSupply
        return (totalEthLocked * 1e18) / rsETHSupply;
    }
}

// Mock LRTConfig
contract MockLRTConfig {
    address public rsETH;
    address public oracle;
    mapping(address => bool) public isSupportedAsset;
    mapping(address => uint256) public depositLimitByAsset;
    
    constructor(address _rsETH, address _oracle) {
        rsETH = _rsETH;
        oracle = _oracle;
    }
    
    function addSupportedAsset(address asset, uint256 depositLimit) external {
        isSupportedAsset[asset] = true;
        depositLimitByAsset[asset] = depositLimit;
    }
    
    function getContract(bytes32) external view returns (address) {
        return oracle;
    }
}

// Vulnerable Deposit Pool (simplified version focusing on the vulnerability)
contract MockDepositPool {
    MockLRTConfig public lrtConfig;
    address public asset;
    
    event AssetDeposit(address indexed asset, uint256 depositAmount, uint256 rsethMintAmount);
    
    error InvalidAmount();
    error MaximumDepositLimitReached();
    error TokenTransferFailed();
    error AssetNotSupported();
    
    constructor(address _lrtConfig, address _asset) {
        lrtConfig = MockLRTConfig(_lrtConfig);
        asset = _asset;
    }
    
    function rsETH() external view returns (address) {
        return lrtConfig.rsETH();
    }
    
    function getTotalAssetDeposits(address _asset) public view returns (uint256) {
        // This includes the balance of this contract
        return MockERC20(_asset).balanceOf(address(this));
    }
    
    function getAssetCurrentLimit(address _asset) public view returns (uint256) {
        return lrtConfig.depositLimitByAsset(_asset) - getTotalAssetDeposits(_asset);
    }
    
    function getRsETHAmountToMint(address _asset, uint256 amount) public view returns (uint256) {
        address oracle = lrtConfig.getContract(bytes32(0));
        
        // rsethAmountToMint = (amount * assetPrice) / rsEthPrice
        uint256 assetPrice = MockLRTOracle(oracle).getAssetPrice(_asset);
        uint256 rsEthPrice = MockLRTOracle(oracle).getRSETHPrice();
        
        return (amount * assetPrice) / rsEthPrice;
    }
    
    // VULNERABLE FUNCTION: Transfers before calculating mint amount
    function depositAsset(address _asset, uint256 depositAmount) external {
        if (!lrtConfig.isSupportedAsset(_asset)) {
            revert AssetNotSupported();
        }
        
        if (depositAmount == 0) {
            revert InvalidAmount();
        }
        
        if (depositAmount > getAssetCurrentLimit(_asset)) {
            revert MaximumDepositLimitReached();
        }
        
        // VULNERABILITY: Transfer happens BEFORE calculating mint amount
        // This increases the balance used in price calculation
        if (!MockERC20(_asset).transferFrom(msg.sender, address(this), depositAmount)) {
            revert TokenTransferFailed();
        }
        
        // Now calculate mint amount with inflated balance
        uint256 rsethAmountMinted = getRsETHAmountToMint(_asset, depositAmount);
        
        // Mint rsETH to user
        MockRSETH(lrtConfig.rsETH()).mint(msg.sender, rsethAmountMinted);
        
        emit AssetDeposit(_asset, depositAmount, rsethAmountMinted);
    }
}

contract ExploitTest is Test {
    MockERC20 public asset;
    MockRSETH public rsETH;
    MockLRTOracle public oracle;
    MockLRTConfig public config;
    MockDepositPool public depositPool;
    
    address public user = address(0x1234);
    address public initialDepositor = address(0x5678);
    
    function setUp() public {
        // Deploy mock contracts
        asset = new MockERC20("Mock LST", "mLST");
        rsETH = new MockRSETH();
        oracle = new MockLRTOracle(address(asset), 1e18); // Asset price = 1 ETH
        config = new MockLRTConfig(address(rsETH), address(oracle));
        depositPool = new MockDepositPool(address(config), address(asset));
        
        // Configure
        config.addSupportedAsset(address(asset), 1000e18);
        oracle.setDepositPool(address(depositPool));
        
        // Setup initial state: 10 ETH locked, 10 rsETH supply
        // This simulates existing deposits in the protocol
        asset.mint(address(depositPool), 10e18);
        rsETH.mint(initialDepositor, 10e18);
        
        // Give user 30 ETH worth of assets to deposit
        asset.mint(user, 30e18);
        
        vm.prank(user);
        asset.approve(address(depositPool), type(uint256).max);
    }
    
    /**
     * @notice Test demonstrating the vulnerability where users receive fewer rsETH than expected
     * 
     * EXPECTED BEHAVIOR:
     * - User deposits 30 ETH worth of assets
     * - rsETH price should be calculated BEFORE transfer: 10 ETH / 10 rsETH = 1 ETH per rsETH
     * - User should receive: (30 ETH * 1 ETH) / 1 ETH = 30 rsETH
     * 
     * ACTUAL BEHAVIOR (VULNERABLE):
     * - User deposits 30 ETH worth of assets
     * - Assets transferred first, balance becomes 40 ETH
     * - rsETH price calculated AFTER transfer: 40 ETH / 10 rsETH = 4 ETH per rsETH
     * - User receives: (30 ETH * 1 ETH) / 4 ETH = 7.5 rsETH
     * 
     * IMPACT: User loses 22.5 rsETH (75% of expected amount)
     */
    function testExploit_IncorrectRsETHMinting() public {
        console.log("=== Vulnerability PoC: Incorrect rsETH Minting ===");
        console.log("");
        
        // Record initial state
        uint256 initialTotalLocked = depositPool.getTotalAssetDeposits(address(asset));
        uint256 initialRsETHSupply = rsETH.totalSupply();
        uint256 userDepositAmount = 30e18;
        
        console.log("Initial State:");
        console.log("  Total ETH Locked:", initialTotalLocked / 1e18, "ETH");
        console.log("  rsETH Supply:", initialRsETHSupply / 1e18, "rsETH");
        console.log("  User Deposit Amount:", userDepositAmount / 1e18, "ETH");
        console.log("");
        
        // Calculate expected rsETH amount (what user SHOULD receive)
        // Expected: rsEthPrice = 10 ETH / 10 rsETH = 1 ETH per rsETH
        // Expected: rsethToMint = (30 ETH * 1 ETH) / 1 ETH = 30 rsETH
        uint256 expectedRsETHPrice = (initialTotalLocked * 1e18) / initialRsETHSupply;
        uint256 expectedRsETHAmount = (userDepositAmount * 1e18) / expectedRsETHPrice;
        
        console.log("Expected Calculation (BEFORE transfer):");
        console.log("  rsETH Price:", expectedRsETHPrice / 1e18, "ETH per rsETH");
        console.log("  Expected rsETH to mint:", expectedRsETHAmount / 1e18, "rsETH");
        console.log("");
        
        // Execute deposit
        uint256 userBalanceBefore = rsETH.balanceOf(user);
        
        vm.prank(user);
        depositPool.depositAsset(address(asset), userDepositAmount);
        
        uint256 userBalanceAfter = rsETH.balanceOf(user);
        uint256 actualRsETHReceived = userBalanceAfter - userBalanceBefore;
        
        // Calculate actual rsETH price used (AFTER transfer)
        // Actual: totalLocked = 40 ETH (10 + 30)
        // Actual: rsEthPrice = 40 ETH / 10 rsETH = 4 ETH per rsETH
        // Actual: rsethToMint = (30 ETH * 1 ETH) / 4 ETH = 7.5 rsETH
        uint256 totalLockedAfterTransfer = initialTotalLocked + userDepositAmount;
        uint256 actualRsETHPrice = (totalLockedAfterTransfer * 1e18) / initialRsETHSupply;
        uint256 calculatedActualAmount = (userDepositAmount * 1e18) / actualRsETHPrice;
        
        console.log("Actual Calculation (AFTER transfer - VULNERABLE):");
        console.log("  Total Locked After Transfer:", totalLockedAfterTransfer / 1e18, "ETH");
        console.log("  rsETH Price (inflated):", actualRsETHPrice / 1e18, "ETH per rsETH");
        console.log("  Actual rsETH minted:", actualRsETHReceived / 1e18, "rsETH");
        console.log("");
        
        // Calculate loss
        uint256 rsETHLoss = expectedRsETHAmount - actualRsETHReceived;
        uint256 lossPercentage = (rsETHLoss * 100) / expectedRsETHAmount;
        
        console.log("Impact:");
        console.log("  Expected rsETH:", expectedRsETHAmount / 1e18, "rsETH");
        console.log("  Actual rsETH:", actualRsETHReceived / 1e18, "rsETH");
        console.log("  Loss:", rsETHLoss / 1e18, "rsETH");
        console.log("  Loss Percentage:", lossPercentage, "%");
        console.log("");
        
        // Assertions proving the vulnerability
        assertEq(actualRsETHReceived, calculatedActualAmount, "Actual amount should match calculated");
        assertEq(actualRsETHReceived, 7.5e18, "User should receive 7.5 rsETH (vulnerable behavior)");
        assertLt(actualRsETHReceived, expectedRsETHAmount, "User receives less than expected");
        assertEq(rsETHLoss, 22.5e18, "User loses 22.5 rsETH");
        assertEq(lossPercentage, 75, "User loses 75% of expected rsETH");
        
        console.log("VULNERABILITY CONFIRMED:");
        console.log("  User deposited 30 ETH but received only 7.5 rsETH instead of 30 rsETH");
        console.log("  This represents a 75% loss due to premature balance update");
    }
}
