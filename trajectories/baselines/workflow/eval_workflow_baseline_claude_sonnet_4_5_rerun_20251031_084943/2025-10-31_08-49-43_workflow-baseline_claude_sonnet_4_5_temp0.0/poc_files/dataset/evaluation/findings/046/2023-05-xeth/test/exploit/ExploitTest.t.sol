// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import "@openzeppelin-contracts/token/ERC20/IERC20.sol";
import "@openzeppelin-contracts/token/ERC20/ERC20.sol";
import "../../src/CVXStaker.sol";
import "../../src/interfaces/ICVXBooster.sol";
import "../../src/interfaces/IBaseRewardPool.sol";

/**
 * @title ExploitTest
 * @notice Proof of Concept demonstrating the zero-amount transfer blocking vulnerability in CVXStaker
 * @dev This test demonstrates how tokens that revert on zero-value transfers can block the getReward() function
 */
contract ExploitTest is Test {
    CVXStaker public cvxStaker;
    MockCLPToken public clpToken;
    MockCVXBooster public booster;
    MockRewardPool public rewardPool;
    MockRewardToken public rewardToken1; // Normal token
    MockRevertOnZeroToken public revertOnZeroToken; // Token that reverts on zero transfer
    
    address public operator = address(0x1);
    address public owner = address(this);
    address public rewardsRecipient = address(0x3);
    
    uint32 public constant POOL_ID = 1;

    function setUp() public {
        // Deploy mock tokens
        clpToken = new MockCLPToken();
        rewardToken1 = new MockRewardToken("Reward Token 1", "RWD1");
        revertOnZeroToken = new MockRevertOnZeroToken("Revert Token", "RVRT");
        
        // Deploy mock booster and reward pool
        booster = new MockCVXBooster();
        rewardPool = new MockRewardPool(address(clpToken));
        
        // Setup reward tokens array
        address[] memory rewardTokens = new address[](2);
        rewardTokens[0] = address(rewardToken1);
        rewardTokens[1] = address(revertOnZeroToken);
        
        // Deploy CVXStaker with ICVXBooster interface cast
        cvxStaker = new CVXStaker(
            operator,
            IERC20(address(clpToken)),
            ICVXBooster(address(booster)),
            rewardTokens
        );
        
        // Configure CVX pool info
        cvxStaker.setCvxPoolInfo(
            POOL_ID,
            address(clpToken),
            address(rewardPool)
        );
        
        // Set rewards recipient
        cvxStaker.setRewardsRecipient(rewardsRecipient);
        
        // Setup booster pool info
        booster.setPoolInfo(POOL_ID, address(clpToken), address(rewardPool), false);
        
        // Configure reward pool to return rewards to CVXStaker
        rewardPool.setRewardRecipient(address(cvxStaker));
        rewardPool.addRewardToken(address(rewardToken1));
        rewardPool.addRewardToken(address(revertOnZeroToken));
    }

    /**
     * @notice Test demonstrating the vulnerability where zero-amount transfers block getReward()
     * @dev This test shows that when one reward token has zero balance and reverts on zero transfer,
     *      the entire getReward() function fails, blocking all reward distribution
     */
    function testExploit_ZeroAmountTransferBlocking() public {
        console.log("=== Starting Zero Amount Transfer Blocking Exploit ===");
        
        // Step 1: Simulate rewards being available
        // Give the reward pool some tokens to distribute
        rewardToken1.mint(address(rewardPool), 1000e18);
        // Note: revertOnZeroToken has 0 balance - this will cause the issue
        
        console.log("Initial state:");
        console.log("- RewardToken1 in pool:", rewardToken1.balanceOf(address(rewardPool)));
        console.log("- RevertOnZeroToken in pool:", revertOnZeroToken.balanceOf(address(rewardPool)));
        
        // Step 2: Simulate the reward pool transferring rewards to CVXStaker
        // This happens inside getReward() when it calls IBaseRewardPool.getReward()
        vm.prank(address(rewardPool));
        rewardToken1.transfer(address(cvxStaker), 1000e18);
        
        console.log("\nAfter simulated reward claim:");
        console.log("- RewardToken1 in CVXStaker:", rewardToken1.balanceOf(address(cvxStaker)));
        console.log("- RevertOnZeroToken in CVXStaker:", revertOnZeroToken.balanceOf(address(cvxStaker)));
        
        // Step 3: Attempt to call getReward() - this should revert
        console.log("\nAttempting to call getReward()...");
        
        // The vulnerability: getReward() will try to transfer 0 amount of revertOnZeroToken
        // which will cause a revert, blocking the entire reward distribution
        vm.expectRevert("ZERO_TRANSFER_NOT_ALLOWED");
        cvxStaker.getReward(false);
        
        console.log("getReward() reverted as expected!");
        
        // Step 4: Verify that rewards are stuck in the contract
        console.log("\nRewards stuck in CVXStaker:");
        console.log("- RewardToken1:", rewardToken1.balanceOf(address(cvxStaker)));
        console.log("- RewardsRecipient balance:", rewardToken1.balanceOf(rewardsRecipient));
        
        // Verify rewards recipient didn't receive anything
        assertEq(rewardToken1.balanceOf(rewardsRecipient), 0, "Rewards should be stuck");
        assertEq(rewardToken1.balanceOf(address(cvxStaker)), 1000e18, "Rewards should remain in CVXStaker");
        
        console.log("\n=== Exploit Successful: Rewards Distribution Blocked ===");
        console.log("Impact: All rewards are stuck in CVXStaker contract");
        console.log("Recovery: Owner must manually call recoverToken() for each token");
    }

    /**
     * @notice Test showing the expected behavior with a fix (zero-check before transfer)
     * @dev This demonstrates how the vulnerability should be fixed
     */
    function testFix_ZeroAmountCheckPreventsBlocking() public {
        console.log("=== Demonstrating Fix: Zero Amount Check ===");
        
        // Setup: Same scenario as exploit
        rewardToken1.mint(address(rewardPool), 1000e18);
        
        vm.prank(address(rewardPool));
        rewardToken1.transfer(address(cvxStaker), 1000e18);
        
        console.log("Initial CVXStaker balances:");
        console.log("- RewardToken1:", rewardToken1.balanceOf(address(cvxStaker)));
        console.log("- RevertOnZeroToken:", revertOnZeroToken.balanceOf(address(cvxStaker)));
        
        // Manually implement the fix: transfer only non-zero amounts
        address[] memory tokens = new address[](2);
        tokens[0] = address(rewardToken1);
        tokens[1] = address(revertOnZeroToken);
        
        for (uint i = 0; i < tokens.length; i++) {
            uint256 balance = IERC20(tokens[i]).balanceOf(address(cvxStaker));
            console.log("\nProcessing token", i, "balance:", balance);
            
            if (balance > 0) {  // THE FIX: Check for zero before transfer
                vm.prank(address(cvxStaker));
                IERC20(tokens[i]).transfer(rewardsRecipient, balance);
                console.log("Transferred", balance, "tokens");
            } else {
                console.log("Skipped zero balance transfer");
            }
        }
        
        // Verify successful distribution
        assertEq(rewardToken1.balanceOf(rewardsRecipient), 1000e18, "Rewards should be distributed");
        assertEq(rewardToken1.balanceOf(address(cvxStaker)), 0, "CVXStaker should be empty");
        
        console.log("\n=== Fix Successful: Rewards Distributed Without Revert ===");
    }
}

/**
 * @notice Mock CLP Token for testing
 */
contract MockCLPToken is ERC20 {
    constructor() ERC20("Mock CLP", "mCLP") {
        _mint(msg.sender, 1000000e18);
    }
}

/**
 * @notice Mock reward token that behaves normally
 */
contract MockRewardToken is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}
    
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

/**
 * @notice Mock token that reverts on zero-value transfers (like LEND, BNB, OMG)
 */
contract MockRevertOnZeroToken is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}
    
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
    
    // Override transfer to revert on zero amount
    function transfer(address to, uint256 amount) public virtual override returns (bool) {
        require(amount > 0, "ZERO_TRANSFER_NOT_ALLOWED");
        return super.transfer(to, amount);
    }
    
    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {
        require(amount > 0, "ZERO_TRANSFER_NOT_ALLOWED");
        return super.transferFrom(from, to, amount);
    }
}

/**
 * @notice Mock CVX Booster implementing ICVXBooster interface
 */
contract MockCVXBooster {
    struct PoolInfo {
        address lptoken;
        address rewards;
        bool shutdown;
    }
    
    mapping(uint256 => PoolInfo) public pools;
    
    function setPoolInfo(uint256 pid, address lptoken, address rewards, bool shutdown) external {
        pools[pid] = PoolInfo(lptoken, rewards, shutdown);
    }
    
    function poolInfo(uint256 pid) external view returns (PoolInfo memory) {
        return pools[pid];
    }
    
    function deposit(uint256 pid, uint256 amount, bool stake) external returns (bool) {
        // Mock implementation - just return true
        return true;
    }
}

/**
 * @notice Mock Base Reward Pool implementing IBaseRewardPool interface
 */
contract MockRewardPool {
    address public stakingToken;
    address public rewardRecipient;
    address[] public rewardTokens;
    
    constructor(address _stakingToken) {
        stakingToken = _stakingToken;
    }
    
    function setRewardRecipient(address _recipient) external {
        rewardRecipient = _recipient;
    }
    
    function addRewardToken(address token) external {
        rewardTokens.push(token);
    }
    
    function getReward(address account, bool claimExtras) external returns (bool) {
        // Mock: Transfer any available reward tokens to the account
        for (uint i = 0; i < rewardTokens.length; i++) {
            uint256 balance = IERC20(rewardTokens[i]).balanceOf(address(this));
            if (balance > 0) {
                IERC20(rewardTokens[i]).transfer(account, balance);
            }
        }
        return true;
    }
    
    function withdrawAndUnwrap(uint256 amount, bool claim) external returns (bool) {
        return true;
    }
    
    function withdrawAllAndUnwrap(bool claim) external {}
    
    function balanceOf(address account) external view returns (uint256) {
        return 0;
    }
    
    function earned(address account) external view returns (uint256) {
        return 0;
    }
}
