// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import {Test} from "forge-std/Test.sol";
import {ERC20} from "lib/solmate/src/tokens/ERC20.sol";

/// @notice Mock ERC20 token that reverts on zero-value transfers
contract RevertOnZeroToken is ERC20 {
    constructor() ERC20("Revert On Zero", "ROZ", 18) {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }

    function transfer(address to, uint256 amount) public override returns (bool) {
        require(amount > 0, "RevertOnZeroToken: zero transfer");
        return super.transfer(to, amount);
    }

    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {
        require(amount > 0, "RevertOnZeroToken: zero transfer");
        return super.transferFrom(from, to, amount);
    }
}

/// @notice Mock standard ERC20 token
contract MockERC20 is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol, 18) {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

/// @notice Proof of Concept: Revert-on-Zero Transfer Tokens Lock Seller Funds
/// @dev This test demonstrates how sellers cannot claim proceeds when using revert-on-zero tokens
contract ExploitTest is Test {
    RevertOnZeroToken public baseToken;
    MockERC20 public quoteToken;
    
    address public seller = address(0x1);
    address public buyer = address(0x2);
    address public auctionHouse = address(0x3);
    
    uint96 public constant CAPACITY = 1000e18;
    uint96 public constant CURATOR_FEE = 50e18;
    uint96 public constant QUOTE_PROCEEDS = 10000e18;

    function setUp() public {
        // Deploy tokens
        baseToken = new RevertOnZeroToken();
        quoteToken = new MockERC20("Quote Token", "QUOTE");
        
        // Setup initial balances
        baseToken.mint(seller, CAPACITY + CURATOR_FEE);
        quoteToken.mint(buyer, QUOTE_PROCEEDS);
        quoteToken.mint(auctionHouse, QUOTE_PROCEEDS);
        
        vm.label(seller, "Seller");
        vm.label(buyer, "Buyer");
        vm.label(auctionHouse, "AuctionHouse");
    }

    /// @notice Test demonstrating the vulnerability where seller funds get locked
    /// @dev Simulates the claimProceeds flow with a revert-on-zero transfer token
    function testExploit_RevertOnZeroTransferLocksSellerFunds() public {
        // ========== STEP 1: Simulate Auction Creation (Prefunded) ==========
        // In a real scenario, seller would transfer CAPACITY + CURATOR_FEE to AuctionHouse
        vm.startPrank(seller);
        baseToken.transfer(auctionHouse, CAPACITY + CURATOR_FEE);
        vm.stopPrank();
        
        uint96 routingFunding = CAPACITY + CURATOR_FEE;
        
        // Verify auction house received the base tokens
        assertEq(baseToken.balanceOf(auctionHouse), CAPACITY + CURATOR_FEE);
        
        // ========== STEP 2: Simulate Auction Settlement ==========
        // After settle(), the following happens:
        // 1. All capacity is sold (sold_ = CAPACITY)
        // 2. Curator fee is paid out (routingFunding -= CURATOR_FEE)
        // 3. No partial fill (payoutSent_ = 0)
        
        uint96 sold = CAPACITY;
        uint96 payoutSent = 0;
        
        // Simulate curator fee payout during settle()
        vm.prank(auctionHouse);
        baseToken.transfer(address(0x999), CURATOR_FEE);
        routingFunding -= CURATOR_FEE;
        
        // After settle(), routing.funding should equal the remaining capacity
        // In this case: routingFunding = (CAPACITY + CURATOR_FEE) - CURATOR_FEE = CAPACITY
        assertEq(routingFunding, CAPACITY);
        
        // ========== STEP 3: Calculate prefundingRefund in claimProceeds ==========
        // This is the exact calculation from AuctionHouse.claimProceeds():
        // uint96 prefundingRefund = routing.funding + payoutSent_ - sold_;
        
        uint96 prefundingRefund = routingFunding + payoutSent - sold;
        
        // Verify that prefundingRefund equals zero
        assertEq(prefundingRefund, 0, "prefundingRefund should be zero");
        
        // ========== STEP 4: Attempt to Transfer Zero Tokens ==========
        // The AuctionHouse attempts to transfer prefundingRefund (0) to the seller
        // This will revert because baseToken reverts on zero transfers
        
        vm.expectRevert("RevertOnZeroToken: zero transfer");
        vm.prank(auctionHouse);
        baseToken.transfer(seller, prefundingRefund);
        
        // ========== STEP 5: Demonstrate Impact - Funds Locked ==========
        // Because the transfer reverts, the entire claimProceeds() transaction fails
        // The seller cannot claim their quote token proceeds
        
        uint256 lockedQuoteTokens = quoteToken.balanceOf(auctionHouse);
        assertEq(lockedQuoteTokens, QUOTE_PROCEEDS, "Quote tokens locked in AuctionHouse");
        
        // Seller has no way to recover these funds
        assertEq(quoteToken.balanceOf(seller), 0, "Seller has no quote tokens");
        
        // ========== VERIFICATION: Show the Fix Would Work ==========
        // If we skip the zero transfer, the seller could claim proceeds
        
        // Simulate successful claim without the zero transfer
        vm.prank(auctionHouse);
        quoteToken.transfer(seller, QUOTE_PROCEEDS);
        
        assertEq(quoteToken.balanceOf(seller), QUOTE_PROCEEDS, "Seller receives proceeds when zero transfer is skipped");
    }

    /// @notice Test showing normal tokens work fine
    /// @dev This demonstrates the issue is specific to revert-on-zero tokens
    function testNormalToken_WorksCorrectly() public {
        // Use a normal ERC20 token as base token
        MockERC20 normalBaseToken = new MockERC20("Normal Base", "NBASE");
        normalBaseToken.mint(seller, CAPACITY + CURATOR_FEE);
        
        // Setup auction
        vm.startPrank(seller);
        normalBaseToken.transfer(auctionHouse, CAPACITY + CURATOR_FEE);
        vm.stopPrank();
        
        uint96 routingFunding = CAPACITY + CURATOR_FEE;
        
        // Simulate settlement
        vm.prank(auctionHouse);
        normalBaseToken.transfer(address(0x999), CURATOR_FEE);
        routingFunding -= CURATOR_FEE;
        
        // Calculate zero refund
        uint96 sold = CAPACITY;
        uint96 payoutSent = 0;
        uint96 prefundingRefund = routingFunding + payoutSent - sold;
        
        assertEq(prefundingRefund, 0);
        
        // Normal token allows zero transfer - no revert
        vm.prank(auctionHouse);
        normalBaseToken.transfer(seller, prefundingRefund);
        
        // Seller can claim proceeds
        vm.prank(auctionHouse);
        quoteToken.transfer(seller, QUOTE_PROCEEDS);
        
        assertEq(quoteToken.balanceOf(seller), QUOTE_PROCEEDS, "Seller successfully claims proceeds with normal token");
    }

    /// @notice Test edge case: Partial fill scenario
    /// @dev Shows the vulnerability can still occur with partial fills
    function testExploit_PartialFillStillCausesIssue() public {
        // Setup auction
        vm.startPrank(seller);
        baseToken.transfer(auctionHouse, CAPACITY + CURATOR_FEE);
        vm.stopPrank();
        
        uint96 routingFunding = CAPACITY + CURATOR_FEE;
        
        // Simulate settlement with partial fill
        uint96 partialFillPayout = 100e18;
        uint96 sold = CAPACITY - partialFillPayout;
        uint96 payoutSent = partialFillPayout;
        
        // Pay curator fee
        vm.prank(auctionHouse);
        baseToken.transfer(address(0x999), CURATOR_FEE);
        routingFunding -= CURATOR_FEE;
        
        // Pay partial fill
        vm.prank(auctionHouse);
        baseToken.transfer(buyer, partialFillPayout);
        routingFunding -= partialFillPayout;
        
        // Calculate refund: routing.funding + payoutSent - sold
        // = (CAPACITY - partialFillPayout) + partialFillPayout - (CAPACITY - partialFillPayout)
        // = CAPACITY - sold = partialFillPayout
        uint96 prefundingRefund = routingFunding + payoutSent - sold;
        
        // In this case, refund is non-zero, so transfer succeeds
        assertGt(prefundingRefund, 0, "Refund is non-zero with partial fill");
        
        vm.prank(auctionHouse);
        baseToken.transfer(seller, prefundingRefund);
        
        // However, if the math works out to zero, the same issue occurs
        // This demonstrates the vulnerability is dependent on specific auction outcomes
    }
}
