// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import "forge-std/Test.sol";
import "../../src/CVXStaker.sol";
import "@openzeppelin-contracts/token/ERC20/ERC20.sol";

// Mock ERC20 token that reverts on zero value transfers
contract RevertOnZeroToken is ERC20 {
    constructor() ERC20("RevertOnZero", "ROZ") {}

    function transfer(address to, uint256 amount) public override returns (bool) {
        require(amount > 0, "Zero transfer not allowed");
        return super.transfer(to, amount);
    }

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

// Mock normal ERC20 token
contract NormalToken is ERC20 {
    constructor() ERC20("Normal", "NRM") {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

// Mock CLP token
contract MockCLPToken is ERC20 {
    constructor() ERC20("CLP", "CLP") {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

// Mock CVX Booster
contract MockCVXBooster is ICVXBooster {
    struct PoolInfo {
        address lptoken;
        address token;
        address gauge;
        address crvRewards;
        address stash;
        bool shutdown;
    }

    mapping(uint256 => PoolInfo) public poolInfo;

    function setPoolInfo(uint256 pid, address lptoken, address crvRewards, bool shutdown) external {
        poolInfo[pid].lptoken = lptoken;
        poolInfo[pid].crvRewards = crvRewards;
        poolInfo[pid].shutdown = shutdown;
    }

    function deposit(uint256 _pid, uint256 _amount, bool _stake) external returns (bool) {
        return true;
    }

    function depositAll(uint256 _pid, bool _stake) external returns (bool) {
        return true;
    }
}

// Mock Base Reward Pool
contract MockBaseRewardPool is IBaseRewardPool {
    mapping(address => uint256) public balances;
    mapping(address => uint256) public earnedRewards;

    function balanceOf(address account) external view returns (uint256) {
        return balances[account];
    }

    function earned(address account) external view returns (uint256) {
        return earnedRewards[account];
    }

    function withdrawAndUnwrap(uint256 amount, bool claim) external returns (bool) {
        balances[msg.sender] -= amount;
        return true;
    }

    function withdrawAllAndUnwrap(bool claim) external returns (bool) {
        balances[msg.sender] = 0;
        return true;
    }

    function getReward(address _account, bool _claimExtras) external returns (bool) {
        // This mock doesn't actually transfer rewards
        // The test will manually transfer rewards to CVXStaker to simulate reward claiming
        return true;
    }

    function setBalance(address account, uint256 amount) external {
        balances[account] = amount;
    }

    function setEarned(address account, uint256 amount) external {
        earnedRewards[account] = amount;
    }
}

contract ExploitTest is Test {
    CVXStaker public cvxStaker;
    MockCLPToken public clpToken;
    MockCVXBooster public booster;
    MockBaseRewardPool public rewardPool;
    
    RevertOnZeroToken public revertToken;
    NormalToken public normalToken;
    
    address public owner;
    address public operator;
    address public rewardsRecipient;

    function setUp() public {
        owner = address(this);
        operator = address(0x1);
        rewardsRecipient = address(0x2);

        // Deploy mock tokens
        clpToken = new MockCLPToken();
        revertToken = new RevertOnZeroToken();
        normalToken = new NormalToken();
        
        // Deploy mock booster and reward pool
        booster = new MockCVXBooster();
        rewardPool = new MockBaseRewardPool();

        // Create reward tokens array with the revert-on-zero token
        address[] memory rewardTokens = new address[](2);
        rewardTokens[0] = address(normalToken);
        rewardTokens[1] = address(revertToken); // This token reverts on zero transfers

        // Deploy CVXStaker
        cvxStaker = new CVXStaker(
            operator,
            IERC20(address(clpToken)),
            ICVXBooster(address(booster)),
            rewardTokens
        );

        // Set CVX pool info
        cvxStaker.setCvxPoolInfo(0, address(clpToken), address(rewardPool));
        
        // Set rewards recipient
        cvxStaker.setRewardsRecipient(rewardsRecipient);

        // Configure mock booster
        booster.setPoolInfo(0, address(clpToken), address(rewardPool), false);
    }

    function testExploit_RevertOnZeroTransferBlocksGetReward() public {
        // STEP 1: Simulate a scenario where CVXStaker has earned some rewards
        // We mint some normalToken rewards to CVXStaker (simulating earned rewards)
        normalToken.mint(address(cvxStaker), 100e18);
        
        // STEP 2: The revertToken has zero balance in CVXStaker
        // This simulates a situation where one reward token has rewards but another doesn't
        uint256 revertTokenBalance = revertToken.balanceOf(address(cvxStaker));
        assertEq(revertTokenBalance, 0, "RevertToken balance should be zero");

        // STEP 3: Verify that normalToken has a non-zero balance
        uint256 normalTokenBalance = normalToken.balanceOf(address(cvxStaker));
        assertGt(normalTokenBalance, 0, "NormalToken should have rewards");

        // STEP 4: Attempt to call getReward() - this should revert
        // The function will try to transfer normalToken (succeeds) and then revertToken (fails due to zero amount)
        vm.expectRevert("Zero transfer not allowed");
        cvxStaker.getReward(false);

        // STEP 5: Verify that rewards are stuck in the contract
        // The normalToken rewards cannot be transferred to rewardsRecipient
        // because the transaction reverts when trying to transfer zero revertTokens
        assertEq(normalToken.balanceOf(address(cvxStaker)), 100e18, "Rewards stuck in contract");
        assertEq(normalToken.balanceOf(rewardsRecipient), 0, "Recipient didn't receive rewards");
    }

    function testExploit_AllRewardsBlockedByOneZeroBalance() public {
        // STEP 1: Setup multiple reward scenarios
        // CVXStaker has earned rewards in normalToken but not in revertToken
        normalToken.mint(address(cvxStaker), 500e18);
        
        // STEP 2: Confirm initial state
        assertEq(normalToken.balanceOf(address(cvxStaker)), 500e18);
        assertEq(revertToken.balanceOf(address(cvxStaker)), 0);
        assertEq(normalToken.balanceOf(rewardsRecipient), 0);

        // STEP 3: The getReward function will iterate through all reward tokens
        // When it reaches revertToken with zero balance, it will attempt a zero transfer
        // This causes the entire transaction to revert, blocking ALL reward claims
        vm.expectRevert("Zero transfer not allowed");
        cvxStaker.getReward(true);

        // STEP 4: Demonstrate that even though normalToken has substantial rewards,
        // they cannot be claimed due to the revertToken blocking the operation
        assertEq(normalToken.balanceOf(address(cvxStaker)), 500e18, "All rewards remain stuck");
        assertEq(normalToken.balanceOf(rewardsRecipient), 0, "No rewards transferred");
    }

    function testExploit_PermanentDenialOfService() public {
        // STEP 1: This test demonstrates that the issue is permanent
        // Once a revert-on-zero token is in the rewards array, getReward() is permanently broken
        
        // Simulate multiple reward cycles
        for (uint i = 0; i < 3; i++) {
            // Each cycle, CVXStaker earns more normalToken rewards
            normalToken.mint(address(cvxStaker), 100e18);
            
            // But getReward() always fails due to zero revertToken balance
            vm.expectRevert("Zero transfer not allowed");
            cvxStaker.getReward(false);
        }

        // STEP 2: Verify that rewards accumulate but can never be claimed
        uint256 totalStuckRewards = normalToken.balanceOf(address(cvxStaker));
        assertEq(totalStuckRewards, 300e18, "Rewards accumulate but are stuck");
        assertEq(normalToken.balanceOf(rewardsRecipient), 0, "Recipient never receives rewards");

        // STEP 3: The vulnerability is permanent because:
        // - The rewardTokens array is immutable (set in constructor)
        // - There's no function to remove a token from the array
        // - There's no check for zero amounts before transfer
        // - The owner cannot fix this without redeploying the contract
    }
}