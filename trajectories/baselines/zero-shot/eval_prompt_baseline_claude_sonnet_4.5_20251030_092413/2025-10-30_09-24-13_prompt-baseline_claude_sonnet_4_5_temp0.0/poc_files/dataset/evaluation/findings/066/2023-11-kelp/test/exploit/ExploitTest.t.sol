// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.21;

import "forge-std/Test.sol";
import "../../src/LRTDepositPool.sol";
import "../../src/interfaces/ILRTConfig.sol";
import "../../src/interfaces/IRSETH.sol";
import "../../src/interfaces/ILRTOracle.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

// Mock contracts for testing
contract MockERC20 is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}
    
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

contract MockRSETH is ERC20 {
    constructor() ERC20("rsETH", "rsETH") {}
    
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

contract MockLRTOracle {
    ILRTConfig public lrtConfig;
    
    constructor(address _lrtConfig) {
        lrtConfig = ILRTConfig(_lrtConfig);
    }
    
    function getAssetPrice(address) external pure returns (uint256) {
        return 1e18; // 1:1 price for simplicity
    }
    
    function getRSETHPrice() external view returns (uint256) {
        address rsethToken = lrtConfig.rsETH();
        address depositPool = lrtConfig.getContract(keccak256("LRT_DEPOSIT_POOL"));
        
        uint256 rsethSupply = IERC20(rsethToken).totalSupply();
        if (rsethSupply == 0) {
            return 1e18;
        }
        
        // Get total ETH locked - this will include the just-transferred deposit
        address[] memory supportedAssets = lrtConfig.getSupportedAssetList();
        uint256 totalETHInPool;
        
        for (uint256 i = 0; i < supportedAssets.length; i++) {
            uint256 assetER = getAssetPrice(supportedAssets[i]);
            uint256 totalAssetAmt = ILRTDepositPool(depositPool).getTotalAssetDeposits(supportedAssets[i]);
            totalETHInPool += totalAssetAmt * assetER;
        }
        
        return totalETHInPool / rsethSupply;
    }
}

contract MockLRTConfig {
    mapping(address => bool) public isSupportedAsset;
    mapping(address => uint256) public depositLimitByAsset;
    mapping(bytes32 => address) public contractMap;
    address public rsETHToken;
    address[] public supportedAssets;
    
    function addNewSupportedAsset(address asset, uint256 depositLimit) external {
        isSupportedAsset[asset] = true;
        depositLimitByAsset[asset] = depositLimit;
        supportedAssets.push(asset);
    }
    
    function setRSETH(address _rseth) external {
        rsETHToken = _rseth;
    }
    
    function rsETH() external view returns (address) {
        return rsETHToken;
    }
    
    function setContract(bytes32 key, address contractAddress) external {
        contractMap[key] = contractAddress;
    }
    
    function getContract(bytes32 key) external view returns (address) {
        return contractMap[key];
    }
    
    function getSupportedAssetList() external view returns (address[] memory) {
        return supportedAssets;
    }
}

contract ExploitTest is Test {
    LRTDepositPool public depositPool;
    MockLRTConfig public lrtConfig;
    MockRSETH public rseth;
    MockERC20 public asset;
    MockLRTOracle public oracle;
    
    address public admin = address(0x1);
    address public manager = address(0x2);
    address public user = address(0x3);
    
    bytes32 constant LRT_ORACLE = keccak256("LRT_ORACLE");
    bytes32 constant LRT_DEPOSIT_POOL = keccak256("LRT_DEPOSIT_POOL");
    bytes32 constant MANAGER = keccak256("MANAGER");
    bytes32 constant ADMIN = keccak256("DEFAULT_ADMIN_ROLE");
    
    function setUp() public {
        // Deploy mock contracts
        lrtConfig = new MockLRTConfig();
        rseth = new MockRSETH();
        asset = new MockERC20("Staked ETH", "stETH");
        
        // Setup LRT config
        lrtConfig.setRSETH(address(rseth));
        lrtConfig.addNewSupportedAsset(address(asset), 1000e18);
        
        // Deploy deposit pool
        depositPool = new LRTDepositPool();
        depositPool.initialize(address(lrtConfig));
        
        // Deploy oracle
        oracle = new MockLRTOracle(address(lrtConfig));
        
        // Configure contracts
        lrtConfig.setContract(LRT_ORACLE, address(oracle));
        lrtConfig.setContract(LRT_DEPOSIT_POOL, address(depositPool));
        lrtConfig.setContract(MANAGER, manager);
        lrtConfig.setContract(ADMIN, admin);
        
        // Setup initial state: mint some rsETH to establish a price
        // totalEthLocked = 10e18, rsETHSupply = 10e18, so rsETHPrice = 1e18
        asset.mint(address(depositPool), 10e18);
        rseth.mint(address(this), 10e18);
    }
    
    function testExploitPriceManipulation() public {
        // Initial state verification
        uint256 initialRsethSupply = rseth.totalSupply();
        uint256 initialTotalAssets = depositPool.getTotalAssetDeposits(address(asset));
        
        console.log("=== Initial State ===");
        console.log("rsETH Supply:", initialRsethSupply);
        console.log("Total Assets in Pool:", initialTotalAssets);
        console.log("rsETH Price:", oracle.getRSETHPrice());
        
        // User wants to deposit 30e18 assets
        uint256 depositAmount = 30e18;
        asset.mint(user, depositAmount);
        
        // Calculate expected rsETH amount BEFORE the deposit
        // With initial state: totalEthLocked = 10e18, rsETHSupply = 10e18
        // rsETHPrice = 10e18 / 10e18 = 1e18
        // Expected rsETH = 30e18 * 1e18 / 1e18 = 30e18
        uint256 expectedRsethBeforeDeposit = (depositAmount * oracle.getAssetPrice(address(asset))) / oracle.getRSETHPrice();
        
        console.log("\n=== Expected Calculation (Before Deposit) ===");
        console.log("Deposit Amount:", depositAmount);
        console.log("Expected rsETH to receive:", expectedRsethBeforeDeposit);
        
        // Execute deposit
        vm.startPrank(user);
        asset.approve(address(depositPool), depositAmount);
        depositPool.depositAsset(address(asset), depositAmount);
        vm.stopPrank();
        
        // Check actual rsETH received
        uint256 actualRsethReceived = rseth.balanceOf(user);
        
        console.log("\n=== Actual Result (After Deposit) ===");
        console.log("Actual rsETH received:", actualRsethReceived);
        
        // Verify the vulnerability: user receives significantly less than expected
        // After transfer but before mint calculation:
        // totalEthLocked = 10e18 + 30e18 = 40e18
        // rsETHSupply = 10e18 (unchanged yet)
        // rsETHPrice = 40e18 / 10e18 = 4e18
        // Actual rsETH = 30e18 * 1e18 / 4e18 = 7.5e18
        
        uint256 expectedRsethWithBug = 7.5e18;
        
        console.log("\n=== Vulnerability Demonstration ===");
        console.log("Expected rsETH (correct):", expectedRsethBeforeDeposit);
        console.log("Expected rsETH (with bug):", expectedRsethWithBug);
        console.log("Actual rsETH received:", actualRsethReceived);
        console.log("Loss to user:", expectedRsethBeforeDeposit - actualRsethReceived);
        console.log("Loss percentage:", ((expectedRsethBeforeDeposit - actualRsethReceived) * 100) / expectedRsethBeforeDeposit);
        
        // Assertions proving the vulnerability
        // User should receive 30e18 rsETH but receives only 7.5e18
        assertEq(actualRsethReceived, expectedRsethWithBug, "User received incorrect amount due to price manipulation");
        assertLt(actualRsethReceived, expectedRsethBeforeDeposit, "User received less than expected");
        
        // The loss is 75% of what user should have received
        uint256 loss = expectedRsethBeforeDeposit - actualRsethReceived;
        assertEq(loss, 22.5e18, "User lost 22.5 rsETH tokens");
        
        // Verify the root cause: balance was updated before price calculation
        uint256 finalTotalAssets = depositPool.getTotalAssetDeposits(address(asset));
        assertEq(finalTotalAssets, initialTotalAssets + depositAmount, "Assets were transferred before minting");
    }
}