// SPDX-License-Identifier: MIT
pragma solidity 0.8.13;

import "forge-std/Test.sol";
import "../../src/PuttyV2.sol";
import "../../src/lib/IWETH.sol";
import "openzeppelin/token/ERC20/ERC20.sol";
import "openzeppelin/token/ERC721/ERC721.sol";

// Mock WETH contract for testing
contract MockWETH is ERC20 {
    constructor() ERC20("Wrapped Ether", "WETH") {}

    function deposit() public payable {
        _mint(msg.sender, msg.value);
    }

    function withdraw(uint256 amount) public {
        _burn(msg.sender, amount);
        payable(msg.sender).transfer(amount);
    }

    receive() external payable {
        deposit();
    }
}

// Mock ERC20 token for testing
contract MockERC20 is ERC20 {
    constructor() ERC20("Mock Token", "MOCK") {
        _mint(msg.sender, 1000000 ether);
    }

    function mint(address to, uint256 amount) public {
        _mint(to, amount);
    }
}

// Mock ERC721 token for testing
contract MockERC721 is ERC721 {
    uint256 private _tokenIdCounter;

    constructor() ERC721("Mock NFT", "MNFT") {}

    function mint(address to) public returns (uint256) {
        uint256 tokenId = _tokenIdCounter++;
        _mint(to, tokenId);
        return tokenId;
    }
}

contract EtherLockExploitTest is Test {
    PuttyV2 public putty;
    MockWETH public weth;
    MockERC20 public baseAsset;
    MockERC721 public nft;

    address public maker;
    address public taker;
    uint256 public makerPrivateKey;
    uint256 public takerPrivateKey;

    function setUp() public {
        // Setup test accounts
        makerPrivateKey = 0xA11CE;
        takerPrivateKey = 0xB0B;
        maker = vm.addr(makerPrivateKey);
        taker = vm.addr(takerPrivateKey);

        // Deploy mock contracts
        weth = new MockWETH();
        baseAsset = new MockERC20();
        nft = new MockERC721();

        // Deploy PuttyV2
        putty = new PuttyV2("https://putty.finance/", 0, address(weth));

        // Fund accounts
        vm.deal(maker, 100 ether);
        vm.deal(taker, 100 ether);
        baseAsset.mint(maker, 1000 ether);
        baseAsset.mint(taker, 1000 ether);
    }

    // Test 1: Ether locked when filling a long order with non-WETH base asset
    function testEtherLockedOnFillLongOrderWithNonWETH() public {
        // VULNERABILITY: When filling a long order where the maker pays premium,
        // any ETH sent by the taker is locked in the contract forever

        uint256 premium = 1 ether;
        uint256 strike = 10 ether;
        uint256 duration = 1 days;

        // Create a long call order with non-WETH base asset
        PuttyV2.Order memory order = PuttyV2.Order({
            maker: maker,
            isCall: true,
            isLong: true,
            baseAsset: address(baseAsset),
            strike: strike,
            premium: premium,
            duration: duration,
            expiration: block.timestamp + 1 days,
            nonce: 0,
            whitelist: new address[](0),
            floorTokens: new address[](0),
            erc20Assets: new PuttyV2.ERC20Asset[](0),
            erc721Assets: new PuttyV2.ERC721Asset[](0)
        });

        // Maker approves premium transfer
        vm.prank(maker);
        baseAsset.approve(address(putty), premium);

        // Sign the order
        bytes32 orderHash = putty.hashOrder(order);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(makerPrivateKey, orderHash);
        bytes memory signature = abi.encodePacked(r, s, v);

        // Record contract balance before
        uint256 contractBalanceBefore = address(putty).balance;

        // EXPLOIT: Taker sends ETH when filling the order even though it's not needed
        // This ETH will be locked in the contract forever
        uint256 lockedEther = 5 ether;
        vm.prank(taker);
        putty.fillOrder{value: lockedEther}(order, signature, new uint256[](0));

        // Verify ETH is locked in contract
        uint256 contractBalanceAfter = address(putty).balance;
        assertEq(contractBalanceAfter - contractBalanceBefore, lockedEther, "ETH should be locked in contract");

        // Verify taker lost the ETH without any benefit
        // The taker receives the short position NFT but the ETH is permanently locked
        console.log("ETH locked in contract:", lockedEther);
        console.log("Contract has no way to return this ETH");
    }

    // Test 2: Ether locked when filling a short order with non-WETH base asset
    function testEtherLockedOnFillShortOrderWithNonWETH() public {
        // VULNERABILITY: When filling a short order with non-WETH base asset,
        // any ETH sent is locked in the contract

        uint256 premium = 1 ether;
        uint256 strike = 10 ether;
        uint256 duration = 1 days;

        // Create a short put order with non-WETH base asset
        PuttyV2.Order memory order = PuttyV2.Order({
            maker: maker,
            isCall: false,
            isLong: false,
            baseAsset: address(baseAsset),
            strike: strike,
            premium: premium,
            duration: duration,
            expiration: block.timestamp + 1 days,
            nonce: 0,
            whitelist: new address[](0),
            floorTokens: new address[](0),
            erc20Assets: new PuttyV2.ERC20Asset[](0),
            erc721Assets: new PuttyV2.ERC721Asset[](0)
        });

        // Maker approves strike transfer
        vm.prank(maker);
        baseAsset.approve(address(putty), strike);

        // Taker approves premium transfer
        vm.prank(taker);
        baseAsset.approve(address(putty), premium);

        // Sign the order
        bytes32 orderHash = putty.hashOrder(order);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(makerPrivateKey, orderHash);
        bytes memory signature = abi.encodePacked(r, s, v);

        // Record contract balance before
        uint256 contractBalanceBefore = address(putty).balance;

        // EXPLOIT: Taker sends ETH when filling but uses ERC20 for premium
        // The ETH is not used and gets locked
        uint256 lockedEther = 3 ether;
        vm.prank(taker);
        putty.fillOrder{value: lockedEther}(order, signature, new uint256[](0));

        // Verify ETH is locked
        uint256 contractBalanceAfter = address(putty).balance;
        assertEq(contractBalanceAfter - contractBalanceBefore, lockedEther, "ETH should be locked in contract");

        console.log("ETH locked when filling short order with non-WETH base:", lockedEther);
    }

    // Test 3: Ether locked when exercising with non-WETH base asset
    function testEtherLockedOnExerciseWithNonWETH() public {
        // VULNERABILITY: When exercising a call option with non-WETH base asset,
        // any ETH sent is locked in the contract

        uint256 premium = 1 ether;
        uint256 strike = 10 ether;
        uint256 duration = 1 days;

        // Mint NFT for the order
        uint256 tokenId = nft.mint(maker);

        // Create ERC721 asset array
        PuttyV2.ERC721Asset[] memory erc721Assets = new PuttyV2.ERC721Asset[](1);
        erc721Assets[0] = PuttyV2.ERC721Asset({token: address(nft), tokenId: tokenId});

        // Create a long call order with non-WETH base asset
        PuttyV2.Order memory order = PuttyV2.Order({
            maker: maker,
            isCall: true,
            isLong: true,
            baseAsset: address(baseAsset),
            strike: strike,
            premium: premium,
            duration: duration,
            expiration: block.timestamp + 1 days,
            nonce: 0,
            whitelist: new address[](0),
            floorTokens: new address[](0),
            erc20Assets: new PuttyV2.ERC20Asset[](0),
            erc721Assets: erc721Assets
        });

        // Maker approves premium and NFT transfer
        vm.startPrank(maker);
        baseAsset.approve(address(putty), premium);
        nft.approve(address(putty), tokenId);
        vm.stopPrank();

        // Taker approves strike
        vm.prank(taker);
        baseAsset.approve(address(putty), strike);

        // Sign and fill the order
        bytes32 orderHash = putty.hashOrder(order);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(makerPrivateKey, orderHash);
        bytes memory signature = abi.encodePacked(r, s, v);

        vm.prank(taker);
        putty.fillOrder(order, signature, new uint256[](0));

        // Record contract balance before exercise
        uint256 contractBalanceBefore = address(putty).balance;

        // EXPLOIT: Maker exercises and sends ETH even though base asset is not WETH
        // This ETH gets locked in the contract
        uint256 lockedEther = 2 ether;
        vm.prank(maker);
        putty.exercise{value: lockedEther}(order, new uint256[](0));

        // Verify ETH is locked
        uint256 contractBalanceAfter = address(putty).balance;
        assertEq(contractBalanceAfter - contractBalanceBefore, lockedEther, "ETH should be locked in contract");

        console.log("ETH locked when exercising with non-WETH base:", lockedEther);
    }

    // Test 4: Demonstrate cumulative ETH lock across multiple operations
    function testCumulativeEtherLock() public {
        // This test shows how ETH can accumulate in the contract over multiple operations
        // with no way to retrieve it

        uint256 totalLockedEther = 0;

        // Scenario 1: Fill long order with ETH sent
        {
            PuttyV2.Order memory order = PuttyV2.Order({
                maker: maker,
                isCall: true,
                isLong: true,
                baseAsset: address(baseAsset),
                strike: 10 ether,
                premium: 1 ether,
                duration: 1 days,
                expiration: block.timestamp + 1 days,
                nonce: 0,
                whitelist: new address[](0),
                floorTokens: new address[](0),
                erc20Assets: new PuttyV2.ERC20Asset[](0),
                erc721Assets: new PuttyV2.ERC721Asset[](0)
            });

            vm.prank(maker);
            baseAsset.approve(address(putty), 1 ether);

            bytes32 orderHash = putty.hashOrder(order);
            (uint8 v, bytes32 r, bytes32 s) = vm.sign(makerPrivateKey, orderHash);
            bytes memory signature = abi.encodePacked(r, s, v);

            uint256 lockedAmount = 1 ether;
            vm.prank(taker);
            putty.fillOrder{value: lockedAmount}(order, signature, new uint256[](0));
            totalLockedEther += lockedAmount;
        }

        // Scenario 2: Fill another order with ETH sent
        {
            PuttyV2.Order memory order = PuttyV2.Order({
                maker: maker,
                isCall: false,
                isLong: false,
                baseAsset: address(baseAsset),
                strike: 10 ether,
                premium: 1 ether,
                duration: 1 days,
                expiration: block.timestamp + 1 days,
                nonce: 1,
                whitelist: new address[](0),
                floorTokens: new address[](0),
                erc20Assets: new PuttyV2.ERC20Asset[](0),
                erc721Assets: new PuttyV2.ERC721Asset[](0)
            });

            vm.prank(maker);
            baseAsset.approve(address(putty), 10 ether);

            vm.prank(taker);
            baseAsset.approve(address(putty), 1 ether);

            bytes32 orderHash = putty.hashOrder(order);
            (uint8 v, bytes32 r, bytes32 s) = vm.sign(makerPrivateKey, orderHash);
            bytes memory signature = abi.encodePacked(r, s, v);

            uint256 lockedAmount = 2 ether;
            vm.prank(taker);
            putty.fillOrder{value: lockedAmount}(order, signature, new uint256[](0));
            totalLockedEther += lockedAmount;
        }

        // Verify total ETH locked
        assertEq(address(putty).balance, totalLockedEther, "Total ETH should be locked");
        console.log("Total ETH permanently locked in contract:", totalLockedEther);
        console.log("This ETH cannot be recovered by anyone");
    }
}