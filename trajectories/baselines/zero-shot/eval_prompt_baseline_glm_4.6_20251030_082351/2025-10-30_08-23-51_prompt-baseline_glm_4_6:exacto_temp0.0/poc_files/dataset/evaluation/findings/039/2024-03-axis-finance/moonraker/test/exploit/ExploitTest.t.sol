// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.19;

import {Test, console} from "forge-std/Test.sol";
import {ERC20} from "lib/solmate/src/tokens/ERC20.sol";
import {AuctionHouse} from "../../src/AuctionHouse.sol";
import {Auctioneer} from "../../src/bases/Auctioneer.sol";
import {FeeManager} from "../../src/bases/FeeManager.sol";
import {Auction, AuctionModule} from "../../src/modules/Auction.sol";
import {Veecode, Keycode, keycodeFromVeecode, WithModules} from "../../src/modules/Modules.sol";
import {ICallback} from "../../src/interfaces/ICallback.sol";
import {Callbacks} from "../../src/lib/Callbacks.sol";
import {Transfer} from "../../src/lib/Transfer.sol";

// Mock ERC20 token that reverts on zero transfers
contract RevertOnZeroTransferToken is ERC20 {
    constructor(string memory name, string memory symbol, uint8 decimals) ERC20(name, symbol, decimals) {}
    
    function transfer(address to, uint256 amount) public override returns (bool) {
        if (amount == 0) revert("Zero transfer not allowed");
        return super.transfer(to, amount);
    }
    
    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {
        if (amount == 0) revert("Zero transfer not allowed");
        return super.transferFrom(from, to, amount);
    }
}

// Mock Auction Module for testing
contract MockAuctionModule is AuctionModule {
    mapping(uint96 => bool) public lots;
    mapping(uint96 => bool) public settled;
    mapping(uint96 => uint96) public remainingCapacity;
    mapping(uint96 => uint96) public purchased;
    mapping(uint96 => uint96) public sold;
    mapping(uint96 => uint96) public payoutSent;
    
    function purchase(
        uint96 lotId_,
        uint96 amount_,
        bytes calldata
    ) external override returns (uint96 payoutAmount, bytes memory auctionOutput) {
        return (amount_, "");
    }
    
    function bid(
        uint96 lotId_,
        address bidder_,
        address referrer_,
        uint96 amount_,
        bytes calldata
    ) external override returns (uint64 bidId) {
        return 1;
    }
    
    function refundBid(
        uint96 lotId_,
        uint64 bidId_,
        address caller_
    ) external override returns (uint96 amount) {
        return 0;
    }
    
    function claimBids(
        uint96 lotId_,
        uint64[] calldata bidIds_
    ) external override returns (Auction.BidClaim[] memory bidClaims, bytes memory auctionOutput) {
        bidClaims = new Auction.BidClaim[](0);
        return (bidClaims, "");
    }
    
    function settle(
        uint96 lotId_
    ) external override returns (Auction.Settlement memory settlement, bytes memory auctionOutput) {
        settled[lotId_] = true;
        settlement.totalIn = purchased[lotId_];
        settlement.totalOut = sold[lotId_];
        return (settlement, "");
    }
    
    function claimProceeds(
        uint96 lotId_
    ) external override returns (uint96 purchased_, uint96 sold_, uint96 payoutSent_) {
        require(settled[lotId_], "Not settled");
        return (purchased[lotId_], sold[lotId_], payoutSent[lotId_]);
    }
    
    function hasEnded(uint96 lotId_) external view override returns (bool) {
        return settled[lotId_];
    }
    
    function remainingCapacity(uint96 lotId_) external view override returns (uint96) {
        return remainingCapacity[lotId_];
    }
    
    // Helper functions for testing
    function setLot(uint96 lotId_, uint96 capacity) external {
        lots[lotId_] = true;
        remainingCapacity[lotId_] = capacity;
    }
    
    function setPurchased(uint96 lotId_, uint96 amount) external {
        purchased[lotId_] = amount;
    }
    
    function setSold(uint96 lotId_, uint96 amount) external {
        sold[lotId_] = amount;
    }
    
    function setPayoutSent(uint96 lotId_, uint96 amount) external {
        payoutSent[lotId_] = amount;
    }
}

contract ExploitTest is Test {
    AuctionHouse public auctionHouse;
    MockAuctionModule public mockModule;
    RevertOnZeroTransferToken public baseToken;
    RevertOnZeroTransferToken public quoteToken;
    
    address public owner = address(0x1);
    address public seller = address(0x2);
    address public protocol = address(0x3);
    address public permit2 = address(0x4);
    
    uint96 public constant LOT_ID = 1;
    uint96 public constant CAPACITY = 1000;
    
    event Settle(uint96 indexed lotId);
    
    function setUp() public {
        // Deploy tokens
        baseToken = new RevertOnZeroTransferToken("Base Token", "BASE", 18);
        quoteToken = new RevertOnZeroTransferToken("Quote Token", "QUOTE", 18);
        
        // Deploy mock module
        mockModule = new MockAuctionModule();
        
        // Deploy auction house
        vm.prank(owner);
        auctionHouse = new AuctionHouse(owner, protocol, permit2);
        
        // Register the mock module
        vm.prank(owner);
        auctionHouse.installModule(Veecode.wrap("AUCTION\00"), address(mockModule));
        
        // Mint tokens to seller
        baseToken.mint(seller, CAPACITY * 2);
        quoteToken.mint(seller, CAPACITY * 2);
        
        // Approve tokens
        vm.prank(seller);
        baseToken.approve(address(auctionHouse), type(uint256).max);
        vm.prank(seller);
        quoteToken.approve(address(auctionHouse), type(uint256).max);
    }
    
    function testExploit_ZeroTransferRevert() public {
        // Create a lot with prefunding
        vm.prank(seller);
        auctionHouse.createLot(
            Auctioneer.CreateLotParams({
                seller: seller,
                baseToken: baseToken,
                quoteToken: quoteToken,
                auctionReference: Veecode.wrap("AUCTION\00"),
                derivativeReference: Veecode.wrap(0),
                callbacks: ICallback(address(0)),
                funding: CAPACITY,
                lotParams: abi.encode(LOT_ID)
            })
        );
        
        // Set up the mock module to simulate a fully settled auction
        // where all base tokens have been sold and paid out
        mockModule.setLot(LOT_ID, CAPACITY);
        mockModule.setPurchased(LOT_ID, CAPACITY); // All quote tokens purchased
        mockModule.setSold(LOT_ID, CAPACITY); // All base tokens sold
        mockModule.setPayoutSent(LOT_ID, CAPACITY); // All payouts sent
        
        // Settle the auction
        vm.prank(seller);
        vm.expectEmit(true, false, false, true);
        emit Settle(LOT_ID);
        auctionHouse.settle(LOT_ID);
        
        // Now try to claim proceeds
        // The prefundingRefund will be: routing.funding + payoutSent_ - sold_
        // Since funding = 0 (all used in settlement), payoutSent = sold = CAPACITY
        // The result is: 0 + CAPACITY - CAPACITY = 0
        // This will cause a revert when trying to transfer 0 tokens
        
        vm.prank(seller);
        vm.expectRevert("Zero transfer not allowed");
        auctionHouse.claimProceeds(LOT_ID, "");
    }
    
    function testExploit_ZeroTransferRevert_WithPartialRefund() public {
        // Create a lot with prefunding
        vm.prank(seller);
        auctionHouse.createLot(
            Auctioneer.CreateLotParams({
                seller: seller,
                baseToken: baseToken,
                quoteToken: quoteToken,
                auctionReference: Veecode.wrap("AUCTION\00"),
                derivativeReference: Veecode.wrap(0),
                callbacks: ICallback(address(0)),
                funding: CAPACITY,
                lotParams: abi.encode(LOT_ID)
            })
        );
        
        // Set up the mock module to simulate a partially settled auction
        // where all base tokens have been sold and paid out
        mockModule.setLot(LOT_ID, CAPACITY);
        mockModule.setPurchased(LOT_ID, CAPACITY * 2); // More quote tokens purchased than capacity
        mockModule.setSold(LOT_ID, CAPACITY); // All base tokens sold
        mockModule.setPayoutSent(LOT_ID, CAPACITY); // All payouts sent
        
        // Settle the auction
        vm.prank(seller);
        auctionHouse.settle(LOT_ID);
        
        // Now try to claim proceeds
        // The prefundingRefund will be: routing.funding + payoutSent_ - sold_
        // Since funding = 0 (all used in settlement), payoutSent = sold = CAPACITY
        // The result is: 0 + CAPACITY - CAPACITY = 0
        // This will cause a revert when trying to transfer 0 tokens
        
        vm.prank(seller);
        vm.expectRevert("Zero transfer not allowed");
        auctionHouse.claimProceeds(LOT_ID, "");
    }
    
    function testExploit_ZeroTransferRevert_WithNoSales() public {
        // Create a lot with prefunding
        vm.prank(seller);
        auctionHouse.createLot(
            Auctioneer.CreateLotParams({
                seller: seller,
                baseToken: baseToken,
                quoteToken: quoteToken,
                auctionReference: Veecode.wrap("AUCTION\00"),
                derivativeReference: Veecode.wrap(0),
                callbacks: ICallback(address(0)),
                funding: CAPACITY,
                lotParams: abi.encode(LOT_ID)
            })
        );
        
        // Set up the mock module to simulate an auction with no sales
        mockModule.setLot(LOT_ID, CAPACITY);
        mockModule.setPurchased(LOT_ID, 0); // No quote tokens purchased
        mockModule.setSold(LOT_ID, 0); // No base tokens sold
        mockModule.setPayoutSent(LOT_ID, 0); // No payouts sent
        
        // Settle the auction
        vm.prank(seller);
        auctionHouse.settle(LOT_ID);
        
        // Now try to claim proceeds
        // The prefundingRefund will be: routing.funding + payoutSent_ - sold_
        // Since funding = CAPACITY (no sales), payoutSent = sold = 0
        // The result is: CAPACITY + 0 - 0 = CAPACITY
        // This should work fine since we're transferring a non-zero amount
        
        vm.prank(seller);
        auctionHouse.claimProceeds(LOT_ID, "");
        
        // Verify the seller received their refund
        assertEq(baseToken.balanceOf(seller), CAPACITY * 2, "Seller should receive full refund");
    }
}