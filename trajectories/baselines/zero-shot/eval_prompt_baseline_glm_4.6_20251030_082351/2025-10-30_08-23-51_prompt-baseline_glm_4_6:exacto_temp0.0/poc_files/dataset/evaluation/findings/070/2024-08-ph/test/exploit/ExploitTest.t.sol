// SPDX-License-Identifier: MIT
pragma solidity 0.8.25;

import {Test, console} from "forge-std/Test.sol";
import {PhiNFT1155} from "../../src/art/PhiNFT1155.sol";
import {IPhiFactory} from "../../src/interfaces/IPhiFactory.sol";
import {IPhiRewards} from "../../src/interfaces/IPhiRewards.sol";

// Mock PhiFactory contract for testing
contract MockPhiFactory is IPhiFactory {
    mapping(uint256 artId => ArtData) public artDataMap;
    address public protocolFeeDestination;
    address public phiRewardsAddress;
    uint256 public artCreateFee = 0.01 ether;
    
    struct ArtData {
        address artist;
        address receiver;
        uint256 mintFee;
        bool soulBounded;
    }
    
    constructor() {
        protocolFeeDestination = address(this);
        phiRewardsAddress = address(new MockPhiRewards());
    }
    
    function artData(uint256 artId) external view returns (ArtData memory) {
        return artDataMap[artId];
    }
    
    function setArtData(uint256 artId, address artist, address receiver, uint256 mintFee, bool soulBounded) external {
        artDataMap[artId] = ArtData(artist, receiver, mintFee, soulBounded);
    }
    
    function contractURI(address) external pure returns (string memory) {
        return "https://example.com/contract";
    }
    
    function getTokenURI(uint256) external pure returns (string memory) {
        return "https://example.com/token";
    }
    
    function protocolFeeDestination() external view returns (address) {
        return protocolFeeDestination;
    }
    
    function phiRewardsAddress() external view returns (address) {
        return phiRewardsAddress;
    }
}

// Mock PhiRewards contract for testing
contract MockPhiRewards is IPhiRewards {
    function handleRewardsAndGetValueSent(
        uint256,
        uint256,
        uint256,
        uint256,
        bytes memory,
        bool
    ) external payable returns (uint256) {
        return msg.value;
    }
}

contract ExploitTest is Test {
    PhiNFT1155 public phiNFT;
    MockPhiFactory public mockFactory;
    
    address public owner = address(0x1);
    address public artist = address(0x2);
    address public user1 = address(0x3);
    address public user2 = address(0x4);
    
    uint256 public constant ART_ID = 1;
    uint256 public constant CRED_ID = 123;
    uint256 public constant CRED_CHAIN_ID = 1;
    
    event Transfer(address indexed from, address indexed to, uint256 indexed id, uint256 value);
    
    function setUp() public {
        // Deploy mock factory
        mockFactory = new MockPhiFactory();
        
        // Set up art data for testing
        mockFactory.setArtData(ART_ID, artist, artist, 0.001 ether, false);
        
        // Deploy PhiNFT1155 as proxy
        vm.prank(address(mockFactory));
        phiNFT = new PhiNFT1155();
        
        // Initialize the contract
        vm.prank(address(mockFactory));
        phiNFT.initialize(CRED_CHAIN_ID, CRED_ID, "test", address(this));
        
        // Create art from factory
        vm.prank(address(mockFactory));
        phiNFT.createArtFromFactory{value: 0.01 ether}(ART_ID);
        
        // Mint tokens to user1
        vm.prank(address(mockFactory));
        phiNFT.claimFromFactory(
            ART_ID,
            user1,
            address(0),
            address(0),
            10,
            "0x1234",
            "https://example.com/image"
        );
    }
    
    function testPauseVulnerability() public {
        // Verify initial state - user1 has tokens
        uint256 tokenId = phiNFT.getTokenIdFromFactoryArtId(ART_ID);
        assertEq(phiNFT.balanceOf(user1, tokenId), 10, "User1 should have 10 tokens initially");
        assertEq(phiNFT.balanceOf(user2, tokenId), 0, "User2 should have 0 tokens initially");
        
        // Pause the contract as owner
        vm.prank(owner);
        phiNFT.pause();
        
        // Verify contract is paused
        assertTrue(phiNFT.paused(), "Contract should be paused");
        
        // VULNERABILITY: Transfer should fail when paused but it succeeds
        // This demonstrates the vulnerability - pause mechanism doesn't work for transfers
        
        // Attempt to transfer tokens while contract is paused
        vm.prank(user1);
        vm.expectEmit(true, true, true, true);
        emit Transfer(user1, user2, tokenId, 5);
        phiNFT.safeTransferFrom(user1, user2, tokenId, 5, "");
        
        // Verify transfer succeeded despite contract being paused
        assertEq(phiNFT.balanceOf(user1, tokenId), 5, "User1 should have 5 tokens after transfer");
        assertEq(phiNFT.balanceOf(user2, tokenId), 5, "User2 should have 5 tokens after transfer");
        
        // Also test batch transfer
        uint256[] memory ids = new uint256[](1);
        uint256[] memory values = new uint256[](1);
        ids[0] = tokenId;
        values[0] = 2;
        
        vm.prank(user1);
        phiNFT.safeBatchTransferFrom(user1, user2, ids, values, "");
        
        // Verify batch transfer also succeeded despite pause
        assertEq(phiNFT.balanceOf(user1, tokenId), 3, "User1 should have 3 tokens after batch transfer");
        assertEq(phiNFT.balanceOf(user2, tokenId), 7, "User2 should have 7 tokens after batch transfer");
    }
    
    function testPauseBlocksMintingButNotTransfers() public {
        // Pause the contract
        vm.prank(owner);
        phiNFT.pause();
        
        // Verify minting is blocked (this works correctly)
        vm.expectRevert(); // Should revert due to whenNotPaused modifier
        vm.prank(address(mockFactory));
        phiNFT.claimFromFactory(
            ART_ID + 1, // Different art ID
            user2,
            address(0),
            address(0),
            5,
            "0x5678",
            "https://example.com/image2"
        );
        
        // But transfers still work (vulnerability)
        uint256 tokenId = phiNFT.getTokenIdFromFactoryArtId(ART_ID);
        vm.prank(user1);
        phiNFT.safeTransferFrom(user1, user2, tokenId, 3, "");
        
        assertEq(phiNFT.balanceOf(user2, tokenId), 3, "Transfer succeeded despite pause");
    }
    
    function testUnpauseResumesNormalOperation() public {
        // Pause the contract
        vm.prank(owner);
        phiNFT.pause();
        
        // Transfer works during pause (vulnerability)
        uint256 tokenId = phiNFT.getTokenIdFromFactoryArtId(ART_ID);
        vm.prank(user1);
        phiNFT.safeTransferFrom(user1, user2, tokenId, 2, "");
        
        // Unpause the contract
        vm.prank(owner);
        phiNFT.unPause();
        
        // Verify contract is unpaused
        assertFalse(phiNFT.paused(), "Contract should be unpaused");
        
        // Transfers still work after unpause
        vm.prank(user1);
        phiNFT.safeTransferFrom(user1, user2, tokenId, 1, "");
        
        assertEq(phiNFT.balanceOf(user1, tokenId), 7, "User1 should have 7 tokens");
        assertEq(phiNFT.balanceOf(user2, tokenId), 3, "User2 should have 3 tokens");
    }
}