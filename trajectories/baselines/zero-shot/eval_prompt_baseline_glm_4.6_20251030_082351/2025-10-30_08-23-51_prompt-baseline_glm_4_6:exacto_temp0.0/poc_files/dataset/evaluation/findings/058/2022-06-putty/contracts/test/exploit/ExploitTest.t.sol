// SPDX-License-Identifier: MIT
pragma solidity 0.8.13;

import "../../src/PuttyV2.sol";
import "openzeppelin/token/ERC20/ERC20.sol";
import "openzeppelin/token/ERC721/ERC721.sol";
import "forge-std/Test.sol";
import "openzeppelin/utils/cryptography/ECDSA.sol";

contract MockERC20 is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {
        _mint(msg.sender, 1000000 * 10**18);
    }

    function mint(address to, uint256 amount) public {
        _mint(to, amount);
    }
}

contract MockERC721 is ERC721 {
    uint256 private _nextTokenId = 1;
    
    constructor(string memory name, string memory symbol) ERC721(name, symbol) {}

    function mint(address to) public returns (uint256) {
        uint256 tokenId = _nextTokenId++;
        _mint(to, tokenId);
        return tokenId;
    }
}

contract MockWETH is MockERC20 {
    receive() external payable {
        _mint(msg.sender, msg.value);
    }

    function withdraw(uint256 amount) external {
        _burn(msg.sender, amount);
        payable(msg.sender).transfer(amount);
    }
}

contract ExploitTest is Test {
    PuttyV2 public putty;
    MockERC20 public baseToken;
    MockERC20 public weth;
    MockERC721 public nft;
    
    address public maker = address(0x1);
    address public taker = address(0x2);
    address public owner = address(0x3);

    function setUp() public {
        // Deploy mock tokens
        baseToken = new MockERC20("Base Token", "BASE");
        weth = new MockWETH("Wrapped Ether", "WETH");
        nft = new MockERC721("Test NFT", "TNFT");
        
        // Deploy PuttyV2
        vm.prank(owner);
        putty = new PuttyV2("https://api.putty.finance/", 10, address(weth));
        
        // Fund accounts
        vm.deal(maker, 100 ether);
        vm.deal(taker, 100 ether);
        baseToken.mint(maker, 1000 * 10**18);
        baseToken.mint(taker, 1000 * 10**18);
        
        // Approve tokens
        vm.prank(maker);
        baseToken.approve(address(putty), type(uint256).max);
        vm.prank(taker);
        baseToken.approve(address(putty), type(uint256).max);
    }

    function test_fillOrderLongWithNonWETHBaseAsset_LocksEther() public {
        // Create a long call order with non-WETH base asset
        PuttyV2.Order memory order = PuttyV2.Order({
            maker: maker,
            isCall: true,
            isLong: true,
            baseAsset: address(baseToken), // Non-WETH base asset
            strike: 100 * 10**18,
            premium: 10 * 10**18,
            duration: 30 days,
            expiration: block.timestamp + 60 days,
            nonce: 0,
            whitelist: new address[](0),
            floorTokens: new address[](0),
            erc20Assets: new PuttyV2.ERC20Asset[](0),
            erc721Assets: new PuttyV2.ERC721Asset[](0)
        });

        // Sign the order
        bytes32 orderHash = putty.hashOrder(order);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, orderHash);
        bytes memory signature = abi.encodePacked(r, s, v);

        // Record initial contract balance
        uint256 initialContractBalance = address(putty).balance;
        
        // Fill the order with excess Ether (vulnerable path)
        // This Ether will be locked because the code path doesn't use msg.value
        vm.prank(taker);
        uint256 positionId = putty.fillOrder{value: 5 ether}(order, signature, new uint256[](0));
        
        // Verify the position was created
        assertEq(putty.ownerOf(positionId), taker);
        
        // Verify Ether was locked in contract
        assertEq(address(putty).balance, initialContractBalance + 5 ether);
        
        // The premium was paid in ERC20 tokens, not Ether
        assertEq(baseToken.balanceOf(maker), 1000 * 10**18 - 10 * 10**18);
        assertEq(baseToken.balanceOf(taker), 1000 * 10**18 + 10 * 10**18);
        
        // The 5 Ether is permanently locked - no way to retrieve it
        console.log("Ether locked in contract:", address(putty).balance);
    }

    function test_fillOrderShortWithNonWETHBaseAsset_LocksEther() public {
        // Create a short call order with non-WETH base asset
        PuttyV2.Order memory order = PuttyV2.Order({
            maker: maker,
            isCall: true,
            isLong: false,
            baseAsset: address(baseToken), // Non-WETH base asset
            strike: 100 * 10**18,
            premium: 10 * 10**18,
            duration: 30 days,
            expiration: block.timestamp + 60 days,
            nonce: 1,
            whitelist: new address[](0),
            floorTokens: new address[](0),
            erc20Assets: new PuttyV2.ERC20Asset[](0),
            erc721Assets: new PuttyV2.ERC721Asset[](0)
        });

        // Sign the order
        bytes32 orderHash = putty.hashOrder(order);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, orderHash);
        bytes memory signature = abi.encodePacked(r, s, v);

        // Record initial contract balance
        uint256 initialContractBalance = address(putty).balance;
        
        // Fill the order with excess Ether (vulnerable path)
        // This Ether will be locked because the code path doesn't use msg.value
        vm.prank(taker);
        uint256 positionId = putty.fillOrder{value: 3 ether}(order, signature, new uint256[](0));
        
        // Verify the position was created
        assertEq(putty.ownerOf(positionId), taker);
        
        // Verify Ether was locked in contract
        assertEq(address(putty).balance, initialContractBalance + 3 ether);
        
        // The premium was paid in ERC20 tokens, not Ether
        assertEq(baseToken.balanceOf(maker), 1000 * 10**18 + 10 * 10**18);
        assertEq(baseToken.balanceOf(taker), 1000 * 10**18 - 10 * 10**18);
        
        // The 3 Ether is permanently locked
        console.log("Ether locked in contract:", address(putty).balance);
    }

    function test_exerciseCallWithNonWETHBaseAsset_LocksEther() public {
        // First create and fill a long call order
        PuttyV2.Order memory order = PuttyV2.Order({
            maker: maker,
            isCall: true,
            isLong: true,
            baseAsset: address(baseToken), // Non-WETH base asset
            strike: 100 * 10**18,
            premium: 10 * 10**18,
            duration: 30 days,
            expiration: block.timestamp + 60 days,
            nonce: 2,
            whitelist: new address[](0),
            floorTokens: new address[](0),
            erc20Assets: new PuttyV2.ERC20Asset[](0),
            erc721Assets: new PuttyV2.ERC721Asset[](0)
        });

        // Sign and fill the order
        bytes32 orderHash = putty.hashOrder(order);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, orderHash);
        bytes memory signature = abi.encodePacked(r, s, v);
        
        vm.prank(taker);
        uint256 positionId = putty.fillOrder(order, signature, new uint256[](0));
        
        // Record initial contract balance
        uint256 initialContractBalance = address(putty).balance;
        
        // Exercise the option with excess Ether (vulnerable path)
        // This Ether will be locked because the code path doesn't use msg.value
        vm.prank(taker);
        putty.exercise{value: 7 ether}(order, new uint256[](0));
        
        // Verify Ether was locked in contract
        assertEq(address(putty).balance, initialContractBalance + 7 ether);
        
        // The strike was paid in ERC20 tokens, not Ether
        assertEq(baseToken.balanceOf(taker), 1000 * 10**18 + 10 * 10**18 - 100 * 10**18);
        
        // The 7 Ether is permanently locked
        console.log("Ether locked in contract:", address(putty).balance);
    }

    function test_multipleEtherLockingScenarios() public {
        uint256 totalLocked = 0;
        
        // Scenario 1: Fill long order with non-WETH base asset
        PuttyV2.Order memory order1 = PuttyV2.Order({
            maker: maker,
            isCall: true,
            isLong: true,
            baseAsset: address(baseToken),
            strike: 100 * 10**18,
            premium: 10 * 10**18,
            duration: 30 days,
            expiration: block.timestamp + 60 days,
            nonce: 3,
            whitelist: new address[](0),
            floorTokens: new address[](0),
            erc20Assets: new PuttyV2.ERC20Asset[](0),
            erc721Assets: new PuttyV2.ERC721Asset[](0)
        });

        bytes32 orderHash1 = putty.hashOrder(order1);
        (uint8 v1, bytes32 r1, bytes32 s1) = vm.sign(1, orderHash1);
        bytes memory signature1 = abi.encodePacked(r1, s1, v1);
        
        uint256 initialBalance = address(putty).balance;
        vm.prank(taker);
        putty.fillOrder{value: 10 ether}(order1, signature1, new uint256[](0));
        totalLocked += 10 ether;
        assertEq(address(putty).balance, initialBalance + totalLocked);
        
        // Scenario 2: Fill short order with non-WETH base asset
        PuttyV2.Order memory order2 = PuttyV2.Order({
            maker: maker,
            isCall: false,
            isLong: false,
            baseAsset: address(baseToken),
            strike: 100 * 10**18,
            premium: 10 * 10**18,
            duration: 30 days,
            expiration: block.timestamp + 60 days,
            nonce: 4,
            whitelist: new address[](0),
            floorTokens: new address[](0),
            erc20Assets: new PuttyV2.ERC20Asset[](0),
            erc721Assets: new PuttyV2.ERC721Asset[](0)
        });

        bytes32 orderHash2 = putty.hashOrder(order2);
        (uint8 v2, bytes32 r2, bytes32 s2) = vm.sign(1, orderHash2);
        bytes memory signature2 = abi.encodePacked(r2, s2, v2);
        
        vm.prank(taker);
        putty.fillOrder{value: 15 ether}(order2, signature2, new uint256[](0));
        totalLocked += 15 ether;
        assertEq(address(putty).balance, initialBalance + totalLocked);
        
        // Scenario 3: Exercise with non-WETH base asset
        PuttyV2.Order memory order3 = PuttyV2.Order({
            maker: maker,
            isCall: true,
            isLong: true,
            baseAsset: address(baseToken),