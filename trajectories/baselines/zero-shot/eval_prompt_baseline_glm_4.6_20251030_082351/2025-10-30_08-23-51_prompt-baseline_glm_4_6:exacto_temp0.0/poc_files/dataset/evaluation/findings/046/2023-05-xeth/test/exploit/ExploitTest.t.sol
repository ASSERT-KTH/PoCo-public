// SPDX-License-Identifier: MIT

pragma solidity 0.8.19;

import "../../src/CVXStaker.sol";
import "@openzeppelin-contracts/token/ERC20/IERC20.sol";
import "@openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin-contracts/access/Ownable.sol";

// Mock interfaces for testing
interface ICVXBooster {
    function deposit(uint256 _pid, uint256 _amount, bool _stake) external;
    function poolInfo(uint256 _pid) external view returns (address lptoken, address token, address gauge, address crvRewards, address stash, bool shutdown);
}

interface IBaseRewardPool {
    function withdrawAndUnwrap(uint256 _amount, bool _claim) external;
    function withdrawAllAndUnwrap(bool _claim) external;
    function getReward(address _account, bool _claimExtras) external;
    function balanceOf(address _account) external view returns (uint256);
    function earned(address _account) external view returns (uint256);
}

// Mock ERC20 token that reverts on zero value transfers
contract RevertOnZeroToken {
    using SafeERC20 for IERC20;
    
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    error ZeroTransfer();

    constructor(string memory _name, string memory _symbol, uint8 _decimals) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
    }

    function mint(address to, uint256 amount) external {
        totalSupply += amount;
        balanceOf[to] += amount;
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        if (amount == 0) revert ZeroTransfer();
        _transfer(msg.sender, to, amount);
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        if (amount == 0) revert ZeroTransfer();
        uint256 current = allowance[from][msg.sender];
        if (current < amount) revert("ERC20: insufficient allowance");
        allowance[from][msg.sender] = current - amount;
        _transfer(from, to, amount);
        return true;
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }

    function _transfer(address from, address to, uint256 amount) internal {
        uint256 fromBalance = balanceOf[from];
        if (fromBalance < amount) revert("ERC20: insufficient balance");
        balanceOf[from] = fromBalance - amount;
        balanceOf[to] += amount;
    }
}

// Mock CVX Booster
contract MockCVXBooster is ICVXBooster {
    struct PoolInfo {
        address lptoken;
        address token;
        address gauge;
        address crvRewards;
        address stash;
        bool shutdown;
    }

    mapping(uint256 => PoolInfo) public poolInfo;

    function setPoolInfo(uint256 _pid, address _lptoken, address _token, address _gauge, address _crvRewards, address _stash, bool _shutdown) external {
        poolInfo[_pid] = PoolInfo(_lptoken, _token, _gauge, _crvRewards, _stash, _shutdown);
    }

    function deposit(uint256 _pid, uint256 _amount, bool _stake) external override {
        // Mock implementation
    }
}

// Mock Base Reward Pool
contract MockBaseRewardPool is IBaseRewardPool {
    mapping(address => uint256) public balances;
    mapping(address => uint256) public earned;

    function setBalance(address account, uint256 amount) external {
        balances[account] = amount;
    }

    function setEarned(address account, uint256 amount) external {
        earned[account] = amount;
    }

    function balanceOf(address _account) external view override returns (uint256) {
        return balances[_account];
    }

    function earned(address _account) external view override returns (uint256) {
        return earned[_account];
    }

    function withdrawAndUnwrap(uint256 _amount, bool _claim) external override {
        // Mock implementation
    }

    function withdrawAllAndUnwrap(bool _claim) external override {
        // Mock implementation
    }

    function getReward(address _account, bool _claimExtras) external override {
        // Mock implementation
    }
}

contract ExploitTest {
    CVXStaker public cvxStaker;
    MockCVXBooster public mockBooster;
    MockBaseRewardPool public mockRewardPool;
    RevertOnZeroToken public clpToken;
    RevertOnZeroToken public revertToken;
    IERC20 public normalToken;

    address public owner = address(0x1);
    address public operator = address(0x2);
    address public rewardsRecipient = address(0x3);

    event RewardClaimed(address indexed token, uint256 amount);

    function setUp() public {
        // Deploy mock contracts
        mockBooster = new MockCVXBooster();
        mockRewardPool = new MockBaseRewardPool();
        clpToken = new RevertOnZeroToken("CLP Token", "CLP", 18);
        revertToken = new RevertOnZeroToken("Revert Token", "RVT", 18);
        
        // Deploy a normal ERC20 token for comparison
        normalToken = new RevertOnZeroToken("Normal Token", "NRM", 18);
        
        // Mint some tokens for testing
        clpToken.mint(address(this), 1000 ether);
        revertToken.mint(address(this), 1000 ether);
        normalToken.mint(address(this), 1000 ether);

        // Set up reward tokens array - includes the problematic token
        address[] memory rewardTokens = new address[](2);
        rewardTokens[0] = address(revertToken);
        rewardTokens[1] = address(normalToken);

        // Deploy CVXStaker contract
        cvxStaker = new CVXStaker(
            operator,
            clpToken,
            mockBooster,
            rewardTokens
        );

        // Configure mock booster
        mockBooster.setPoolInfo(
            1,
            address(clpToken),
            address(clpToken),
            address(0),
            address(mockRewardPool),
            address(0),
            false
        );

        // Set CVX pool info
        vm.prank(owner);
        cvxStaker.setCvxPoolInfo(1, address(clpToken), address(mockRewardPool));

        // Set rewards recipient
        vm.prank(owner);
        cvxStaker.setRewardsRecipient(rewardsRecipient);

        // Set initial balances in mock reward pool
        mockRewardPool.setBalance(address(cvxStaker), 100 ether);
        mockRewardPool.setEarned(address(cvxStaker), 50 ether);
    }

    function testExploit_ZeroTransferRevert() public {
        // Step 1: Verify initial state
        assertEq(cvxStaker.rewardsRecipient(), rewardsRecipient, "Rewards recipient not set correctly");
        
        // Step 2: Ensure the revert token has zero balance in the CVXStaker contract
        // This simulates a scenario where no rewards were earned for this token
        assertEq(revertToken.balanceOf(address(cvxStaker)), 0, "Revert token should have zero balance");
        
        // Step 3: Attempt to call getReward() which should fail due to zero transfer
        // The function will try to transfer 0 amount of revertToken, which reverts
        vm.expectRevert(RevertOnZeroToken.ZeroTransfer.selector);
        cvxStaker.getReward(false);
        
        // Step 4: Verify that the exploit blocks the reward claiming functionality
        // Even though there might be rewards in other tokens, the whole operation fails
    }

    function testExploit_WithNonZeroBalance() public {
        // Step 1: Give the revert token a non-zero balance to show normal operation works
        revertToken.mint(address(cvxStaker), 10 ether);
        
        // Step 2: This should work fine since the transfer amount is non-zero
        cvxStaker.getReward(false);
        
        // Step 3: Verify the transfer succeeded
        assertEq(revertToken.balanceOf(rewardsRecipient), 10 ether, "Transfer should succeed with non-zero amount");
    }

    function testExploit_DemonstrateVulnerability() public {
        // This test demonstrates the core vulnerability:
        // When a token in the rewardTokens array has zero balance, getReward() fails
        
        // Step 1: Set up scenario where one reward token has balance, another doesn't
        normalToken.mint(address(cvxStaker), 20 ether);
        // revertToken remains at 0 balance
        
        // Step 2: Even though normalToken has rewards, the whole operation fails
        // because revertToken transfer with 0 amount reverts
        vm.expectRevert(RevertOnZeroToken.ZeroTransfer.selector);
        cvxStaker.getReward(false);
        
        // Step 3: Verify normalToken rewards are stuck (not transferred)
        assertEq(normalToken.balanceOf(rewardsRecipient), 0, "Normal token rewards should be stuck");
        assertEq(normalToken.balanceOf(address(cvxStaker)), 20 ether, "Normal token rewards remain in contract");
    }

    // Helper function to use Foundry cheatcodes
    function _prank(address caller) internal {
        vm.prank(caller);
    }
}