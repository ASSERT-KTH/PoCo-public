// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.21;

import {Test, console} from "forge-std/Test.sol";
import {LRTDepositPool} from "../../src/LRTDepositPool.sol";
import {ILRTConfig} from "../../src/utils/ILRTConfig.sol";
import {IRSETH} from "../../src/interfaces/IRSETH.sol";
import {ILRTOracle} from "../../src/interfaces/ILRTOracle.sol";
import {INodeDelegator} from "../../src/interfaces/INodeDelegator.sol";
import {LRTConstants} from "../../src/utils/LRTConstants.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {UtilLib} from "../../src/utils/UtilLib.sol";

// Mock contracts for testing
contract MockERC20 is IERC20 {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    constructor(string memory _name, string memory _symbol, uint8 _decimals) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
    }

    function transfer(address to, uint256 amount) external override returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        return true;
    }

    function approve(address spender, uint256 amount) external override returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) external override returns (bool) {
        allowance[from][msg.sender] -= amount;
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        return true;
    }

    function mint(address to, uint256 amount) external {
        balanceOf[to] += amount;
        totalSupply += amount;
    }
}

contract MockRSETH is IRSETH {
    string public name = "rsETH";
    string public symbol = "rsETH";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    function transfer(address to, uint256 amount) external override returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        return true;
    }

    function approve(address spender, uint256 amount) external override returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) external override returns (bool) {
        allowance[from][msg.sender] -= amount;
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        return true;
    }

    function mint(address to, uint256 amount) external override {
        balanceOf[to] += amount;
        totalSupply += amount;
    }

    function burn(uint256 amount) external override {
        balanceOf[msg.sender] -= amount;
        totalSupply -= amount;
    }
}

contract MockLRTOracle is ILRTOracle {
    mapping(address => uint256) public assetPrices;
    uint256 public rsETHPrice;
    LRTDepositPool public depositPool;

    constructor(LRTDepositPool _depositPool) {
        depositPool = _depositPool;
    }

    function setAssetPrice(address asset, uint256 price) external {
        assetPrices[asset] = price;
    }

    function getAssetPrice(address asset) external view override returns (uint256) {
        return assetPrices[asset];
    }

    function getRSETHPrice() external view override returns (uint256) {
        // Calculate rsETH price based on total assets / rsETH supply
        // This simulates the actual oracle behavior
        address rseth = depositPool.lrtConfig().rsETH();
        uint256 rsETHSupply = IRSETH(rseth).totalSupply();
        
        if (rsETHSupply == 0) return 1e18;
        
        // Get total ETH value locked (simplified - using just one asset for demo)
        address asset = address(0x123); // Mock asset address
        uint256 totalAssets = depositPool.getTotalAssetDeposits(asset);
        uint256 assetPrice = assetPrices[asset];
        
        return (totalAssets * assetPrice) / rsETHSupply;
    }
}

contract MockLRTConfig is ILRTConfig {
    address public rsETHAddress;
    mapping(address => uint256) public depositLimitByAsset;
    mapping(string => address) public contracts;

    function setRsETH(address _rsETH) external {
        rsETHAddress = _rsETH;
    }

    function rsETH() external view override returns (address) {
        return rsETHAddress;
    }

    function setDepositLimit(address asset, uint256 limit) external {
        depositLimitByAsset[asset] = limit;
    }

    function setContract(string memory name, address addr) external {
        contracts[name] = addr;
    }

    function getContract(string memory name) external view override returns (address) {
        return contracts[name];
    }
}

contract MockNodeDelegator is INodeDelegator {
    mapping(address => uint256) public assetBalances;

    function getAssetBalance(address asset) external view override returns (uint256) {
        return assetBalances[asset];
    }

    function setAssetBalance(address asset, uint256 amount) external {
        assetBalances[asset] = amount;
    }
}

contract ExploitTest is Test {
    LRTDepositPool public depositPool;
    MockERC20 public asset;
    MockRSETH public rsETH;
    MockLRTOracle public oracle;
    MockLRTConfig public config;
    MockNodeDelegator public nodeDelegator;

    address public admin = address(0x1);
    address public manager = address(0x2);
    address public user = address(0x3);

    function setUp() public {
        // Deploy mock contracts
        asset = new MockERC20("Mock Asset", "MA", 18);
        rsETH = new MockRSETH();
        config = new MockLRTConfig();
        nodeDelegator = new MockNodeDelegator();

        // Deploy deposit pool
        vm.prank(admin);
        depositPool = new LRTDepositPool();
        
        // Initialize deposit pool
        vm.prank(admin);
        depositPool.initialize(address(config));

        // Deploy oracle after deposit pool is deployed
        oracle = new MockLRTOracle(depositPool);

        // Setup config
        config.setRsETH(address(rsETH));
        config.setContract(LRTConstants.LRT_ORACLE, address(oracle));
        config.setDepositLimit(address(asset), 1000e18);

        // Setup roles
        vm.prank(admin);
        config.setContract(LRTConstants.LRT_ADMIN, admin);
        vm.prank(admin);
        config.setContract(LRTConstants.LRT_MANAGER, manager);

        // Add node delegator to queue
        address[] memory ndcs = new address[](1);
        ndcs[0] = address(nodeDelegator);
        vm.prank(admin);
        depositPool.addNodeDelegatorContractToQueue(ndcs);

        // Set initial prices
        oracle.setAssetPrice(address(asset), 1e18); // 1:1 price

        // Mint initial assets to user
        asset.mint(user, 100e18);
        
        // Give user approval
        vm.prank(user);
        asset.approve(address(depositPool), 100e18);
    }

    function testDepositAssetVulnerability() public {
        // Setup initial state: 10 ETH worth of assets already in protocol
        asset.mint(address(depositPool), 10e18);
        
        // Mint initial rsETH to simulate existing supply
        rsETH.mint(address(0xdead), 10e18);
        
        // User deposits 30 ETH worth of assets
        uint256 depositAmount = 30e18;
        
        // Calculate expected rsETH amount (what user SHOULD get)
        // Formula: amount * assetPrice / rsETHPrice
        // Initial state: totalAssets = 10e18, rsETHSupply = 10e18, so rsETHPrice = 1e18
        // User expects: 30e18 * 1e18 / 1e18 = 30e18 rsETH
        uint256 expectedRsETH = depositAmount;
        
        // Perform deposit
        vm.prank(user);
        depositPool.depositAsset(address(asset), depositAmount);
        
        // Check actual rsETH received
        uint256 actualRsETH = rsETH.balanceOf(user);
        
        console.log("Expected rsETH:", expectedRsETH);
        console.log("Actual rsETH received:", actualRsETH);
        console.log("Loss:", expectedRsETH - actualRsETH);
        
        // The vulnerability: user receives less rsETH than expected
        // Actual calculation: 30e18 * 1e18 / ((10e18 + 30e18) / 10e18) = 7.5e18
        assertEq(actualRsETH, 7.5e18, "User received incorrect amount due to vulnerability");
        
        // Verify the loss
        assertTrue(actualRsETH < expectedRsETH, "User received less rsETH than expected");
        assertEq(expectedRsETH - actualRsETH, 22.5e18, "Unexpected loss amount");
    }

    function testCorrectCalculationOrder() public {
        // This test shows what SHOULD happen if calculation was done before transfer
        
        // Setup initial state
        asset.mint(address(depositPool), 10e18);
        rsETH.mint(address(0xdead), 10e18);
        
        uint256 depositAmount = 30e18;
        
        // Calculate rsETH amount BEFORE transfer (correct way)
        uint256 rsETHPriceBefore = oracle.getRSETHPrice();
        uint256 expectedRsETH = (depositAmount * oracle.getAssetPrice(address(asset))) / rsETHPriceBefore;
        
        console.log("rsETH price before deposit:", rsETHPriceBefore);
        console.log("Expected rsETH (correct calculation):", expectedRsETH);
        
        // Now perform the actual deposit (vulnerable way)
        vm.prank(user);
        depositPool.depositAsset(address(asset), depositAmount);
        
        uint256 actualRsETH = rsETH.balanceOf(user);
        
        // The actual should be less than expected due to the vulnerability
        assertTrue(actualRsETH < expectedRsETH, "Vulnerability causes user to receive less rsETH");
    }

    function testShowPriceManipulation() public {
        // Setup initial state
        asset.mint(address(depositPool), 10e18);
        rsETH.mint(address(0xdead), 10e18);
        
        uint256 depositAmount = 30e18;
        
        // Check rsETH price before deposit
        uint256 priceBefore = oracle.getRSETHPrice();
        console.log("rsETH price before deposit:", priceBefore);
        
        // Perform deposit
        vm.prank(user);
        depositPool.depositAsset(address(asset), depositAmount);
        
        // Check rsETH price after deposit
        uint256 priceAfter = oracle.getRSETHPrice();
        console.log("rsETH price after deposit:", priceAfter);
        
        // Price should have increased due to the deposit being included in calculation
        assertTrue(priceAfter > priceBefore, "Price increased due to premature asset transfer");
        
        // This price increase causes users to receive less rsETH
        uint256 actualRsETH = rsETH.balanceOf(user);
        uint256 expectedWithoutManipulation = depositAmount; // What they should get at 1:1
        
        console.log("User should receive:", expectedWithoutManipulation);
        console.log("User actually received:", actualRsETH);
        
        assertTrue(actualRsETH < expectedWithoutManipulation, "User loses due to price manipulation");
    }
}