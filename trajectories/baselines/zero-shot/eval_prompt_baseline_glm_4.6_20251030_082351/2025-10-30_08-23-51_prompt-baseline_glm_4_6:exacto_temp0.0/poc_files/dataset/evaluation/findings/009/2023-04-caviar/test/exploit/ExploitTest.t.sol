// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import {Test, console} from "forge-std/Test.sol";
import {ERC20} from "solmate/tokens/ERC20.sol";
import {ERC721} from "solmate/tokens/ERC721.sol";
import {PrivatePool} from "../../src/PrivatePool.sol";
import {Factory} from "../../src/Factory.sol";
import {IERC2981} from "openzeppelin/interfaces/IERC2981.sol";
import {IRoyaltyRegistry} from "royalty-registry-solidity/IRoyaltyRegistry.sol";
import {IStolenNftOracle} from "../../src/interfaces/IStolenNftOracle.sol";

// Mock NFT contract that returns non-zero royalty fee but zero address as recipient
contract MockNFTWithZeroRecipient is ERC721, IERC2981 {
    uint256 public tokenId;
    uint256 public royaltyFee;
    
    constructor() ERC721("Mock NFT", "MNFT") {
        tokenId = 1;
        _mint(msg.sender, tokenId);
        royaltyFee = 10 ether; // 10 ETH royalty fee
    }
    
    function royaltyInfo(uint256, uint256) external view override returns (address, uint256) {
        // Return zero address as recipient but non-zero royalty fee
        return (address(0), royaltyFee);
    }
    
    function supportsInterface(bytes4 interfaceId) public view override(ERC721, IERC2981) returns (bool) {
        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);
    }
}

// Mock Factory contract
contract MockFactory {
    address public owner;
    uint256 public protocolFeeRate = 0; // 0% protocol fee for simplicity
    
    constructor() {
        owner = msg.sender;
    }
    
    function ownerOf(uint256) external view returns (address) {
        return owner;
    }
    
    function protocolFeeRate() external view returns (uint256) {
        return protocolFeeRate;
    }
}

// Mock Royalty Registry
contract MockRoyaltyRegistry is IRoyaltyRegistry {
    mapping(address => address) public royaltyLookup;
    
    function setRoyaltyLookup(address nft, address lookup) external {
        royaltyLookup[nft] = lookup;
    }
    
    function getRoyaltyLookupAddress(address nft) external view override returns (address) {
        return royaltyLookup[nft];
    }
}

// Mock Stolen NFT Oracle
contract MockStolenNftOracle is IStolenNftOracle {
    function validateTokensAreNotStolen(
        address,
        uint256[] calldata,
        Message[] calldata
    ) external pure override {
        // Always pass validation
    }
}

contract ExploitTest is Test {
    PrivatePool privatePool;
    MockNFTWithZeroRecipient nft;
    MockFactory factory;
    MockRoyaltyRegistry royaltyRegistry;
    MockStolenNftOracle stolenNftOracle;
    ERC20 baseToken;
    
    address owner = address(0x1);
    address trader = address(0x2);
    
    event Buy(uint256[] tokenIds, uint256[] tokenWeights, uint256 inputAmount, uint256 feeAmount, uint256 protocolFeeAmount, uint256 royaltyFeeAmount);
    
    function setUp() public {
        // Deploy mock contracts
        factory = new MockFactory();
        royaltyRegistry = new MockRoyaltyRegistry();
        stolenNftOracle = new MockStolenNftOracle();
        nft = new MockNFTWithZeroRecipient();
        
        // Deploy base token (WETH-like)
        baseToken = new ERC20("Base Token", "BASE");
        baseToken.mint(trader, 1000 ether);
        
        // Deploy PrivatePool
        privatePool = new PrivatePool(address(factory), address(royaltyRegistry), address(stolenNftOracle));
        
        // Set up royalty registry to point to the NFT itself
        royaltyRegistry.setRoyaltyLookup(address(nft), address(nft));
        
        // Initialize the pool with ETH as base token and payRoyalties = true
        vm.prank(owner);
        privatePool.initialize(
            address(0), // ETH as base token
            address(nft),
            100 ether, // virtualBaseTokenReserves
            10 ether,  // virtualNftReserves
            0,         // changeFee
            0,         // feeRate (0% for simplicity)
            bytes32(0), // merkleRoot (no weights)
            false,     // useStolenNftOracle
            true       // payRoyalties - THIS IS KEY FOR THE VULNERABILITY
        );
        
        // Transfer NFT to the pool
        vm.prank(owner);
        nft.safeTransferFrom(owner, address(privatePool), 1);
        
        // Fund the pool with ETH
        vm.deal(address(privatePool), 100 ether);
        
        // Approve base token for trader
        vm.prank(trader);
        baseToken.approve(address(privatePool), type(uint256).max);
    }
    
    function testRoyaltyFeeCollectedButNotDistributed() public {
        // Record initial balances
        uint256 initialTraderBalance = trader.balance;
        uint256 initialPoolBalance = address(privatePool).balance;
        
        // Prepare buy parameters
        uint256[] memory tokenIds = new uint256[](1);
        tokenIds[0] = 1;
        uint256[] memory tokenWeights = new uint256[](1);
        tokenWeights[0] = 1 ether;
        PrivatePool.MerkleMultiProof memory proof;
        
        // Calculate expected buy amount
        (uint256 netInputAmount,,) = privatePool.buyQuote(1 ether);
        
        // The royalty fee should be 10 ETH (as set in MockNFTWithZeroRecipient)
        uint256 expectedRoyaltyFee = 10 ether;
        
        // Trader buys the NFT, paying extra for royalty
        vm.deal(trader, netInputAmount + expectedRoyaltyFee + 1 ether);
        
        // Expect the Buy event to be emitted with royaltyFeeAmount
        vm.expectEmit(true, true, true, true);
        emit Buy(tokenIds, tokenWeights, netInputAmount + expectedRoyaltyFee, 0, 0, expectedRoyaltyFee);
        
        vm.prank(trader);
        privatePool.buy{value: netInputAmount + expectedRoyaltyFee}(tokenIds, tokenWeights, proof);
        
        // Verify the trader paid the royalty fee
        uint256 finalTraderBalance = trader.balance;
        uint256 expectedTraderBalance = initialTraderBalance - (netInputAmount + expectedRoyaltyFee);
        assertEq(finalTraderBalance, expectedTraderBalance, "Trader should have paid royalty fee");
        
        // Verify the pool received the royalty fee
        uint256 finalPoolBalance = address(privatePool).balance;
        assertEq(finalPoolBalance, initialPoolBalance + netInputAmount + expectedRoyaltyFee, "Pool should have received royalty fee");
        
        // THE VULNERABILITY: The royalty fee was collected but never distributed
        // Since the recipient address is 0x00, the royalty stays in the pool
        // and is effectively lost to the trader
        
        // Verify NFT was transferred to trader
        assertEq(nft.ownerOf(1), trader, "NFT should be transferred to trader");
        
        // The 10 ETH royalty fee is now stuck in the pool contract
        // It was collected from the trader but never distributed to anyone
        // because the recipient address was 0x00
    }
    
    function testRoyaltyFeeCollectedButNotDistributed_Sell() public {
        // First, transfer NFT to trader for sell test
        vm.prank(owner);
        nft.safeTransferFrom(address(privatePool), trader, 1);
        
        // Record initial balances
        uint256 initialTraderBalance = trader.balance;
        uint256 initialPoolBalance = address(privatePool).balance;
        
        // Prepare sell parameters
        uint256[] memory tokenIds = new uint256[](1);
        tokenIds[0] = 1;
        uint256[] memory tokenWeights = new uint256[](1);
        tokenWeights[0] = 1 ether;
        PrivatePool.MerkleMultiProof memory proof;
        IStolenNftOracle.Message[] memory stolenNftProofs;
        
        // Calculate expected sell amount
        (uint256 netOutputAmount,,) = privatePool.sellQuote(1 ether);
        
        // The royalty fee should be 10 ETH (as set in MockNFTWithZeroRecipient)
        uint256 expectedRoyaltyFee = 10 ether;
        
        // Trader sells the NFT
        vm.prank(trader);
        nft.approve(address(privatePool), 1);
        
        vm.prank(trader);
        (uint256 actualNetOutputAmount,,) = privatePool.sell(tokenIds, tokenWeights, proof, stolenNftProofs);
        
        // Verify the trader received less due to royalty fee
        uint256 finalTraderBalance = trader.balance;
        uint256 expectedTraderBalance = initialTraderBalance + (netOutputAmount - expectedRoyaltyFee);
        assertEq(finalTraderBalance, expectedTraderBalance, "Trader should receive less due to royalty fee");
        
        // Verify the pool kept the royalty fee
        uint256 finalPoolBalance = address(privatePool).balance;
        assertEq(finalPoolBalance, initialPoolBalance - netOutputAmount + expectedRoyaltyFee, "Pool should keep royalty fee");
        
        // THE VULNERABILITY: The royalty fee was deducted from trader's payout
        // but never distributed to anyone because recipient address is 0x00
        
        // Verify NFT was transferred to pool
        assertEq(nft.ownerOf(1), address(privatePool), "NFT should be transferred to pool");
        
        // The 10 ETH royalty fee is now stuck in the pool contract
        // It was deducted from the trader's payout but never distributed
    }
}