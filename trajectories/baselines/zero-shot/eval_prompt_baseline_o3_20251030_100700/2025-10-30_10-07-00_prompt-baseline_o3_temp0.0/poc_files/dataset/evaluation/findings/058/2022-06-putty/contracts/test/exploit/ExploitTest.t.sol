pragma solidity 0.8.13;

import "forge-std/Test.sol";
import "../../src/PuttyV2.sol";
import "solmate/tokens/ERC20.sol";

/*//////////////////////////////////////////////////////////////
                          TEST UTILITIES
//////////////////////////////////////////////////////////////*/

/// @notice Minimal WETH implementation matching the IWETH interface
contract MockWETH is ERC20("Wrapped Ether", "WETH", 18) {
    event Deposit(address indexed sender, uint256 amount);
    event Withdrawal(address indexed sender, uint256 amount);

    constructor() {}

    function deposit() public payable {
        _mint(msg.sender, msg.value);
        emit Deposit(msg.sender, msg.value);
    }

    function withdraw(uint256 amount) public {
        _burn(msg.sender, amount);
        payable(msg.sender).transfer(amount);
        emit Withdrawal(msg.sender, amount);
    }

    receive() external payable {
        deposit();
    }
}

/// @notice ERC20 with open mint for convenient testing
contract MockERC20 is ERC20 {
    constructor(string memory name_, string memory symbol_, uint8 dec_)
        ERC20(name_, symbol_, dec_)
    {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

/*//////////////////////////////////////////////////////////////
                          EXPLOIT TEST
//////////////////////////////////////////////////////////////*/

contract PuttyV2EtherLockTest is Test {
    PuttyV2        putty;     // Contract under test
    MockERC20      token;     // Arbitrary ERC20 used as baseAsset
    MockWETH       weth;      // WETH placeholder passed to constructor

    uint256 makerPk;          // Private key controlling the order.maker
    address maker;            // Address of the order.maker (signer)
    address taker;            // Address filling the order – this test contract

    /*//////////////////////////////////////////////////////////////
                               SET-UP
    //////////////////////////////////////////////////////////////*/

    function setUp() public {
        /* Deploy helper contracts */
        token = new MockERC20("Mock Token", "MCK", 18);
        weth  = new MockWETH();

        /* Deploy PuttyV2 – test contract is the owner */
        putty = new PuttyV2("https://base.uri/", 0, address(weth));

        /* Prepare maker keypair and balances */
        makerPk = uint256(0xA11CE);               // deterministic test key
        maker   = vm.addr(makerPk);
        taker   = address(this);                  // the test contract itself

        token.mint(maker, 1_000e18);              // fund maker with ERC20
        vm.startPrank(maker);
        token.approve(address(putty), type(uint256).max); // allow PuttyV2 to pull premium
        vm.stopPrank();

        /* Give the taker plenty of ETH to purposely burn */
        vm.deal(taker, 10 ether);
    }

    /*//////////////////////////////////////////////////////////////
                           EXPLOIT SCENARIO
    //////////////////////////////////////////////////////////////*/

    /// @notice Demonstrates that arbitrary ETH sent to fillOrder()
    ///         on the `isLong == true` branch is silently accepted
    ///         and becomes permanently locked inside the contract.
    function test_EtherGetsLockedIn_fillOrder_longPath() public {
        /*--------------------------------------------------------
        STEP 1: Construct an order whose code path ignores msg.value
        ----------------------------------------------------------*/
        PuttyV2.ERC20Asset[]  memory erc20Assets  = new PuttyV2.ERC20Asset[](0);
        PuttyV2.ERC721Asset[] memory erc721Assets = new PuttyV2.ERC721Asset[](0);
        address[] memory emptyAddresses = new address[](0);

        PuttyV2.Order memory order;
        order.maker        = maker;
        order.isCall       = false;               // *put* so strike transfer branch executes
        order.isLong       = true;                // enters vulnerable branch (prem. from maker)
        order.baseAsset    = address(token);      // NOT equal to WETH -> msg.value unused
        order.strike       = 0;                   // arbitrary
        order.premium      = 10e18;               // premium paid in ERC20
        order.duration     = 1 days;
        order.expiration   = block.timestamp + 1 days;
        order.nonce        = 1;
        order.whitelist    = emptyAddresses;
        order.floorTokens  = emptyAddresses;
        order.erc20Assets  = erc20Assets;
        order.erc721Assets = erc721Assets;

        /*--------------------------------------------------------
        STEP 2: Off-chain signing (simulated with vm.sign)
        ----------------------------------------------------------*/
        bytes32 orderHash = putty.hashOrder(order);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(makerPk, orderHash);
        bytes memory signature = abi.encodePacked(r, s, v);

        /* Sanity check – contract ETH balance is zero */
        assertEq(address(putty).balance, 0, "pre-condition failed");

        /*--------------------------------------------------------
        STEP 3: Fill the order while *deliberately* sending 1 ether
        ----------------------------------------------------------*/
        uint256 valueSent = 1 ether;              // ETH that will be stranded
        putty.fillOrder{value: valueSent}(order, signature, new uint256[](0));

        /*--------------------------------------------------------
        STEP 4: Assert that ETH is now trapped in the contract
        ----------------------------------------------------------*/
        assertEq(address(putty).balance, valueSent, "ether not locked");
        assertEq(address(this).balance, 10 ether - valueSent, "taker balance mismatch");

        /*--------------------------------------------------------
        STEP 5: Show that even privileged calls cannot retrieve ETH
        ----------------------------------------------------------*/
        uint256 before = address(putty).balance;

        // owner-only function (test contract is owner) — does NOT touch ETH
        putty.setFee(1);

        assertEq(address(putty).balance, before, "ETH unexpectedly moved");

        /*========================================================
        RESULT: 1 ether is stuck forever – PoC proven successful
        ========================================================*/
    }
}