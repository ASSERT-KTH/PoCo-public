// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "../shared/Fixture.t.sol";

/*
    PoC for Code4rena 2022-06-putty finding 058
    -------------------------------------------
    Vulnerability
    -------------
    `fillOrder()` and `exercise()` are marked **payable** because some
    execution branches legitimately need native ETH (when WETH is the
    `baseAsset`).  Unfortunately *all* branches are payable and the code
    never validates that `msg.value` is zero when ETH is **not** required.

    When the order's `baseAsset` is *any token other than WETH* the ETH sent
    by the caller is simply ignored â€“ it is **not** refunded and there is no
    method that allows it to be withdrawn later.  The ether becomes trapped
    inside the PuttyV2 contract forever, resulting in a permanent loss for
    the sender.

    This test demonstrates the bug through the `fillOrder()` code-path.
*/
contract ExploitTest is Fixture {
    function testExploit_lockEtherDuringFillOrder() public {
        /* ------------------------------------------------- */
        /*                     Arrange                       */
        /* ------------------------------------------------- */

        // 1. Create a short CALL order whose baseAsset is **LINK** (not WETH).
        PuttyV2.Order memory order = defaultOrder();
        order.baseAsset = address(link);  // any ERC-20 that is *not* WETH
        order.premium   = 1 ether;        // arbitrary premium amount

        // Babe signs the order off-chain
        bytes memory sig = signOrder(babePrivateKey, order);

        // Bob (taker) preparations
        uint256 ethToLock = 5 ether;      // ETH that will be sent and trapped
        link.mint(bob, order.premium);    // fund Bob with LINK to pay premium

        vm.startPrank(bob);
        link.approve(address(p), order.premium);
        vm.deal(bob, ethToLock);          // give Bob ETH to perform the exploit
        vm.stopPrank();

        // Baseline contract ETH balance before the attack
        uint256 contractEthBefore = address(p).balance;

        /* ------------------------------------------------- */
        /*                       Act                         */
        /* ------------------------------------------------- */
        // Bob fills the order *and* sends unnecessary ETH along with the call.
        vm.prank(bob);
        p.fillOrder{value: ethToLock}(order, sig, new uint256[](0));

        /* ------------------------------------------------- */
        /*                    Assert                         */
        /* ------------------------------------------------- */
        // 1. ETH has been added to the contract balance and is now stuck.
        assertEq(
            address(p).balance,
            contractEthBefore + ethToLock,
            "ETH should be trapped inside PuttyV2"
        );

        // 2. Order executed successfully (sanity check)
        bytes32 oppositeOrderHash = p.hashOppositeOrder(order);
        assertEq(p.ownerOf(uint256(oppositeOrderHash)), bob, "Bob should own the new position NFT");
        assertEq(link.balanceOf(babe), order.premium, "Babe should receive the premium");
    }
}