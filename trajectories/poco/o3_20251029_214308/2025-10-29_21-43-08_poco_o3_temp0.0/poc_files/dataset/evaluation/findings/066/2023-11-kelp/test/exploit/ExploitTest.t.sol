// SPDX-License-Identifier: MIT
pragma solidity 0.8.21;

import "forge-std/Test.sol";
import {LRTDepositPool} from "src/LRTDepositPool.sol";
import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
import {ILRTOracle} from "src/interfaces/ILRTOracle.sol";
import {ILRTConfig} from "src/interfaces/ILRTConfig.sol";
import {IRSETH} from "src/interfaces/IRSETH.sol";
import {LRTConstants} from "src/utils/LRTConstants.sol";

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/// -----------------------------------------------------------------------------
///                                Mock Tokens
/// -----------------------------------------------------------------------------

/// @notice Simple ERC20 token that allows anyone to mint for testing
contract MockERC20 is ERC20 {
    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

/// @notice rsETH mock implementing IRSETH on top of ERC20 with open mint/burn
contract MockRSETH is ERC20, IRSETH {
    constructor() ERC20("rsETH", "rsETH") {}

    function mint(address account, uint256 amount) public override {
        _mint(account, amount);
    }

    function burn(address account, uint256 amount) external override {
        _burn(account, amount);
    }
}

/// -----------------------------------------------------------------------------
///                               Mock Oracle
/// -----------------------------------------------------------------------------

/// @notice Oracle that computes rsETH price as total locked asset / rsETH supply
/// This replicates the logic described in the vulnerability annotation.
contract OracleMock is ILRTOracle {
    address public immutable assetToken;
    LRTDepositPool public immutable depositPool;
    IRSETH public immutable rsEth;

    constructor(address _asset, LRTDepositPool _pool, IRSETH _rsEth) {
        assetToken = _asset;
        depositPool = _pool;
        rsEth = _rsEth;
    }

    // Always returns 1e18 for the asset price (pegged 1-to-1 with ETH).
    function getAssetPrice(address) external pure override returns (uint256) {
        return 1e18;
    }

    // Not used in the PoC but included to satisfy the interface.
    function assetPriceOracle(address) external view override returns (address) {
        return address(this);
    }

    // rsETH price = totalLockedAsset / rsETHSupply  (scaled by 1e18)
    function getRSETHPrice() external view override returns (uint256) {
        uint256 totalLocked = IERC20(assetToken).balanceOf(address(depositPool));
        uint256 supply = rsEth.totalSupply();
        require(supply > 0, "ZERO_SUPPLY");
        return (totalLocked * 1e18) / supply;
    }
}

/// -----------------------------------------------------------------------------
///                          Minimal LRTConfig Mock
/// -----------------------------------------------------------------------------

contract LRTConfigMock is ILRTConfig {
    address public override rsETH;

    mapping(address => bool) private _supported;
    mapping(address => uint256) private _limits;
    mapping(bytes32 => address) private _contracts;

    /* --------------------------- admin functions --------------------------- */

    function setRsEth(address _rsEth) external {
        rsETH = _rsEth;
    }

    function addSupportedAsset(address asset, uint256 limit) external {
        _supported[asset] = true;
        _limits[asset] = limit;
    }

    function setContract(bytes32 key, address addr) external {
        _contracts[key] = addr;
    }

    /* ---------------------------- view helpers ---------------------------- */

    function assetStrategy(address) external pure override returns (address) {
        return address(0);
    }

    function isSupportedAsset(address asset) external view override returns (bool) {
        return _supported[asset];
    }

    function getLSTToken(bytes32) external pure override returns (address) {
        return address(0);
    }

    function getContract(bytes32 key) external view override returns (address) {
        return _contracts[key];
    }

    function getSupportedAssetList() external pure override returns (address[] memory) {
        address[] memory list = new address[](0);
        return list;
    }

    function depositLimitByAsset(address asset) external view override returns (uint256) {
        return _limits[asset];
    }

    /* ----------------------------- unused ----------------------------- */

    // OpenZeppelin's AccessControl is *not* required for this PoC.
}

/// -----------------------------------------------------------------------------
///                                 PoC Test
/// -----------------------------------------------------------------------------

contract ExploitTest is Test {
    LRTDepositPool public pool;
    LRTConfigMock public config;

    MockERC20 public asset; // LST token the user deposits (pegged to ETH)
    MockRSETH public rsEth; // Receipt token minted by protocol
    OracleMock public oracle;

    address public attacker = address(1);

    function setUp() public {
        /* ----------------------- deploy core contracts ---------------------- */
        // Deploy upgradeable pool via proxy so we can call initialize()
        LRTDepositPool poolImpl = new LRTDepositPool();
        config = new LRTConfigMock();

        bytes memory initData = abi.encodeWithSelector(LRTDepositPool.initialize.selector, address(config));
        ERC1967Proxy proxy = new ERC1967Proxy(address(poolImpl), initData);
        pool = LRTDepositPool(address(proxy));

        // Now pool is initialized
        rsEth = new MockRSETH();
        asset = new MockERC20("Mock Staked ETH", "mETH");

        // Link config to other contracts
        config.setRsEth(address(rsEth));
        config.addSupportedAsset(address(asset), 1_000 ether);

        // Deploy oracle that references the pool (needs pool address)
        oracle = new OracleMock(address(asset), pool, rsEth);
        config.setContract(LRTConstants.LRT_ORACLE, address(oracle));

        /* ----------------------- prepare initial state ---------------------- */
        // 1) Protocol starts with 10 ETH worth of the asset already locked.
        asset.mint(address(pool), 10 ether);

        // 2) There is an existing rsETH supply of 10 tokens.
        rsEth.mint(address(0xdead), 10 ether);

        // 3) Fund attacker with 30 asset tokens and approve the pool.
        asset.mint(attacker, 30 ether);
        vm.prank(attacker);
        asset.approve(address(pool), 30 ether);
    }

    /// @notice Demonstrates that the attacker receives far fewer rsETH tokens
    /// than expected due to TVL being updated *before* price calculation.
    function testDepositMintsInsufficientrsETH() public {
        uint256 depositAmount = 30 ether;

        // Expected amount *if* price were calculated using the PRE-deposit TVL:
        // Price before deposit = 10/10 = 1 => should mint 30 rsETH.
        uint256 expectedFairMint = depositAmount; // 30 ether

        // Compute on-chain balances before deposit.
        uint256 attackerPre = rsEth.balanceOf(attacker);

        /* ----------------------------- exploit ----------------------------- */
        vm.prank(attacker);
        pool.depositAsset(address(asset), depositAmount);

        /* -------------------------- post conditions ------------------------- */
        uint256 attackerPost = rsEth.balanceOf(attacker);
        uint256 minted = attackerPost - attackerPre;

        // Due to the bug TVL is now 40, price = 4 -> minted = 7.5
        uint256 expectedBuggyMint = 7.5 ether;

        assertEq(minted, expectedBuggyMint, "Mint amount matches buggy calculation");
        assertLt(minted, expectedFairMint, "User receives less than fair amount");
    }
}
