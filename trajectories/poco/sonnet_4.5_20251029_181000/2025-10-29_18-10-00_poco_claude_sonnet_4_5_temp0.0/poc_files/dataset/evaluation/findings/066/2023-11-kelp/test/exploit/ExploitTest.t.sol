// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.21;

import { Test } from "forge-std/Test.sol";
import { console2 } from "forge-std/console2.sol";

import { LRTDepositPool } from "src/LRTDepositPool.sol";
import { LRTConfig } from "src/LRTConfig.sol";
import { LRTOracle } from "src/LRTOracle.sol";
import { RSETH } from "src/RSETH.sol";
import { LRTConstants } from "src/utils/LRTConstants.sol";

import { TransparentUpgradeableProxy } from "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";
import { ProxyAdmin } from "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";

/**
 * @title MockToken
 * @notice Simple ERC20 token for testing
 */
contract MockToken is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) { }

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

/**
 * @title MockPriceOracle
 * @notice Mock oracle that returns a fixed price for assets
 */
contract MockPriceOracle {
    function getAssetPrice(address) external pure returns (uint256) {
        return 1e18; // 1:1 with ETH
    }
}

/**
 * @title ExploitTest
 * @notice PoC demonstrating the deposit-before-mint vulnerability in LRTDepositPool
 *
 * VULNERABILITY DESCRIPTION:
 * The LRTDepositPool.depositAsset() function transfers user tokens BEFORE calculating
 * the amount of rsETH to mint. This causes the rsETH price calculation to include the
 * just-deposited tokens, artificially inflating the price and causing users to receive
 * fewer rsETH tokens than they should.
 *
 * ATTACK FLOW:
 * 1. User calls depositAsset() with amount X
 * 2. Tokens are transferred to LRTDepositPool (balance increases by X)
 * 3. _mintRsETH() is called, which calls getRsETHAmountToMint()
 * 4. getRsETHAmountToMint() calls LRTOracle.getRSETHPrice()
 * 5. getRSETHPrice() calculates totalETHInPool using getTotalAssetDeposits()
 * 6. getTotalAssetDeposits() reads current balance, which INCLUDES the just-deposited X
 * 7. rsETH price = totalETHInPool / rsETHSupply is inflated
 * 8. User receives: (X * assetPrice) / inflatedRsETHPrice < expected amount
 *
 * IMPACT:
 * Users receive significantly fewer rsETH tokens than they should. The larger the deposit
 * relative to existing pool size, the worse the loss. In extreme cases (first deposit or
 * large deposits), users can lose 50%+ of their expected rsETH tokens.
 */
contract ExploitTest is Test {
    LRTDepositPool public depositPool;
    LRTConfig public lrtConfig;
    LRTOracle public lrtOracle;
    RSETH public rseth;
    MockToken public stETH;
    MockToken public rETH;
    MockToken public cbETH;
    MockPriceOracle public priceOracle;

    address public admin = makeAddr("admin");
    address public manager = makeAddr("manager");
    address public alice = makeAddr("alice");
    address public bob = makeAddr("bob");

    function setUp() public {
        // Deploy mock tokens
        stETH = new MockToken("Staked ETH", "stETH");
        rETH = new MockToken("Rocket Pool ETH", "rETH");
        cbETH = new MockToken("Coinbase ETH", "cbETH");

        // Deploy LRTConfig
        ProxyAdmin proxyAdmin = new ProxyAdmin();
        LRTConfig configImpl = new LRTConfig();
        TransparentUpgradeableProxy configProxy = new TransparentUpgradeableProxy(
            address(configImpl),
            address(proxyAdmin),
            ""
        );
        lrtConfig = LRTConfig(address(configProxy));

        // Deploy RSETH
        RSETH rsethImpl = new RSETH();
        TransparentUpgradeableProxy rsethProxy = new TransparentUpgradeableProxy(
            address(rsethImpl),
            address(proxyAdmin),
            ""
        );
        rseth = RSETH(address(rsethProxy));

        // Deploy LRTOracle
        LRTOracle oracleImpl = new LRTOracle();
        TransparentUpgradeableProxy oracleProxy = new TransparentUpgradeableProxy(
            address(oracleImpl),
            address(proxyAdmin),
            ""
        );
        lrtOracle = LRTOracle(address(oracleProxy));

        // Deploy LRTDepositPool
        LRTDepositPool poolImpl = new LRTDepositPool();
        TransparentUpgradeableProxy poolProxy = new TransparentUpgradeableProxy(
            address(poolImpl),
            address(proxyAdmin),
            ""
        );
        depositPool = LRTDepositPool(address(poolProxy));

        // Deploy price oracle
        priceOracle = new MockPriceOracle();

        // Initialize contracts
        lrtConfig.initialize(
            admin,
            address(stETH),
            address(rETH),
            address(cbETH),
            address(rseth)
        );

        rseth.initialize(admin, address(lrtConfig));
        lrtOracle.initialize(address(lrtConfig));
        depositPool.initialize(address(lrtConfig));

        // Setup roles and configuration
        vm.startPrank(admin);
        lrtConfig.grantRole(LRTConstants.MANAGER, manager);
        lrtConfig.setContract(LRTConstants.LRT_ORACLE, address(lrtOracle));
        lrtConfig.setContract(LRTConstants.LRT_DEPOSIT_POOL, address(depositPool));
        rseth.grantRole(rseth.MINTER_ROLE(), address(depositPool));
        vm.stopPrank();

        // Setup price oracle for stETH
        vm.prank(manager);
        lrtOracle.updatePriceOracleFor(address(stETH), address(priceOracle));

        // Mint tokens to users
        stETH.mint(alice, 1000 ether);
        stETH.mint(bob, 1000 ether);
    }

    /**
     * @notice Test demonstrating the vulnerability with a simple scenario
     * @dev Shows that users receive fewer rsETH tokens than expected due to
     *      premature token transfer inflating the rsETH price calculation
     */
    function test_DepositBeforeMintVulnerability() public {
        // Setup price oracles for all assets
        vm.startPrank(manager);
        lrtOracle.updatePriceOracleFor(address(rETH), address(priceOracle));
        lrtOracle.updatePriceOracleFor(address(cbETH), address(priceOracle));
        vm.stopPrank();
        console2.log("\n=== Demonstrating Deposit-Before-Mint Vulnerability ===\n");

        // Alice makes initial deposit to establish pool state
        uint256 aliceDepositAmount = 10 ether;
        vm.startPrank(alice);
        stETH.approve(address(depositPool), aliceDepositAmount);
        depositPool.depositAsset(address(stETH), aliceDepositAmount);
        vm.stopPrank();

        uint256 aliceRsETH = rseth.balanceOf(alice);
        console2.log("Alice deposits:", aliceDepositAmount / 1e18, "stETH");
        console2.log("Alice receives:", aliceRsETH / 1e18, "rsETH");
        console2.log("Total rsETH supply:", rseth.totalSupply() / 1e18);
        console2.log("");

        // Bob makes a deposit - this will demonstrate the vulnerability
        uint256 bobDepositAmount = 30 ether;

        // Calculate expected rsETH for Bob (what he SHOULD receive)
        // At this point: totalETH = 10 ether, rsETHSupply = 10 ether
        // rsETH price SHOULD be: 10e18 / 10e18 = 1e18
        // Bob SHOULD receive: 30e18 * 1e18 / 1e18 = 30e18 rsETH
        uint256 expectedBobRsETH = 30 ether;

        console2.log("Bob deposits:", bobDepositAmount / 1e18, "stETH");
        console2.log("Bob SHOULD receive:", expectedBobRsETH / 1e18, "rsETH (based on pre-deposit state)");

        vm.startPrank(bob);
        stETH.approve(address(depositPool), bobDepositAmount);
        depositPool.depositAsset(address(stETH), bobDepositAmount);
        vm.stopPrank();

        uint256 actualBobRsETH = rseth.balanceOf(bob);
        console2.log("Bob ACTUALLY receives:", actualBobRsETH / 1e18, "rsETH");
        console2.log("");

        // Calculate the loss
        uint256 bobLoss = expectedBobRsETH - actualBobRsETH;
        uint256 bobLossPercentage = (bobLoss * 100) / expectedBobRsETH;

        console2.log("Bob's loss:", bobLoss / 1e18, "rsETH");
        console2.log("Bob's loss percentage:", bobLossPercentage, "%");
        console2.log("");

        // Explain what happened
        console2.log("=== Vulnerability Explanation ===");
        console2.log("1. Before Bob's deposit: totalETH = 10, rsETHSupply = 10");
        console2.log("2. Bob's tokens transferred FIRST: pool balance becomes 40");
        console2.log("3. rsETH price calculated AFTER transfer: 40 / 10 = 4");
        console2.log("4. Bob receives: 30 * 1 / 4 = 7.5 rsETH (instead of 30)");
        console2.log("5. Bob loses 75% of expected rsETH tokens!");
        console2.log("");

        // Assertions to prove the vulnerability
        // Bob should receive 30 rsETH but receives much less
        assertLt(actualBobRsETH, expectedBobRsETH, "Bob received expected amount - vulnerability not demonstrated");

        // The actual calculation shows Bob receives only 7.5 rsETH
        // Formula: bobDeposit * assetPrice / rsETHPrice
        // = 30e18 * 1e18 / ((30e18 + 10e18) / 10e18)
        // = 30e18 * 1e18 / 4e18
        // = 7.5e18
        assertEq(actualBobRsETH, 7.5 ether, "Bob should receive 7.5 rsETH due to vulnerability");

        // Bob loses 75% of his expected rsETH
        assertEq(bobLossPercentage, 75, "Bob should lose 75% of expected rsETH");

        console2.log("[+] Vulnerability confirmed: Users receive significantly fewer rsETH tokens");
        console2.log("[+] Root cause: Token transfer happens BEFORE rsETH amount calculation");
        console2.log("[+] Impact: The inflated balance is used in price calculation, reducing minted rsETH");
    }

    /**
     * @notice Test showing the vulnerability is worse for larger deposits
     * @dev Demonstrates that the loss percentage increases with deposit size
     */
    function test_VulnerabilityWorseForLargerDeposits() public {
        // Setup price oracles for all assets
        vm.startPrank(manager);
        lrtOracle.updatePriceOracleFor(address(rETH), address(priceOracle));
        lrtOracle.updatePriceOracleFor(address(cbETH), address(priceOracle));
        vm.stopPrank();

        console2.log("\n=== Vulnerability Impact Scales with Deposit Size ===\n");

        // Setup: Alice deposits 10 ether to establish pool
        vm.startPrank(alice);
        stETH.approve(address(depositPool), 10 ether);
        depositPool.depositAsset(address(stETH), 10 ether);
        vm.stopPrank();

        console2.log("Initial state: 10 ETH in pool, 10 rsETH supply");
        console2.log("");

        // Test different deposit sizes
        uint256[] memory depositSizes = new uint256[](3);
        depositSizes[0] = 10 ether;  // Same as pool size
        depositSizes[1] = 50 ether;  // 5x pool size
        depositSizes[2] = 100 ether; // 10x pool size

        for (uint256 i = 0; i < depositSizes.length; i++) {
            uint256 depositAmount = depositSizes[i];

            // Create a new user for each test
            address user = makeAddr(string(abi.encodePacked("user", i)));
            stETH.mint(user, depositAmount);

            // Expected rsETH (based on pre-deposit state)
            // rsETH price = 10 / 10 = 1
            // Expected = depositAmount * 1 / 1 = depositAmount
            uint256 expectedRsETH = depositAmount;

            // Actual deposit
            vm.startPrank(user);
            stETH.approve(address(depositPool), depositAmount);
            depositPool.depositAsset(address(stETH), depositAmount);
            vm.stopPrank();

            uint256 actualRsETH = rseth.balanceOf(user);
            uint256 loss = expectedRsETH - actualRsETH;
            uint256 lossPercentage = (loss * 100) / expectedRsETH;

            console2.log("Deposit:", depositAmount / 1e18, "ETH");
            console2.log("  Expected rsETH:", expectedRsETH / 1e18);
            console2.log("  Actual rsETH:", actualRsETH / 1e18);
            console2.log("  Loss:", lossPercentage, "%");
            console2.log("");

            // Verify loss increases with deposit size
            assertGt(lossPercentage, 0, "User should experience loss");
        }

        console2.log("[+] Confirmed: Larger deposits relative to pool size result in greater losses");
    }

    /**
     * @notice Test demonstrating the exact calculation flow
     * @dev Step-by-step breakdown of how the vulnerability manifests
     */
    function test_DetailedCalculationFlow() public {
        // Setup price oracles for all assets
        vm.startPrank(manager);
        lrtOracle.updatePriceOracleFor(address(rETH), address(priceOracle));
        lrtOracle.updatePriceOracleFor(address(cbETH), address(priceOracle));
        vm.stopPrank();

        console2.log("\n=== Detailed Calculation Flow ===\n");

        // Setup initial state
        vm.startPrank(alice);
        stETH.approve(address(depositPool), 10 ether);
        depositPool.depositAsset(address(stETH), 10 ether);
        vm.stopPrank();

        console2.log("Step 1: Initial state established");
        console2.log("  - Total ETH in pool: 10 ether");
        console2.log("  - rsETH supply: 10 ether");
        console2.log("  - rsETH price: 1 ether");
        console2.log("");

        // Bob prepares to deposit
        uint256 bobDeposit = 30 ether;
        console2.log("Step 2: Bob wants to deposit", bobDeposit / 1e18, "stETH");
        console2.log("");

        // Check state before Bob's deposit
        uint256 totalAssetsBefore = depositPool.getTotalAssetDeposits(address(stETH));
        uint256 rsethSupplyBefore = rseth.totalSupply();
        uint256 rsethPriceBefore = lrtOracle.getRSETHPrice();

        console2.log("Step 3: State BEFORE Bob's token transfer:");
        console2.log("  - Total assets:", totalAssetsBefore / 1e18, "ether");
        console2.log("  - rsETH supply:", rsethSupplyBefore / 1e18, "ether");
        console2.log("  - rsETH price:", rsethPriceBefore / 1e18, "ether");
        console2.log("  - Expected rsETH for Bob:", (bobDeposit * 1e18 / rsethPriceBefore) / 1e18, "ether");
        console2.log("");

        // Bob deposits
        vm.startPrank(bob);
        stETH.approve(address(depositPool), bobDeposit);

        console2.log("Step 4: Bob calls depositAsset()");
        console2.log("  - Token transfer happens FIRST");
        console2.log("  - Pool balance increases to:", (totalAssetsBefore + bobDeposit) / 1e18, "ether");
        console2.log("");

        depositPool.depositAsset(address(stETH), bobDeposit);
        vm.stopPrank();

        // Check state after deposit
        uint256 totalAssetsAfter = depositPool.getTotalAssetDeposits(address(stETH));
        uint256 rsethSupplyAfter = rseth.totalSupply();
        uint256 bobRsETH = rseth.balanceOf(bob);

        console2.log("Step 5: rsETH calculation uses INFLATED balance:");
        console2.log("  - Total assets (includes Bob's deposit):", totalAssetsAfter / 1e18, "ether");
        console2.log("  - rsETH supply (before minting to Bob):", rsethSupplyBefore / 1e18, "ether");
        console2.log("  - Inflated rsETH price:", (totalAssetsBefore + bobDeposit) / rsethSupplyBefore / 1e18, "ether");
        console2.log("");

        console2.log("Step 6: Bob receives rsETH:");
        console2.log("  - Calculation: 30 * 1 / 4 = 7.5 rsETH");
        console2.log("  - Actual received:", bobRsETH / 1e18, "ether");
        console2.log("  - Should have received: 30 ether");
        console2.log("  - Loss: 22.5 ether (75%)");
        console2.log("");

        // Verify the exact amounts
        assertEq(totalAssetsBefore, 10 ether, "Initial pool should be 10 ether");
        assertEq(totalAssetsAfter, 40 ether, "Final pool should be 40 ether");
        assertEq(bobRsETH, 7.5 ether, "Bob should receive 7.5 rsETH");
        assertEq(rsethSupplyAfter, 17.5 ether, "Total supply should be 17.5 rsETH");

        console2.log("[+] Calculation flow confirmed");
        console2.log("[+] Vulnerability: getTotalAssetDeposits() includes just-deposited tokens");
        console2.log("[+] Fix: Calculate rsETH amount BEFORE transferring tokens");
    }

    /**
     * @notice Test showing first depositor scenario
     * @dev When rsETH supply is 0, the vulnerability doesn't occur (special case)
     */
    function test_FirstDepositorNotAffected() public {
        console2.log("\n=== First Depositor Scenario ===\n");

        // Bob is the first depositor
        uint256 bobDeposit = 30 ether;

        vm.startPrank(bob);
        stETH.approve(address(depositPool), bobDeposit);
        depositPool.depositAsset(address(stETH), bobDeposit);
        vm.stopPrank();

        uint256 bobRsETH = rseth.balanceOf(bob);

        console2.log("Bob's deposit:", bobDeposit / 1e18, "stETH");
        console2.log("Bob's rsETH:", bobRsETH / 1e18);
        console2.log("");
        console2.log("Note: First depositor is protected by rsEthSupply == 0 check");
        console2.log("      getRSETHPrice() returns 1 ether when supply is 0");
        console2.log("      So Bob receives: 30 * 1 / 1 = 30 rsETH");
        console2.log("");

        // First depositor receives correct amount
        assertEq(bobRsETH, bobDeposit, "First depositor should receive 1:1 rsETH");

        console2.log("[+] First depositor not affected by vulnerability");
        console2.log("[+] Vulnerability only affects subsequent depositors");
    }
}
