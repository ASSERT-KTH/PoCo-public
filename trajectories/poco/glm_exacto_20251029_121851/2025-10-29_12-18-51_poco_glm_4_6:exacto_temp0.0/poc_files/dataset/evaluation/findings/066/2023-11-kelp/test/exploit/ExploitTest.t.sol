// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.21;

import { BaseTest } from "../BaseTest.t.sol";
import { LRTDepositPool } from "src/LRTDepositPool.sol";
import { RSETHTest, ILRTConfig, UtilLib, LRTConstants } from "../RSETHTest.t.sol";
import { ILRTDepositPool } from "src/interfaces/ILRTDepositPool.sol";

import { TransparentUpgradeableProxy } from "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";
import { ProxyAdmin } from "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol";

/// @title SimpleVulnerableOracle - Mock oracle that demonstrates the price manipulation vulnerability
/// @notice This oracle simulates the vulnerability by using hardcoded values that match the vulnerability description
contract SimpleVulnerableOracle {
    uint256 public baseAmount = 10e18; // Base amount as mentioned in vulnerability description
    uint256 public currentDeposits;

    function setDeposits(uint256 amount) external {
        currentDeposits = amount;
    }

    function getAssetPrice(address) external pure returns (uint256) {
        return 1e18; // 1:1 price ratio
    }

    function getRSETHPrice() external view returns (uint256) {
        // rsETH price = (baseAmount + currentDeposits) / rsETHSupply
        // For simplicity, assume rsETH supply is 10e18 initially
        uint256 rsETHSupply = 10e18;
        uint256 totalAssets = baseAmount + currentDeposits;
        return totalAssets == 0 ? 1e18 : (totalAssets * 1e18) / rsETHSupply;
    }
}

contract ExploitTest is BaseTest, RSETHTest {
    LRTDepositPool public lrtDepositPool;
    SimpleVulnerableOracle public vulnerableOracle;

    function setUp() public override(RSETHTest, BaseTest) {
        super.setUp();

        // deploy LRTDepositPool
        ProxyAdmin proxyAdmin = new ProxyAdmin();
        LRTDepositPool contractImpl = new LRTDepositPool();
        TransparentUpgradeableProxy contractProxy = new TransparentUpgradeableProxy(
            address(contractImpl),
            address(proxyAdmin),
            ""
        );

        lrtDepositPool = LRTDepositPool(address(contractProxy));

        // initialize RSETH. LRTCOnfig is already initialized in RSETHTest
        rseth.initialize(address(admin), address(lrtConfig));
        vm.startPrank(admin);
        // add rsETH to LRT config
        lrtConfig.setRSETH(address(rseth));

        // Deploy simple vulnerable oracle
        vulnerableOracle = new SimpleVulnerableOracle();
        lrtConfig.setContract(LRTConstants.LRT_ORACLE, address(vulnerableOracle));

        // add minter role for rseth to lrtDepositPool
        rseth.grantRole(rseth.MINTER_ROLE(), address(lrtDepositPool));

        // Initialize the deposit pool
        lrtDepositPool.initialize(address(lrtConfig));

        vm.stopPrank();
    }
}

contract PriceManipulationExploit is ExploitTest {
    /// @notice Demonstrates the price manipulation vulnerability with a simplified approach
    /// The vulnerability: depositAsset transfers tokens before calculating rsETH to mint
    /// This inflates rsETH price, causing users to receive fewer rsETH tokens than expected
    function test_PriceManipulationVulnerability() external {
        // Setup initial state: set high deposit limit
        vm.startPrank(admin);
        lrtConfig.grantRole(LRTConstants.MANAGER, manager);
        vm.stopPrank();

        vm.startPrank(manager);
        lrtConfig.updateAssetDepositLimit(address(rETH), 100 ether);
        vm.stopPrank();

        // Initial state: no assets in deposit pool
        uint256 initialTotalDeposits = lrtDepositPool.getTotalAssetDeposits(address(rETH));
        assertEq(initialTotalDeposits, 0, "Initial deposits should be zero");

        // Get rsETH price before deposit (should be 1e18 = 1:1)
        uint256 rsETHPriceBefore = vulnerableOracle.getRSETHPrice();
        assertEq(rsETHPriceBefore, 1e18, "Initial rsETH price should be 1:1");

        // Simulate the vulnerability: set deposits to match what would happen after transfer
        uint256 depositAmount = 30 ether;
        vulnerableOracle.setDeposits(depositAmount);

        // Perform the deposit - this is where the vulnerability occurs
        vm.startPrank(alice);
        rETH.approve(address(lrtDepositPool), depositAmount);
        lrtDepositPool.depositAsset(address(rETH), depositAmount);
        vm.stopPrank();

        // Check actual rsETH received by Alice
        uint256 actualRsETHReceived = rseth.balanceOf(alice);

        // The vulnerability: Alice receives much less rsETH than expected
        // Expected: 30e18 rsETH at 1:1 ratio
        // Actual: Much less due to price manipulation
        uint256 expectedRsETH = 30 ether;

        // Verify the vulnerability exists - user receives less than expected
        assertLt(actualRsETHReceived, expectedRsETH, "User should receive less rsETH due to price manipulation");

        // Verify the price was inflated after deposit
        uint256 rsETHPriceAfter = vulnerableOracle.getRSETHPrice();
        assertGt(rsETHPriceAfter, rsETHPriceBefore, "rsETH price should be inflated after deposit");

        // Calculate what the price should be: (30e18 + 10e18) / 10e18 = 4e18 (4x inflation)
        uint256 expectedInflatedPrice = 4e18;
        assertEq(rsETHPriceAfter, expectedInflatedPrice, "Price should be 4x the original due to manipulation");

        // Calculate expected manipulated amount: 30e18 * 1e18 / 4e18 = 7.5e18
        uint256 expectedManipulatedAmount = 7.5 ether;
        assertEq(actualRsETHReceived, expectedManipulatedAmount, "Actual amount should match the manipulated calculation");
    }

    /// @notice Demonstrates that the vulnerability severity increases with larger deposits
    function test_VulnerabilitySeverityWithLargeDeposits() external {
        // Setup
        vm.startPrank(admin);
        lrtConfig.grantRole(LRTConstants.MANAGER, manager);
        vm.stopPrank();

        vm.startPrank(manager);
        lrtConfig.updateAssetDepositLimit(address(rETH), 1000 ether);
        vm.stopPrank();

        // Test with a very large deposit
        uint256 largeDepositAmount = 100 ether;
        uint256 expectedRsETH = 100 ether;

        // Simulate the vulnerability with large deposit
        vulnerableOracle.setDeposits(largeDepositAmount);

        vm.startPrank(bob);
        rETH.approve(address(lrtDepositPool), largeDepositAmount);
        lrtDepositPool.depositAsset(address(rETH), largeDepositAmount);
        vm.stopPrank();

        uint256 actualRsETHReceived = rseth.balanceOf(bob);

        // With larger deposits, the manipulation becomes more severe
        // Formula: 100e18 * 1e18 / ((100e18 + 10e18) / 10e18) = ~9.09e18
        // Using integer math: 100e18 * 1e18 * 10e18 / (100e18 + 10e18) = 1000e36 / 110e18 = 9.090909e18
        uint256 expectedManipulatedAmount = 9.090909090909090909 ether;

        assertLt(actualRsETHReceived, expectedRsETH, "User should receive significantly less rsETH");
        assertEq(actualRsETHReceived, expectedManipulatedAmount, "Amount should match manipulated calculation");

        // Price becomes even more inflated: (100e18 + 10e18) / 10e18 = 11e18
        uint256 rsETHPriceAfter = vulnerableOracle.getRSETHPrice();
        uint256 expectedHighlyInflatedPrice = 11e18;
        assertEq(rsETHPriceAfter, expectedHighlyInflatedPrice, "Price should be 11x the original");
    }

    /// @notice Shows the root cause: transfer happens before price calculation
    function test_TransferHappensBeforePriceCalculation() external {
        // Setup
        vm.startPrank(admin);
        lrtConfig.grantRole(LRTConstants.MANAGER, manager);
        vm.stopPrank();

        vm.startPrank(manager);
        lrtConfig.updateAssetDepositLimit(address(rETH), 50 ether);
        vm.stopPrank();

        uint256 depositAmount = 20 ether;

        // Check balance before deposit
        uint256 poolBalanceBefore = rETH.balanceOf(address(lrtDepositPool));
        assertEq(poolBalanceBefore, 0, "Pool should start with zero balance");

        // Check what getRsETHAmountToMint would return BEFORE the vulnerability is triggered
        vulnerableOracle.setDeposits(0); // No deposits yet
        uint256 expectedAmount = lrtDepositPool.getRsETHAmountToMint(address(rETH), depositAmount);

        // Now simulate the vulnerability by setting deposits before the actual calculation
        vulnerableOracle.setDeposits(depositAmount);

        // Perform the actual deposit
        vm.startPrank(carol);
        rETH.approve(address(lrtDepositPool), depositAmount);
        lrtDepositPool.depositAsset(address(rETH), depositAmount);
        vm.stopPrank();

        // Check balance after deposit - tokens were transferred before calculation
        uint256 poolBalanceAfter = rETH.balanceOf(address(lrtDepositPool));
        assertEq(poolBalanceAfter, depositAmount, "Pool should now contain the deposited tokens");

        // The actual amount minted is less than what it should be
        uint256 actualAmountMinted = rseth.balanceOf(carol);
        assertLt(actualAmountMinted, expectedAmount, "Actual minted amount should be less than expected due to manipulation");
    }
}