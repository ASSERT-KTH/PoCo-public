// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "forge-std/console.sol";

import "src/PuttyV2.sol";
import "../shared/Fixture.t.sol";

/**
 * @title ExploitTest
 * @notice Proof of Concept for ETH locking vulnerability in PuttyV2
 * @dev This test demonstrates how ETH can be permanently locked in the contract
 *      when sent to payable functions that take non-ETH code paths
 */
contract ExploitTest is Fixture {
    receive() external payable {}

    function setUp() public {
        // Setup token balances and approvals
        deal(address(weth), address(this), 0xffffffff);
        deal(address(weth), babe, 0xffffffff);

        weth.approve(address(p), type(uint256).max);

        vm.prank(babe);
        weth.approve(address(p), type(uint256).max);
    }

    /**
     * @notice Test ETH locking vulnerability in fillOrder() for long positions
     * @dev When filling a long order with WETH as base asset, the contract expects
     *      ERC20 transfer, not ETH. But since function is payable, ETH gets locked.
     */
    function testFillOrderLongPositionLocksETH() public {
        // Create a long order with WETH as base asset
        PuttyV2.Order memory order = defaultOrder();
        order.isLong = true;
        order.baseAsset = address(weth); // WETH as base asset
        order.premium = 1 ether; // 1 WETH premium

        // Mint WETH to maker for premium payment
        vm.startPrank(babe);
        deal(babe, order.premium);
        weth.deposit{value: order.premium}();
        vm.stopPrank();

        // Sign the order
        bytes memory signature = signOrder(babePrivateKey, order);

        // Record contract balance before exploit
        uint256 contractBalanceBefore = address(p).balance;
        uint256 attackerBalanceBefore = address(this).balance;

        // Send ETH along with the transaction - this ETH will be locked!
        uint256 ethToLock = 2 ether;
        deal(address(this), ethToLock);

        // Exploit: Call fillOrder with ETH even though it expects WETH transfer
        // The function will succeed but ETH will be locked forever
        p.fillOrder{value: ethToLock}(order, signature, new uint256[](0));

        // Verify the exploit worked
        uint256 contractBalanceAfter = address(p).balance;
        uint256 attackerBalanceAfter = address(this).balance;

        // ETH should be locked in contract (balance increased by ethToLock)
        assertEq(
            contractBalanceAfter - contractBalanceBefore,
            ethToLock,
            "ETH should be locked in contract"
        );

        // Attacker's ETH should be gone
        assertEq(
            attackerBalanceBefore - attackerBalanceAfter,
            ethToLock,
            "Attacker should lose ETH"
        );

        // The order should still be filled correctly
        bytes32 orderHash = p.hashOrder(order);
        address makerPositionOwner = p.ownerOf(uint256(orderHash));
        console.log("Maker position owner:", makerPositionOwner);
        console.log("Expected maker:", order.maker);
        assertEq(makerPositionOwner, order.maker, "Order should be filled");
    }

    /**
     * @notice Test ETH locking vulnerability in fillOrder() for short positions
     * @dev When filling a short order with non-WETH base asset, any ETH sent gets locked
     */
    function testFillOrderShortPositionLocksETH() public {
        // Create a short order with non-WETH base asset
        PuttyV2.Order memory order = defaultOrder();
        order.isLong = false;
        order.baseAsset = address(link); // Use LINK instead of WETH
        order.premium = 100 * 1e18; // 100 LINK premium

        // Mint LINK to taker for premium payment
        link.mint(address(this), order.premium);
        link.approve(address(p), order.premium);

        // Sign the order
        bytes memory signature = signOrder(babePrivateKey, order);

        // Record contract balance before exploit
        uint256 contractBalanceBefore = address(p).balance;
        uint256 attackerBalanceBefore = address(this).balance;

        // Send ETH along with transaction - this ETH will be locked!
        uint256 ethToLock = 2 ether;
        deal(address(this), ethToLock);

        // Exploit: Call fillOrder with ETH even though baseAsset is LINK
        // The function will succeed but ETH will be locked forever
        p.fillOrder{value: ethToLock}(order, signature, new uint256[](0));

        // Verify the exploit worked
        uint256 contractBalanceAfter = address(p).balance;
        uint256 attackerBalanceAfter = address(this).balance;

        // ETH should be locked in contract (balance increased by ethToLock)
        assertEq(
            contractBalanceAfter - contractBalanceBefore,
            ethToLock,
            "ETH should be locked in contract"
        );

        // Attacker should lose all ETH sent
        assertEq(
            attackerBalanceBefore - attackerBalanceAfter,
            ethToLock,
            "Attacker should lose all ETH sent"
        );
    }

    /**
     * @notice Test ETH locking vulnerability in exercise() for call options
     * @dev When exercising a call option with WETH as base asset, if we send
     *      more ETH than strike, extra gets locked
     */
    function testExerciseCallOptionLocksETH() public {
        // Create and fill a long call order first
        PuttyV2.Order memory order = defaultOrder();
        order.isLong = true;
        order.isCall = true;
        order.baseAsset = address(weth); // WETH as base asset
        order.strike = 2 ether; // 2 WETH strike
        order.premium = 0.5 ether; // 0.5 WETH premium

        // Mint WETH to maker for premium
        vm.startPrank(babe);
        deal(babe, order.premium);
        weth.deposit{value: order.premium}();
        vm.stopPrank();

        // Fill the order first
        bytes memory signature = signOrder(babePrivateKey, order);
        uint256 positionId = p.fillOrder(order, signature, new uint256[](0));

        // Debug: Check who owns the position
        address positionOwner = p.ownerOf(positionId);
        console.log("Position owner:", positionOwner);
        console.log("This contract:", address(this));

        // Record balances before exploit
        uint256 contractBalanceBefore = address(p).balance;
        uint256 attackerBalanceBefore = address(this).balance;

        // Send MORE ETH than needed for strike - extra ETH will be locked!
        uint256 ethToSend = order.strike + 1 ether; // Strike + extra 1 ETH
        deal(address(this), ethToSend);

        // Exploit: Exercise with more ETH than strike
        // The contract will only use order.strike amount, extra gets locked
        p.exercise{value: ethToSend}(order, new uint256[](0));

        // Verify ETH is locked
        uint256 contractBalanceAfter = address(p).balance;
        uint256 attackerBalanceAfter = address(this).balance;

        // Only strike amount should be converted to WETH, extra ETH locked
        uint256 expectedLockedETH = ethToSend - order.strike;
        assertEq(
            contractBalanceAfter - contractBalanceBefore,
            expectedLockedETH,
            "Extra ETH should be locked in contract during exercise"
        );

        // Attacker should lose all ETH sent
        assertEq(
            attackerBalanceBefore - attackerBalanceAfter,
            ethToSend,
            "Attacker should lose all ETH sent during exercise"
        );

        // Position should be exercised (sent to dead address)
        assertEq(p.ownerOf(positionId), address(0xdead), "Position should be exercised");
    }

    /**
     * @notice Test that correct amounts work properly (non-vulnerable path)
     * @dev This test shows the correct behavior when exact amounts are sent
     */
    function testCorrectETHUsageWorks() public {
        // Create a short order with WETH as base asset
        PuttyV2.Order memory order = defaultOrder();
        order.isLong = false;
        order.baseAsset = address(weth);
        order.premium = 1 ether;

        // Sign the order
        bytes memory signature = signOrder(babePrivateKey, order);

        // Record balances
        uint256 contractBalanceBefore = address(p).balance;
        uint256 makerWETHBefore = weth.balanceOf(order.maker);

        // Send exact amount of ETH for premium
        uint256 ethToSend = order.premium;
        deal(address(this), ethToSend);

        // This should work correctly - ETH gets converted to WETH
        p.fillOrder{value: ethToSend}(order, signature, new uint256[](0));

        // ETH should not be locked (contract balance unchanged)
        assertEq(
            address(p).balance,
            contractBalanceBefore,
            "Contract ETH balance should not change when using correct amount"
        );

        // Maker should receive WETH
        assertEq(
            weth.balanceOf(order.maker) - makerWETHBefore,
            order.premium,
            "Maker should receive WETH premium"
        );
    }

    /**
     * @notice Demonstrate the economic impact of the vulnerability
     * @dev Shows how multiple attackers can lock significant amounts of ETH
     */
    function testEconomicImpactOfETHLocking() public {
        uint256 totalETHLocked = 0;

        // Multiple attackers can lock ETH in the contract
        for (uint i = 0; i < 5; i++) {
            // Create unique order for each attack
            PuttyV2.Order memory order = defaultOrder();
            order.isLong = true;
            order.baseAsset = address(weth);
            order.premium = 0.1 ether;
            order.nonce = i; // Make each order unique

            // Setup maker for each order
            vm.startPrank(babe);
            deal(babe, order.premium);
            weth.deposit{value: order.premium}();
            vm.stopPrank();

            bytes memory signature = signOrder(babePrivateKey, order);

            // Each attacker locks 10 ETH
            uint256 ethToLock = 10 ether;
            address attacker = address(uint160(0x10000 + i)); // Unique attacker address
            deal(attacker, ethToLock);

            uint256 contractBalanceBefore = address(p).balance;

            vm.prank(attacker);
            p.fillOrder{value: ethToLock}(order, signature, new uint256[](0));

            uint256 ethLocked = address(p).balance - contractBalanceBefore;
            totalETHLocked += ethLocked;

            assertEq(ethLocked, ethToLock, "Each attacker should lock their ETH");
        }

        // Total ETH locked should be 50 ETH (5 attackers Ã— 10 ETH each)
        assertEq(totalETHLocked, 50 ether, "Total ETH locked should be 50 ETH");
        assertEq(address(p).balance, 50 ether, "Contract should hold 50 ETH");

        // This ETH is permanently locked - no way to recover it
        console.log("Total ETH permanently locked in contract:", totalETHLocked / 1e18);
    }
}